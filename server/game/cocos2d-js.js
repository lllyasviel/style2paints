(function outer(modules, cache, entry) {
    var previousRequire = "function" == typeof require && require;
    function newRequire(name, jumped) {
        var module = cache[name];
        if (!module) {
            var moduleData = modules[name];
            if (!moduleData) {
                var currentRequire = "function" == typeof require && require;
                if (!jumped && currentRequire) {
                    return currentRequire(name, true);
                }
                if (previousRequire) {
                    return previousRequire(name, true);
                }
                var err = new Error("Cannot find module '" + name + "'");
                err.code = "MODULE_NOT_FOUND";
                throw err;
            }
            var exports = {};
            module = cache[name] = {
                exports: exports
            };
            moduleData[0]((function(x) {
                return newRequire(moduleData[1][x] || x);
            }), module, exports);
        }
        return module.exports;
    }
    for (var i = 0; i < entry.length; i++) {
        newRequire(entry[i]);
    }
    return newRequire;
})({
    1: [ (function(require, module, exports) {
        cc._tmp = cc._tmp || {};
        cc._LogInfos = cc._LogInfos || {};
        var engineVersion;
        engineVersion = "1.5.1";
        window["CocosEngine"] = cc.ENGINE_VERSION = engineVersion;
        cc._drawingUtil = null;
        cc._renderContext = null;
        cc._supportRender = false;
        cc._canvas = null;
        cc.container = null;
        cc._gameDiv = null;
        require("./cocos2d/core/utils");
        require("./cocos2d/core/platform/CCSys");
        (function() {
            var _jsAddedCache = {}, _engineInitCalled = false, _engineLoadedCallback = null;
            cc._engineLoaded = false;
            function _determineRenderType(config) {
                var CONFIG_KEY = cc.game.CONFIG_KEY, userRenderMode = parseInt(config[CONFIG_KEY.renderMode]) || 0;
                (isNaN(userRenderMode) || userRenderMode > 2 || userRenderMode < 0) && (config[CONFIG_KEY.renderMode] = 0);
                cc._renderType = cc.game.RENDER_TYPE_CANVAS;
                cc._supportRender = false;
                if (0 === userRenderMode) {
                    if (cc.sys.capabilities["opengl"]) {
                        cc._renderType = cc.game.RENDER_TYPE_WEBGL;
                        cc._supportRender = true;
                    } else {
                        if (cc.sys.capabilities["canvas"]) {
                            cc._renderType = cc.game.RENDER_TYPE_CANVAS;
                            cc._supportRender = true;
                        }
                    }
                } else {
                    if (1 === userRenderMode && cc.sys.capabilities["canvas"]) {
                        cc._renderType = cc.game.RENDER_TYPE_CANVAS;
                        cc._supportRender = true;
                    } else {
                        if (2 === userRenderMode && cc.sys.capabilities["opengl"]) {
                            cc._renderType = cc.game.RENDER_TYPE_WEBGL;
                            cc._supportRender = true;
                        }
                    }
                }
            }
            function _getJsListOfModule(moduleMap, moduleName, dir) {
                if (_jsAddedCache[moduleName]) {
                    return null;
                }
                dir = dir || "";
                var jsList = [];
                var tempList = moduleMap[moduleName];
                if (!tempList) {
                    throw new Error("can not find module [" + moduleName + "]");
                }
                var ccPath = cc.path;
                for (var i = 0, li = tempList.length; i < li; i++) {
                    var item = tempList[i];
                    if (_jsAddedCache[item]) {
                        continue;
                    }
                    var extname = ccPath.extname(item);
                    if (extname) {
                        ".js" === extname.toLowerCase() && jsList.push(ccPath.join(dir, item));
                    } else {
                        var arr = _getJsListOfModule(moduleMap, item, dir);
                        arr && (jsList = jsList.concat(arr));
                    }
                    _jsAddedCache[item] = 1;
                }
                return jsList;
            }
            function _afterEngineLoaded() {
                cc._engineLoaded = true;
                console.log(cc.ENGINE_VERSION);
                _engineLoadedCallback && _engineLoadedCallback();
            }
            function _load(config) {
                var CONFIG_KEY = cc.game.CONFIG_KEY, engineDir = config[CONFIG_KEY.engineDir], loader = cc.loader;
                if (cc._Class) {
                    _afterEngineLoaded();
                } else {
                    var ccModulesPath = cc.path.join(engineDir, "moduleConfig.json");
                    loader.load(ccModulesPath, (function(err, modulesJson) {
                        if (err) {
                            throw new Error(err);
                        }
                        var modules = config["modules"] || [];
                        var moduleMap = modulesJson["module"];
                        var jsList = [];
                        cc.sys.capabilities["opengl"] && modules.indexOf("base4webgl") < 0 ? modules.splice(0, 0, "base4webgl") : modules.indexOf("core") < 0 && modules.splice(0, 0, "core");
                        for (var i = 0, li = modules.length; i < li; i++) {
                            var arr = _getJsListOfModule(moduleMap, modules[i], engineDir);
                            arr && (jsList = jsList.concat(arr));
                        }
                        loader.load(jsList, (function(err) {
                            if (err) {
                                throw new Error(JSON.stringify(err));
                            }
                            _afterEngineLoaded();
                        }));
                    }));
                }
            }
            function _windowLoaded() {
                window.removeEventListener("load", _windowLoaded, false);
                _load(cc.game.config);
            }
            cc.initEngine = function(config, cb) {
                if (_engineInitCalled) {
                    var previousCallback = _engineLoadedCallback;
                    _engineLoadedCallback = function() {
                        previousCallback && previousCallback();
                        cb && cb();
                    };
                    return;
                }
                _engineLoadedCallback = cb;
                !cc.game.config && config ? cc.game.config = config : cc.game.config || cc.game._loadConfig();
                config = cc.game.config;
                _determineRenderType(config);
                document.body ? _load(config) : window.addEventListener("load", _windowLoaded, false);
                _engineInitCalled = true;
            };
        })();
    }), {
        "./cocos2d/core/platform/CCSys": 182,
        "./cocos2d/core/utils": 222
    } ],
    2: [ (function(require, module, exports) {
        cc._logToWebPage = function(msg) {
            if (!cc._canvas) {
                return;
            }
            var logList = cc._logList;
            var doc = document;
            if (!logList) {
                var logDiv = doc.createElement("Div");
                var logDivStyle = logDiv.style;
                logDiv.setAttribute("id", "logInfoDiv");
                cc._canvas.parentNode.appendChild(logDiv);
                logDiv.setAttribute("width", "200");
                logDiv.setAttribute("height", cc._canvas.height);
                logDivStyle.zIndex = "99999";
                logDivStyle.position = "absolute";
                logDivStyle.top = "0";
                logDivStyle.left = "0";
                logList = cc._logList = doc.createElement("textarea");
                var logListStyle = logList.style;
                logList.setAttribute("rows", "20");
                logList.setAttribute("cols", "30");
                logList.setAttribute("disabled", true);
                logDiv.appendChild(logList);
                logListStyle.backgroundColor = "transparent";
                logListStyle.borderBottom = "1px solid #cccccc";
                logListStyle.borderRightWidth = "0px";
                logListStyle.borderLeftWidth = "0px";
                logListStyle.borderTopWidth = "0px";
                logListStyle.borderTopStyle = "none";
                logListStyle.borderRightStyle = "none";
                logListStyle.borderLeftStyle = "none";
                logListStyle.padding = "0px";
                logListStyle.margin = 0;
            }
            logList.value = logList.value + msg + "\r\n";
            logList.scrollTop = logList.scrollHeight;
        };
        var Enum = require("./cocos2d/core/platform/CCEnum");
        cc.DebugMode = Enum({
            NONE: 0,
            INFO: 1,
            WARN: 2,
            ERROR: 3,
            INFO_FOR_WEB_PAGE: 4,
            WARN_FOR_WEB_PAGE: 5,
            ERROR_FOR_WEB_PAGE: 6
        });
        var jsbLog = cc.log || console.log;
        cc._initDebugSetting = function(mode) {
            cc.log = cc.logID = cc.warn = cc.warnID = cc.error = cc.errorID = cc._throw = cc.assert = cc.assertID = function() {};
            if (mode === cc.DebugMode.NONE) {
                return;
            }
            var locLog;
            if (mode > cc.DebugMode.ERROR) {
                locLog = cc._logToWebPage.bind(cc);
                cc.error = function() {
                    locLog("ERROR :  " + cc.js.formatStr.apply(null, arguments));
                };
                cc.assert = function(cond, msg) {
                    "use strict";
                    if (!cond && msg) {
                        msg = cc.js.formatStr.apply(null, cc.js.shiftArguments.apply(null, arguments));
                        locLog("ASSERT: " + msg);
                    }
                };
                mode !== cc.DebugMode.ERROR_FOR_WEB_PAGE && (cc.warn = function() {
                    locLog("WARN :  " + cc.js.formatStr.apply(null, arguments));
                });
                mode === cc.DebugMode.INFO_FOR_WEB_PAGE && (cc.log = cc.info = function() {
                    locLog(cc.js.formatStr.apply(null, arguments));
                });
            } else {
                if (console && console.log.apply) {
                    console.error || (console.error = console.log);
                    console.warn || (console.warn = console.log);
                    console.error.bind ? cc.error = console.error.bind(console) : cc.error = function() {
                        return console.error.apply(console, arguments);
                    };
                    cc.assert = function(cond, msg) {
                        if (!cond) {
                            msg && (msg = cc.js.formatStr.apply(null, cc.js.shiftArguments.apply(null, arguments)));
                            debugger;
                            throw new Error(msg);
                        }
                    };
                }
            }
            mode !== cc.DebugMode.ERROR && (console.warn.bind ? cc.warn = console.warn.bind(console) : cc.warn = function() {
                return console.warn.apply(console, arguments);
            });
            if (mode === cc.DebugMode.INFO) {
                console.log.bind ? cc.log = console.log.bind(console) : cc.log = function() {
                    return console.log.apply(console, arguments);
                };
                cc.info = function() {
                    (console.info || console.log).apply(console, arguments);
                };
            }
            cc.warnID = genLogFunc(cc.warn, "Warning");
            cc.errorID = genLogFunc(cc.error, "Error");
            cc.logID = genLogFunc(cc.log, "Log");
            var assertFailed = genLogFunc((function() {
                var argsArr = [ false ];
                for (var i = 0; i < arguments.length; ++i) {
                    argsArr.push(arguments[i]);
                }
                cc.assert.apply(null, argsArr);
            }), "Assert");
            cc.assertID = function(cond) {
                "use strict";
                if (cond) {
                    return;
                }
                assertFailed.apply(null, cc.js.shiftArguments.apply(null, arguments));
            };
        };
        cc._throw = function(error) {
            var stack = error.stack;
            stack ? cc.error(stack) : cc.error(error);
        };
        var errorMapUrl = "https://github.com/cocos-creator/engine/blob/master/EngineErrorMap.md";
        function genLogFunc(func, type) {
            return function(id) {
                "use strict";
                if (1 === arguments.length) {
                    func(cc._LogInfos[id]);
                    return;
                }
                var msg;
                var argsArr = cc.js.shiftArguments.apply(null, arguments);
                func.apply(cc, [ cc._LogInfos[id] ].concat(argsArr));
            };
        }
    }), {
        "./cocos2d/core/platform/CCEnum": 175
    } ],
    3: [ (function(require, module, exports) {
        var logs = {
            "1000": "cc.ActionManager.addAction(): action must be non-null",
            "1001": "cocos2d: removeAction: Target not found",
            "1002": "cc.ActionManager.removeActionByTag(): an invalid tag",
            "1003": "cc.ActionManager.removeActionByTag(): target must be non-null",
            "1004": "cc.ActionManager.getActionByTag(): an invalid tag",
            "1005": "cocos2d : getActionByTag(tag = %s): Action not found",
            "1006": "[Action step]. override me",
            "1007": "[Action update]. override me",
            "1008": "cocos2d: FiniteTimeAction#reverse: Implement me",
            "1009": "cc.EaseElastic.reverse(): it should be overridden in subclass.",
            "1010": "cc.IntervalAction: reverse not implemented.",
            "1011": "cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.",
            "1012": "cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.",
            "1013": "The speed parameter error",
            "1014": "The repeat parameter error",
            "1015": "parameters should not be ending with null in Javascript",
            "1016": "cc.RotateTo.reverse(): it should be overridden in subclass.",
            "1017": "cc.GridAction.getGrid(): it should be overridden in subclass.",
            "1018": "Grid size must be (1,1)",
            "1100": "Expected 'data' dict, but not found. Config file: %s",
            "1101": "Please load the resource first : %s",
            "1200": "cocos2d: Director: Error in gettimeofday",
            "1201": "cocos2d: Director: unrecognized projection",
            "1202": "cocos2d: Director: unrecognized projection",
            "1203": "cocos2d: Director: Error in gettimeofday",
            "1204": "running scene should not null",
            "1205": "the scene should not null",
            "1206": "loadScene: The scene index to load (%s) is out of range.",
            "1207": "loadScene: Unknown name type to load: '%s'",
            "1208": "loadScene: Failed to load scene '%s' because '%s' is already loading",
            "1209": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
            "1210": "Failed to preload '%s', %s",
            "1211": "loadScene: The scene index to load (%s) is out of range.",
            "1212": "loadScene: Unknown name type to load: '%s'",
            "1213": "loadScene: Failed to load scene '%s' because '%s' is already loading",
            "1214": "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
            "1215": "Failed to preload '%s', %s",
            "1300": "element type is wrong!",
            "1400": "'%s' is deprecated, please use '%s' instead.",
            "1401": "The first argument should be the destination object",
            "1402": "The 'visible' property of %s is deprecated, use 'enabled' instead please.",
            "1403": "Sorry, cc.audioEngine.willPlayMusic is removed.",
            "1404": "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
            "1500": "cc.Scheduler#schedule: Callback already scheduled. Updating interval from:%s to %s",
            "1501": "cc.Scheduler#scheduleCallbackForTarget(): callback_fn should be non-null.",
            "1502": "cc.Scheduler#scheduleCallbackForTarget(): target should be non-null.",
            "1503": "cc.Scheduler#pauseTarget():target should be non-null",
            "1504": "cc.Scheduler#resumeTarget():target should be non-null",
            "1505": "cc.Scheduler#isTargetPaused():target should be non-null",
            "1506": "warning: you CANNOT change update priority in scheduled function",
            "1507": "cc.Scheduler#scheduleSelector: Selector already scheduled. Updating interval from: %.4f to %.4f",
            "1508": "Argument callback must not be empty",
            "1509": "Argument target must be non-nullptr",
            "1510": "cc.Scheduler: Illegal target which doesn't have uuid or instanceId",
            "1600": "getZOrder is deprecated. Please use getLocalZOrder instead.",
            "1601": "setZOrder is deprecated. Please use setLocalZOrder instead.",
            "1602": "RotationX != RotationY. Don't know which one to return",
            "1603": "ScaleX != ScaleY. Don't know which one to return",
            "1604": "An Node can't be added as a child of itself.",
            "1605": "child already added. It can't be added again",
            "1606": "child must be non-null",
            "1607": "removeFromParentAndCleanup is deprecated. Use removeFromParent instead",
            "1608": "boundingBox is deprecated. Use getBoundingBox instead",
            "1609": "argument tag is an invalid tag",
            "1610": "cocos2d: removeChildByTag(tag = %s): child not found!",
            "1611": "removeAllChildrenWithCleanup is deprecated. Use removeAllChildren instead",
            "1612": "cc.Node.stopActionBy(): argument tag an invalid tag",
            "1613": "cc.Node.getActionByTag(): argument tag is an invalid tag",
            "1614": "resumeSchedulerAndActions is deprecated, please use resume instead.",
            "1615": "pauseSchedulerAndActions is deprecated, please use pause instead.",
            "1616": "Unknown callback function",
            "1617": "child must be non-null",
            "1618": "cc.Node.runAction(): action must be non-null",
            "1619": "callback function must be non-null",
            "1620": "interval must be positive",
            "1621": "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
            "1622": "_ccsg.Node._requestDirtyFlag: failed to satisfy the request, key (%s) for flag have already been taken",
            "1623": "Set '%s' to normal node (not persist root node).",
            "1624": "Replacing with the same sgNode",
            "1625": "The replacement sgNode should not contain any child.",
            "1626": "Should not set alpha via 'color', set 'opacity' please.",
            "1627": "Not support for asynchronous creating node in SG",
            "1628": "Renderer error: Size of the cc._RendererInSG._sgNode must be zero",
            "1629": "The node '%s' has a component inherited from 'cc._RendererInSG'",
            "1630": "JSB environment is not support invoke node.runAction before the 'cc._RendererInSG' component enabled.",
            "1631": "Please use runAction in the method 'start' instead.",
            "1632": "Node name can not include '/'.",
            "1633": "Internal error, should not remove unknown node from parent.",
            "1634": "addChild: The child to add must be instance of cc.Node, not %s.",
            "1635": "reorderChild: this child is not in children list",
            "1700": "cc.AtlasNode.updateAtlasValues(): Shall be overridden in subclasses",
            "1701": "",
            "1702": "cocos2d: Could not initialize cc.AtlasNode. Invalid Texture.",
            "1703": "The new text must be String",
            "1800": "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
            "1801": "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
            "1802": "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
            "1803": "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
            "1900": "Invalid parameter.",
            "2000": "Don't call this method if the event is for touch.",
            "2100": "parameters should not be ending with null in Javascript",
            "2101": "Invalid index in MultiplexLayer switchTo message",
            "2102": "Invalid index in MultiplexLayer switchTo message",
            "2103": "cc.Layer.addLayer(): layer should be non-null",
            "2200": "Resolution not valid",
            "2201": "should set resolutionPolicy",
            "2300": "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
            "2400": "WebGL error %s",
            "2401": "Too many graphics vertices generated, only 65536 vertices support.",
            "2500": "cocos2d: cc.SpriteFrameAnimationCache: No animations were found in provided dictionary.",
            "2501": "cc.SpriteFrameAnimationCache. Invalid animation format",
            "2502": "cc.SpriteFrameAnimationCache.addAnimations(): File could not be found",
            "2503": "cocos2d: cc.SpriteFrameAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
            "2504": "cocos2d: cc.SpriteFrameAnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
            "2505": "cocos2d: cc.SpriteFrameAnimationCache: None of the frames for animation '%s' were found in the cc.SpriteFrameCache. Animation is not being added to the Animation Cache.",
            "2506": "cocos2d: cc.SpriteFrameAnimationCache: An animation in your dictionary refers to a frame which is not in the cc.SpriteFrameCache. Some or all of the frames for the animation '%s' may be missing.",
            "2507": "cocos2d: CCAnimationCache: Animation '%s' found in dictionary without any frames - cannot add to animation cache.",
            "2508": "cocos2d: cc.SpriteFrameAnimationCache: Animation '%s' refers to frame '%s' which is not currently in the cc.SpriteFrameCache. This frame will not be added to the animation.",
            "2509": "cc.SpriteFrameAnimationCache.addAnimations(): Invalid texture file name",
            "2600": "cc.Sprite.reorderChild(): this child is not in children list",
            "2601": "cc.Sprite.setIgnoreAnchorPointForPosition(): it is invalid in cc.Sprite when using SpriteBatchNode",
            "2602": "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
            "2603": "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
            "2604": "setDisplayFrame is deprecated, please use setSpriteFrame instead.",
            "2605": "cc.Sprite._updateBlendFunc(): _updateBlendFunc doesn't work when the sprite is rendered using a cc.CCSpriteBatchNode",
            "2606": "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
            "2608": "initWithSpriteFrameName is deprecated and can not provide correct functionality",
            "2609": "cc.Sprite.initWithFile(): filename should be non-null",
            "2610": "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
            "2611": "cc.Sprite.reorderChild(): child should be non-null",
            "2612": "cc.Sprite.addChild(): cc.Sprite only supports cc.Sprites as children when using cc.SpriteBatchNode",
            "2613": "cc.Sprite.addChild(): cc.Sprite only supports a sprite using same texture as children when using cc.SpriteBatchNode",
            "2614": "cc.Sprite.addChild(): child should be non-null",
            "2615": "cc.Sprite.texture setter: Batched sprites should use the same texture as the batchnode",
            "2616": "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
            "2617": "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
            "2618": "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
            "2619": "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
            "2620": "Sprite.initWithTexture(): Argument must be non-nil ",
            "2621": "Invalid spriteFrameName",
            "2622": "Invalid argument: cc.Sprite.texture setter expects a CCTexture2D.",
            "2623": "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
            "2624": "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
            "2625": "too many tiles, only 16384 tiles will be show",
            "2626": "Unrecognized fill type in bar fill",
            "2627": "Can not generate quad",
            "2728": "%s does not exist",
            "2700": "cc.SpriteBatchNode.addQuadFromSprite(): SpriteBatchNode only supports cc.Sprites as children",
            "2701": "cocos2d: CCSpriteBatchNode: resizing TextureAtlas capacity from %s to %s.",
            "2702": "cocos2d: WARNING: Not enough memory to resize the atlas",
            "2703": "cc.SpriteBatchNode.addChild(): Child doesn't belong to Sprite",
            "2704": "cc.SpriteBatchNode.addChild(): sprite batch node should contain the child",
            "2705": "cc.SpriteBatchNode.addQuadFromSprite(): child should be non-null",
            "2706": "cc.SpriteBatchNode.addChild(): child should be non-null",
            "2707": "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
            "2708": "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
            "2709": "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
            "2710": "Sprite.initWithTexture(): Argument must be non-nil ",
            "2711": "cc.Sprite.addChild(): child should be non-null",
            "2712": "Invalid spriteFrameName",
            "2713": "Invalid argument: cc.Sprite texture setter expects a CCTexture2D.",
            "2714": "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
            "2715": "cc.SpriteBatchNode.insertQuadFromSprite(): sprite should be non-null",
            "2716": "cc.SpriteBatchNode.addChild(): child should be non-null",
            "2800": "cocos2d: WARNING: originalWidth/Height not found on the cc.SpriteFrame. AnchorPoint won't work as expected. Regenrate the .plist",
            "2801": "cocos2d: WARNING: an alias with name %s already exists",
            "2802": "cocos2d: WARNING: Sprite frame: %s has already been added by another source, please fix name conflit",
            "2803": "cocos2d: cc.SpriteFrameCahce: Frame %s not found",
            "2804": "Please load the resource first : %s",
            "2805": "cc.SpriteFrameCache.addSpriteFrames(): plist should be non-null",
            "2806": "Argument must be non-nil",
            "2900": "cocos2d: Could not open file: %s",
            "2901": "cc.TextureAtlas.insertQuad(): invalid totalQuads",
            "2902": "cc.TextureAtlas.initWithTexture():texture should be non-null",
            "2903": "cc.TextureAtlas.updateQuad(): quad should be non-null",
            "2904": "cc.TextureAtlas.updateQuad(): Invalid index",
            "2905": "cc.TextureAtlas.insertQuad(): Invalid index",
            "2906": "cc.TextureAtlas.insertQuad(): Invalid index + amount",
            "2907": "cc.TextureAtlas.insertQuadFromIndex(): Invalid newIndex",
            "2908": "cc.TextureAtlas.insertQuadFromIndex(): Invalid fromIndex",
            "2909": "cc.TextureAtlas.removeQuadAtIndex(): Invalid index",
            "2910": "cc.TextureAtlas.removeQuadsAtIndex(): index + amount out of bounds",
            "2911": "cc.TextureAtlas.moveQuadsFromIndex(): move is out of bounds",
            "2912": "cc.TextureAtlas.moveQuadsFromIndex(): Invalid newIndex",
            "2913": "cc.TextureAtlas.moveQuadsFromIndex(): Invalid oldIndex",
            "3000": "TextureCache:addPVRTCImage does not support on HTML5",
            "3001": "TextureCache:addPVRTCImage does not support on HTML5",
            "3002": "textureForKey is deprecated. Please use getTextureForKey instead.",
            "3003": "addPVRImage does not support on HTML5",
            "3004": "cocos2d: Couldn't add UIImage in TextureCache",
            "3005": "cocos2d: '%s' id=%s %s x %s",
            "3006": "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
            "3007": "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
            "3008": "cc.Texture.addUIImage(): image should be non-null",
            "3009": "TextureCache: url should be non-null",
            "3100": "initWithETCFile does not support on HTML5",
            "3101": "initWithPVRFile does not support on HTML5",
            "3102": "initWithPVRTCData does not support on HTML5",
            "3103": "cc.Texture.addImage(): path should be non-null",
            "3104": "cocos2d: cc.Texture2D. Can't create Texture. UIImage is nil",
            "3105": "cocos2d: WARNING: Image (%s x %s) is bigger than the supported %s x %s",
            "3106": "initWithString isn't supported on cocos2d-html5",
            "3107": "initWithETCFile does not support on HTML5",
            "3108": "initWithPVRFile does not support on HTML5",
            "3109": "initWithPVRTCData does not support on HTML5",
            "3110": "bitsPerPixelForFormat: %s, cannot give useful result, it's a illegal pixel format",
            "3111": "cocos2d: cc.Texture2D: Using RGB565 texture since image has no alpha",
            "3112": "cc.Texture.addImage(): path should be non-null",
            "3113": "NSInternalInconsistencyException",
            "3114": "SpriteFrame: Failed to load sprite texture '%s'",
            "3115": "Frame Grabber: could not attach texture to framebuffer",
            "3116": "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures",
            "3117": "Mimpap texture only works in POT textures",
            "3200": "Missing file: %s",
            "3300": "Rect width exceeds maximum margin: %s",
            "3400": "Rect height exceeds maximum margin: %s",
            "3500": "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
            "3501": "Invalid listener type!",
            "3502": "Can't set fixed priority with scene graph based listener.",
            "3503": "Invalid parameters.",
            "3504": "listener must be a cc.EventListener object when adding a fixed priority listener",
            "3505": "The listener has been registered, please don't register it again.",
            "3506": "Unsupported listener target.",
            "3507": "Invalid scene graph priority!",
            "3508": "If program goes here, there should be event in dispatch.",
            "3509": "_inDispatch should be 1 here.",
            "3510": "%s's scene graph node not contains in the parent's children",
            "3600": "cc.Class will automatically call super constructor of %s, you should not call it manually.",
            "3601": "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
            "3602": "Unknown editor property '%s' in class '%s'.",
            "3603": "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please. ðŸ˜‚",
            "3604": "Can only indicate one type attribute for %s.",
            "3605": "The default value of %s is not instance of %s.",
            "3606": "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
            "3607": "The default value of %s must be an empty string.",
            "3608": "The type of %s must be cc.String, not String.",
            "3609": "The type of %s must be cc.Boolean, not Boolean.",
            "3610": "The type of %s must be cc.Float or cc.Integer, not Number.",
            "3611": "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
            "3612": "%s Just set the default value to 'new %s()' and it will be handled properly.",
            "3613": "'No need to specify the '%s' attribute for the getter of '%s.%s', every getter is actually non-serialized.",
            "3615": "Each script can have at most one Component.",
            "3616": "Should not specify class name %s for Component which defines in project.",
            "3617": "ctor of CCClass '%s' should not accept any arguments.",
            "3618": "ctor of '%s' can not be another CCClass",
            "3619": "ctor of '%s' must be function type",
            "3620": "this._super declared in '%s.%s' but no super method defined",
            "3621": "Unknown type of %s.%s, maybe you want is '%s'.",
            "3622": "Unknown type of %s.%s, property should be defined in 'properties' or 'ctor'",
            "3623": "Can not use 'editor' attribute, '%s' not inherits from Components.",
            "3624": "'%s' overrided '%s' but '%s' is defined as 'false' so the super method will not be called. You can set '%s' to null to disable this warning.",
            "3625": "[isChildClassOf] superclass should be function type, not",
            "3626": "Can't remove '%s' because '%s' depends on it.",
            "3627": "Should not add renderer component (%s) to a Canvas node.",
            "3628": "Should not add %s to a node which size is already used by its other component.",
            "3629": "attribute must be type object",
            "3630": "RawType is only available for Assets",
            "3631": "RawType name cannot contain uppercase",
            "3632": "Each asset cannot have more than one RawType",
            "3633": "Properties function of '%s' should return an object!",
            "3634": "Disallow to use '.' in property name",
            "3635": "Default array must be empty, set default value of %s.%s to [], and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = [...];')",
            "3636": "Do not set default value to non-empty object, unless the object defines its own 'clone' function. Set default value of %s.%s to null or {}, and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = {foo: bar};')",
            "3637": "Can not declare %s.%s, it is already defined in the prototype of %s",
            "3638": "'%s': the getter of '%s' is already defined!",
            "3640": "'%s': the setter of '%s' is already defined!",
            "3641": "Can not construct %s because it contains object property.",
            "3642": "Cannot define %s.%s because static member name can not be '%s'.",
            "3643": "Can not define a member called 'constructor' in the class '%s', please use 'ctor' instead.",
            "3644": "Please define 'type' parameter of %s.%s as the actual constructor.",
            "3645": "Please define 'type' parameter of %s.%s as the constructor of %s.",
            "3646": "Unknown 'type' parameter of %s.%sï¼š%s",
            "3647": "The length of range array must be equal or greater than 2",
            "3648": "Can not declare %s.%s method, it is already defined in the properties of %s.",
            "3649": "CCClass %s have conflict between its ctor and __ctor__.",
            "3650": "No need to specifiy '%s' attribute for '%s' in class \"%s\".",
            "3651": 'Can not call `_super` or `prototype.ctor` in ES6 Classes "%s", use `super` instead please.',
            "3700": "internal error: _prefab is undefined",
            "3701": "Failed to load prefab asset for node '%s'",
            "3800": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
            "3801": "The node can not be made persist because it's not under root node.",
            "3802": "The node can not be made persist because it's not in current scene.",
            "3803": "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
            "3804": "getComponent: Type must be non-nil",
            "3805": "Can't add component '%s' because %s already contains the same component.",
            "3806": "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
            "3807": "addComponent: Failed to get class '%s'",
            "3808": "addComponent: Should not add component ('%s') when the scripts are still loading.",
            "3809": "addComponent: The component to add must be a constructor",
            "3810": "addComponent: The component to add must be child class of cc.Component",
            "3811": "_addComponentAt: The component to add must be a constructor",
            "3812": "_addComponentAt: Index out of range",
            "3813": "removeComponent: Component must be non-nil",
            "3814": "Argument must be non-nil",
            "3815": "Component not owned by this entity",
            "3816": "Node '%s' is already activating or deactivating.",
            "3817": "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
            "3818": "Failed to read or parse project.json",
            "3819": "Warning: target element is not a DIV or CANVAS",
            "3900": "Invalid clip to add",
            "3901": "Invalid clip to remove",
            "3902": "clip is defaultClip, set force to true to force remove clip and animation state",
            "3903": "animation state is playing, set force to true to force stop and remove clip and animation state",
            "3904": "motion path of target [%s] in prop [%s] frame [%s] is not valid",
            "3905": "sprite frames must be an Array.",
            "3906": "Can't find easing type [%s]",
            "3907": "animator not added or already removed",
            "3908": "animation not added or already removed",
            "3909": "[animate] keyFrames must be non-nil",
            "3910": "[animate] ratio should >= 0!",
            "3911": "[animate] ratio should in the order of smallest to largest!",
            "4000": "Sorry, the cc.Font has been modified from Raw Asset to Asset. Please load the font asset before using.",
            "4001": "_ccsg.Label._initBMFontWithString(): Impossible to create font. Please check file",
            "4002": "_ccsg.Label._initBMFontWithString(): re-init is no longer supported",
            "4003": "Label font size can't be shirnked less than 0!",
            "4004": "force notify all fonts loaded!",
            "4005": "cc.LabelAtlas.initWithString(): Unsupported version. Upgrade cocos2d version",
            "4006": "cc.LabelAtlas._updateAtlasValues(): Invalid String length",
            "4007": "cc.LabelBMFont.initWithString(): re-init is no longer supported",
            "4008": "cc.LabelBMFont.initWithString(): Impossible to create font. Please check file",
            "4009": "cocos2d: LabelBMFont: character not found %s",
            "4010": "cc.LabelBMFont.setFntFile() : Impossible to create font. Please check file",
            "4011": "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
            "4012": "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
            "4100": "Property padding is deprecated, please use paddingLeft, paddingRight, paddingTop and paddingBottom instead",
            "4200": "MaskType: IMAGE_STENCIL only support WebGL mode.",
            "4201": "The alphaThreshold invalid in Canvas Mode.",
            "4202": "The inverted invalid in Canvas Mode.",
            "4300": "can not found the %s page.",
            "4400": "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
            "4600": "Script attached to '%s' is missing or invalid.",
            "4700": "The dom control is not created!",
            "4800": "unknown asset type %s",
            "4901": "loadRes: should not specify the extname in %s %s",
            "4902": "No need to release non-cached asset.",
            "4903": "Can not get class '%s'",
            "4904": "%s does not exist",
            "4905": "%s load error, must be json file",
            "4906": "Can't find the parser : %s",
            "4907": "%s is armature. please use:",
            "4908": "    ccs.armatureDataManager.addArmatureFileInfoAsync(%s);",
            "4909": "    var armature = new ccs.Armature('name');",
            "4910": "Can't find the parser : %s",
            "4911": "register parser error",
            "4912": "Can't find the parser : %s",
            "4913": "Group versions haven't been loaded, you can also set group data with 'cc.LoaderLayer.groups'",
            "4914": "Resources url '%s' does not exist.",
            "4915": "Pack indices and data do not match in size",
            "4916": "Failed to download package for %s",
            "4917": "cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported",
            "4918": "cc.LabelBMFont._parseCommonArguments(): only supports 1 page",
            "4919": "cc.LabelBMFont._parseImageFileName() : file could not be found",
            "4920": "Sorry, you shouldn't use id as item identity any more, please use url or uuid instead, the current id is being set as url: (%s)",
            "5000": "object already destroyed",
            "5001": "object not yet destroyed",
            "5100": "Not a plist file!",
            "5200": "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
            "5201": "browser don't support web audio",
            "5300": "Type of target to deserialize not matched with data: target is %s, data is %s",
            "5301": "Can not find script '%s'",
            "5302": "Can not find class '%s'",
            "5400": "'%s' is deprecated, use '%s' instead please.",
            "5401": "'%s' is deprecated, use '%s' instead please.",
            "5402": "cc.js.addon called on non-object: ",
            "5403": "cc.js.mixin: arguments must be type object: ",
            "5404": "The base class to extend from must be non-nil",
            "5405": "The class to extend must be non-nil",
            "5406": "Class should be extended before assigning any prototype members.",
            "5500": "'notify' can't work with 'get/set' !",
            "5501": "'notify' must work with 'default' !",
            "5502": "Invalid url of %s.%s",
            "5503": "The 'url' attribute of '%s.%s' is undefined when loading script.",
            "5504": "The 'url' type of '%s.%s' must be child class of cc.RawAsset.",
            "5505": "The 'url' type of '%s.%s' must not be child class of cc.Asset, otherwise you should use 'type: %s' instead.",
            "5506": "Can not specify 'type' attribute for '%s.%s', because its 'url' is already defined.",
            "5507": "The 'default' attribute of '%s.%s' must be an array",
            "5508": "Invalid type of %s.%s",
            "5509": "The 'type' attribute of '%s.%s' must be child class of cc.Asset, otherwise you should use 'url: %s' instead",
            "5510": "The 'type' attribute of '%s.%s' can not be 'Number', use 'Float' or 'Integer' instead please.",
            "5511": "The 'type' attribute of '%s.%s' is undefined when loading script",
            "5512": "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
            "5513": "The 'default' value of '%s.%s' should not be used with a 'get' function.",
            "5514": "The 'default' value of '%s.%s' should not be used with a 'set' function.",
            "5515": "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
            "5516": "Property '%s.%s' must define at least one of 'default', 'get' or 'set'.",
            "5517": "'%s.%s' hides inherited property '%s.%s'. To make the current property override that implementation, add the `override: true` attribute please.",
            "5600": "Argument must be non-nil",
            "5601": "Can not get current scene.",
            "5602": "Scene is destroyed",
            "5603": "reference node is destroyed",
            "5700": "no %s or %s on %s",
            "5800": "%s.lerp not yet implemented.",
            "5801": "%s.clone not yet implemented.",
            "5802": "%s.equals not yet implemented.",
            "5900": "MotionStreak only support WebGL mode.",
            "5901": "cc.MotionStreak.getOpacity has not been supported.",
            "5902": "cc.MotionStreak.setOpacity has not been supported.",
            "6000": "Custom should not be false if file is not specified.",
            "6001": "The new %s must not be NaN",
            "6002": "_ccsg.ParticleSystem.addChild() : Can't add a ParticleSystem that uses a different blending function",
            "6003": "cc.ParticleBatchNode.removeChild(): doesn't contain the sprite. Can't remove it",
            "6004": "cc.ParticleBatchNode.reorderChild(): Child doesn't belong to batch",
            "6005": "cc.ParticleBatchNode._increaseAtlasCapacityTo() : WARNING: Not enough memory to resize the atlas",
            "6006": "cocos2d: cc.ParticleBatchNode: resizing TextureAtlas capacity from [%d] to [%d]",
            "6007": "cc.ParticleBatchNode._addChildHelper(): child already added. It can't be added again",
            "6008": "_ccsg.ParticleSystem.initWithFile(): Particles: file not found",
            "6009": "_ccsg.ParticleSystem.initWithDictionary(): Invalid emitterType in config file",
            "6010": "_ccsg.ParticleSystem: error decoding or ungzipping textureImageData",
            "6011": "_ccsg.ParticleSystem: unknown image format with Data",
            "6012": "_ccsg.ParticleSystem.initWithDictionary() : error loading the texture",
            "6013": "Particle system: not enough memory",
            "6014": "Can't change blending functions when the particle is being batched",
            "6015": "_ccsg.ParticleSystem.setDisplayFrame(): QuadParticle only supports SpriteFrames with no offsets",
            "6016": "_ccsg.ParticleSystem._allocMemory(): Memory should not be allocated when not using batchNode",
            "6100": "Not supported file types, Please try use the ccs.load",
            "6200": "Canvas doesn't support mesh slot!",
            "6300": "only cc.DrawNode is accepted as stencil",
            "6301": "Stencil buffer is not enabled.",
            "6302": "Nesting more than %d stencils is not supported. Everything will be drawn without stencil for this node and its children.",
            "6400": "asset.url is not usable in core process",
            "6401": "asset.urls is not usable in core process",
            "6402": "AssetLibrary has already been initialized!",
            "6500": "Widget target must be one of the parent nodes of it",
            "6600": "collider not added or already removed",
            "6601": "Can't find testFunc for (%s, $s).",
            "6700": "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time",
            "6701": "Should not add Canvas to a node which already contains a renderer component (%s).",
            "6702": "Should not add Canvas to a node which size is already used by its other component.",
            "6800": "Callback of event must be non-nil",
            "6801": "The message must be provided",
            "6900": "The thing you want to instantiate must be an object",
            "6901": "The thing you want to instantiate is nil",
            "6902": "The thing you want to instantiate is destroyed",
            "6903": "The instantiate method for given asset do not implemented",
            "6904": "Can not instantiate array",
            "6905": "Can not instantiate DOM element",
            "7000": "Failed to init asset's raw path.",
            "7001": "Should not load '%s' from script dynamically, unless it is placed in the 'resources' folder.",
            "7002": "Sorry can not load '%s' because it is not placed in the 'resources' folder.",
            "7003": "Failed to init builtin asset's raw path.",
            "7100": "%s already defined in Enum.",
            "7101": "Sorry, 'cc.Enum' not available on this platform, please report this error here: https://github.com/cocos-creator/engine/issues/new",
            "7200": "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
            "7201": "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
            "7202": "Add component TiledLayer into node failed.",
            "7203": "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
            "7204": "_ccsg.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
            "7205": "_ccsg.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
            "7206": "_ccsg.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
            "7207": "_ccsg.TMXLayer.setTileGID(): invalid gid: %s",
            "7208": "_ccsg.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
            "7209": "_ccsg.TMXLayer.removeTileAt(): TMXLayer: the tiles map has been released",
            "7210": "TMX Hexa zOrder not supported",
            "7211": "TMX invalid value",
            "7212": "_ccsg.TMXTiledMap.initWithTMXFile(): Map not found. Please check the filename.",
            "7213": "_ccsg.TMXTiledMap.initWithXML(): Map not found. Please check the filename.",
            "7214": "propertiesForGID is deprecated. Please use getPropertiesForGID instead.",
            "7215": "cocos2d: Warning: TMX Layer %s has no tiles",
            "7216": "cocos2d: TMXFormat: Unsupported TMX version: %s",
            "7217": "cocos2d: TMXFomat: Unsupported orientation: %s",
            "7218": "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
            "7219": "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
            "7300": "The new selected must be number",
            "7301": "The new bake must be boolean",
            "7400": "Failed to set _defaultArmatureIndex for '%s' because its dragonAsset is invalid.",
            "7401": "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
            "7402": "Failed to set _animationIndex for '%s' because the index is out of range.",
            "7500": "Failed to set _defaultSkinIndex for '%s' because its skeletonData is invalid.",
            "7501": "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
            "7502": "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
            "7503": "Failed to set _animationIndex for '%s' because the index is out of range.",
            "7504": "Can not render dynamic created SkeletonData",
            "7505": "Invalid type of atlasFile, atlas should be registered as raw asset.",
            "7506": "Failed to load spine atlas '$s'",
            "7507": "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
            "7508": "The atlas asset of '%s' is not exists!",
            "7509": "Spine: Animation not found: %s",
            "7510": "Spine: Animation not found: %s",
            "7600": "The context of RenderTexture is invalid.",
            "7700": "On the web is always keep the aspect ratio",
            "7701": "Can't know status",
            "7702": "Video player's duration is not ready to get now!",
            "7800": "Web does not support loading",
            "7801": "Web does not support query history",
            "7802": "Web does not support query history",
            "7803": "The current browser does not support the GoBack",
            "7804": "The current browser does not support the GoForward",
            "7805": "Web does not support zoom",
            "7900": "cc.math.Matrix3.assign(): current matrix equals matIn",
            "7901": "cc.math.mat4Assign(): pOut equals pIn",
            "7902": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
            "7903": "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
            "7904": "cc.math.Matrix4.extractPlane: Invalid plane index",
            "7905": "cc.math.mat4Assign(): pOut equals pIn",
            "7906": "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
            "7907": "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
            "8000": "Can't handle this field type or size",
            "8001": "No bytes requested",
            "8002": "Too many bytes requested",
            "8003": "Missing StripByteCounts!",
            "8100": "cocos2d: ERROR: Failed to compile shader:\n %s",
            "8101": "cocos2d: ERROR: Failed to compile vertex shader",
            "8102": "cocos2d: ERROR: Failed to compile fragment shader",
            "8103": "cc.GLProgram.link(): Cannot link invalid program",
            "8104": "cocos2d: ERROR: Failed to link program: %s",
            "8105": "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
            "8200": "Please set node's active instead of rigidbody's enabled.",
            "8300": "Should only one camera exists, please check your project.",
            "8301": "Camera does not support Canvas Mode."
        };
        cc._LogInfos = logs;
    }), {} ],
    4: [ (function(require, module, exports) {
        cc.Action = cc._Class.extend({
            ctor: function() {
                this.originalTarget = null;
                this.target = null;
                this.tag = cc.Action.TAG_INVALID;
            },
            clone: function() {
                var action = new cc.Action();
                action.originalTarget = null;
                action.target = null;
                action.tag = this.tag;
                return action;
            },
            isDone: function() {
                return true;
            },
            startWithTarget: function(target) {
                this.originalTarget = target;
                this.target = target;
            },
            stop: function() {
                this.target = null;
            },
            step: function(dt) {
                cc.logID(1006);
            },
            update: function(dt) {
                cc.logID(1007);
            },
            getTarget: function() {
                return this.target;
            },
            setTarget: function(target) {
                this.target = target;
            },
            getOriginalTarget: function() {
                return this.originalTarget;
            },
            setOriginalTarget: function(originalTarget) {
                this.originalTarget = originalTarget;
            },
            getTag: function() {
                return this.tag;
            },
            setTag: function(tag) {
                this.tag = tag;
            },
            retain: function() {},
            release: function() {}
        });
        cc.Action.TAG_INVALID = -1;
        cc.FiniteTimeAction = cc.Action.extend({
            _duration: 0,
            ctor: function() {
                cc.Action.prototype.ctor.call(this);
                this._duration = 0;
            },
            getDuration: function() {
                return this._duration * (this._timesForRepeat || 1);
            },
            setDuration: function(duration) {
                this._duration = duration;
            },
            reverse: function() {
                cc.logID(1008);
                return null;
            },
            clone: function() {
                return new cc.FiniteTimeAction();
            }
        });
        cc.Speed = cc.Action.extend({
            _speed: 0,
            _innerAction: null,
            ctor: function(action, speed) {
                cc.Action.prototype.ctor.call(this);
                this._speed = 0;
                this._innerAction = null;
                action && this.initWithAction(action, speed);
            },
            getSpeed: function() {
                return this._speed;
            },
            setSpeed: function(speed) {
                this._speed = speed;
            },
            initWithAction: function(action, speed) {
                if (!action) {
                    throw new Error("cc.Speed.initWithAction(): action must be non nil");
                }
                this._innerAction = action;
                this._speed = speed;
                return true;
            },
            clone: function() {
                var action = new cc.Speed();
                action.initWithAction(this._innerAction.clone(), this._speed);
                return action;
            },
            startWithTarget: function(target) {
                cc.Action.prototype.startWithTarget.call(this, target);
                this._innerAction.startWithTarget(target);
            },
            stop: function() {
                this._innerAction.stop();
                cc.Action.prototype.stop.call(this);
            },
            step: function(dt) {
                this._innerAction.step(dt * this._speed);
            },
            isDone: function() {
                return this._innerAction.isDone();
            },
            reverse: function() {
                return new cc.Speed(this._innerAction.reverse(), this._speed);
            },
            setInnerAction: function(action) {
                this._innerAction !== action && (this._innerAction = action);
            },
            getInnerAction: function() {
                return this._innerAction;
            }
        });
        cc.speed = function(action, speed) {
            return new cc.Speed(action, speed);
        };
        cc.Follow = cc.Action.extend({
            _followedNode: null,
            _boundarySet: false,
            _boundaryFullyCovered: false,
            _halfScreenSize: null,
            _fullScreenSize: null,
            _worldRect: null,
            leftBoundary: 0,
            rightBoundary: 0,
            topBoundary: 0,
            bottomBoundary: 0,
            ctor: function(followedNode, rect) {
                cc.Action.prototype.ctor.call(this);
                this._followedNode = null;
                this._boundarySet = false;
                this._boundaryFullyCovered = false;
                this._halfScreenSize = null;
                this._fullScreenSize = null;
                this.leftBoundary = 0;
                this.rightBoundary = 0;
                this.topBoundary = 0;
                this.bottomBoundary = 0;
                this._worldRect = cc.rect(0, 0, 0, 0);
                followedNode && (rect ? this.initWithTarget(followedNode, rect) : this.initWithTarget(followedNode));
            },
            clone: function() {
                var action = new cc.Follow();
                var locRect = this._worldRect;
                var rect = new cc.Rect(locRect.x, locRect.y, locRect.width, locRect.height);
                action.initWithTarget(this._followedNode, rect);
                return action;
            },
            isBoundarySet: function() {
                return this._boundarySet;
            },
            setBoudarySet: function(value) {
                this._boundarySet = value;
            },
            initWithTarget: function(followedNode, rect) {
                if (!followedNode) {
                    throw new Error("cc.Follow.initWithAction(): followedNode must be non nil");
                }
                var _this = this;
                rect = rect || cc.rect(0, 0, 0, 0);
                _this._followedNode = followedNode;
                _this._worldRect = rect;
                _this._boundarySet = !cc._rectEqualToZero(rect);
                _this._boundaryFullyCovered = false;
                var winSize = cc.director.getWinSize();
                _this._fullScreenSize = cc.p(winSize.width, winSize.height);
                _this._halfScreenSize = cc.pMult(_this._fullScreenSize, .5);
                if (_this._boundarySet) {
                    _this.leftBoundary = -(rect.x + rect.width - _this._fullScreenSize.x);
                    _this.rightBoundary = -rect.x;
                    _this.topBoundary = -rect.y;
                    _this.bottomBoundary = -(rect.y + rect.height - _this._fullScreenSize.y);
                    _this.rightBoundary < _this.leftBoundary && (_this.rightBoundary = _this.leftBoundary = (_this.leftBoundary + _this.rightBoundary) / 2);
                    _this.topBoundary < _this.bottomBoundary && (_this.topBoundary = _this.bottomBoundary = (_this.topBoundary + _this.bottomBoundary) / 2);
                    _this.topBoundary === _this.bottomBoundary && _this.leftBoundary === _this.rightBoundary && (_this._boundaryFullyCovered = true);
                }
                return true;
            },
            step: function(dt) {
                var targetWorldPos = this.target.convertToWorldSpaceAR(cc.Vec2.ZERO);
                var followedWorldPos = this._followedNode.convertToWorldSpaceAR(cc.Vec2.ZERO);
                var delta = cc.pSub(targetWorldPos, followedWorldPos);
                var tempPos = this.target.parent.convertToNodeSpaceAR(cc.pAdd(delta, this._halfScreenSize));
                if (this._boundarySet) {
                    if (this._boundaryFullyCovered) {
                        return;
                    }
                    this.target.setPosition(cc.clampf(tempPos.x, this.leftBoundary, this.rightBoundary), cc.clampf(tempPos.y, this.bottomBoundary, this.topBoundary));
                } else {
                    this.target.setPosition(tempPos.x, tempPos.y);
                }
            },
            isDone: function() {
                return !this._followedNode.isRunning();
            },
            stop: function() {
                this.target = null;
                cc.Action.prototype.stop.call(this);
            }
        });
        cc.follow = function(followedNode, rect) {
            return new cc.Follow(followedNode, rect);
        };
    }), {} ],
    5: [ (function(require, module, exports) {
        cc.cardinalSplineAt = function(p0, p1, p2, p3, tension, t) {
            var t2 = t * t;
            var t3 = t2 * t;
            var s = (1 - tension) / 2;
            var b1 = s * (-t3 + 2 * t2 - t);
            var b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
            var b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
            var b4 = s * (t3 - t2);
            var x = p0.x * b1 + p1.x * b2 + p2.x * b3 + p3.x * b4;
            var y = p0.y * b1 + p1.y * b2 + p2.y * b3 + p3.y * b4;
            return cc.p(x, y);
        };
        cc.getControlPointAt = function(controlPoints, pos) {
            var p = Math.min(controlPoints.length - 1, Math.max(pos, 0));
            return controlPoints[p];
        };
        function reverseControlPoints(controlPoints) {
            var newArray = [];
            for (var i = controlPoints.length - 1; i >= 0; i--) {
                newArray.push(cc.p(controlPoints[i].x, controlPoints[i].y));
            }
            return newArray;
        }
        function cloneControlPoints(controlPoints) {
            var newArray = [];
            for (var i = 0; i < controlPoints.length; i++) {
                newArray.push(cc.p(controlPoints[i].x, controlPoints[i].y));
            }
            return newArray;
        }
        cc.CardinalSplineTo = cc.ActionInterval.extend({
            _points: null,
            _deltaT: 0,
            _tension: 0,
            _previousPosition: null,
            _accumulatedDiff: null,
            ctor: function(duration, points, tension) {
                cc.ActionInterval.prototype.ctor.call(this);
                this._points = [];
                void 0 !== tension && this.initWithDuration(duration, points, tension);
            },
            initWithDuration: function(duration, points, tension) {
                if (!points || 0 === points.length) {
                    throw new Error("Invalid configuration. It must at least have one control point");
                }
                if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                    this.setPoints(points);
                    this._tension = tension;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.CardinalSplineTo();
                action.initWithDuration(this._duration, cloneControlPoints(this._points), this._tension);
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._deltaT = 1 / (this._points.length - 1);
                this._previousPosition = cc.p(this.target.getPositionX(), this.target.getPositionY());
                this._accumulatedDiff = cc.p(0, 0);
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                var p, lt;
                var ps = this._points;
                if (1 === dt) {
                    p = ps.length - 1;
                    lt = 1;
                } else {
                    var locDT = this._deltaT;
                    p = 0 | dt / locDT;
                    lt = (dt - locDT * p) / locDT;
                }
                var newPos = cc.cardinalSplineAt(cc.getControlPointAt(ps, p - 1), cc.getControlPointAt(ps, p - 0), cc.getControlPointAt(ps, p + 1), cc.getControlPointAt(ps, p + 2), this._tension, lt);
                if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
                    var tempX, tempY;
                    tempX = this.target.getPositionX() - this._previousPosition.x;
                    tempY = this.target.getPositionY() - this._previousPosition.y;
                    if (0 !== tempX || 0 !== tempY) {
                        var locAccDiff = this._accumulatedDiff;
                        tempX = locAccDiff.x + tempX;
                        tempY = locAccDiff.y + tempY;
                        locAccDiff.x = tempX;
                        locAccDiff.y = tempY;
                        newPos.x += tempX;
                        newPos.y += tempY;
                    }
                }
                this.updatePosition(newPos);
            },
            reverse: function() {
                var reversePoints = reverseControlPoints(this._points);
                return cc.cardinalSplineTo(this._duration, reversePoints, this._tension);
            },
            updatePosition: function(newPos) {
                this.target.setPosition(newPos);
                this._previousPosition = newPos;
            },
            getPoints: function() {
                return this._points;
            },
            setPoints: function(points) {
                this._points = points;
            }
        });
        cc.cardinalSplineTo = function(duration, points, tension) {
            return new cc.CardinalSplineTo(duration, points, tension);
        };
        cc.CardinalSplineBy = cc.CardinalSplineTo.extend({
            _startPosition: null,
            ctor: function(duration, points, tension) {
                cc.CardinalSplineTo.prototype.ctor.call(this);
                this._startPosition = cc.p(0, 0);
                void 0 !== tension && this.initWithDuration(duration, points, tension);
            },
            startWithTarget: function(target) {
                cc.CardinalSplineTo.prototype.startWithTarget.call(this, target);
                this._startPosition.x = target.getPositionX();
                this._startPosition.y = target.getPositionY();
            },
            reverse: function() {
                var copyConfig = this._points.slice();
                var current;
                var p = copyConfig[0];
                for (var i = 1; i < copyConfig.length; ++i) {
                    current = copyConfig[i];
                    copyConfig[i] = cc.pSub(current, p);
                    p = current;
                }
                var reverseArray = reverseControlPoints(copyConfig);
                p = reverseArray[reverseArray.length - 1];
                reverseArray.pop();
                p.x = -p.x;
                p.y = -p.y;
                reverseArray.unshift(p);
                for (var i = 1; i < reverseArray.length; ++i) {
                    current = reverseArray[i];
                    current.x = -current.x;
                    current.y = -current.y;
                    current.x += p.x;
                    current.y += p.y;
                    reverseArray[i] = current;
                    p = current;
                }
                return cc.cardinalSplineBy(this._duration, reverseArray, this._tension);
            },
            updatePosition: function(newPos) {
                var pos = this._startPosition;
                var posX = newPos.x + pos.x;
                var posY = newPos.y + pos.y;
                this._previousPosition.x = posX;
                this._previousPosition.y = posY;
                this.target.setPosition(posX, posY);
            },
            clone: function() {
                var a = new cc.CardinalSplineBy();
                a.initWithDuration(this._duration, cloneControlPoints(this._points), this._tension);
                return a;
            }
        });
        cc.cardinalSplineBy = function(duration, points, tension) {
            return new cc.CardinalSplineBy(duration, points, tension);
        };
        cc.CatmullRomTo = cc.CardinalSplineTo.extend({
            ctor: function(dt, points) {
                points && this.initWithDuration(dt, points);
            },
            initWithDuration: function(dt, points) {
                return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, .5);
            },
            clone: function() {
                var action = new cc.CatmullRomTo();
                action.initWithDuration(this._duration, cloneControlPoints(this._points));
                return action;
            }
        });
        cc.catmullRomTo = function(dt, points) {
            return new cc.CatmullRomTo(dt, points);
        };
        cc.CatmullRomBy = cc.CardinalSplineBy.extend({
            ctor: function(dt, points) {
                cc.CardinalSplineBy.prototype.ctor.call(this);
                points && this.initWithDuration(dt, points);
            },
            initWithDuration: function(dt, points) {
                return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, .5);
            },
            clone: function() {
                var action = new cc.CatmullRomBy();
                action.initWithDuration(this._duration, cloneControlPoints(this._points));
                return action;
            }
        });
        cc.catmullRomBy = function(dt, points) {
            return new cc.CatmullRomBy(dt, points);
        };
    }), {} ],
    6: [ (function(require, module, exports) {
        cc.ActionEase = cc.ActionInterval.extend({
            _inner: null,
            ctor: function(action) {
                cc.ActionInterval.prototype.ctor.call(this);
                action && this.initWithAction(action);
            },
            initWithAction: function(action) {
                if (!action) {
                    throw new Error("cc.ActionEase.initWithAction(): action must be non nil");
                }
                if (this.initWithDuration(action.getDuration())) {
                    this._inner = action;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.ActionEase();
                action.initWithAction(this._inner.clone());
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._inner.startWithTarget(this.target);
            },
            stop: function() {
                this._inner.stop();
                cc.ActionInterval.prototype.stop.call(this);
            },
            update: function(dt) {
                this._inner.update(dt);
            },
            reverse: function() {
                return new cc.ActionEase(this._inner.reverse());
            },
            getInnerAction: function() {
                return this._inner;
            }
        });
        cc.actionEase = function(action) {
            return new cc.ActionEase(action);
        };
        cc.EaseRateAction = cc.ActionEase.extend({
            _rate: 0,
            ctor: function(action, rate) {
                cc.ActionEase.prototype.ctor.call(this);
                void 0 !== rate && this.initWithAction(action, rate);
            },
            setRate: function(rate) {
                this._rate = rate;
            },
            getRate: function() {
                return this._rate;
            },
            initWithAction: function(action, rate) {
                if (cc.ActionEase.prototype.initWithAction.call(this, action)) {
                    this._rate = rate;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.EaseRateAction();
                action.initWithAction(this._inner.clone(), this._rate);
                return action;
            },
            reverse: function() {
                return new cc.EaseRateAction(this._inner.reverse(), 1 / this._rate);
            }
        });
        cc.easeRateAction = function(action, rate) {
            return new cc.EaseRateAction(action, rate);
        };
        cc.EaseIn = cc.EaseRateAction.extend({
            update: function(dt) {
                this._inner.update(Math.pow(dt, this._rate));
            },
            reverse: function() {
                return new cc.EaseIn(this._inner.reverse(), 1 / this._rate);
            },
            clone: function() {
                var action = new cc.EaseIn();
                action.initWithAction(this._inner.clone(), this._rate);
                return action;
            }
        });
        cc.easeIn = function(rate) {
            return {
                _rate: rate,
                easing: function(dt) {
                    return Math.pow(dt, this._rate);
                },
                reverse: function() {
                    return cc.easeIn(1 / this._rate);
                }
            };
        };
        cc.EaseOut = cc.EaseRateAction.extend({
            update: function(dt) {
                this._inner.update(Math.pow(dt, 1 / this._rate));
            },
            reverse: function() {
                return new cc.EaseOut(this._inner.reverse(), 1 / this._rate);
            },
            clone: function() {
                var action = new cc.EaseOut();
                action.initWithAction(this._inner.clone(), this._rate);
                return action;
            }
        });
        cc.easeOut = function(rate) {
            return {
                _rate: rate,
                easing: function(dt) {
                    return Math.pow(dt, 1 / this._rate);
                },
                reverse: function() {
                    return cc.easeOut(1 / this._rate);
                }
            };
        };
        cc.EaseInOut = cc.EaseRateAction.extend({
            update: function(dt) {
                dt *= 2;
                dt < 1 ? this._inner.update(.5 * Math.pow(dt, this._rate)) : this._inner.update(1 - .5 * Math.pow(2 - dt, this._rate));
            },
            clone: function() {
                var action = new cc.EaseInOut();
                action.initWithAction(this._inner.clone(), this._rate);
                return action;
            },
            reverse: function() {
                return new cc.EaseInOut(this._inner.reverse(), this._rate);
            }
        });
        cc.easeInOut = function(rate) {
            return {
                _rate: rate,
                easing: function(dt) {
                    dt *= 2;
                    return dt < 1 ? .5 * Math.pow(dt, this._rate) : 1 - .5 * Math.pow(2 - dt, this._rate);
                },
                reverse: function() {
                    return cc.easeInOut(this._rate);
                }
            };
        };
        cc.EaseExponentialIn = cc.ActionEase.extend({
            update: function(dt) {
                this._inner.update(0 === dt ? 0 : Math.pow(2, 10 * (dt - 1)));
            },
            reverse: function() {
                return new cc.EaseExponentialOut(this._inner.reverse());
            },
            clone: function() {
                var action = new cc.EaseExponentialIn();
                action.initWithAction(this._inner.clone());
                return action;
            }
        });
        cc._easeExponentialInObj = {
            easing: function(dt) {
                return 0 === dt ? 0 : Math.pow(2, 10 * (dt - 1));
            },
            reverse: function() {
                return cc._easeExponentialOutObj;
            }
        };
        cc.easeExponentialIn = function() {
            return cc._easeExponentialInObj;
        };
        cc.EaseExponentialOut = cc.ActionEase.extend({
            update: function(dt) {
                this._inner.update(1 === dt ? 1 : -Math.pow(2, -10 * dt) + 1);
            },
            reverse: function() {
                return new cc.EaseExponentialIn(this._inner.reverse());
            },
            clone: function() {
                var action = new cc.EaseExponentialOut();
                action.initWithAction(this._inner.clone());
                return action;
            }
        });
        cc._easeExponentialOutObj = {
            easing: function(dt) {
                return 1 === dt ? 1 : -Math.pow(2, -10 * dt) + 1;
            },
            reverse: function() {
                return cc._easeExponentialInObj;
            }
        };
        cc.easeExponentialOut = function() {
            return cc._easeExponentialOutObj;
        };
        cc.EaseExponentialInOut = cc.ActionEase.extend({
            update: function(dt) {
                if (1 !== dt && 0 !== dt) {
                    dt *= 2;
                    dt = dt < 1 ? .5 * Math.pow(2, 10 * (dt - 1)) : .5 * (-Math.pow(2, -10 * (dt - 1)) + 2);
                }
                this._inner.update(dt);
            },
            reverse: function() {
                return new cc.EaseExponentialInOut(this._inner.reverse());
            },
            clone: function() {
                var action = new cc.EaseExponentialInOut();
                action.initWithAction(this._inner.clone());
                return action;
            }
        });
        cc._easeExponentialInOutObj = {
            easing: function(dt) {
                if (1 !== dt && 0 !== dt) {
                    dt *= 2;
                    return dt < 1 ? .5 * Math.pow(2, 10 * (dt - 1)) : .5 * (-Math.pow(2, -10 * (dt - 1)) + 2);
                }
                return dt;
            },
            reverse: function() {
                return cc._easeExponentialInOutObj;
            }
        };
        cc.easeExponentialInOut = function() {
            return cc._easeExponentialInOutObj;
        };
        cc.EaseSineIn = cc.ActionEase.extend({
            update: function(dt) {
                dt = 0 === dt || 1 === dt ? dt : -1 * Math.cos(dt * Math.PI / 2) + 1;
                this._inner.update(dt);
            },
            reverse: function() {
                return new cc.EaseSineOut(this._inner.reverse());
            },
            clone: function() {
                var action = new cc.EaseSineIn();
                action.initWithAction(this._inner.clone());
                return action;
            }
        });
        cc._easeSineInObj = {
            easing: function(dt) {
                return 0 === dt || 1 === dt ? dt : -1 * Math.cos(dt * Math.PI / 2) + 1;
            },
            reverse: function() {
                return cc._easeSineOutObj;
            }
        };
        cc.easeSineIn = function() {
            return cc._easeSineInObj;
        };
        cc.EaseSineOut = cc.ActionEase.extend({
            update: function(dt) {
                dt = 0 === dt || 1 === dt ? dt : Math.sin(dt * Math.PI / 2);
                this._inner.update(dt);
            },
            reverse: function() {
                return new cc.EaseSineIn(this._inner.reverse());
            },
            clone: function() {
                var action = new cc.EaseSineOut();
                action.initWithAction(this._inner.clone());
                return action;
            }
        });
        cc._easeSineOutObj = {
            easing: function(dt) {
                return 0 === dt || 1 === dt ? dt : Math.sin(dt * Math.PI / 2);
            },
            reverse: function() {
                return cc._easeSineInObj;
            }
        };
        cc.easeSineOut = function() {
            return cc._easeSineOutObj;
        };
        cc.EaseSineInOut = cc.ActionEase.extend({
            update: function(dt) {
                dt = 0 === dt || 1 === dt ? dt : -.5 * (Math.cos(Math.PI * dt) - 1);
                this._inner.update(dt);
            },
            clone: function() {
                var action = new cc.EaseSineInOut();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseSineInOut(this._inner.reverse());
            }
        });
        cc._easeSineInOutObj = {
            easing: function(dt) {
                return 0 === dt || 1 === dt ? dt : -.5 * (Math.cos(Math.PI * dt) - 1);
            },
            reverse: function() {
                return cc._easeSineInOutObj;
            }
        };
        cc.easeSineInOut = function() {
            return cc._easeSineInOutObj;
        };
        cc.EaseElastic = cc.ActionEase.extend({
            _period: .3,
            ctor: function(action, period) {
                cc.ActionEase.prototype.ctor.call(this);
                action && this.initWithAction(action, period);
            },
            getPeriod: function() {
                return this._period;
            },
            setPeriod: function(period) {
                this._period = period;
            },
            initWithAction: function(action, period) {
                cc.ActionEase.prototype.initWithAction.call(this, action);
                this._period = null == period ? .3 : period;
                return true;
            },
            reverse: function() {
                cc.logID(1009);
                return null;
            },
            clone: function() {
                var action = new cc.EaseElastic();
                action.initWithAction(this._inner.clone(), this._period);
                return action;
            }
        });
        cc.EaseElasticIn = cc.EaseElastic.extend({
            update: function(dt) {
                var newT = 0;
                if (0 === dt || 1 === dt) {
                    newT = dt;
                } else {
                    var s = this._period / 4;
                    dt -= 1;
                    newT = -Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / this._period);
                }
                this._inner.update(newT);
            },
            reverse: function() {
                return new cc.EaseElasticOut(this._inner.reverse(), this._period);
            },
            clone: function() {
                var action = new cc.EaseElasticIn();
                action.initWithAction(this._inner.clone(), this._period);
                return action;
            }
        });
        cc._easeElasticInObj = {
            easing: function(dt) {
                if (0 === dt || 1 === dt) {
                    return dt;
                }
                dt -= 1;
                return -Math.pow(2, 10 * dt) * Math.sin((dt - .075) * Math.PI * 2 / .3);
            },
            reverse: function() {
                return cc._easeElasticOutObj;
            }
        };
        cc.easeElasticIn = function(period) {
            if (period && .3 !== period) {
                return {
                    _period: period,
                    easing: function(dt) {
                        if (0 === dt || 1 === dt) {
                            return dt;
                        }
                        dt -= 1;
                        return -Math.pow(2, 10 * dt) * Math.sin((dt - this._period / 4) * Math.PI * 2 / this._period);
                    },
                    reverse: function() {
                        return cc.easeElasticOut(this._period);
                    }
                };
            }
            return cc._easeElasticInObj;
        };
        cc.EaseElasticOut = cc.EaseElastic.extend({
            update: function(dt) {
                var newT = 0;
                if (0 === dt || 1 === dt) {
                    newT = dt;
                } else {
                    var s = this._period / 4;
                    newT = Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / this._period) + 1;
                }
                this._inner.update(newT);
            },
            reverse: function() {
                return new cc.EaseElasticIn(this._inner.reverse(), this._period);
            },
            clone: function() {
                var action = new cc.EaseElasticOut();
                action.initWithAction(this._inner.clone(), this._period);
                return action;
            }
        });
        cc._easeElasticOutObj = {
            easing: function(dt) {
                return 0 === dt || 1 === dt ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - .075) * Math.PI * 2 / .3) + 1;
            },
            reverse: function() {
                return cc._easeElasticInObj;
            }
        };
        cc.easeElasticOut = function(period) {
            if (period && .3 !== period) {
                return {
                    _period: period,
                    easing: function(dt) {
                        return 0 === dt || 1 === dt ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - this._period / 4) * Math.PI * 2 / this._period) + 1;
                    },
                    reverse: function() {
                        return cc.easeElasticIn(this._period);
                    }
                };
            }
            return cc._easeElasticOutObj;
        };
        cc.EaseElasticInOut = cc.EaseElastic.extend({
            update: function(dt) {
                var newT = 0;
                var locPeriod = this._period;
                if (0 === dt || 1 === dt) {
                    newT = dt;
                } else {
                    dt *= 2;
                    locPeriod || (locPeriod = this._period = .3 * 1.5);
                    var s = locPeriod / 4;
                    dt -= 1;
                    newT = dt < 0 ? -.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) : Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) * .5 + 1;
                }
                this._inner.update(newT);
            },
            reverse: function() {
                return new cc.EaseElasticInOut(this._inner.reverse(), this._period);
            },
            clone: function() {
                var action = new cc.EaseElasticInOut();
                action.initWithAction(this._inner.clone(), this._period);
                return action;
            }
        });
        cc.easeElasticInOut = function(period) {
            period = period || .3;
            return {
                _period: period,
                easing: function(dt) {
                    var newT = 0;
                    var locPeriod = this._period;
                    if (0 === dt || 1 === dt) {
                        newT = dt;
                    } else {
                        dt *= 2;
                        locPeriod || (locPeriod = this._period = .3 * 1.5);
                        var s = locPeriod / 4;
                        dt -= 1;
                        newT = dt < 0 ? -.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) : Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) * .5 + 1;
                    }
                    return newT;
                },
                reverse: function() {
                    return cc.easeElasticInOut(this._period);
                }
            };
        };
        cc.EaseBounce = cc.ActionEase.extend({
            bounceTime: function(time1) {
                if (time1 < 1 / 2.75) {
                    return 7.5625 * time1 * time1;
                }
                if (time1 < 2 / 2.75) {
                    time1 -= 1.5 / 2.75;
                    return 7.5625 * time1 * time1 + .75;
                }
                if (time1 < 2.5 / 2.75) {
                    time1 -= 2.25 / 2.75;
                    return 7.5625 * time1 * time1 + .9375;
                }
                time1 -= 2.625 / 2.75;
                return 7.5625 * time1 * time1 + .984375;
            },
            clone: function() {
                var action = new cc.EaseBounce();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseBounce(this._inner.reverse());
            }
        });
        cc.EaseBounceIn = cc.EaseBounce.extend({
            update: function(dt) {
                var newT = 1 - this.bounceTime(1 - dt);
                this._inner.update(newT);
            },
            reverse: function() {
                return new cc.EaseBounceOut(this._inner.reverse());
            },
            clone: function() {
                var action = new cc.EaseBounceIn();
                action.initWithAction(this._inner.clone());
                return action;
            }
        });
        cc._bounceTime = function(time1) {
            if (time1 < 1 / 2.75) {
                return 7.5625 * time1 * time1;
            }
            if (time1 < 2 / 2.75) {
                time1 -= 1.5 / 2.75;
                return 7.5625 * time1 * time1 + .75;
            }
            if (time1 < 2.5 / 2.75) {
                time1 -= 2.25 / 2.75;
                return 7.5625 * time1 * time1 + .9375;
            }
            time1 -= 2.625 / 2.75;
            return 7.5625 * time1 * time1 + .984375;
        };
        cc._easeBounceInObj = {
            easing: function(dt) {
                return 1 - cc._bounceTime(1 - dt);
            },
            reverse: function() {
                return cc._easeBounceOutObj;
            }
        };
        cc.easeBounceIn = function() {
            return cc._easeBounceInObj;
        };
        cc.EaseBounceOut = cc.EaseBounce.extend({
            update: function(dt) {
                var newT = this.bounceTime(dt);
                this._inner.update(newT);
            },
            reverse: function() {
                return new cc.EaseBounceIn(this._inner.reverse());
            },
            clone: function() {
                var action = new cc.EaseBounceOut();
                action.initWithAction(this._inner.clone());
                return action;
            }
        });
        cc._easeBounceOutObj = {
            easing: function(dt) {
                return cc._bounceTime(dt);
            },
            reverse: function() {
                return cc._easeBounceInObj;
            }
        };
        cc.easeBounceOut = function() {
            return cc._easeBounceOutObj;
        };
        cc.EaseBounceInOut = cc.EaseBounce.extend({
            update: function(dt) {
                var newT = 0;
                if (dt < .5) {
                    dt *= 2;
                    newT = .5 * (1 - this.bounceTime(1 - dt));
                } else {
                    newT = .5 * this.bounceTime(2 * dt - 1) + .5;
                }
                this._inner.update(newT);
            },
            clone: function() {
                var action = new cc.EaseBounceInOut();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseBounceInOut(this._inner.reverse());
            }
        });
        cc._easeBounceInOutObj = {
            easing: function(time1) {
                var newT;
                if (time1 < .5) {
                    time1 *= 2;
                    newT = .5 * (1 - cc._bounceTime(1 - time1));
                } else {
                    newT = .5 * cc._bounceTime(2 * time1 - 1) + .5;
                }
                return newT;
            },
            reverse: function() {
                return cc._easeBounceInOutObj;
            }
        };
        cc.easeBounceInOut = function() {
            return cc._easeBounceInOutObj;
        };
        cc.EaseBackIn = cc.ActionEase.extend({
            update: function(dt) {
                var overshoot = 1.70158;
                dt = 0 === dt || 1 === dt ? dt : dt * dt * ((overshoot + 1) * dt - overshoot);
                this._inner.update(dt);
            },
            reverse: function() {
                return new cc.EaseBackOut(this._inner.reverse());
            },
            clone: function() {
                var action = new cc.EaseBackIn();
                action.initWithAction(this._inner.clone());
                return action;
            }
        });
        cc._easeBackInObj = {
            easing: function(time1) {
                var overshoot = 1.70158;
                return 0 === time1 || 1 === time1 ? time1 : time1 * time1 * ((overshoot + 1) * time1 - overshoot);
            },
            reverse: function() {
                return cc._easeBackOutObj;
            }
        };
        cc.easeBackIn = function() {
            return cc._easeBackInObj;
        };
        cc.EaseBackOut = cc.ActionEase.extend({
            update: function(dt) {
                var overshoot = 1.70158;
                dt -= 1;
                this._inner.update(dt * dt * ((overshoot + 1) * dt + overshoot) + 1);
            },
            reverse: function() {
                return new cc.EaseBackIn(this._inner.reverse());
            },
            clone: function() {
                var action = new cc.EaseBackOut();
                action.initWithAction(this._inner.clone());
                return action;
            }
        });
        cc._easeBackOutObj = {
            easing: function(time1) {
                var overshoot = 1.70158;
                time1 -= 1;
                return time1 * time1 * ((overshoot + 1) * time1 + overshoot) + 1;
            },
            reverse: function() {
                return cc._easeBackInObj;
            }
        };
        cc.easeBackOut = function() {
            return cc._easeBackOutObj;
        };
        cc.EaseBackInOut = cc.ActionEase.extend({
            update: function(dt) {
                var overshoot = 2.5949095;
                dt *= 2;
                if (dt < 1) {
                    this._inner.update(dt * dt * ((overshoot + 1) * dt - overshoot) / 2);
                } else {
                    dt -= 2;
                    this._inner.update(dt * dt * ((overshoot + 1) * dt + overshoot) / 2 + 1);
                }
            },
            clone: function() {
                var action = new cc.EaseBackInOut();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseBackInOut(this._inner.reverse());
            }
        });
        cc._easeBackInOutObj = {
            easing: function(time1) {
                var overshoot = 2.5949095;
                time1 *= 2;
                if (time1 < 1) {
                    return time1 * time1 * ((overshoot + 1) * time1 - overshoot) / 2;
                }
                time1 -= 2;
                return time1 * time1 * ((overshoot + 1) * time1 + overshoot) / 2 + 1;
            },
            reverse: function() {
                return cc._easeBackInOutObj;
            }
        };
        cc.easeBackInOut = function() {
            return cc._easeBackInOutObj;
        };
        cc.EaseBezierAction = cc.ActionEase.extend({
            _p0: null,
            _p1: null,
            _p2: null,
            _p3: null,
            ctor: function(action) {
                cc.ActionEase.prototype.ctor.call(this, action);
            },
            _updateTime: function(a, b, c, d, t) {
                return Math.pow(1 - t, 3) * a + 3 * t * Math.pow(1 - t, 2) * b + 3 * Math.pow(t, 2) * (1 - t) * c + Math.pow(t, 3) * d;
            },
            update: function(dt) {
                var t = this._updateTime(this._p0, this._p1, this._p2, this._p3, dt);
                this._inner.update(t);
            },
            clone: function() {
                var action = new cc.EaseBezierAction();
                action.initWithAction(this._inner.clone());
                action.setBezierParamer(this._p0, this._p1, this._p2, this._p3);
                return action;
            },
            reverse: function() {
                var action = new cc.EaseBezierAction(this._inner.reverse());
                action.setBezierParamer(this._p3, this._p2, this._p1, this._p0);
                return action;
            },
            setBezierParamer: function(p0, p1, p2, p3) {
                this._p0 = p0 || 0;
                this._p1 = p1 || 0;
                this._p2 = p2 || 0;
                this._p3 = p3 || 0;
            }
        });
        cc.easeBezierAction = function(p0, p1, p2, p3) {
            return {
                easing: function(time) {
                    return cc.EaseBezierAction.prototype._updateTime(p0, p1, p2, p3, time);
                },
                reverse: function() {
                    return cc.easeBezierAction(p3, p2, p1, p0);
                }
            };
        };
        cc.EaseQuadraticActionIn = cc.ActionEase.extend({
            _updateTime: function(time) {
                return Math.pow(time, 2);
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseQuadraticActionIn();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseQuadraticActionIn(this._inner.reverse());
            }
        });
        cc._easeQuadraticActionIn = {
            easing: cc.EaseQuadraticActionIn.prototype._updateTime,
            reverse: function() {
                return cc._easeQuadraticActionIn;
            }
        };
        cc.easeQuadraticActionIn = function() {
            return cc._easeQuadraticActionIn;
        };
        cc.EaseQuadraticActionOut = cc.ActionEase.extend({
            _updateTime: function(time) {
                return -time * (time - 2);
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseQuadraticActionOut();
                action.initWithAction();
                return action;
            },
            reverse: function() {
                return new cc.EaseQuadraticActionOut(this._inner.reverse());
            }
        });
        cc._easeQuadraticActionOut = {
            easing: cc.EaseQuadraticActionOut.prototype._updateTime,
            reverse: function() {
                return cc._easeQuadraticActionOut;
            }
        };
        cc.easeQuadraticActionOut = function() {
            return cc._easeQuadraticActionOut;
        };
        cc.EaseQuadraticActionInOut = cc.ActionEase.extend({
            _updateTime: function(time) {
                var resultTime = time;
                time *= 2;
                if (time < 1) {
                    resultTime = time * time * .5;
                } else {
                    --time;
                    resultTime = -.5 * (time * (time - 2) - 1);
                }
                return resultTime;
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseQuadraticActionInOut();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseQuadraticActionInOut(this._inner.reverse());
            }
        });
        cc._easeQuadraticActionInOut = {
            easing: cc.EaseQuadraticActionInOut.prototype._updateTime,
            reverse: function() {
                return cc._easeQuadraticActionInOut;
            }
        };
        cc.easeQuadraticActionInOut = function() {
            return cc._easeQuadraticActionInOut;
        };
        cc.EaseQuarticActionIn = cc.ActionEase.extend({
            _updateTime: function(time) {
                return time * time * time * time;
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseQuarticActionIn();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseQuarticActionIn(this._inner.reverse());
            }
        });
        cc._easeQuarticActionIn = {
            easing: cc.EaseQuarticActionIn.prototype._updateTime,
            reverse: function() {
                return cc._easeQuarticActionIn;
            }
        };
        cc.easeQuarticActionIn = function() {
            return cc._easeQuarticActionIn;
        };
        cc.EaseQuarticActionOut = cc.ActionEase.extend({
            _updateTime: function(time) {
                time -= 1;
                return -(time * time * time * time - 1);
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseQuarticActionOut();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseQuarticActionOut(this._inner.reverse());
            }
        });
        cc._easeQuarticActionOut = {
            easing: cc.EaseQuarticActionOut.prototype._updateTime,
            reverse: function() {
                return cc._easeQuarticActionOut;
            }
        };
        cc.easeQuarticActionOut = function() {
            return cc._easeQuarticActionOut;
        };
        cc.EaseQuarticActionInOut = cc.ActionEase.extend({
            _updateTime: function(time) {
                time *= 2;
                if (time < 1) {
                    return .5 * time * time * time * time;
                }
                time -= 2;
                return -.5 * (time * time * time * time - 2);
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseQuarticActionInOut();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseQuarticActionInOut(this._inner.reverse());
            }
        });
        cc._easeQuarticActionInOut = {
            easing: cc.EaseQuarticActionInOut.prototype._updateTime,
            reverse: function() {
                return cc._easeQuarticActionInOut;
            }
        };
        cc.easeQuarticActionInOut = function() {
            return cc._easeQuarticActionInOut;
        };
        cc.EaseQuinticActionIn = cc.ActionEase.extend({
            _updateTime: function(time) {
                return time * time * time * time * time;
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseQuinticActionIn();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseQuinticActionIn(this._inner.reverse());
            }
        });
        cc._easeQuinticActionIn = {
            easing: cc.EaseQuinticActionIn.prototype._updateTime,
            reverse: function() {
                return cc._easeQuinticActionIn;
            }
        };
        cc.easeQuinticActionIn = function() {
            return cc._easeQuinticActionIn;
        };
        cc.EaseQuinticActionOut = cc.ActionEase.extend({
            _updateTime: function(time) {
                time -= 1;
                return time * time * time * time * time + 1;
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseQuinticActionOut();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseQuinticActionOut(this._inner.reverse());
            }
        });
        cc._easeQuinticActionOut = {
            easing: cc.EaseQuinticActionOut.prototype._updateTime,
            reverse: function() {
                return cc._easeQuinticActionOut;
            }
        };
        cc.easeQuinticActionOut = function() {
            return cc._easeQuinticActionOut;
        };
        cc.EaseQuinticActionInOut = cc.ActionEase.extend({
            _updateTime: function(time) {
                time *= 2;
                if (time < 1) {
                    return .5 * time * time * time * time * time;
                }
                time -= 2;
                return .5 * (time * time * time * time * time + 2);
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseQuinticActionInOut();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseQuinticActionInOut(this._inner.reverse());
            }
        });
        cc._easeQuinticActionInOut = {
            easing: cc.EaseQuinticActionInOut.prototype._updateTime,
            reverse: function() {
                return cc._easeQuinticActionInOut;
            }
        };
        cc.easeQuinticActionInOut = function() {
            return cc._easeQuinticActionInOut;
        };
        cc.EaseCircleActionIn = cc.ActionEase.extend({
            _updateTime: function(time) {
                return -1 * (Math.sqrt(1 - time * time) - 1);
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseCircleActionIn();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseCircleActionIn(this._inner.reverse());
            }
        });
        cc._easeCircleActionIn = {
            easing: cc.EaseCircleActionIn.prototype._updateTime,
            reverse: function() {
                return cc._easeCircleActionIn;
            }
        };
        cc.easeCircleActionIn = function() {
            return cc._easeCircleActionIn;
        };
        cc.EaseCircleActionOut = cc.ActionEase.extend({
            _updateTime: function(time) {
                time -= 1;
                return Math.sqrt(1 - time * time);
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseCircleActionOut();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseCircleActionOut(this._inner.reverse());
            }
        });
        cc._easeCircleActionOut = {
            easing: cc.EaseCircleActionOut.prototype._updateTime,
            reverse: function() {
                return cc._easeCircleActionOut;
            }
        };
        cc.easeCircleActionOut = function() {
            return cc._easeCircleActionOut;
        };
        cc.EaseCircleActionInOut = cc.ActionEase.extend({
            _updateTime: function(time) {
                time *= 2;
                if (time < 1) {
                    return -.5 * (Math.sqrt(1 - time * time) - 1);
                }
                time -= 2;
                return .5 * (Math.sqrt(1 - time * time) + 1);
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseCircleActionInOut();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseCircleActionInOut(this._inner.reverse());
            }
        });
        cc._easeCircleActionInOut = {
            easing: cc.EaseCircleActionInOut.prototype._updateTime,
            reverse: function() {
                return cc._easeCircleActionInOut;
            }
        };
        cc.easeCircleActionInOut = function() {
            return cc._easeCircleActionInOut;
        };
        cc.EaseCubicActionIn = cc.ActionEase.extend({
            _updateTime: function(time) {
                return time * time * time;
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseCubicActionIn();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseCubicActionIn(this._inner.reverse());
            }
        });
        cc._easeCubicActionIn = {
            easing: cc.EaseCubicActionIn.prototype._updateTime,
            reverse: function() {
                return cc._easeCubicActionIn;
            }
        };
        cc.easeCubicActionIn = function() {
            return cc._easeCubicActionIn;
        };
        cc.EaseCubicActionOut = cc.ActionEase.extend({
            _updateTime: function(time) {
                time -= 1;
                return time * time * time + 1;
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseCubicActionOut();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseCubicActionOut(this._inner.reverse());
            }
        });
        cc._easeCubicActionOut = {
            easing: cc.EaseCubicActionOut.prototype._updateTime,
            reverse: function() {
                return cc._easeCubicActionOut;
            }
        };
        cc.easeCubicActionOut = function() {
            return cc._easeCubicActionOut;
        };
        cc.EaseCubicActionInOut = cc.ActionEase.extend({
            _updateTime: function(time) {
                time *= 2;
                if (time < 1) {
                    return .5 * time * time * time;
                }
                time -= 2;
                return .5 * (time * time * time + 2);
            },
            update: function(dt) {
                this._inner.update(this._updateTime(dt));
            },
            clone: function() {
                var action = new cc.EaseCubicActionInOut();
                action.initWithAction(this._inner.clone());
                return action;
            },
            reverse: function() {
                return new cc.EaseCubicActionInOut(this._inner.reverse());
            }
        });
        cc._easeCubicActionInOut = {
            easing: cc.EaseCubicActionInOut.prototype._updateTime,
            reverse: function() {
                return cc._easeCubicActionInOut;
            }
        };
        cc.easeCubicActionInOut = function() {
            return cc._easeCubicActionInOut;
        };
    }), {} ],
    7: [ (function(require, module, exports) {
        cc.ActionInstant = cc.FiniteTimeAction.extend({
            isDone: function() {
                return true;
            },
            step: function(dt) {
                this.update(1);
            },
            update: function(dt) {},
            reverse: function() {
                return this.clone();
            },
            clone: function() {
                return new cc.ActionInstant();
            }
        });
        cc.Show = cc.ActionInstant.extend({
            update: function(dt) {
                var _renderComps = this.target.getComponentsInChildren(cc._SGComponent);
                for (var i = 0; i < _renderComps.length; ++i) {
                    var render = _renderComps[i];
                    render.enabled = true;
                }
            },
            reverse: function() {
                return new cc.Hide();
            },
            clone: function() {
                return new cc.Show();
            }
        });
        cc.show = function() {
            return new cc.Show();
        };
        cc.Hide = cc.ActionInstant.extend({
            update: function(dt) {
                var _renderComps = this.target.getComponentsInChildren(cc._SGComponent);
                for (var i = 0; i < _renderComps.length; ++i) {
                    var render = _renderComps[i];
                    render.enabled = false;
                }
            },
            reverse: function() {
                return new cc.Show();
            },
            clone: function() {
                return new cc.Hide();
            }
        });
        cc.hide = function() {
            return new cc.Hide();
        };
        cc.ToggleVisibility = cc.ActionInstant.extend({
            update: function(dt) {
                var _renderComps = this.target.getComponentsInChildren(cc._SGComponent);
                for (var i = 0; i < _renderComps.length; ++i) {
                    var render = _renderComps[i];
                    render.enabled = !render.enabled;
                }
            },
            reverse: function() {
                return new cc.ToggleVisibility();
            },
            clone: function() {
                return new cc.ToggleVisibility();
            }
        });
        cc.toggleVisibility = function() {
            return new cc.ToggleVisibility();
        };
        cc.RemoveSelf = cc.ActionInstant.extend({
            _isNeedCleanUp: true,
            ctor: function(isNeedCleanUp) {
                cc.FiniteTimeAction.prototype.ctor.call(this);
                void 0 !== isNeedCleanUp && this.init(isNeedCleanUp);
            },
            update: function(dt) {
                this.target.removeFromParent(this._isNeedCleanUp);
            },
            init: function(isNeedCleanUp) {
                this._isNeedCleanUp = isNeedCleanUp;
                return true;
            },
            reverse: function() {
                return new cc.RemoveSelf(this._isNeedCleanUp);
            },
            clone: function() {
                return new cc.RemoveSelf(this._isNeedCleanUp);
            }
        });
        cc.removeSelf = function(isNeedCleanUp) {
            return new cc.RemoveSelf(isNeedCleanUp);
        };
        cc.FlipX = cc.ActionInstant.extend({
            _flippedX: false,
            ctor: function(flip) {
                cc.FiniteTimeAction.prototype.ctor.call(this);
                this._flippedX = false;
                void 0 !== flip && this.initWithFlipX(flip);
            },
            initWithFlipX: function(flip) {
                this._flippedX = flip;
                return true;
            },
            update: function(dt) {
                this.target.scaleX = Math.abs(this.target.scaleX) * (this._flippedX ? -1 : 1);
            },
            reverse: function() {
                return new cc.FlipX(!this._flippedX);
            },
            clone: function() {
                var action = new cc.FlipX();
                action.initWithFlipX(this._flippedX);
                return action;
            }
        });
        cc.flipX = function(flip) {
            return new cc.FlipX(flip);
        };
        cc.FlipY = cc.ActionInstant.extend({
            _flippedY: false,
            ctor: function(flip) {
                cc.FiniteTimeAction.prototype.ctor.call(this);
                this._flippedY = false;
                void 0 !== flip && this.initWithFlipY(flip);
            },
            initWithFlipY: function(flip) {
                this._flippedY = flip;
                return true;
            },
            update: function(dt) {
                this.target.scaleY = Math.abs(this.target.scaleY) * (this._flippedY ? -1 : 1);
            },
            reverse: function() {
                return new cc.FlipY(!this._flippedY);
            },
            clone: function() {
                var action = new cc.FlipY();
                action.initWithFlipY(this._flippedY);
                return action;
            }
        });
        cc.flipY = function(flip) {
            return new cc.FlipY(flip);
        };
        cc.Place = cc.ActionInstant.extend({
            _x: 0,
            _y: 0,
            ctor: function(pos, y) {
                cc.FiniteTimeAction.prototype.ctor.call(this);
                this._x = 0;
                this._y = 0;
                if (void 0 !== pos) {
                    if (void 0 !== pos.x) {
                        y = pos.y;
                        pos = pos.x;
                    }
                    this.initWithPosition(pos, y);
                }
            },
            initWithPosition: function(x, y) {
                this._x = x;
                this._y = y;
                return true;
            },
            update: function(dt) {
                this.target.setPosition(this._x, this._y);
            },
            clone: function() {
                var action = new cc.Place();
                action.initWithPosition(this._x, this._y);
                return action;
            }
        });
        cc.place = function(pos, y) {
            return new cc.Place(pos, y);
        };
        cc.CallFunc = cc.ActionInstant.extend({
            _selectorTarget: null,
            _function: null,
            _data: null,
            ctor: function(selector, selectorTarget, data) {
                cc.FiniteTimeAction.prototype.ctor.call(this);
                this.initWithFunction(selector, selectorTarget, data);
            },
            initWithFunction: function(selector, selectorTarget, data) {
                selector && (this._function = selector);
                selectorTarget && (this._selectorTarget = selectorTarget);
                void 0 !== data && (this._data = data);
                return true;
            },
            execute: function() {
                this._function && this._function.call(this._selectorTarget, this.target, this._data);
            },
            update: function(dt) {
                this.execute();
            },
            getTargetCallback: function() {
                return this._selectorTarget;
            },
            setTargetCallback: function(sel) {
                if (sel !== this._selectorTarget) {
                    this._selectorTarget && (this._selectorTarget = null);
                    this._selectorTarget = sel;
                }
            },
            clone: function() {
                var action = new cc.CallFunc();
                action.initWithFunction(this._function, this._selectorTarget, this._data);
                return action;
            }
        });
        cc.callFunc = function(selector, selectorTarget, data) {
            return new cc.CallFunc(selector, selectorTarget, data);
        };
    }), {} ],
    8: [ (function(require, module, exports) {
        cc.ActionInterval = cc.FiniteTimeAction.extend({
            _elapsed: 0,
            _firstTick: false,
            _easeList: null,
            _timesForRepeat: 1,
            _repeatForever: false,
            _repeatMethod: false,
            _speed: 1,
            _speedMethod: false,
            ctor: function(d) {
                this._speed = 1;
                this._timesForRepeat = 1;
                this._repeatForever = false;
                this.MAX_VALUE = 2;
                this._repeatMethod = false;
                this._speedMethod = false;
                cc.FiniteTimeAction.prototype.ctor.call(this);
                void 0 !== d && this.initWithDuration(d);
            },
            getElapsed: function() {
                return this._elapsed;
            },
            initWithDuration: function(d) {
                this._duration = 0 === d ? cc.macro.FLT_EPSILON : d;
                this._elapsed = 0;
                this._firstTick = true;
                return true;
            },
            isDone: function() {
                return this._elapsed >= this._duration;
            },
            _cloneDecoration: function(action) {
                action._repeatForever = this._repeatForever;
                action._speed = this._speed;
                action._timesForRepeat = this._timesForRepeat;
                action._easeList = this._easeList;
                action._speedMethod = this._speedMethod;
                action._repeatMethod = this._repeatMethod;
            },
            _reverseEaseList: function(action) {
                if (this._easeList) {
                    action._easeList = [];
                    for (var i = 0; i < this._easeList.length; i++) {
                        action._easeList.push(this._easeList[i].reverse());
                    }
                }
            },
            clone: function() {
                var action = new cc.ActionInterval(this._duration);
                this._cloneDecoration(action);
                return action;
            },
            easing: function(easeObj) {
                this._easeList ? this._easeList.length = 0 : this._easeList = [];
                for (var i = 0; i < arguments.length; i++) {
                    this._easeList.push(arguments[i]);
                }
                return this;
            },
            _computeEaseTime: function(dt) {
                var locList = this._easeList;
                if (!locList || 0 === locList.length) {
                    return dt;
                }
                for (var i = 0, n = locList.length; i < n; i++) {
                    dt = locList[i].easing(dt);
                }
                return dt;
            },
            step: function(dt) {
                if (this._firstTick) {
                    this._firstTick = false;
                    this._elapsed = 0;
                } else {
                    this._elapsed += dt;
                }
                var t = this._elapsed / (this._duration > 1.192092896e-7 ? this._duration : 1.192092896e-7);
                t = 1 > t ? t : 1;
                this.update(t > 0 ? t : 0);
                if (this._repeatMethod && this._timesForRepeat > 1 && this.isDone()) {
                    this._repeatForever || this._timesForRepeat--;
                    this.startWithTarget(this.target);
                    this.step(this._elapsed - this._duration);
                }
            },
            startWithTarget: function(target) {
                cc.Action.prototype.startWithTarget.call(this, target);
                this._elapsed = 0;
                this._firstTick = true;
            },
            reverse: function() {
                cc.logID(1010);
                return null;
            },
            setAmplitudeRate: function(amp) {
                cc.logID(1011);
            },
            getAmplitudeRate: function() {
                cc.logID(1012);
                return 0;
            },
            speed: function(speed) {
                if (speed <= 0) {
                    cc.logID(1013);
                    return this;
                }
                this._speedMethod = true;
                this._speed *= speed;
                return this;
            },
            getSpeed: function() {
                return this._speed;
            },
            setSpeed: function(speed) {
                this._speed = speed;
                return this;
            },
            repeat: function(times) {
                times = Math.round(times);
                if (isNaN(times) || times < 1) {
                    cc.logID(1014);
                    return this;
                }
                this._repeatMethod = true;
                this._timesForRepeat *= times;
                return this;
            },
            repeatForever: function() {
                this._repeatMethod = true;
                this._timesForRepeat = this.MAX_VALUE;
                this._repeatForever = true;
                return this;
            }
        });
        cc.actionInterval = function(d) {
            return new cc.ActionInterval(d);
        };
        cc.Sequence = cc.ActionInterval.extend({
            _actions: null,
            _split: null,
            _last: 0,
            ctor: function(tempArray) {
                cc.ActionInterval.prototype.ctor.call(this);
                this._actions = [];
                var paramArray = tempArray instanceof Array ? tempArray : arguments;
                var last = paramArray.length - 1;
                last >= 0 && null == paramArray[last] && cc.logID(1015);
                if (last >= 0) {
                    var prev = paramArray[0], action1;
                    for (var i = 1; i < last; i++) {
                        if (paramArray[i]) {
                            action1 = prev;
                            prev = cc.Sequence._actionOneTwo(action1, paramArray[i]);
                        }
                    }
                    this.initWithTwoActions(prev, paramArray[last]);
                }
            },
            initWithTwoActions: function(actionOne, actionTwo) {
                if (!actionOne || !actionTwo) {
                    throw new Error("cc.Sequence.initWithTwoActions(): arguments must all be non nil");
                }
                var d = actionOne._duration + actionTwo._duration;
                this.initWithDuration(d);
                this._actions[0] = actionOne;
                this._actions[1] = actionTwo;
                return true;
            },
            clone: function() {
                var action = new cc.Sequence();
                this._cloneDecoration(action);
                action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._split = this._actions[0]._duration / this._duration;
                this._last = -1;
            },
            stop: function() {
                this._last !== -1 && this._actions[this._last].stop();
                cc.Action.prototype.stop.call(this);
            },
            update: function(dt) {
                var new_t, found = 0;
                var locSplit = this._split, locActions = this._actions, locLast = this._last, actionFound;
                dt = this._computeEaseTime(dt);
                if (dt < locSplit) {
                    new_t = 0 !== locSplit ? dt / locSplit : 1;
                    if (0 === found && 1 === locLast) {
                        locActions[1].update(0);
                        locActions[1].stop();
                    }
                } else {
                    found = 1;
                    new_t = 1 === locSplit ? 1 : (dt - locSplit) / (1 - locSplit);
                    if (locLast === -1) {
                        locActions[0].startWithTarget(this.target);
                        locActions[0].update(1);
                        locActions[0].stop();
                    }
                    if (!locLast) {
                        locActions[0].update(1);
                        locActions[0].stop();
                    }
                }
                actionFound = locActions[found];
                if (locLast === found && actionFound.isDone()) {
                    return;
                }
                locLast !== found && actionFound.startWithTarget(this.target);
                new_t *= actionFound._timesForRepeat;
                actionFound.update(new_t > 1 ? new_t % 1 : new_t);
                this._last = found;
            },
            reverse: function() {
                var action = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            }
        });
        cc.sequence = function(tempArray) {
            var paramArray = tempArray instanceof Array ? tempArray : arguments;
            var last = paramArray.length - 1;
            last >= 0 && null == paramArray[last] && cc.logID(1015);
            var result = null;
            if (last >= 0) {
                result = paramArray[0];
                for (var i = 1; i <= last; i++) {
                    paramArray[i] && (result = cc.Sequence._actionOneTwo(result, paramArray[i]));
                }
            }
            return result;
        };
        cc.Sequence._actionOneTwo = function(actionOne, actionTwo) {
            var sequence = new cc.Sequence();
            sequence.initWithTwoActions(actionOne, actionTwo);
            return sequence;
        };
        cc.Repeat = cc.ActionInterval.extend({
            _times: 0,
            _total: 0,
            _nextDt: 0,
            _actionInstant: false,
            _innerAction: null,
            ctor: function(action, times) {
                cc.ActionInterval.prototype.ctor.call(this);
                void 0 !== times && this.initWithAction(action, times);
            },
            initWithAction: function(action, times) {
                var duration = action._duration * times;
                if (this.initWithDuration(duration)) {
                    this._times = times;
                    this._innerAction = action;
                    if (action instanceof cc.ActionInstant) {
                        this._actionInstant = true;
                        this._times -= 1;
                    }
                    this._total = 0;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.Repeat();
                this._cloneDecoration(action);
                action.initWithAction(this._innerAction.clone(), this._times);
                return action;
            },
            startWithTarget: function(target) {
                this._total = 0;
                this._nextDt = this._innerAction._duration / this._duration;
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._innerAction.startWithTarget(target);
            },
            stop: function() {
                this._innerAction.stop();
                cc.Action.prototype.stop.call(this);
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                var locInnerAction = this._innerAction;
                var locDuration = this._duration;
                var locTimes = this._times;
                var locNextDt = this._nextDt;
                if (dt >= locNextDt) {
                    while (dt > locNextDt && this._total < locTimes) {
                        locInnerAction.update(1);
                        this._total++;
                        locInnerAction.stop();
                        locInnerAction.startWithTarget(this.target);
                        locNextDt += locInnerAction._duration / locDuration;
                        this._nextDt = locNextDt;
                    }
                    if (dt >= 1 && this._total < locTimes) {
                        locInnerAction.update(1);
                        this._total++;
                    }
                    this._actionInstant || (this._total === locTimes ? locInnerAction.stop() : locInnerAction.update(dt - (locNextDt - locInnerAction._duration / locDuration)));
                } else {
                    locInnerAction.update(dt * locTimes % 1);
                }
            },
            isDone: function() {
                return this._total === this._times;
            },
            reverse: function() {
                var action = new cc.Repeat(this._innerAction.reverse(), this._times);
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            },
            setInnerAction: function(action) {
                this._innerAction !== action && (this._innerAction = action);
            },
            getInnerAction: function() {
                return this._innerAction;
            }
        });
        cc.repeat = function(action, times) {
            return new cc.Repeat(action, times);
        };
        cc.RepeatForever = cc.ActionInterval.extend({
            _innerAction: null,
            ctor: function(action) {
                cc.ActionInterval.prototype.ctor.call(this);
                this._innerAction = null;
                action && this.initWithAction(action);
            },
            initWithAction: function(action) {
                if (!action) {
                    throw new Error("cc.RepeatForever.initWithAction(): action must be non null");
                }
                this._innerAction = action;
                return true;
            },
            clone: function() {
                var action = new cc.RepeatForever();
                this._cloneDecoration(action);
                action.initWithAction(this._innerAction.clone());
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._innerAction.startWithTarget(target);
            },
            step: function(dt) {
                var locInnerAction = this._innerAction;
                locInnerAction.step(dt);
                if (locInnerAction.isDone()) {
                    locInnerAction.startWithTarget(this.target);
                    locInnerAction.step(locInnerAction.getElapsed() - locInnerAction._duration);
                }
            },
            isDone: function() {
                return false;
            },
            reverse: function() {
                var action = new cc.RepeatForever(this._innerAction.reverse());
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            },
            setInnerAction: function(action) {
                this._innerAction !== action && (this._innerAction = action);
            },
            getInnerAction: function() {
                return this._innerAction;
            }
        });
        cc.repeatForever = function(action) {
            return new cc.RepeatForever(action);
        };
        cc.Spawn = cc.ActionInterval.extend({
            _one: null,
            _two: null,
            ctor: function(tempArray) {
                cc.ActionInterval.prototype.ctor.call(this);
                this._one = null;
                this._two = null;
                var paramArray = tempArray instanceof Array ? tempArray : arguments;
                var last = paramArray.length - 1;
                last >= 0 && null == paramArray[last] && cc.logID(1015);
                if (last >= 0) {
                    var prev = paramArray[0], action1;
                    for (var i = 1; i < last; i++) {
                        if (paramArray[i]) {
                            action1 = prev;
                            prev = cc.Spawn._actionOneTwo(action1, paramArray[i]);
                        }
                    }
                    this.initWithTwoActions(prev, paramArray[last]);
                }
            },
            initWithTwoActions: function(action1, action2) {
                if (!action1 || !action2) {
                    throw new Error("cc.Spawn.initWithTwoActions(): arguments must all be non null");
                }
                var ret = false;
                var d1 = action1._duration;
                var d2 = action2._duration;
                if (this.initWithDuration(Math.max(d1, d2))) {
                    this._one = action1;
                    this._two = action2;
                    d1 > d2 ? this._two = cc.Sequence._actionOneTwo(action2, cc.delayTime(d1 - d2)) : d1 < d2 && (this._one = cc.Sequence._actionOneTwo(action1, cc.delayTime(d2 - d1)));
                    ret = true;
                }
                return ret;
            },
            clone: function() {
                var action = new cc.Spawn();
                this._cloneDecoration(action);
                action.initWithTwoActions(this._one.clone(), this._two.clone());
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._one.startWithTarget(target);
                this._two.startWithTarget(target);
            },
            stop: function() {
                this._one.stop();
                this._two.stop();
                cc.Action.prototype.stop.call(this);
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                this._one && this._one.update(dt);
                this._two && this._two.update(dt);
            },
            reverse: function() {
                var action = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            }
        });
        cc.spawn = function(tempArray) {
            var paramArray = tempArray instanceof Array ? tempArray : arguments;
            paramArray.length > 0 && null == paramArray[paramArray.length - 1] && cc.logID(1015);
            var prev = paramArray[0];
            for (var i = 1; i < paramArray.length; i++) {
                null != paramArray[i] && (prev = cc.Spawn._actionOneTwo(prev, paramArray[i]));
            }
            return prev;
        };
        cc.Spawn._actionOneTwo = function(action1, action2) {
            var pSpawn = new cc.Spawn();
            pSpawn.initWithTwoActions(action1, action2);
            return pSpawn;
        };
        cc.RotateTo = cc.ActionInterval.extend({
            _dstAngleX: 0,
            _startAngleX: 0,
            _diffAngleX: 0,
            _dstAngleY: 0,
            _startAngleY: 0,
            _diffAngleY: 0,
            ctor: function(duration, deltaAngleX, deltaAngleY) {
                cc.ActionInterval.prototype.ctor.call(this);
                void 0 !== deltaAngleX && this.initWithDuration(duration, deltaAngleX, deltaAngleY);
            },
            initWithDuration: function(duration, deltaAngleX, deltaAngleY) {
                if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                    this._dstAngleX = deltaAngleX || 0;
                    this._dstAngleY = void 0 !== deltaAngleY ? deltaAngleY : this._dstAngleX;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.RotateTo();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._dstAngleX, this._dstAngleY);
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                var locStartAngleX = target.rotationX % 360;
                var locDiffAngleX = this._dstAngleX - locStartAngleX;
                locDiffAngleX > 180 && (locDiffAngleX -= 360);
                locDiffAngleX < -180 && (locDiffAngleX += 360);
                this._startAngleX = locStartAngleX;
                this._diffAngleX = locDiffAngleX;
                this._startAngleY = target.rotationY % 360;
                var locDiffAngleY = this._dstAngleY - this._startAngleY;
                locDiffAngleY > 180 && (locDiffAngleY -= 360);
                locDiffAngleY < -180 && (locDiffAngleY += 360);
                this._diffAngleY = locDiffAngleY;
            },
            reverse: function() {
                cc.logID(1016);
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                if (this.target) {
                    this.target.rotationX = this._startAngleX + this._diffAngleX * dt;
                    this.target.rotationY = this._startAngleY + this._diffAngleY * dt;
                }
            }
        });
        cc.rotateTo = function(duration, deltaAngleX, deltaAngleY) {
            return new cc.RotateTo(duration, deltaAngleX, deltaAngleY);
        };
        cc.RotateBy = cc.ActionInterval.extend({
            _angleX: 0,
            _startAngleX: 0,
            _angleY: 0,
            _startAngleY: 0,
            ctor: function(duration, deltaAngleX, deltaAngleY) {
                cc.ActionInterval.prototype.ctor.call(this);
                void 0 !== deltaAngleX && this.initWithDuration(duration, deltaAngleX, deltaAngleY);
            },
            initWithDuration: function(duration, deltaAngleX, deltaAngleY) {
                if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                    this._angleX = deltaAngleX || 0;
                    this._angleY = void 0 !== deltaAngleY ? deltaAngleY : this._angleX;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.RotateBy();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._angleX, this._angleY);
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._startAngleX = target.rotationX;
                this._startAngleY = target.rotationY;
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                if (this.target) {
                    this.target.rotationX = this._startAngleX + this._angleX * dt;
                    this.target.rotationY = this._startAngleY + this._angleY * dt;
                }
            },
            reverse: function() {
                var action = new cc.RotateBy(this._duration, -this._angleX, -this._angleY);
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            }
        });
        cc.rotateBy = function(duration, deltaAngleX, deltaAngleY) {
            return new cc.RotateBy(duration, deltaAngleX, deltaAngleY);
        };
        cc.MoveBy = cc.ActionInterval.extend({
            _positionDelta: null,
            _startPosition: null,
            _previousPosition: null,
            ctor: function(duration, deltaPos, deltaY) {
                cc.ActionInterval.prototype.ctor.call(this);
                this._positionDelta = cc.p(0, 0);
                this._startPosition = cc.p(0, 0);
                this._previousPosition = cc.p(0, 0);
                void 0 !== deltaPos && this.initWithDuration(duration, deltaPos, deltaY);
            },
            initWithDuration: function(duration, position, y) {
                if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                    if (void 0 !== position.x) {
                        y = position.y;
                        position = position.x;
                    }
                    this._positionDelta.x = position;
                    this._positionDelta.y = y;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.MoveBy();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._positionDelta);
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                var locPosX = target.getPositionX();
                var locPosY = target.getPositionY();
                this._previousPosition.x = locPosX;
                this._previousPosition.y = locPosY;
                this._startPosition.x = locPosX;
                this._startPosition.y = locPosY;
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                if (this.target) {
                    var x = this._positionDelta.x * dt;
                    var y = this._positionDelta.y * dt;
                    var locStartPosition = this._startPosition;
                    if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
                        var targetX = this.target.getPositionX();
                        var targetY = this.target.getPositionY();
                        var locPreviousPosition = this._previousPosition;
                        locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
                        locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
                        x += locStartPosition.x;
                        y += locStartPosition.y;
                        locPreviousPosition.x = x;
                        locPreviousPosition.y = y;
                        this.target.setPosition(x, y);
                    } else {
                        this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
                    }
                }
            },
            reverse: function() {
                var action = new cc.MoveBy(this._duration, cc.p(-this._positionDelta.x, -this._positionDelta.y));
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            }
        });
        cc.moveBy = function(duration, deltaPos, deltaY) {
            return new cc.MoveBy(duration, deltaPos, deltaY);
        };
        cc.MoveTo = cc.MoveBy.extend({
            _endPosition: null,
            ctor: function(duration, position, y) {
                cc.MoveBy.prototype.ctor.call(this);
                this._endPosition = cc.p(0, 0);
                void 0 !== position && this.initWithDuration(duration, position, y);
            },
            initWithDuration: function(duration, position, y) {
                if (cc.MoveBy.prototype.initWithDuration.call(this, duration, position, y)) {
                    if (void 0 !== position.x) {
                        y = position.y;
                        position = position.x;
                    }
                    this._endPosition.x = position;
                    this._endPosition.y = y;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.MoveTo();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._endPosition);
                return action;
            },
            startWithTarget: function(target) {
                cc.MoveBy.prototype.startWithTarget.call(this, target);
                this._positionDelta.x = this._endPosition.x - target.getPositionX();
                this._positionDelta.y = this._endPosition.y - target.getPositionY();
            }
        });
        cc.moveTo = function(duration, position, y) {
            return new cc.MoveTo(duration, position, y);
        };
        cc.SkewTo = cc.ActionInterval.extend({
            _skewX: 0,
            _skewY: 0,
            _startSkewX: 0,
            _startSkewY: 0,
            _endSkewX: 0,
            _endSkewY: 0,
            _deltaX: 0,
            _deltaY: 0,
            ctor: function(t, sx, sy) {
                cc.ActionInterval.prototype.ctor.call(this);
                void 0 !== sy && this.initWithDuration(t, sx, sy);
            },
            initWithDuration: function(t, sx, sy) {
                var ret = false;
                if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
                    this._endSkewX = sx;
                    this._endSkewY = sy;
                    ret = true;
                }
                return ret;
            },
            clone: function() {
                var action = new cc.SkewTo();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._startSkewX = target.skewX % 180;
                this._deltaX = this._endSkewX - this._startSkewX;
                this._deltaX > 180 && (this._deltaX -= 360);
                this._deltaX < -180 && (this._deltaX += 360);
                this._startSkewY = target.skewY % 360;
                this._deltaY = this._endSkewY - this._startSkewY;
                this._deltaY > 180 && (this._deltaY -= 360);
                this._deltaY < -180 && (this._deltaY += 360);
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                this.target.skewX = this._startSkewX + this._deltaX * dt;
                this.target.skewY = this._startSkewY + this._deltaY * dt;
            }
        });
        cc.skewTo = function(t, sx, sy) {
            return new cc.SkewTo(t, sx, sy);
        };
        cc.SkewBy = cc.SkewTo.extend({
            ctor: function(t, sx, sy) {
                cc.SkewTo.prototype.ctor.call(this);
                void 0 !== sy && this.initWithDuration(t, sx, sy);
            },
            initWithDuration: function(t, deltaSkewX, deltaSkewY) {
                var ret = false;
                if (cc.SkewTo.prototype.initWithDuration.call(this, t, deltaSkewX, deltaSkewY)) {
                    this._skewX = deltaSkewX;
                    this._skewY = deltaSkewY;
                    ret = true;
                }
                return ret;
            },
            clone: function() {
                var action = new cc.SkewBy();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._skewX, this._skewY);
                return action;
            },
            startWithTarget: function(target) {
                cc.SkewTo.prototype.startWithTarget.call(this, target);
                this._deltaX = this._skewX;
                this._deltaY = this._skewY;
                this._endSkewX = this._startSkewX + this._deltaX;
                this._endSkewY = this._startSkewY + this._deltaY;
            },
            reverse: function() {
                var action = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            }
        });
        cc.skewBy = function(t, sx, sy) {
            return new cc.SkewBy(t, sx, sy);
        };
        cc.JumpBy = cc.ActionInterval.extend({
            _startPosition: null,
            _delta: null,
            _height: 0,
            _jumps: 0,
            _previousPosition: null,
            ctor: function(duration, position, y, height, jumps) {
                cc.ActionInterval.prototype.ctor.call(this);
                this._startPosition = cc.p(0, 0);
                this._previousPosition = cc.p(0, 0);
                this._delta = cc.p(0, 0);
                void 0 !== height && this.initWithDuration(duration, position, y, height, jumps);
            },
            initWithDuration: function(duration, position, y, height, jumps) {
                if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                    if (void 0 === jumps) {
                        jumps = height;
                        height = y;
                        y = position.y;
                        position = position.x;
                    }
                    this._delta.x = position;
                    this._delta.y = y;
                    this._height = height;
                    this._jumps = jumps;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.JumpBy();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._delta, this._height, this._jumps);
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                var locPosX = target.getPositionX();
                var locPosY = target.getPositionY();
                this._previousPosition.x = locPosX;
                this._previousPosition.y = locPosY;
                this._startPosition.x = locPosX;
                this._startPosition.y = locPosY;
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                if (this.target) {
                    var frac = dt * this._jumps % 1;
                    var y = 4 * this._height * frac * (1 - frac);
                    y += this._delta.y * dt;
                    var x = this._delta.x * dt;
                    var locStartPosition = this._startPosition;
                    if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
                        var targetX = this.target.getPositionX();
                        var targetY = this.target.getPositionY();
                        var locPreviousPosition = this._previousPosition;
                        locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
                        locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
                        x += locStartPosition.x;
                        y += locStartPosition.y;
                        locPreviousPosition.x = x;
                        locPreviousPosition.y = y;
                        this.target.setPosition(x, y);
                    } else {
                        this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
                    }
                }
            },
            reverse: function() {
                var action = new cc.JumpBy(this._duration, cc.p(-this._delta.x, -this._delta.y), this._height, this._jumps);
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            }
        });
        cc.jumpBy = function(duration, position, y, height, jumps) {
            return new cc.JumpBy(duration, position, y, height, jumps);
        };
        cc.JumpTo = cc.JumpBy.extend({
            _endPosition: null,
            ctor: function(duration, position, y, height, jumps) {
                cc.JumpBy.prototype.ctor.call(this);
                this._endPosition = cc.p(0, 0);
                void 0 !== height && this.initWithDuration(duration, position, y, height, jumps);
            },
            initWithDuration: function(duration, position, y, height, jumps) {
                if (cc.JumpBy.prototype.initWithDuration.call(this, duration, position, y, height, jumps)) {
                    if (void 0 === jumps) {
                        y = position.y;
                        position = position.x;
                    }
                    this._endPosition.x = position;
                    this._endPosition.y = y;
                    return true;
                }
                return false;
            },
            startWithTarget: function(target) {
                cc.JumpBy.prototype.startWithTarget.call(this, target);
                this._delta.x = this._endPosition.x - this._startPosition.x;
                this._delta.y = this._endPosition.y - this._startPosition.y;
            },
            clone: function() {
                var action = new cc.JumpTo();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
                return action;
            }
        });
        cc.jumpTo = function(duration, position, y, height, jumps) {
            return new cc.JumpTo(duration, position, y, height, jumps);
        };
        cc.bezierAt = function(a, b, c, d, t) {
            return Math.pow(1 - t, 3) * a + 3 * t * Math.pow(1 - t, 2) * b + 3 * Math.pow(t, 2) * (1 - t) * c + Math.pow(t, 3) * d;
        };
        cc.BezierBy = cc.ActionInterval.extend({
            _config: null,
            _startPosition: null,
            _previousPosition: null,
            ctor: function(t, c) {
                cc.ActionInterval.prototype.ctor.call(this);
                this._config = [];
                this._startPosition = cc.p(0, 0);
                this._previousPosition = cc.p(0, 0);
                c && this.initWithDuration(t, c);
            },
            initWithDuration: function(t, c) {
                if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
                    this._config = c;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.BezierBy();
                this._cloneDecoration(action);
                var newConfigs = [];
                for (var i = 0; i < this._config.length; i++) {
                    var selConf = this._config[i];
                    newConfigs.push(cc.p(selConf.x, selConf.y));
                }
                action.initWithDuration(this._duration, newConfigs);
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                var locPosX = target.getPositionX();
                var locPosY = target.getPositionY();
                this._previousPosition.x = locPosX;
                this._previousPosition.y = locPosY;
                this._startPosition.x = locPosX;
                this._startPosition.y = locPosY;
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                if (this.target) {
                    var locConfig = this._config;
                    var xa = 0;
                    var xb = locConfig[0].x;
                    var xc = locConfig[1].x;
                    var xd = locConfig[2].x;
                    var ya = 0;
                    var yb = locConfig[0].y;
                    var yc = locConfig[1].y;
                    var yd = locConfig[2].y;
                    var x = cc.bezierAt(xa, xb, xc, xd, dt);
                    var y = cc.bezierAt(ya, yb, yc, yd, dt);
                    var locStartPosition = this._startPosition;
                    if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
                        var targetX = this.target.getPositionX();
                        var targetY = this.target.getPositionY();
                        var locPreviousPosition = this._previousPosition;
                        locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
                        locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
                        x += locStartPosition.x;
                        y += locStartPosition.y;
                        locPreviousPosition.x = x;
                        locPreviousPosition.y = y;
                        this.target.setPosition(x, y);
                    } else {
                        this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
                    }
                }
            },
            reverse: function() {
                var locConfig = this._config;
                var r = [ cc.pAdd(locConfig[1], cc.pNeg(locConfig[2])), cc.pAdd(locConfig[0], cc.pNeg(locConfig[2])), cc.pNeg(locConfig[2]) ];
                var action = new cc.BezierBy(this._duration, r);
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            }
        });
        cc.bezierBy = function(t, c) {
            return new cc.BezierBy(t, c);
        };
        cc.BezierTo = cc.BezierBy.extend({
            _toConfig: null,
            ctor: function(t, c) {
                cc.BezierBy.prototype.ctor.call(this);
                this._toConfig = [];
                c && this.initWithDuration(t, c);
            },
            initWithDuration: function(t, c) {
                if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
                    this._toConfig = c;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.BezierTo();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._toConfig);
                return action;
            },
            startWithTarget: function(target) {
                cc.BezierBy.prototype.startWithTarget.call(this, target);
                var locStartPos = this._startPosition;
                var locToConfig = this._toConfig;
                var locConfig = this._config;
                locConfig[0] = cc.pSub(locToConfig[0], locStartPos);
                locConfig[1] = cc.pSub(locToConfig[1], locStartPos);
                locConfig[2] = cc.pSub(locToConfig[2], locStartPos);
            }
        });
        cc.bezierTo = function(t, c) {
            return new cc.BezierTo(t, c);
        };
        cc.ScaleTo = cc.ActionInterval.extend({
            _scaleX: 1,
            _scaleY: 1,
            _startScaleX: 1,
            _startScaleY: 1,
            _endScaleX: 0,
            _endScaleY: 0,
            _deltaX: 0,
            _deltaY: 0,
            ctor: function(duration, sx, sy) {
                cc.ActionInterval.prototype.ctor.call(this);
                void 0 !== sx && this.initWithDuration(duration, sx, sy);
            },
            initWithDuration: function(duration, sx, sy) {
                if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                    this._endScaleX = sx;
                    this._endScaleY = null != sy ? sy : sx;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.ScaleTo();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._startScaleX = target.scaleX;
                this._startScaleY = target.scaleY;
                this._deltaX = this._endScaleX - this._startScaleX;
                this._deltaY = this._endScaleY - this._startScaleY;
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                if (this.target) {
                    this.target.scaleX = this._startScaleX + this._deltaX * dt;
                    this.target.scaleY = this._startScaleY + this._deltaY * dt;
                }
            }
        });
        cc.scaleTo = function(duration, sx, sy) {
            return new cc.ScaleTo(duration, sx, sy);
        };
        cc.ScaleBy = cc.ScaleTo.extend({
            startWithTarget: function(target) {
                cc.ScaleTo.prototype.startWithTarget.call(this, target);
                this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
                this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY;
            },
            reverse: function() {
                var action = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            },
            clone: function() {
                var action = new cc.ScaleBy();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
                return action;
            }
        });
        cc.scaleBy = function(duration, sx, sy) {
            return new cc.ScaleBy(duration, sx, sy);
        };
        cc.Blink = cc.ActionInterval.extend({
            _times: 0,
            _originalState: false,
            ctor: function(duration, blinks) {
                cc.ActionInterval.prototype.ctor.call(this);
                void 0 !== blinks && this.initWithDuration(duration, blinks);
            },
            initWithDuration: function(duration, blinks) {
                if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                    this._times = blinks;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.Blink();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._times);
                return action;
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                if (this.target && !this.isDone()) {
                    var slice = 1 / this._times;
                    var m = dt % slice;
                    this.target.opacity = m > slice / 2 ? 255 : 0;
                }
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._originalState = target.opacity;
            },
            stop: function() {
                this.target.opacity = this._originalState;
                cc.ActionInterval.prototype.stop.call(this);
            },
            reverse: function() {
                var action = new cc.Blink(this._duration, this._times);
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            }
        });
        cc.blink = function(duration, blinks) {
            return new cc.Blink(duration, blinks);
        };
        cc.FadeTo = cc.ActionInterval.extend({
            _toOpacity: 0,
            _fromOpacity: 0,
            ctor: function(duration, opacity) {
                cc.ActionInterval.prototype.ctor.call(this);
                void 0 !== opacity && this.initWithDuration(duration, opacity);
            },
            initWithDuration: function(duration, opacity) {
                if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                    this._toOpacity = opacity;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.FadeTo();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._toOpacity);
                return action;
            },
            update: function(time) {
                time = this._computeEaseTime(time);
                var fromOpacity = void 0 !== this._fromOpacity ? this._fromOpacity : 255;
                this.target.opacity = fromOpacity + (this._toOpacity - fromOpacity) * time;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._fromOpacity = target.opacity;
            }
        });
        cc.fadeTo = function(duration, opacity) {
            return new cc.FadeTo(duration, opacity);
        };
        cc.FadeIn = cc.FadeTo.extend({
            _reverseAction: null,
            ctor: function(duration) {
                cc.FadeTo.prototype.ctor.call(this);
                null == duration && (duration = 0);
                this.initWithDuration(duration, 255);
            },
            reverse: function() {
                var action = new cc.FadeOut();
                action.initWithDuration(this._duration, 0);
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            },
            clone: function() {
                var action = new cc.FadeIn();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._toOpacity);
                return action;
            },
            startWithTarget: function(target) {
                this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity);
                cc.FadeTo.prototype.startWithTarget.call(this, target);
            }
        });
        cc.fadeIn = function(duration) {
            return new cc.FadeIn(duration);
        };
        cc.FadeOut = cc.FadeTo.extend({
            ctor: function(duration) {
                cc.FadeTo.prototype.ctor.call(this);
                null == duration && (duration = 0);
                this.initWithDuration(duration, 0);
            },
            reverse: function() {
                var action = new cc.FadeIn();
                action._reverseAction = this;
                action.initWithDuration(this._duration, 255);
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            },
            clone: function() {
                var action = new cc.FadeOut();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._toOpacity);
                return action;
            }
        });
        cc.fadeOut = function(d) {
            return new cc.FadeOut(d);
        };
        cc.TintTo = cc.ActionInterval.extend({
            _to: null,
            _from: null,
            ctor: function(duration, red, green, blue) {
                cc.ActionInterval.prototype.ctor.call(this);
                this._to = cc.color(0, 0, 0);
                this._from = cc.color(0, 0, 0);
                if (red instanceof cc.Color) {
                    blue = red.b;
                    green = red.g;
                    red = red.r;
                }
                void 0 !== blue && this.initWithDuration(duration, red, green, blue);
            },
            initWithDuration: function(duration, red, green, blue) {
                if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                    this._to = cc.color(red, green, blue);
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.TintTo();
                this._cloneDecoration(action);
                var locTo = this._to;
                action.initWithDuration(this._duration, locTo.r, locTo.g, locTo.b);
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._from = this.target.color;
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                var locFrom = this._from, locTo = this._to;
                locFrom && this.target.setColor(cc.color(locFrom.r + (locTo.r - locFrom.r) * dt, locFrom.g + (locTo.g - locFrom.g) * dt, locFrom.b + (locTo.b - locFrom.b) * dt));
            }
        });
        cc.tintTo = function(duration, red, green, blue) {
            return new cc.TintTo(duration, red, green, blue);
        };
        cc.TintBy = cc.ActionInterval.extend({
            _deltaR: 0,
            _deltaG: 0,
            _deltaB: 0,
            _fromR: 0,
            _fromG: 0,
            _fromB: 0,
            ctor: function(duration, deltaRed, deltaGreen, deltaBlue) {
                cc.ActionInterval.prototype.ctor.call(this);
                void 0 !== deltaBlue && this.initWithDuration(duration, deltaRed, deltaGreen, deltaBlue);
            },
            initWithDuration: function(duration, deltaRed, deltaGreen, deltaBlue) {
                if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
                    this._deltaR = deltaRed;
                    this._deltaG = deltaGreen;
                    this._deltaB = deltaBlue;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.TintBy();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                var color = target.color;
                this._fromR = color.r;
                this._fromG = color.g;
                this._fromB = color.b;
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                this.target.color = cc.color(this._fromR + this._deltaR * dt, this._fromG + this._deltaG * dt, this._fromB + this._deltaB * dt);
            },
            reverse: function() {
                var action = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            }
        });
        cc.tintBy = function(duration, deltaRed, deltaGreen, deltaBlue) {
            return new cc.TintBy(duration, deltaRed, deltaGreen, deltaBlue);
        };
        cc.DelayTime = cc.ActionInterval.extend({
            update: function(dt) {},
            reverse: function() {
                var action = new cc.DelayTime(this._duration);
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            },
            clone: function() {
                var action = new cc.DelayTime();
                this._cloneDecoration(action);
                action.initWithDuration(this._duration);
                return action;
            }
        });
        cc.delayTime = function(d) {
            return new cc.DelayTime(d);
        };
        cc.ReverseTime = cc.ActionInterval.extend({
            _other: null,
            ctor: function(action) {
                cc.ActionInterval.prototype.ctor.call(this);
                this._other = null;
                action && this.initWithAction(action);
            },
            initWithAction: function(action) {
                if (!action) {
                    throw new Error("cc.ReverseTime.initWithAction(): action must be non null");
                }
                if (action === this._other) {
                    throw new Error("cc.ReverseTime.initWithAction(): the action was already passed in.");
                }
                if (cc.ActionInterval.prototype.initWithDuration.call(this, action._duration)) {
                    this._other = action;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.ReverseTime();
                this._cloneDecoration(action);
                action.initWithAction(this._other.clone());
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._other.startWithTarget(target);
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                this._other && this._other.update(1 - dt);
            },
            reverse: function() {
                return this._other.clone();
            },
            stop: function() {
                this._other.stop();
                cc.Action.prototype.stop.call(this);
            }
        });
        cc.reverseTime = function(action) {
            return new cc.ReverseTime(action);
        };
        cc.Animate = cc.ActionInterval.extend({
            _animation: null,
            _nextFrame: 0,
            _origFrame: null,
            _executedLoops: 0,
            _splitTimes: null,
            _currFrameIndex: 0,
            ctor: function(animation) {
                cc.ActionInterval.prototype.ctor.call(this);
                this._splitTimes = [];
                animation && this.initWithAnimation(animation);
            },
            getAnimation: function() {
                return this._animation;
            },
            setAnimation: function(animation) {
                this._animation = animation;
            },
            getCurrentFrameIndex: function() {
                return this._currFrameIndex;
            },
            initWithAnimation: function(animation) {
                if (!animation) {
                    throw new Error("cc.Animate.initWithAnimation(): animation must be non-NULL");
                }
                var singleDuration = animation.getDuration();
                if (this.initWithDuration(singleDuration * animation.getLoops())) {
                    this._nextFrame = 0;
                    this.setAnimation(animation);
                    this._origFrame = null;
                    this._executedLoops = 0;
                    var locTimes = this._splitTimes;
                    locTimes.length = 0;
                    var accumUnitsOfTime = 0;
                    var newUnitOfTimeValue = singleDuration / animation.getTotalDelayUnits();
                    var frames = animation.getFrames();
                    cc.js.array.verifyType(frames, cc.AnimationFrame);
                    for (var i = 0; i < frames.length; i++) {
                        var frame = frames[i];
                        var value = accumUnitsOfTime * newUnitOfTimeValue / singleDuration;
                        accumUnitsOfTime += frame.getDelayUnits();
                        locTimes.push(value);
                    }
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.Animate();
                this._cloneDecoration(action);
                action.initWithAnimation(this._animation.clone());
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._animation.getRestoreOriginalFrame() && (this._origFrame = target.getSpriteFrame());
                this._nextFrame = 0;
                this._executedLoops = 0;
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                if (dt < 1) {
                    dt *= this._animation.getLoops();
                    var loopNumber = 0 | dt;
                    if (loopNumber > this._executedLoops) {
                        this._nextFrame = 0;
                        this._executedLoops++;
                    }
                    dt %= 1;
                }
                var frames = this._animation.getFrames();
                var numberOfFrames = frames.length, locSplitTimes = this._splitTimes;
                for (var i = this._nextFrame; i < numberOfFrames; i++) {
                    if (!(locSplitTimes[i] <= dt)) {
                        break;
                    }
                    _currFrameIndex = i;
                    this.target.setSpriteFrame(frames[_currFrameIndex].getSpriteFrame());
                    this._nextFrame = i + 1;
                }
            },
            reverse: function() {
                var locAnimation = this._animation;
                var oldArray = locAnimation.getFrames();
                var newArray = [];
                cc.js.array.verifyType(oldArray, cc.AnimationFrame);
                if (oldArray.length > 0) {
                    for (var i = oldArray.length - 1; i >= 0; i--) {
                        var element = oldArray[i];
                        if (!element) {
                            break;
                        }
                        newArray.push(element.clone());
                    }
                }
                var newAnim = new cc.SpriteFrameAnimation(newArray, locAnimation.getDelayPerUnit(), locAnimation.getLoops());
                newAnim.setRestoreOriginalFrame(locAnimation.getRestoreOriginalFrame());
                var action = new cc.Animate(newAnim);
                this._cloneDecoration(action);
                this._reverseEaseList(action);
                return action;
            },
            stop: function() {
                this._animation.getRestoreOriginalFrame() && this.target && this.target.setSpriteFrame(this._origFrame);
                cc.Action.prototype.stop.call(this);
            }
        });
        cc.animate = function(animation) {
            return new cc.Animate(animation);
        };
        cc.TargetedAction = cc.ActionInterval.extend({
            _action: null,
            _forcedTarget: null,
            ctor: function(target, action) {
                cc.ActionInterval.prototype.ctor.call(this);
                action && this.initWithTarget(target, action);
            },
            initWithTarget: function(target, action) {
                if (this.initWithDuration(action._duration)) {
                    this._forcedTarget = target;
                    this._action = action;
                    return true;
                }
                return false;
            },
            clone: function() {
                var action = new cc.TargetedAction();
                this._cloneDecoration(action);
                action.initWithTarget(this._forcedTarget, this._action.clone());
                return action;
            },
            startWithTarget: function(target) {
                cc.ActionInterval.prototype.startWithTarget.call(this, target);
                this._action.startWithTarget(this._forcedTarget);
            },
            stop: function() {
                this._action.stop();
            },
            update: function(dt) {
                dt = this._computeEaseTime(dt);
                this._action.update(dt);
            },
            getForcedTarget: function() {
                return this._forcedTarget;
            },
            setForcedTarget: function(forcedTarget) {
                this._forcedTarget !== forcedTarget && (this._forcedTarget = forcedTarget);
            }
        });
        cc.targetedAction = function(target, action) {
            return new cc.TargetedAction(target, action);
        };
    }), {} ],
    9: [ (function(require, module, exports) {
        var HashElement = cc._Class.extend({
            ctor: function() {
                this.actions = [];
                this.target = null;
                this.actionIndex = 0;
                this.currentAction = null;
                this.currentActionSalvaged = false;
                this.paused = false;
            }
        });
        cc.ActionManager = cc._Class.extend({
            _elementPool: [],
            _searchElementByTarget: function(arr, target) {
                for (var k = 0; k < arr.length; k++) {
                    if (target === arr[k].target) {
                        return arr[k];
                    }
                }
                return null;
            },
            ctor: function() {
                this._hashTargets = {};
                this._arrayTargets = [];
                this._currentTarget = null;
                this._currentTargetSalvaged = false;
            },
            _getElement: function(target, paused) {
                var element = this._elementPool.pop();
                element || (element = new HashElement());
                element.target = target;
                element.paused = !!paused;
                return element;
            },
            _putElement: function(element) {
                element.actions.length = 0;
                element.actionIndex = 0;
                element.currentAction = null;
                element.currentActionSalvaged = false;
                element.paused = false;
                this._elementPool.push(element);
            },
            addAction: function(action, target, paused) {
                if (!action) {
                    throw new Error("cc.ActionManager.addAction(): action must be non-null");
                }
                if (!target) {
                    throw new Error("cc.ActionManager.addAction(): action must be non-null");
                }
                var element = this._hashTargets[target.__instanceId];
                if (element) {
                    element.actions || (element.actions = []);
                } else {
                    element = this._getElement(target, paused);
                    this._hashTargets[target.__instanceId] = element;
                    this._arrayTargets.push(element);
                }
                element.actions.push(action);
                action.startWithTarget(target);
            },
            removeAllActions: function() {
                var locTargets = this._arrayTargets;
                for (var i = 0; i < locTargets.length; i++) {
                    var element = locTargets[i];
                    element && this.removeAllActionsFromTarget(element.target, true);
                }
            },
            removeAllActionsFromTarget: function(target, forceDelete) {
                if (null == target) {
                    return;
                }
                var element = this._hashTargets[target.__instanceId];
                if (element) {
                    element.actions.indexOf(element.currentAction) === -1 || element.currentActionSalvaged || (element.currentActionSalvaged = true);
                    element.actions.length = 0;
                    this._currentTarget !== element || forceDelete ? this._deleteHashElement(element) : this._currentTargetSalvaged = true;
                }
            },
            removeAction: function(action) {
                if (null == action) {
                    return;
                }
                var target = action.getOriginalTarget();
                var element = this._hashTargets[target.__instanceId];
                if (element) {
                    for (var i = 0; i < element.actions.length; i++) {
                        if (element.actions[i] === action) {
                            element.actions.splice(i, 1);
                            break;
                        }
                    }
                } else {
                    cc.logID(1001);
                }
            },
            removeActionByTag: function(tag, target) {
                tag === cc.Action.TAG_INVALID && cc.logID(1002);
                cc.assertID(target, 1003);
                var element = this._hashTargets[target.__instanceId];
                if (element) {
                    var limit = element.actions.length;
                    for (var i = 0; i < limit; ++i) {
                        var action = element.actions[i];
                        if (action && action.getTag() === tag && action.getOriginalTarget() === target) {
                            this._removeActionAtIndex(i, element);
                            break;
                        }
                    }
                }
            },
            getActionByTag: function(tag, target) {
                tag === cc.Action.TAG_INVALID && cc.logID(1004);
                var element = this._hashTargets[target.__instanceId];
                if (element) {
                    if (null != element.actions) {
                        for (var i = 0; i < element.actions.length; ++i) {
                            var action = element.actions[i];
                            if (action && action.getTag() === tag) {
                                return action;
                            }
                        }
                    }
                    cc.logID(1005, tag);
                }
                return null;
            },
            getNumberOfRunningActionsInTarget: function(target) {
                var element = this._hashTargets[target.__instanceId];
                if (element) {
                    return element.actions ? element.actions.length : 0;
                }
                return 0;
            },
            pauseTarget: function(target) {
                var element = this._hashTargets[target.__instanceId];
                element && (element.paused = true);
            },
            resumeTarget: function(target) {
                var element = this._hashTargets[target.__instanceId];
                element && (element.paused = false);
            },
            pauseAllRunningActions: function() {
                var idsWithActions = [];
                var locTargets = this._arrayTargets;
                for (var i = 0; i < locTargets.length; i++) {
                    var element = locTargets[i];
                    if (element && !element.paused) {
                        element.paused = true;
                        idsWithActions.push(element.target);
                    }
                }
                return idsWithActions;
            },
            resumeTargets: function(targetsToResume) {
                if (!targetsToResume) {
                    return;
                }
                for (var i = 0; i < targetsToResume.length; i++) {
                    targetsToResume[i] && this.resumeTarget(targetsToResume[i]);
                }
            },
            pauseTargets: function(targetsToPause) {
                if (!targetsToPause) {
                    return;
                }
                for (var i = 0; i < targetsToPause.length; i++) {
                    targetsToPause[i] && this.pauseTarget(targetsToPause[i]);
                }
            },
            purgeSharedManager: function() {
                cc.director.getScheduler().unscheduleUpdate(this);
            },
            _removeActionAtIndex: function(index, element) {
                var action = element.actions[index];
                action !== element.currentAction || element.currentActionSalvaged || (element.currentActionSalvaged = true);
                element.actions.splice(index, 1);
                element.actionIndex >= index && element.actionIndex--;
                0 === element.actions.length && (this._currentTarget === element ? this._currentTargetSalvaged = true : this._deleteHashElement(element));
            },
            _deleteHashElement: function(element) {
                var ret = false;
                if (element && this._hashTargets[element.target.__instanceId]) {
                    delete this._hashTargets[element.target.__instanceId];
                    var targets = this._arrayTargets;
                    for (var i = 0, l = targets.length; i < l; i++) {
                        if (targets[i] === element) {
                            targets.splice(i, 1);
                            break;
                        }
                    }
                    this._putElement(element);
                    ret = true;
                }
                return ret;
            },
            update: function(dt) {
                var locTargets = this._arrayTargets, locCurrTarget;
                for (var elt = 0; elt < locTargets.length; elt++) {
                    this._currentTarget = locTargets[elt];
                    locCurrTarget = this._currentTarget;
                    if (!locCurrTarget.paused) {
                        for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < (locCurrTarget.actions ? locCurrTarget.actions.length : 0); locCurrTarget.actionIndex++) {
                            locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
                            if (!locCurrTarget.currentAction) {
                                continue;
                            }
                            locCurrTarget.currentActionSalvaged = false;
                            locCurrTarget.currentAction.step(dt * (locCurrTarget.currentAction._speedMethod ? locCurrTarget.currentAction._speed : 1));
                            if (locCurrTarget.currentActionSalvaged) {
                                locCurrTarget.currentAction = null;
                            } else {
                                if (locCurrTarget.currentAction.isDone()) {
                                    locCurrTarget.currentAction.stop();
                                    var action = locCurrTarget.currentAction;
                                    locCurrTarget.currentAction = null;
                                    this.removeAction(action);
                                }
                            }
                            locCurrTarget.currentAction = null;
                        }
                    }
                    this._currentTargetSalvaged && 0 === locCurrTarget.actions.length && this._deleteHashElement(locCurrTarget) && elt--;
                }
            }
        });
    }), {} ],
    10: [ (function(require, module, exports) {
        require("./CCActionManager.js");
        require("./CCAction.js");
        require("./CCActionInterval.js");
        require("./CCActionInstant.js");
        require("./CCActionEase.js");
        require("./CCActionCatmullRom.js");
    }), {
        "./CCAction.js": 4,
        "./CCActionCatmullRom.js": 5,
        "./CCActionEase.js": 6,
        "./CCActionInstant.js": 7,
        "./CCActionInterval.js": 8,
        "./CCActionManager.js": 9
    } ],
    11: [ (function(require, module, exports) {
        var JS = cc.js;
        var Animator = require("./animators").Animator;
        var DynamicAnimCurve = require("./animation-curves").DynamicAnimCurve;
        var SampledAnimCurve = require("./animation-curves").SampledAnimCurve;
        var sampleMotionPaths = require("./motion-path-helper").sampleMotionPaths;
        var EventAnimCurve = require("./animation-curves").EventAnimCurve;
        var EventInfo = require("./animation-curves").EventInfo;
        var WrapModeMask = require("./types").WrapModeMask;
        var binarySearch = require("../core/utils/binary-search").binarySearchEpsilon;
        function AnimationAnimator(target, animation) {
            Animator.call(this, target);
            this.animation = animation;
        }
        JS.extend(AnimationAnimator, Animator);
        var p = AnimationAnimator.prototype;
        p.playState = function(state, startTime) {
            if (!state.clip) {
                return;
            }
            state.curveLoaded || initClipData(this.target, state);
            this.addAnimation(state);
            state.animator = this;
            state.play();
            "number" === typeof startTime && state.setTime(startTime);
            this.play();
        };
        p.addAnimation = function(anim) {
            Animator.prototype.addAnimation.call(this, anim);
            var listeners = this.animation._listeners;
            for (var i = 0, l = listeners.length; i < l; i++) {
                var listener = listeners[i];
                anim.on(listener[0], listener[1], listener[2], listener[3]);
            }
        };
        p.removeAnimation = function(anim) {
            Animator.prototype.removeAnimation.call(this, anim);
            anim.animator = null;
        };
        p.sample = function() {
            var iterator = this._anims;
            var array = iterator.array;
            for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                var anim = array[iterator.i];
                anim.sample();
            }
        };
        p.stopState = function(state) {
            state && state.stop();
        };
        p.pauseState = function(state) {
            state && state.pause();
        };
        p.resumeState = function(state) {
            state && state.resume();
            this.isPaused && this.resume();
        };
        p.setStateTime = function(state, time) {
            if (void 0 !== time) {
                if (state) {
                    state.setTime(time);
                    state.sample();
                }
            } else {
                time = state;
                var iterator = this._anims;
                var array = iterator.array;
                for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                    var anim = array[iterator.i];
                    anim.setTime(time);
                    anim.sample();
                }
            }
        };
        p.onStop = function() {
            var iterator = this._anims;
            var array = iterator.array;
            for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                var anim = array[iterator.i];
                anim.stop();
            }
            Animator.prototype.onStop.call(this);
        };
        p.onPause = function() {
            var array = this._anims.array;
            for (var i = 0; i < array.length; ++i) {
                var anim = array[i];
                anim.pause();
                anim.animator = null;
            }
            Animator.prototype.onPause.call(this);
        };
        p.onResume = function() {
            var array = this._anims.array;
            for (var i = 0; i < array.length; ++i) {
                var anim = array[i];
                anim.animator = this;
                anim.resume();
            }
            Animator.prototype.onResume.call(this);
        };
        p._reloadClip = function(state) {
            initClipData(this.target, state);
        };
        function createBatchedProperty(propPath, firstDotIndex, mainValue, animValue) {
            mainValue = mainValue.clone();
            var nextValue = mainValue;
            var leftIndex = firstDotIndex + 1;
            var rightIndex = propPath.indexOf(".", leftIndex);
            while (rightIndex !== -1) {
                var nextName = propPath.slice(leftIndex, rightIndex);
                nextValue = nextValue[nextName];
                leftIndex = rightIndex + 1;
                rightIndex = propPath.indexOf(".", leftIndex);
            }
            var lastPropName = propPath.slice(leftIndex);
            nextValue[lastPropName] = animValue;
            return mainValue;
        }
        function splitPropPath(propPath) {
            var array = propPath.split(".");
            array.shift();
            return array.length > 0 ? array : null;
        }
        function initClipData(root, state) {
            var clip = state.clip;
            var curves = state.curves;
            curves.length = 0;
            state.duration = clip.duration;
            state.speed = clip.speed;
            state.wrapMode = clip.wrapMode;
            state.frameRate = clip.sample;
            (state.wrapMode & WrapModeMask.Loop) === WrapModeMask.Loop ? state.repeatCount = 1 / 0 : state.repeatCount = 1;
            function checkMotionPath(motionPath) {
                if (!Array.isArray(motionPath)) {
                    return false;
                }
                for (var i = 0, l = motionPath.length; i < l; i++) {
                    var controls = motionPath[i];
                    if (!Array.isArray(controls) || 6 !== controls.length) {
                        return false;
                    }
                }
                return true;
            }
            function createPropCurve(target, propPath, keyframes) {
                var isMotionPathProp = target instanceof cc.Node && "position" === propPath;
                var motionPaths = [];
                var curve;
                curve = isMotionPathProp ? new SampledAnimCurve() : new DynamicAnimCurve();
                curve.target = target;
                var propName, propValue;
                var dotIndex = propPath.indexOf(".");
                var hasSubProp = dotIndex !== -1;
                if (hasSubProp) {
                    propName = propPath.slice(0, dotIndex);
                    propValue = target[propName];
                } else {
                    propName = propPath;
                }
                curve.prop = propName;
                curve.subProps = splitPropPath(propPath);
                for (var j = 0, l = keyframes.length; j < l; j++) {
                    var keyframe = keyframes[j];
                    var ratio = keyframe.frame / state.duration;
                    curve.ratios.push(ratio);
                    if (isMotionPathProp) {
                        var motionPath = keyframe.motionPath;
                        if (motionPath && !checkMotionPath(motionPath)) {
                            cc.errorID(3904, target.name, propPath, j);
                            motionPath = null;
                        }
                        motionPaths.push(motionPath);
                    }
                    var curveValue = keyframe.value;
                    curve.values.push(curveValue);
                    var curveTypes = keyframe.curve;
                    if (curveTypes) {
                        if ("string" === typeof curveTypes) {
                            curve.types.push(curveTypes);
                            continue;
                        }
                        if (Array.isArray(curveTypes)) {
                            curveTypes[0] === curveTypes[1] && curveTypes[2] === curveTypes[3] ? curve.types.push(DynamicAnimCurve.Linear) : curve.types.push(DynamicAnimCurve.Bezier(curveTypes));
                            continue;
                        }
                    }
                    curve.types.push(DynamicAnimCurve.Linear);
                }
                isMotionPathProp && sampleMotionPaths(motionPaths, curve, clip.duration, clip.sample);
                return curve;
            }
            function createTargetCurves(target, curveData) {
                var propsData = curveData.props;
                var compsData = curveData.comps;
                if (propsData) {
                    for (var propPath in propsData) {
                        var data = propsData[propPath];
                        var curve = createPropCurve(target, propPath, data);
                        curves.push(curve);
                    }
                }
                if (compsData) {
                    for (var compName in compsData) {
                        var comp = target.getComponent(compName);
                        if (!comp) {
                            continue;
                        }
                        var compData = compsData[compName];
                        for (var propPath in compData) {
                            var data = compData[propPath];
                            var curve = createPropCurve(comp, propPath, data);
                            curves.push(curve);
                        }
                    }
                }
            }
            var curveData = clip.curveData;
            var childrenCurveDatas = curveData.paths;
            createTargetCurves(root, curveData);
            for (var namePath in childrenCurveDatas) {
                var target = cc.find(namePath, root);
                if (!target) {
                    continue;
                }
                var childCurveDatas = childrenCurveDatas[namePath];
                createTargetCurves(target, childCurveDatas);
            }
            var events = clip.events;
            if (events) {
                var curve;
                for (var i = 0, l = events.length; i < l; i++) {
                    if (!curve) {
                        curve = new EventAnimCurve();
                        curve.target = root;
                        curves.push(curve);
                    }
                    var eventData = events[i];
                    var ratio = eventData.frame / state.duration;
                    var eventInfo;
                    var index = binarySearch(curve.ratios, ratio);
                    if (index >= 0) {
                        eventInfo = curve.events[index];
                    } else {
                        eventInfo = new EventInfo();
                        curve.ratios.push(ratio);
                        curve.events.push(eventInfo);
                    }
                    eventInfo.add(eventData.func, eventData.params);
                }
            }
        }
        module.exports = AnimationAnimator;
    }), {
        "../core/utils/binary-search": 220,
        "./animation-curves": 13,
        "./animators": 16,
        "./motion-path-helper": 20,
        "./types": 22
    } ],
    12: [ (function(require, module, exports) {
        var AnimationClip = cc.Class({
            name: "cc.AnimationClip",
            extends: cc.Asset,
            properties: {
                _duration: {
                    default: 0,
                    type: "Float"
                },
                duration: {
                    get: function() {
                        return this._duration;
                    }
                },
                sample: {
                    default: 60
                },
                speed: {
                    default: 1
                },
                wrapMode: {
                    default: cc.WrapMode.Normal
                },
                curveData: {
                    default: {},
                    visible: false
                },
                events: {
                    default: [],
                    visible: false
                }
            },
            statics: {
                createWithSpriteFrames: function(spriteFrames, sample) {
                    if (!Array.isArray(spriteFrames)) {
                        cc.errorID(3905);
                        return null;
                    }
                    var clip = new AnimationClip();
                    clip.sample = sample || clip.sample;
                    clip._duration = spriteFrames.length / clip.sample;
                    var frames = [];
                    var step = 1 / clip.sample;
                    for (var i = 0, l = spriteFrames.length; i < l; i++) {
                        frames[i] = {
                            frame: i * step,
                            value: spriteFrames[i]
                        };
                    }
                    clip.curveData = {
                        comps: {
                            "cc.Sprite": {
                                spriteFrame: frames
                            }
                        }
                    };
                    return clip;
                }
            }
        });
        cc.AnimationClip = module.exports = AnimationClip;
    }), {} ],
    13: [ (function(require, module, exports) {
        var bezierByTime = require("./bezier").bezierByTime;
        var binarySearch = require("../core/utils/binary-search").binarySearchEpsilon;
        var WrapModeMask = require("./types").WrapModeMask;
        var WrappedInfo = require("./types").WrappedInfo;
        function computeRatioByType(ratio, type) {
            if ("string" === typeof type) {
                var func = cc.Easing[type];
                func ? ratio = func(ratio) : cc.errorID(3906, type);
            } else {
                Array.isArray(type) && (ratio = bezierByTime(type, ratio));
            }
            return ratio;
        }
        var AnimCurve = cc.Class({
            name: "cc.AnimCurve",
            sample: function(time, ratio, animationNode) {},
            onTimeChangedManually: function() {}
        });
        var DynamicAnimCurve = cc.Class({
            name: "cc.DynamicAnimCurve",
            extends: AnimCurve,
            properties: {
                target: null,
                prop: "",
                values: [],
                ratios: [],
                types: [],
                subProps: null
            },
            _calcValue: function(frameIndex, ratio) {
                var values = this.values;
                var fromVal = values[frameIndex - 1];
                var toVal = values[frameIndex];
                var value;
                value = "number" === typeof fromVal ? fromVal + (toVal - fromVal) * ratio : fromVal && fromVal.lerp ? fromVal.lerp(toVal, ratio) : fromVal;
                return value;
            },
            _applyValue: function(target, prop, value) {
                target[prop] = value;
            },
            _findFrameIndex: binarySearch,
            sample: function(time, ratio, animationNode) {
                var values = this.values;
                var ratios = this.ratios;
                var frameCount = ratios.length;
                if (0 === frameCount) {
                    return;
                }
                var value;
                var index = this._findFrameIndex(ratios, ratio);
                if (index < 0) {
                    index = ~index;
                    if (index <= 0) {
                        value = values[0];
                    } else {
                        if (index >= frameCount) {
                            value = values[frameCount - 1];
                        } else {
                            var fromRatio = ratios[index - 1];
                            var toRatio = ratios[index];
                            var type = this.types[index - 1];
                            var ratioBetweenFrames = (ratio - fromRatio) / (toRatio - fromRatio);
                            ratioBetweenFrames = computeRatioByType(ratioBetweenFrames, type);
                            value = this._calcValue(index, ratioBetweenFrames);
                        }
                    }
                } else {
                    value = values[index];
                }
                var subProps = this.subProps;
                if (subProps) {
                    var mainProp = this.target[this.prop];
                    var subProp = mainProp;
                    for (var i = 0; i < subProps.length - 1; i++) {
                        var subPropName = subProps[i];
                        if (!subProp) {
                            return;
                        }
                        subProp = subProp[subPropName];
                    }
                    var propName = subProps[subProps.length - 1];
                    if (!subProp) {
                        return;
                    }
                    this._applyValue(subProp, propName, value);
                    value = mainProp;
                }
                this._applyValue(this.target, this.prop, value);
            }
        });
        DynamicAnimCurve.Linear = null;
        DynamicAnimCurve.Bezier = function(controlPoints) {
            return controlPoints;
        };
        var SampledAnimCurve = cc.Class({
            name: "cc.SampledAnimCurve",
            extends: DynamicAnimCurve,
            _findFrameIndex: function(ratios, ratio) {
                var length = ratios.length - 1;
                if (0 === length) {
                    return 0;
                }
                var start = ratios[0];
                if (ratio < start) {
                    return 0;
                }
                var end = ratios[length];
                if (ratio > end) {
                    return length;
                }
                ratio = (ratio - start) / (end - start);
                var eachLength = 1 / length;
                var index = ratio / eachLength;
                var floorIndex = 0 | index;
                var EPSILON = 1e-6;
                if (index - floorIndex < EPSILON) {
                    return floorIndex;
                }
                return ~(floorIndex + 1);
            }
        });
        var EventInfo = function() {
            this.events = [];
        };
        EventInfo.prototype.add = function(func, params) {
            this.events.push({
                func: func || "",
                params: params || []
            });
        };
        var EventAnimCurve = cc.Class({
            name: "cc.EventAnimCurve",
            extends: AnimCurve,
            properties: {
                target: null,
                ratios: [],
                events: [],
                _wrappedInfo: {
                    default: function() {
                        return new WrappedInfo();
                    }
                },
                _lastWrappedInfo: null,
                _ignoreIndex: NaN
            },
            _wrapIterations: function(iterations) {
                iterations - (0 | iterations) === 0 && (iterations -= 1);
                return 0 | iterations;
            },
            sample: function(time, ratio, animationNode) {
                var length = this.ratios.length;
                var currentWrappedInfo = animationNode.getWrappedInfo(animationNode.time, this._wrappedInfo);
                var direction = currentWrappedInfo.direction;
                var currentIndex = binarySearch(this.ratios, currentWrappedInfo.ratio);
                if (currentIndex < 0) {
                    currentIndex = ~currentIndex - 1;
                    direction < 0 && (currentIndex += 1);
                }
                this._ignoreIndex !== currentIndex && (this._ignoreIndex = NaN);
                currentWrappedInfo.frameIndex = currentIndex;
                if (!this._lastWrappedInfo) {
                    this._fireEvent(currentIndex);
                    this._lastWrappedInfo = new WrappedInfo(currentWrappedInfo);
                    return;
                }
                var wrapMode = animationNode.wrapMode;
                var currentIterations = this._wrapIterations(currentWrappedInfo.iterations);
                var lastWrappedInfo = this._lastWrappedInfo;
                var lastIterations = this._wrapIterations(lastWrappedInfo.iterations);
                var lastIndex = lastWrappedInfo.frameIndex;
                var lastDirection = lastWrappedInfo.direction;
                var interationsChanged = lastIterations !== -1 && currentIterations !== lastIterations;
                if (lastIndex === currentIndex && interationsChanged && 1 === length) {
                    this._fireEvent(0);
                } else {
                    if (lastIndex !== currentIndex || interationsChanged) {
                        direction = lastDirection;
                        do {
                            if (lastIndex !== currentIndex) {
                                if (direction === -1 && 0 === lastIndex && currentIndex > 0) {
                                    (wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = length;
                                    lastIterations++;
                                } else {
                                    if (1 === direction && lastIndex === length - 1 && currentIndex < length - 1) {
                                        (wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = -1;
                                        lastIterations++;
                                    }
                                }
                                if (lastIndex === currentIndex) {
                                    break;
                                }
                                if (lastIterations > currentIterations) {
                                    break;
                                }
                            }
                            lastIndex += direction;
                            cc.director.getAnimationManager().pushDelayEvent(this, "_fireEvent", [ lastIndex ]);
                        } while (lastIndex !== currentIndex && lastIndex > -1 && lastIndex < length);
                    }
                }
                this._lastWrappedInfo.set(currentWrappedInfo);
            },
            _fireEvent: function(index) {
                if (index < 0 || index >= this.events.length || this._ignoreIndex === index) {
                    return;
                }
                var eventInfo = this.events[index];
                var events = eventInfo.events;
                if (!this.target.isValid) {
                    return;
                }
                var components = this.target._components;
                for (var i = 0; i < events.length; i++) {
                    var event = events[i];
                    var funcName = event.func;
                    for (var j = 0; j < components.length; j++) {
                        var component = components[j];
                        var func = component[funcName];
                        func && func.apply(component, event.params);
                    }
                }
            },
            onTimeChangedManually: function(time, animationNode) {
                this._lastWrappedInfo = null;
                this._ignoreIndex = NaN;
                var info = animationNode.getWrappedInfo(time, this._wrappedInfo);
                var direction = info.direction;
                var frameIndex = binarySearch(this.ratios, info.ratio);
                if (frameIndex < 0) {
                    frameIndex = ~frameIndex - 1;
                    direction < 0 && (frameIndex += 1);
                    this._ignoreIndex = frameIndex;
                }
            }
        });
        module.exports = {
            AnimCurve: AnimCurve,
            DynamicAnimCurve: DynamicAnimCurve,
            SampledAnimCurve: SampledAnimCurve,
            EventAnimCurve: EventAnimCurve,
            EventInfo: EventInfo,
            computeRatioByType: computeRatioByType
        };
    }), {
        "../core/utils/binary-search": 220,
        "./bezier": 17,
        "./types": 22
    } ],
    14: [ (function(require, module, exports) {
        var JS = cc.js;
        var AnimationManager = cc.Class({
            ctor: function() {
                this.__instanceId = cc.ClassManager.getNewInstanceId();
                this._animators = new JS.array.MutableForwardIterator([]);
                this._delayEvents = [];
            },
            update: function(dt) {
                var iterator = this._animators;
                var array = iterator.array;
                for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                    var animator = array[iterator.i];
                    animator._isPlaying && !animator._isPaused && animator.update(dt);
                }
                var events = this._delayEvents;
                for (i = 0, l = events.length; i < l; i++) {
                    var event = events[i];
                    event.target[event.func].apply(event.target, event.args);
                }
                events.length = 0;
            },
            destruct: function() {},
            addAnimator: function(animator) {
                var index = this._animators.array.indexOf(animator);
                index === -1 && this._animators.push(animator);
            },
            removeAnimator: function(animator) {
                var index = this._animators.array.indexOf(animator);
                index >= 0 ? this._animators.fastRemoveAt(index) : cc.errorID(3907);
            },
            pushDelayEvent: function(target, func, args) {
                this._delayEvents.push({
                    target: target,
                    func: func,
                    args: args
                });
            }
        });
        cc.AnimationManager = module.exports = AnimationManager;
    }), {} ],
    15: [ (function(require, module, exports) {
        var JS = cc.js;
        var AnimationNode = require("./types").AnimationNode;
        function AnimationState(clip, name) {
            AnimationNode.call(this, null, null, {
                duration: clip.length
            });
            this._emit = this.emit;
            this.emit = function() {
                var args = new Array(arguments.length);
                for (var i = 0, l = args.length; i < l; i++) {
                    args[i] = arguments[i];
                }
                cc.director.getAnimationManager().pushDelayEvent(this, "_emit", args);
            };
            this._clip = clip;
            this._name = name || clip.name;
        }
        JS.extend(AnimationState, AnimationNode);
        var state = AnimationState.prototype;
        JS.get(state, "clip", (function() {
            return this._clip;
        }));
        JS.get(state, "name", (function() {
            return this._name;
        }));
        JS.obsolete(state, "AnimationState.length", "duration");
        JS.getset(state, "curveLoaded", (function() {
            return this.curves.length > 0;
        }), (function() {
            this.curves.length = 0;
        }));
        state.onPlay = function() {
            this.setTime(0);
            AnimationNode.prototype.onPlay.call(this);
        };
        state.onStop = function() {
            AnimationNode.prototype.onStop.call(this);
            this.animator && this.animator.removeAnimation(this);
        };
        state.setTime = function(time) {
            this.time = time || 0;
            var self = this;
            this.curves.forEach((function(curve) {
                curve.onTimeChangedManually(time, self);
            }));
        };
        cc.AnimationState = module.exports = AnimationState;
    }), {
        "./types": 22
    } ],
    16: [ (function(require, module, exports) {
        var JS = cc.js;
        var Playable = require("./playable");
        var AnimationNode = require("./types").AnimationNode;
        var DynamicAnimCurve = require("./animation-curves").DynamicAnimCurve;
        function Animator(target) {
            this.target = target;
            this._anims = new JS.array.MutableForwardIterator([]);
        }
        JS.extend(Animator, Playable);
        var animProto = Animator.prototype;
        animProto.update = function(dt) {
            var iterator = this._anims;
            var array = iterator.array;
            var stoppedCount = 0;
            var originLength = array.length;
            for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                var anim = array[iterator.i];
                if (anim._isPlaying && !anim._isPaused) {
                    anim.update(dt);
                    anim._isPlaying || stoppedCount++;
                }
            }
            var allRemoved = 0 === array.length;
            var allStopped = stoppedCount >= originLength;
            (allRemoved || allStopped) && this.stop();
        };
        animProto.stopStatesExcept = function(state) {
            var iterator = this._anims;
            var array = iterator.array;
            for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                var anim = array[iterator.i];
                if (anim === state) {
                    continue;
                }
                this.stopState(anim);
            }
        };
        animProto.on = function(type, callback, target, useCapture) {
            var array = this._anims.array;
            for (var i = 0; i < array.length; ++i) {
                array[i].on(type, callback, target, useCapture);
            }
        };
        animProto.onPlay = function() {
            cc.director.getAnimationManager().addAnimator(this);
        };
        animProto.onStop = function() {
            this._isPaused || cc.director.getAnimationManager().removeAnimator(this);
        };
        animProto.onResume = function() {
            cc.director.getAnimationManager().addAnimator(this);
        };
        animProto.onPause = function() {
            cc.director.getAnimationManager().removeAnimator(this);
        };
        animProto.addAnimation = function(anim) {
            var index = this._anims.array.indexOf(anim);
            index === -1 && this._anims.push(anim);
        };
        animProto.removeAnimation = function(anim) {
            var index = this._anims.array.indexOf(anim);
            index >= 0 ? this._anims.fastRemoveAt(index) : cc.errorID(3908);
        };
        function EntityAnimator(target) {
            Animator.call(this, target);
        }
        JS.extend(EntityAnimator, Animator);
        var entProto = EntityAnimator.prototype;
        function computeNullRatios(keyFrames) {
            var lastIndex = 0;
            var lastRatio = 0;
            var len = keyFrames.length;
            for (var i = 0; i < len; i++) {
                var frame = keyFrames[i];
                var ratio = frame.ratio;
                0 === i && "number" !== typeof ratio ? frame.computedRatio = ratio = 0 : i === len - 1 && "number" !== typeof ratio && (frame.computedRatio = ratio = 1);
                if ("number" === typeof ratio) {
                    if (lastIndex + 1 < i) {
                        var count = i - lastIndex;
                        var step = (ratio - lastRatio) / count;
                        for (var j = lastIndex + 1; j < i; j++) {
                            lastRatio += step;
                            keyFrames[j].computedRatio = lastRatio;
                        }
                    }
                    lastIndex = i;
                    lastRatio = ratio;
                }
            }
        }
        entProto.animate = function(keyFrames, timingInput) {
            if (!keyFrames) {
                cc.errorID(3909);
                return null;
            }
            computeNullRatios(keyFrames);
            var anim = this._doAnimate(keyFrames, timingInput);
            this.play();
            return anim;
        };
        function findCurve(curves, target, propName) {
            var i = 0, curve;
            for (;i < curves.length; i++) {
                curve = curves[i];
                if (curve.target === target && curve.prop === propName) {
                    return curve;
                }
            }
            return null;
        }
        function createPropCurve(curves, target, propName, value, ratio) {
            var curve = findCurve(curves, target, propName);
            if (!curve) {
                curve = new DynamicAnimCurve();
                curves.push(curve);
                curve.target = target;
                curve.prop = propName;
            }
            curve.values.push(value);
            curve.ratios.push(ratio);
        }
        entProto._doAnimate = function(keyFrames, timingInput) {
            var anim = new AnimationNode(this, null, timingInput);
            anim.play();
            var curves = anim.curves;
            var lastRatio = -1;
            for (var i = 0; i < keyFrames.length; i++) {
                var frame = keyFrames[i];
                var ratio = frame.ratio;
                "number" !== typeof ratio && (ratio = frame.computedRatio);
                if (ratio < 0) {
                    cc.errorID(3910);
                    continue;
                }
                if (ratio < lastRatio) {
                    cc.errorID(3911);
                    continue;
                }
                lastRatio = ratio;
                for (var key in frame) {
                    var data = frame[key];
                    if ("props" === key) {
                        for (var propName in data) {
                            createPropCurve(curves, this.target, propName, data[propName], ratio);
                        }
                    } else {
                        if ("comps" === key) {
                            for (var compName in data) {
                                var comp = this.target.getComponent(compName);
                                var compData = data[compName];
                                for (var propName in compData) {
                                    createPropCurve(curves, comp, propName, compData[propName], ratio);
                                }
                            }
                        }
                    }
                }
            }
            this._anims.push(anim);
            return anim;
        };
        module.exports = {
            Animator: Animator,
            EntityAnimator: EntityAnimator
        };
    }), {
        "./animation-curves": 13,
        "./playable": 21,
        "./types": 22
    } ],
    17: [ (function(require, module, exports) {
        function bezier(C1, C2, C3, C4, t) {
            var t1 = 1 - t;
            return C1 * t1 * t1 * t1 + 3 * C2 * t1 * t1 * t + 3 * C3 * t1 * t * t + C4 * t * t * t;
        }
        var cos = Math.cos, acos = Math.acos, max = Math.max, pi = Math.PI, tau = 2 * pi, sqrt = Math.sqrt;
        function crt(v) {
            return v < 0 ? -Math.pow(-v, 1 / 3) : Math.pow(v, 1 / 3);
        }
        function cardano(curve, x) {
            var pa = x - 0;
            var pb = x - curve[0];
            var pc = x - curve[2];
            var pd = x - 1;
            var pa3 = 3 * pa;
            var pb3 = 3 * pb;
            var pc3 = 3 * pc;
            var d = -pa + pb3 - pc3 + pd, rd = 1 / d, r3 = 1 / 3, a = (pa3 - 6 * pb + pc3) * rd, a3 = a * r3, b = (-pa3 + pb3) * rd, c = pa * rd, p = (3 * b - a * a) * r3, p3 = p * r3, q = (2 * a * a * a - 9 * a * b + 27 * c) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3, u1, v1, x1, x2, x3;
            if (discriminant < 0) {
                var mp3 = -p * r3, mp33 = mp3 * mp3 * mp3, r = sqrt(mp33), t = -q / (2 * r), cosphi = t < -1 ? -1 : t > 1 ? 1 : t, phi = acos(cosphi), crtr = crt(r), t1 = 2 * crtr;
                x1 = t1 * cos(phi * r3) - a3;
                x2 = t1 * cos((phi + tau) * r3) - a3;
                x3 = t1 * cos((phi + 2 * tau) * r3) - a3;
                return 0 <= x1 && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max(x1, x2, x3) : max(x1, x2) : 0 <= x3 && x3 <= 1 ? max(x1, x3) : x1 : 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max(x2, x3) : x2 : x3;
            }
            if (0 === discriminant) {
                u1 = q2 < 0 ? crt(-q2) : -crt(q2);
                x1 = 2 * u1 - a3;
                x2 = -u1 - a3;
                return 0 <= x1 && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? max(x1, x2) : x1 : x2;
            }
            var sd = sqrt(discriminant);
            u1 = crt(-q2 + sd);
            v1 = crt(q2 + sd);
            x1 = u1 - v1 - a3;
            return x1;
        }
        function bezierByTime(controlPoints, x) {
            var percent = cardano(controlPoints, x);
            var p0y = 0;
            var p1y = controlPoints[1];
            var p2y = controlPoints[3];
            var p3y = 1;
            var t1 = 1 - percent;
            return p0y * t1 * t1 * t1 + 3 * p1y * percent * t1 * t1 + 3 * p2y * percent * percent * t1 + p3y * percent * percent * percent;
        }
        module.exports = {
            bezier: bezier,
            bezierByTime: bezierByTime
        };
    }), {} ],
    18: [ (function(require, module, exports) {
        var Easing = {
            constant: function() {
                return 0;
            },
            linear: function(k) {
                return k;
            },
            quadIn: function(k) {
                return k * k;
            },
            quadOut: function(k) {
                return k * (2 - k);
            },
            quadInOut: function(k) {
                if ((k *= 2) < 1) {
                    return .5 * k * k;
                }
                return -.5 * (--k * (k - 2) - 1);
            },
            cubicIn: function(k) {
                return k * k * k;
            },
            cubicOut: function(k) {
                return --k * k * k + 1;
            },
            cubicInOut: function(k) {
                if ((k *= 2) < 1) {
                    return .5 * k * k * k;
                }
                return .5 * ((k -= 2) * k * k + 2);
            },
            quartIn: function(k) {
                return k * k * k * k;
            },
            quartOut: function(k) {
                return 1 - --k * k * k * k;
            },
            quartInOut: function(k) {
                if ((k *= 2) < 1) {
                    return .5 * k * k * k * k;
                }
                return -.5 * ((k -= 2) * k * k * k - 2);
            },
            quintIn: function(k) {
                return k * k * k * k * k;
            },
            quintOut: function(k) {
                return --k * k * k * k * k + 1;
            },
            quintInOut: function(k) {
                if ((k *= 2) < 1) {
                    return .5 * k * k * k * k * k;
                }
                return .5 * ((k -= 2) * k * k * k * k + 2);
            },
            sineIn: function(k) {
                return 1 - Math.cos(k * Math.PI / 2);
            },
            sineOut: function(k) {
                return Math.sin(k * Math.PI / 2);
            },
            sineInOut: function(k) {
                return .5 * (1 - Math.cos(Math.PI * k));
            },
            expoIn: function(k) {
                return 0 === k ? 0 : Math.pow(1024, k - 1);
            },
            expoOut: function(k) {
                return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
            },
            expoInOut: function(k) {
                if (0 === k) {
                    return 0;
                }
                if (1 === k) {
                    return 1;
                }
                if ((k *= 2) < 1) {
                    return .5 * Math.pow(1024, k - 1);
                }
                return .5 * (-Math.pow(2, -10 * (k - 1)) + 2);
            },
            circIn: function(k) {
                return 1 - Math.sqrt(1 - k * k);
            },
            circOut: function(k) {
                return Math.sqrt(1 - --k * k);
            },
            circInOut: function(k) {
                if ((k *= 2) < 1) {
                    return -.5 * (Math.sqrt(1 - k * k) - 1);
                }
                return .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
            },
            elasticIn: function(k) {
                var s, a = .1, p = .4;
                if (0 === k) {
                    return 0;
                }
                if (1 === k) {
                    return 1;
                }
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else {
                    s = p * Math.asin(1 / a) / (2 * Math.PI);
                }
                return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
            },
            elasticOut: function(k) {
                var s, a = .1, p = .4;
                if (0 === k) {
                    return 0;
                }
                if (1 === k) {
                    return 1;
                }
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else {
                    s = p * Math.asin(1 / a) / (2 * Math.PI);
                }
                return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
            },
            elasticInOut: function(k) {
                var s, a = .1, p = .4;
                if (0 === k) {
                    return 0;
                }
                if (1 === k) {
                    return 1;
                }
                if (!a || a < 1) {
                    a = 1;
                    s = p / 4;
                } else {
                    s = p * Math.asin(1 / a) / (2 * Math.PI);
                }
                if ((k *= 2) < 1) {
                    return -.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
                }
                return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * .5 + 1;
            },
            backIn: function(k) {
                var s = 1.70158;
                return k * k * ((s + 1) * k - s);
            },
            backOut: function(k) {
                var s = 1.70158;
                return --k * k * ((s + 1) * k + s) + 1;
            },
            backInOut: function(k) {
                var s = 2.5949095;
                if ((k *= 2) < 1) {
                    return .5 * (k * k * ((s + 1) * k - s));
                }
                return .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
            },
            bounceOut: function(k) {
                return k < 1 / 2.75 ? 7.5625 * k * k : k < 2 / 2.75 ? 7.5625 * (k -= 1.5 / 2.75) * k + .75 : k < 2.5 / 2.75 ? 7.5625 * (k -= 2.25 / 2.75) * k + .9375 : 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
            },
            smooth: function(t) {
                if (t <= 0) {
                    return 0;
                }
                if (t >= 1) {
                    return 1;
                }
                return t * t * (3 - 2 * t);
            },
            fade: function(t) {
                if (t <= 0) {
                    return 0;
                }
                if (t >= 1) {
                    return 1;
                }
                return t * t * t * (t * (6 * t - 15) + 10);
            }
        };
        function _makeOutIn(fnIn, fnOut) {
            return function(k) {
                if (k < .5) {
                    return fnOut(2 * k) / 2;
                }
                return fnIn(2 * k - 1) / 2 + .5;
            };
        }
        Easing.quadOutIn = _makeOutIn(Easing.quadIn, Easing.quadOut);
        Easing.cubicOutIn = _makeOutIn(Easing.cubicIn, Easing.cubicOut);
        Easing.quartOutIn = _makeOutIn(Easing.quartIn, Easing.quartOut);
        Easing.quintOutIn = _makeOutIn(Easing.quintIn, Easing.quintOut);
        Easing.sineOutIn = _makeOutIn(Easing.sineIn, Easing.sineOut);
        Easing.expoOutIn = _makeOutIn(Easing.expoIn, Easing.expoOut);
        Easing.circOutIn = _makeOutIn(Easing.circIn, Easing.circOut);
        Easing.backOutIn = _makeOutIn(Easing.backIn, Easing.backOut);
        Easing.backOutIn = _makeOutIn(Easing.backIn, Easing.backOut);
        Easing.bounceIn = function(k) {
            return 1 - Easing.bounceOut(1 - k);
        };
        Easing.bounceInOut = function(k) {
            if (k < .5) {
                return .5 * Easing.bounceIn(2 * k);
            }
            return .5 * Easing.bounceOut(2 * k - 1) + .5;
        };
        Easing.bounceOutIn = _makeOutIn(Easing.bounceIn, Easing.bounceOut);
        cc.Easing = module.exports = Easing;
    }), {} ],
    19: [ (function(require, module, exports) {
        require("./bezier");
        require("./easing");
        require("./types");
        require("./motion-path-helper");
        require("./animation-curves");
        require("./animation-clip");
        require("./animators");
        require("./animation-manager");
        require("./animation-state");
        require("./animation-animator");
    }), {
        "./animation-animator": 11,
        "./animation-clip": 12,
        "./animation-curves": 13,
        "./animation-manager": 14,
        "./animation-state": 15,
        "./animators": 16,
        "./bezier": 17,
        "./easing": 18,
        "./motion-path-helper": 20,
        "./types": 22
    } ],
    20: [ (function(require, module, exports) {
        var DynamicAnimCurve = require("./animation-curves").DynamicAnimCurve;
        var computeRatioByType = require("./animation-curves").computeRatioByType;
        var bezier = require("./bezier").bezier;
        var binarySearch = require("../core/utils/binary-search").binarySearchEpsilon;
        var v2 = cc.v2;
        function Curve(points) {
            this.points = points || [];
            this.beziers = [];
            this.ratios = [];
            this.progresses = [];
            this.length = 0;
            this.computeBeziers();
        }
        Curve.prototype.computeBeziers = function() {
            this.beziers.length = 0;
            this.ratios.length = 0;
            this.progresses.length = 0;
            this.length = 0;
            var bezier;
            for (var i = 1; i < this.points.length; i++) {
                var startPoint = this.points[i - 1];
                var endPoint = this.points[i];
                bezier = new Bezier();
                bezier.start = startPoint.pos;
                bezier.startCtrlPoint = startPoint.out;
                bezier.end = endPoint.pos;
                bezier.endCtrlPoint = endPoint.in;
                this.beziers.push(bezier);
                this.length += bezier.getLength();
            }
            var current = 0;
            for (var i = 0; i < this.beziers.length; i++) {
                bezier = this.beziers[i];
                this.ratios[i] = bezier.getLength() / this.length;
                this.progresses[i] = current += this.ratios[i];
            }
            return this.beziers;
        };
        function Bezier() {
            this.start = v2();
            this.end = v2();
            this.startCtrlPoint = v2();
            this.endCtrlPoint = v2();
        }
        Bezier.prototype.getPointAt = function(u) {
            var t = this.getUtoTmapping(u);
            return this.getPoint(t);
        };
        Bezier.prototype.getPoint = function(t) {
            var x = bezier(this.start.x, this.startCtrlPoint.x, this.endCtrlPoint.x, this.end.x, t);
            var y = bezier(this.start.y, this.startCtrlPoint.y, this.endCtrlPoint.y, this.end.y, t);
            return new v2(x, y);
        };
        Bezier.prototype.getLength = function() {
            var lengths = this.getLengths();
            return lengths[lengths.length - 1];
        };
        Bezier.prototype.getLengths = function(divisions) {
            divisions || (divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
            if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1) {
                return this.cacheArcLengths;
            }
            var cache = [];
            var current, last = this.getPoint(0);
            var p, sum = 0;
            cache.push(0);
            for (p = 1; p <= divisions; p++) {
                current = this.getPoint(p / divisions);
                sum += cc.pDistance(current, last);
                cache.push(sum);
                last = current;
            }
            this.cacheArcLengths = cache;
            return cache;
        };
        Bezier.prototype.getUtoTmapping = function(u, distance) {
            var arcLengths = this.getLengths();
            var i = 0, il = arcLengths.length;
            var targetArcLength;
            targetArcLength = distance ? distance : u * arcLengths[il - 1];
            var low = 0, high = il - 1, comparison;
            while (low <= high) {
                i = Math.floor(low + (high - low) / 2);
                comparison = arcLengths[i] - targetArcLength;
                if (comparison < 0) {
                    low = i + 1;
                    continue;
                }
                if (comparison > 0) {
                    high = i - 1;
                    continue;
                }
                high = i;
                break;
            }
            i = high;
            if (arcLengths[i] === targetArcLength) {
                var t = i / (il - 1);
                return t;
            }
            var lengthBefore = arcLengths[i];
            var lengthAfter = arcLengths[i + 1];
            var segmentLength = lengthAfter - lengthBefore;
            var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
            var t = (i + segmentFraction) / (il - 1);
            return t;
        };
        function sampleMotionPaths(motionPaths, data, duration, fps) {
            function createControlPoints(array) {
                if (array instanceof cc.Vec2) {
                    return {
                        in: array,
                        pos: array,
                        out: array
                    };
                }
                if (Array.isArray(array) && 6 === array.length) {
                    return {
                        in: v2(array[2], array[3]),
                        pos: v2(array[0], array[1]),
                        out: v2(array[4], array[5])
                    };
                }
                return {
                    in: cc.Vec2.ZERO,
                    pos: cc.Vec2.ZERO,
                    out: cc.Vec2.ZERO
                };
            }
            var values = data.values;
            if (0 === motionPaths.length || 0 === values.length) {
                return;
            }
            values = values.map((function(value) {
                return v2(value[0], value[1]);
            }));
            if (1 === values.length) {
                data.values = values;
                return;
            }
            var types = data.types;
            var ratios = data.ratios;
            var newValues = data.values = [];
            var newTypes = data.types = [];
            var newRatios = data.ratios = [];
            function addNewDatas(value, type, ratio) {
                newValues.push(value);
                newTypes.push(type);
                newRatios.push(ratio);
            }
            var startRatioOffset = 0;
            var EPSILON = 1e-6;
            var newType = DynamicAnimCurve.Linear;
            for (var i = 0, l = motionPaths.length; i < l - 1; i++) {
                var motionPath = motionPaths[i];
                var ratio = ratios[i];
                var nextRatio = ratios[i + 1];
                var betweenRatio = nextRatio - ratio;
                var value = values[i];
                var nextValue = values[i + 1];
                var type = types[i];
                var results = [];
                var progress = startRatioOffset / betweenRatio;
                var speed = 1 / (betweenRatio * duration * fps);
                var finalProgress;
                if (motionPath && motionPath.length > 0) {
                    var points = [];
                    points.push(createControlPoints(value));
                    for (var j = 0, l2 = motionPath.length; j < l2; j++) {
                        var controlPoints = createControlPoints(motionPath[j]);
                        points.push(controlPoints);
                    }
                    points.push(createControlPoints(nextValue));
                    var curve = new Curve(points);
                    curve.computeBeziers();
                    var progresses = curve.progresses;
                    while (1 - progress > EPSILON) {
                        finalProgress = progress;
                        finalProgress = computeRatioByType(finalProgress, type);
                        var pos, bezier, normal, length;
                        if (finalProgress < 0) {
                            bezier = curve.beziers[0];
                            length = (0 - finalProgress) * bezier.getLength();
                            normal = bezier.start.sub(bezier.endCtrlPoint).normalize();
                            pos = bezier.start.add(normal.mul(length));
                        } else {
                            if (finalProgress > 1) {
                                bezier = curve.beziers[curve.beziers.length - 1];
                                length = (finalProgress - 1) * bezier.getLength();
                                normal = bezier.end.sub(bezier.startCtrlPoint).normalize();
                                pos = bezier.end.add(normal.mul(length));
                            } else {
                                var bezierIndex = binarySearch(progresses, finalProgress);
                                bezierIndex < 0 && (bezierIndex = ~bezierIndex);
                                finalProgress -= bezierIndex > 0 ? progresses[bezierIndex - 1] : 0;
                                finalProgress /= curve.ratios[bezierIndex];
                                pos = curve.beziers[bezierIndex].getPointAt(finalProgress);
                            }
                        }
                        results.push(pos);
                        progress += speed;
                    }
                } else {
                    while (1 - progress > EPSILON) {
                        finalProgress = progress;
                        finalProgress = computeRatioByType(finalProgress, type);
                        results.push(value.lerp(nextValue, finalProgress));
                        progress += speed;
                    }
                }
                newType = "constant" === type ? type : DynamicAnimCurve.Linear;
                for (var j = 0, l2 = results.length; j < l2; j++) {
                    var newRatio = ratio + startRatioOffset + speed * j * betweenRatio;
                    addNewDatas(results[j], newType, newRatio);
                }
                startRatioOffset = Math.abs(progress - 1) > EPSILON ? (progress - 1) * betweenRatio : 0;
            }
            ratios[ratios.length - 1] !== newRatios[newRatios.length - 1] && addNewDatas(values[values.length - 1], newType, ratios[ratios.length - 1]);
        }
        module.exports = {
            sampleMotionPaths: sampleMotionPaths,
            Curve: Curve,
            Bezier: Bezier
        };
    }), {
        "../core/utils/binary-search": 220,
        "./animation-curves": 13,
        "./bezier": 17
    } ],
    21: [ (function(require, module, exports) {
        var JS = cc.js;
        function Playable() {
            this._isPlaying = false;
            this._isPaused = false;
            this._stepOnce = false;
        }
        var prototype = Playable.prototype;
        JS.get(prototype, "isPlaying", (function() {
            return this._isPlaying;
        }), true);
        JS.get(prototype, "isPaused", (function() {
            return this._isPaused;
        }), true);
        var virtual = function() {};
        prototype.onPlay = virtual;
        prototype.onPause = virtual;
        prototype.onResume = virtual;
        prototype.onStop = virtual;
        prototype.onError = virtual;
        prototype.play = function() {
            if (this._isPlaying) {
                if (this._isPaused) {
                    this._isPaused = false;
                    this.onResume();
                } else {
                    this.onError("already-playing");
                }
            } else {
                this._isPlaying = true;
                this.onPlay();
            }
        };
        prototype.stop = function() {
            if (this._isPlaying) {
                this._isPlaying = false;
                this.onStop();
                this._isPaused = false;
            }
        };
        prototype.pause = function() {
            if (this._isPlaying) {
                this._isPaused = true;
                this.onPause();
            }
        };
        prototype.resume = function() {
            if (this._isPlaying && this._isPaused) {
                this._isPaused = false;
                this.onResume();
            }
        };
        prototype.step = function() {
            this.pause();
            this._stepOnce = true;
            this._isPlaying || this.play();
        };
        module.exports = Playable;
    }), {} ],
    22: [ (function(require, module, exports) {
        var JS = cc.js;
        var Playable = require("./playable");
        var WrapModeMask = {
            Loop: 2,
            ShouldWrap: 4,
            PingPong: 22,
            Reverse: 36
        };
        var WrapMode = cc.Enum({
            Default: 0,
            Normal: 1,
            Reverse: WrapModeMask.Reverse,
            Loop: WrapModeMask.Loop,
            LoopReverse: WrapModeMask.Loop | WrapModeMask.Reverse,
            PingPong: WrapModeMask.PingPong,
            PingPongReverse: WrapModeMask.PingPong | WrapModeMask.Reverse
        });
        cc.WrapMode = WrapMode;
        function WrappedInfo(info) {
            if (info) {
                this.set(info);
                return;
            }
            this.ratio = 0;
            this.time = 0;
            this.direction = 1;
            this.stopped = true;
            this.iterations = 0;
        }
        WrappedInfo.prototype.set = function(info) {
            for (var k in info) {
                this[k] = info[k];
            }
        };
        function AnimationNodeBase() {
            Playable.call(this);
        }
        JS.extend(AnimationNodeBase, Playable);
        AnimationNodeBase.prototype.update = function(deltaTime) {};
        function AnimationNode(animator, curves, timingInput) {
            AnimationNodeBase.call(this);
            this._firstFramePlayed = false;
            this._delay = 0;
            this._delayTime = 0;
            this._wrappedInfo = new WrappedInfo();
            this._lastWrappedInfo = null;
            this.animator = animator;
            this.curves = curves || [];
            this.delay = 0;
            this.repeatCount = 1;
            this.duration = 1;
            this.speed = 1;
            this.wrapMode = WrapMode.Normal;
            if (timingInput) {
                this.delay = timingInput.delay || this.delay;
                var duration = timingInput.duration;
                "undefined" !== typeof duration && (this.duration = duration);
                var speed = timingInput.speed;
                "undefined" !== typeof speed && (this.speed = speed);
                var wrapMode = timingInput.wrapMode;
                if ("undefined" !== typeof wrapMode) {
                    var isEnum = "number" === typeof wrapMode;
                    isEnum ? this.wrapMode = wrapMode : this.wrapMode = WrapMode[wrapMode];
                }
                var repeatCount = timingInput.repeatCount;
                "undefined" !== typeof repeatCount ? this.repeatCount = repeatCount : this.wrapMode & WrapModeMask.Loop && (this.repeatCount = 1 / 0);
            }
            this.time = 0;
        }
        JS.extend(AnimationNode, AnimationNodeBase);
        var proto = AnimationNode.prototype;
        proto.update = function(delta) {
            if (this._delayTime > 0) {
                this._delayTime -= delta;
                if (this._delayTime > 0) {
                    return;
                }
            }
            this._firstFramePlayed ? this.time += delta * this.speed : this._firstFramePlayed = true;
            var info = this.sample();
            this._lastWrappedInfo || (this._lastWrappedInfo = new WrappedInfo(info));
            var anotherIteration = (0 | info.iterations) > (0 | this._lastWrappedInfo.iterations);
            this.repeatCount > 1 && anotherIteration && ((this.wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse ? this._lastWrappedInfo.direction < 0 && this.emit("lastframe", this) : this._lastWrappedInfo.direction > 0 && this.emit("lastframe", this));
            if (info.stopped) {
                this.stop();
                this.emit("finished", this);
            }
            this._lastWrappedInfo.set(info);
        };
        proto._needRevers = function(currentIterations) {
            var wrapMode = this.wrapMode;
            var needRevers = false;
            if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
                var isEnd = currentIterations - (0 | currentIterations) === 0;
                isEnd && currentIterations > 0 && (currentIterations -= 1);
                var isOddIteration = 1 & currentIterations;
                isOddIteration && (needRevers = !needRevers);
            }
            (wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse && (needRevers = !needRevers);
            return needRevers;
        };
        proto.getWrappedInfo = function(time, info) {
            info = info || new WrappedInfo();
            var stopped = false;
            var duration = this.duration;
            var ratio = 0;
            var wrapMode = this.wrapMode;
            var currentIterations = Math.abs(time / duration);
            currentIterations > this.repeatCount && (currentIterations = this.repeatCount);
            var needRevers = false;
            wrapMode & WrapModeMask.ShouldWrap && (needRevers = this._needRevers(currentIterations));
            var direction = needRevers ? -1 : 1;
            this.speed < 0 && (direction *= -1);
            if (currentIterations >= this.repeatCount) {
                stopped = true;
                var tempRatio = this.repeatCount - (0 | this.repeatCount);
                0 === tempRatio && (tempRatio = 1);
                time = tempRatio * duration * (time > 0 ? 1 : -1);
            }
            if (time > duration) {
                var tempTime = time % duration;
                time = 0 === tempTime ? duration : tempTime;
            } else {
                if (time < 0) {
                    time %= duration;
                    0 !== time && (time += duration);
                }
            }
            wrapMode & WrapModeMask.ShouldWrap && needRevers && (time = duration - time);
            ratio = time / duration;
            info.ratio = ratio;
            info.time = time;
            info.direction = direction;
            info.stopped = stopped;
            info.iterations = currentIterations;
            return info;
        };
        proto.sample = function() {
            var info = this.getWrappedInfo(this.time, this._wrappedInfo);
            var curves = this.curves;
            for (var i = 0, len = curves.length; i < len; i++) {
                var curve = curves[i];
                curve.sample(info.time, info.ratio, this);
            }
            return info;
        };
        proto.onStop = function() {
            this.emit("stop", this);
        };
        proto.onPlay = function() {
            this._delayTime = this._delay;
            this.emit("play", this);
        };
        proto.onPause = function() {
            this.emit("pause", this);
        };
        proto.onResume = function() {
            this.emit("resume", this);
        };
        JS.getset(proto, "wrapMode", (function() {
            return this._wrapMode;
        }), (function(value) {
            this._wrapMode = value;
            this.time = 0;
            value & WrapModeMask.Loop ? this.repeatCount = 1 / 0 : this.repeatCount = 1;
        }));
        JS.getset(proto, "delay", (function() {
            return this._delay;
        }), (function(value) {
            this._delayTime = this._delay = value;
        }));
        cc.js.mixin(proto, cc.EventTarget.prototype);
        cc.AnimationNode = AnimationNode;
        module.exports = {
            WrapModeMask: WrapModeMask,
            WrapMode: WrapMode,
            AnimationNode: AnimationNode,
            WrappedInfo: WrappedInfo
        };
    }), {
        "./playable": 21
    } ],
    23: [ (function(require, module, exports) {
        var EventTarget = require("../core/event/event-target");
        var touchBinded = false;
        var touchPlayList = [];
        var Audio = function(src) {
            EventTarget.call(this);
            this._src = src;
            this._audioType = Audio.Type.UNKNOWN;
            this._element = null;
            this._eventList = {};
            this._state = Audio.State.INITIALZING;
            this._loaded = false;
            this._onended = function() {
                this.emit("ended");
            }.bind(this);
        };
        cc.js.extend(Audio, EventTarget);
        Audio.Type = {
            DOM: "AUDIO",
            WEBAUDIO: "WEBAUDIO",
            NATIVE: "NATIVE",
            UNKNOWN: "UNKNOWN"
        };
        Audio.State = {
            ERROR: -1,
            INITIALZING: 0,
            PLAYING: 1,
            PAUSED: 2
        };
        (function(proto) {
            proto.preload = function() {
                var src = this._src, audio = this;
                var item = cc.loader.getItem(src);
                item || (item = cc.loader.getItem(src + "?useDom=1"));
                if (!item) {
                    return cc.loader.load(src, (function(error) {
                        if (!error) {
                            var item = cc.loader.getItem(src);
                            audio.mount(item.element || item.buffer);
                            audio.emit("load");
                        }
                    }));
                }
                if (item.complete) {
                    audio.mount(item.element || item.buffer);
                    audio.emit("load");
                }
            };
            proto._bindEnded = function(callback) {
                callback = callback || this._onended;
                this._audioType === Audio.Type.DOM ? this._element.addEventListener("ended", callback) : this._element.onended = callback;
            };
            proto._unbindEnded = function() {
                this._audioType === Audio.Type.DOM ? this._element.removeEventListener("ended", this._onended) : this._element.onended = null;
            };
            proto.mount = function(elem) {
                if (elem instanceof HTMLElement) {
                    this._element = document.createElement("audio");
                    this._element.src = elem.src;
                    this._audioType = Audio.Type.DOM;
                } else {
                    this._element = new WebAudioElement(elem, this);
                    this._audioType = Audio.Type.WEBAUDIO;
                }
                this._bindEnded();
                this._state = Audio.State.INITIALZING;
                this._loaded = true;
            };
            proto.play = function() {
                if (!this._element) {
                    return;
                }
                this._element.play();
                this.emit("play");
                this._state = Audio.State.PLAYING;
                this._audioType === Audio.Type.DOM && this._element.paused && touchPlayList.push({
                    instance: this,
                    offset: 0,
                    audio: this._element
                });
                if (touchBinded) {
                    return;
                }
                touchBinded = true;
                cc.game.canvas.addEventListener("touchstart", (function() {
                    var item;
                    while (item = touchPlayList.pop()) {
                        item.audio.play(item.offset);
                    }
                }));
            };
            proto.pause = function() {
                if (!this._element) {
                    return;
                }
                this._unbindEnded();
                this._element.pause();
                this.emit("pause");
                this._state = Audio.State.PAUSED;
            };
            proto.resume = function() {
                if (!this._element || 0 === this._element.currentTime) {
                    return;
                }
                this._bindEnded();
                this._element.play();
                this.emit("resume");
                this._state = Audio.State.PLAYING;
            };
            proto.stop = function() {
                if (!this._element) {
                    return;
                }
                try {
                    this._element.currentTime = 0;
                } catch (error) {}
                this._element.pause();
                for (var i = 0; i < touchPlayList; i++) {
                    if (touchPlayList[i].instance === this) {
                        touchPlayList.splice(i, 1);
                        break;
                    }
                }
                this.emit("ended");
                this.emit("stop");
                this._state = Audio.State.PAUSED;
            };
            proto.setLoop = function(loop) {
                if (!this._element) {
                    return;
                }
                this._element.loop = loop;
            };
            proto.getLoop = function() {
                return this._element && this._element.loop;
            };
            proto.setVolume = function(num) {
                if (!this._element) {
                    return;
                }
                this._element.volume = num;
            };
            proto.getVolume = function() {
                return this._element ? this._element.volume : 1;
            };
            proto.setCurrentTime = function(num) {
                if (!this._element) {
                    return;
                }
                this._unbindEnded();
                this._bindEnded(function() {
                    this._bindEnded();
                }.bind(this));
                this._element.currentTime = num;
            };
            proto.getCurrentTime = function() {
                return this._element ? this._element.currentTime : 0;
            };
            proto.getDuration = function() {
                return this._element ? this._element.duration : 0;
            };
            proto.getState = function() {
                var elem = this._element;
                Audio.State.PLAYING === this._state && elem.paused && (this._state = Audio.State.PAUSED);
                return this._state;
            };
            proto.__defineGetter__("src", (function() {
                return this._src;
            }));
            proto.__defineSetter__("src", (function(string) {
                return this._src = string;
            }));
            proto.__defineGetter__("paused", (function() {
                return !this._element || this._element.paused;
            }));
        })(Audio.prototype);
        var WebAudioElement = function(buffer, audio) {
            this._audio = audio;
            this._context = cc.sys.__audioSupport.context;
            this._buffer = buffer;
            this._volume = this._context["createGain"]();
            this._volume["gain"].value = 1;
            this._volume["connect"](this._context["destination"]);
            this._loop = false;
            this._startTime = -1;
            this._currentSource = null;
            this.playedLength = 0;
            this._currextTimer = null;
            this._endCallback = function() {
                this.onended && this.onended(this);
            }.bind(this);
        };
        (function(proto) {
            proto.play = function(offset) {
                if (this._currentSource && !this.paused) {
                    this._currentSource.onended = null;
                    this._currentSource.stop(0);
                    this.playedLength = 0;
                }
                var audio = this._context["createBufferSource"]();
                audio.buffer = this._buffer;
                audio["connect"](this._volume);
                audio.loop = this._loop;
                this._startTime = this._context.currentTime;
                offset = offset || this.playedLength;
                offset && (this._startTime -= offset);
                var duration = this._buffer.duration;
                var startTime = offset;
                var endTime;
                if (this._loop) {
                    audio.start ? audio.start(0, startTime) : audio["notoGrainOn"] ? audio["noteGrainOn"](0, startTime) : audio["noteOn"](0, startTime);
                } else {
                    endTime = duration - offset;
                    audio.start ? audio.start(0, startTime, endTime) : audio["notoGrainOn"] ? audio["noteGrainOn"](0, startTime, endTime) : audio["noteOn"](0, startTime, endTime);
                }
                this._currentSource = audio;
                audio.onended = this._endCallback;
                if (0 === this._context.currentTime) {
                    var self = this;
                    clearTimeout(this._currextTimer);
                    this._currextTimer = setTimeout((function() {
                        0 === self._context.currentTime && touchPlayList.push({
                            instance: self._audio,
                            offset: offset,
                            audio: self
                        });
                    }), 10);
                }
            };
            proto.pause = function() {
                clearTimeout(this._currextTimer);
                if (this.paused) {
                    return;
                }
                this.playedLength = this._context.currentTime - this._startTime;
                this.playedLength %= this._buffer.duration;
                var audio = this._currentSource;
                this._currentSource = null;
                this._startTime = -1;
                audio && audio.stop(0);
            };
            proto.__defineGetter__("paused", (function() {
                if (this._currentSource && this._currentSource.loop) {
                    return false;
                }
                if (this._startTime === -1) {
                    return true;
                }
                return this._context.currentTime - this._startTime > this._buffer.duration;
            }));
            proto.__defineGetter__("loop", (function() {
                return this._loop;
            }));
            proto.__defineSetter__("loop", (function(bool) {
                this._currentSource && (this._currentSource.loop = bool);
                return this._loop = bool;
            }));
            proto.__defineGetter__("volume", (function() {
                return this._volume["gain"].value;
            }));
            proto.__defineSetter__("volume", (function(num) {
                this._volume["gain"].value = num;
                if (cc.sys.os === cc.sys.OS_IOS && !this.paused && this._currentSource) {
                    this._currentSource.onended = null;
                    this.pause();
                    this.play();
                }
                return num;
            }));
            proto.__defineGetter__("currentTime", (function() {
                if (this.paused) {
                    return this.playedLength;
                }
                this.playedLength = this._context.currentTime - this._startTime;
                this.playedLength %= this._buffer.duration;
                return this.playedLength;
            }));
            proto.__defineSetter__("currentTime", (function(num) {
                if (this.paused) {
                    this.playedLength = num;
                } else {
                    this.pause();
                    this.playedLength = num;
                    this.play();
                }
                return num;
            }));
            proto.__defineGetter__("duration", (function() {
                return this._buffer.duration;
            }));
        })(WebAudioElement.prototype);
        module.exports = cc.Audio = Audio;
    }), {
        "../core/event/event-target": 112
    } ],
    24: [ (function(require, module, exports) {
        var Audio = require("./CCAudio");
        var instanceId = 0;
        var id2audio = {};
        var url2id = {};
        var getAudioFromPath = function(path) {
            var id = instanceId++;
            var list = url2id[path];
            list || (list = url2id[path] = []);
            var audio;
            if (audioEngine._maxAudioInstance <= list.length) {
                var oldId = list.shift();
                var oldAudio = id2audio[oldId];
                oldAudio.stop();
            }
            audio = new Audio(path);
            audio.on("ended", (function() {
                var id = this.instanceId;
                delete id2audio[id];
                var index = list.indexOf(id);
                cc.js.array.fastRemoveAt(list, index);
            }));
            id2audio[id] = audio;
            audio.instanceId = id;
            list.push(id);
            return audio;
        };
        var getAudioFromId = function(id) {
            return id2audio[id];
        };
        var audioEngine = {
            AudioState: Audio.State,
            _maxWebAudioSize: 2097152,
            _maxAudioInstance: 24,
            _id2audio: id2audio,
            play: function(filePath, loop, volume) {
                var audio = getAudioFromPath(filePath);
                var callback = function() {
                    audio.setLoop(loop || false);
                    audio.setVolume(volume || 1);
                    audio.play();
                };
                audio.__callback = callback;
                audio.on("load", callback);
                audio.preload();
                return audio.instanceId;
            },
            setLoop: function(audioID, loop) {
                var audio = getAudioFromId(audioID);
                if (!audio || !audio.setLoop) {
                    return;
                }
                audio.setLoop(loop);
            },
            isLoop: function(audioID) {
                var audio = getAudioFromId(audioID);
                if (!audio || !audio.isLoop) {
                    return false;
                }
                return audio.isLoop();
            },
            setVolume: function(audioID, volume) {
                var audio = getAudioFromId(audioID);
                if (!audio) {
                    return;
                }
                audio._loaded || audio.once("load", (function() {
                    audio.setVolume && audio.setVolume(volume);
                }));
                audio.setVolume && audio.setVolume(volume);
            },
            getVolume: function(audioID) {
                var audio = getAudioFromId(audioID);
                if (!audio || !audio.getVolume) {
                    return 1;
                }
                return audio.getVolume();
            },
            setCurrentTime: function(audioID, sec) {
                var audio = getAudioFromId(audioID);
                if (!audio) {
                    return false;
                }
                if (!audio._loaded) {
                    audio.once("load", (function() {
                        audio.setCurrentTime && audio.setCurrentTime(sec);
                    }));
                    return true;
                }
                audio.setCurrentTime && audio.setCurrentTime(sec);
                return true;
            },
            getCurrentTime: function(audioID) {
                var audio = getAudioFromId(audioID);
                if (!audio || !audio.getCurrentTime) {
                    return 0;
                }
                return audio.getCurrentTime();
            },
            getDuration: function(audioID) {
                var audio = getAudioFromId(audioID);
                if (!audio || !audio.getDuration) {
                    return 0;
                }
                return audio.getDuration();
            },
            getState: function(audioID) {
                var audio = getAudioFromId(audioID);
                if (!audio || !audio.getState) {
                    return this.AudioState.ERROR;
                }
                return audio.getState();
            },
            setFinishCallback: function(audioID, callback) {
                var audio = getAudioFromId(audioID);
                if (!audio) {
                    return;
                }
                audio.off("ended");
                audio.on("ended", callback);
            },
            pause: function(audioID) {
                var audio = getAudioFromId(audioID);
                if (!audio || !audio.pause) {
                    return false;
                }
                audio.pause();
                return true;
            },
            _pauseIDCache: [],
            pauseAll: function() {
                for (var id in id2audio) {
                    var audio = id2audio[id];
                    var state = audio.getState();
                    if (state === Audio.State.PLAYING) {
                        this._pauseIDCache.push(id);
                        audio.pause();
                    }
                }
            },
            resume: function(audioID) {
                var audio = getAudioFromId(audioID);
                if (!audio || !audio.resume) {
                    return false;
                }
                0 === audio.getCurrentTime() ? audio.play() : audio.resume();
            },
            resumeAll: function() {
                while (this._pauseIDCache.length > 0) {
                    var id = this._pauseIDCache.pop();
                    var audio = getAudioFromId(id);
                    audio && audio.resume && audio.resume();
                }
            },
            stop: function(audioID) {
                var audio = getAudioFromId(audioID);
                if (!audio || !audio.stop) {
                    return false;
                }
                audio.off("load", audio.__callback);
                audio.stop();
                audio.emit("ended");
                return true;
            },
            stopAll: function() {
                for (var id in id2audio) {
                    var audio = id2audio[id];
                    if (audio && audio.stop) {
                        audio.stop();
                        audio.off("load", audio.__callback);
                        audio.emit("ended");
                    }
                }
            },
            setMaxAudioInstance: function(num) {
                return this._maxAudioInstance = num;
            },
            getMaxAudioInstance: function() {
                return this._maxAudioInstance;
            },
            uncache: function(filePath) {
                var list = url2id[filePath];
                if (!list) {
                    return;
                }
                while (list.length > 0) {
                    var id = list.pop();
                    var audio = id2audio[id];
                    if (audio) {
                        audio.stop();
                        delete id2audio[id];
                    }
                }
            },
            uncacheAll: function() {
                this.stopAll();
                id2audio = {};
                url2id = {};
            },
            getProfile: function(profileName) {},
            preload: function(filePath, callback) {
                cc.loader.load(filePath, (function(error) {
                    error || callback();
                }));
            },
            setMaxWebAudioSize: function(kb) {
                this._maxWebAudioSize = 1024 * kb;
            },
            _breakCache: null,
            _break: function() {
                this._breakCache = [];
                for (var id in id2audio) {
                    var audio = id2audio[id];
                    var state = audio.getState();
                    if (state === Audio.State.PLAYING) {
                        this._breakCache.push(id);
                        audio.pause();
                    }
                }
            },
            _restore: function() {
                if (!this._breakCache) {
                    return;
                }
                while (this._breakCache.length > 0) {
                    var id = this._breakCache.pop();
                    var audio = getAudioFromId(id);
                    audio && audio.resume && audio.resume();
                }
                this._breakCache = null;
            }
        };
        module.exports = cc.audioEngine = audioEngine;
        var Module = require("./deprecated");
        Module.removed(audioEngine);
        Module.deprecated(audioEngine);
    }), {
        "./CCAudio": 23,
        "./deprecated": 25
    } ],
    25: [ (function(require, module, exports) {
        var js = cc.js;
        exports.removed = function(audioEngine) {
            function willPlayMusicError() {
                cc.errorID(1403);
            }
            js.getset(audioEngine, "willPlayMusic", willPlayMusicError, willPlayMusicError);
        };
        exports.deprecated = function(audioEngine) {
            var musicId = -1;
            var musicPath = 1;
            var musicLoop = 1;
            var musicVolume = 1;
            var effectsVolume = 1;
            var pauseIDCache = [];
            js.get(audioEngine, "playMusic", (function() {
                return function(url, loop) {
                    audioEngine.stop(musicId);
                    musicId = audioEngine.play(url, loop, musicVolume);
                    musicPath = url;
                    musicLoop = loop;
                    return musicId;
                };
            }));
            js.get(audioEngine, "stopMusic", (function() {
                return function() {
                    audioEngine.stop(musicId);
                    return musicId;
                };
            }));
            js.get(audioEngine, "pauseMusic", (function() {
                return function() {
                    audioEngine.pause(musicId);
                    return musicId;
                };
            }));
            js.get(audioEngine, "resumeMusic", (function() {
                return function() {
                    audioEngine.resume(musicId);
                    return musicId;
                };
            }));
            js.get(audioEngine, "rewindMusic", (function() {
                return function() {
                    audioEngine.setCurrentTime(musicId, 0);
                    return musicId;
                };
            }));
            js.get(audioEngine, "getMusicVolume", (function() {
                return function() {
                    return musicVolume;
                };
            }));
            js.get(audioEngine, "setMusicVolume", (function() {
                return function(volume) {
                    musicVolume = volume;
                    audioEngine.setVolume(musicId, musicVolume);
                    return musicVolume;
                };
            }));
            js.get(audioEngine, "isMusicPlaying", (function() {
                return function() {
                    return audioEngine.getState(musicId) === audioEngine.AudioState.PLAYING;
                };
            }));
            js.get(audioEngine, "playEffect", (function() {
                return function(url, loop, volume) {
                    return audioEngine.play(url, loop, void 0 === volume ? effectsVolume : volume);
                };
            }));
            js.get(audioEngine, "setEffectsVolume", (function(volume) {
                return function(volume) {
                    effectsVolume = volume;
                    var id2audio = audioEngine._id2audio;
                    for (var id in id2audio) {
                        if (id === musicId) {
                            continue;
                        }
                        audioEngine.setVolume(id, volume);
                    }
                };
            }));
            js.get(audioEngine, "getEffectsVolume", (function() {
                return function() {
                    return effectsVolume;
                };
            }));
            js.get(audioEngine, "pauseEffect", (function() {
                return function(id) {
                    return audioEngine.pause(id);
                };
            }));
            js.get(audioEngine, "pauseAllEffects", (function() {
                return function() {
                    pauseIDCache.length = 0;
                    var id2audio = audioEngine._id2audio;
                    for (var id in id2audio) {
                        if (id === musicId) {
                            continue;
                        }
                        var audio = id2audio[id];
                        var state = audio.getState();
                        if (state === audioEngine.AudioState.PLAYING) {
                            pauseIDCache.push(id);
                            audio.pause();
                        }
                    }
                };
            }));
            js.get(audioEngine, "resumeEffect", (function() {
                return function(id) {
                    audioEngine.resume(id);
                };
            }));
            js.get(audioEngine, "resumeAllEffects", (function() {
                return function() {
                    var id2audio = audioEngine._id2audio;
                    while (pauseIDCache.length > 0) {
                        var id = pauseIDCache.pop();
                        var audio = id2audio[id];
                        audio && audio.resume && audio.resume();
                    }
                };
            }));
            js.get(audioEngine, "stopEffect", (function() {
                return function(id) {
                    return audioEngine.stop(id);
                };
            }));
            js.get(audioEngine, "stopAllEffects", (function() {
                return function() {
                    var id2audio = audioEngine._id2audio;
                    for (var id in id2audio) {
                        if (id === musicId) {
                            continue;
                        }
                        var audio = id2audio[id];
                        var state = audio.getState();
                        state === audioEngine.AudioState.PLAYING && audio.stop();
                    }
                };
            }));
            js.get(audioEngine, "unloadEffect", (function() {
                return function(id) {
                    return audioEngine.stop(id);
                };
            }));
            js.get(audioEngine, "end", (function() {
                return function() {
                    return audioEngine.stopAll();
                };
            }));
        };
    }), {} ],
    26: [ (function(require, module, exports) {
        cc.ClippingNode = _ccsg.Node.extend({
            inverted: false,
            _alphaThreshold: 0,
            _stencil: null,
            _className: "ClippingNode",
            _originStencilProgram: null,
            ctor: function(stencil) {
                stencil = stencil || null;
                _ccsg.Node.prototype.ctor.call(this);
                this._stencil = stencil;
                stencil && (this._originStencilProgram = stencil.getShaderProgram());
                this.alphaThreshold = 1;
                this.inverted = false;
                this._renderCmd.initStencilBits();
            },
            onEnter: function() {
                _ccsg.Node.prototype.onEnter.call(this);
                this._stencil && this._stencil.performRecursive(_ccsg.Node.performType.onEnter);
            },
            onEnterTransitionDidFinish: function() {
                _ccsg.Node.prototype.onEnterTransitionDidFinish.call(this);
                this._stencil && this._stencil.performRecursive(_ccsg.Node.performType.onEnterTransitionDidFinish);
            },
            onExitTransitionDidStart: function() {
                this._stencil && this._stencil.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
                _ccsg.Node.prototype.onExitTransitionDidStart.call(this);
            },
            onExit: function() {
                this._stencil && this._stencil.performRecursive(_ccsg.Node.performType.onExit);
                _ccsg.Node.prototype.onExit.call(this);
            },
            visit: function(parent) {
                this._renderCmd.clippingVisit(parent && parent._renderCmd);
            },
            _visitChildren: function() {
                this._reorderChildDirty && this.sortAllChildren();
                var children = this._children, child;
                for (var i = 0, len = children.length; i < len; i++) {
                    child = children[i];
                    child && child._visible && child.visit(this);
                }
                this._renderCmd._dirtyFlag = 0;
            },
            getAlphaThreshold: function() {
                return this._alphaThreshold;
            },
            setAlphaThreshold: function(alphaThreshold) {
                1 === alphaThreshold && alphaThreshold !== this._alphaThreshold && this._renderCmd.resetProgramByStencil();
                this._alphaThreshold = alphaThreshold;
            },
            isInverted: function() {
                return this.inverted;
            },
            setInverted: function(inverted) {
                this.inverted = inverted;
            },
            getStencil: function() {
                return this._stencil;
            },
            setStencil: function(stencil) {
                if (this._stencil === stencil) {
                    return;
                }
                stencil && (this._originStencilProgram = stencil.getShaderProgram());
                this._renderCmd.setStencil(stencil);
            },
            _createRenderCmd: function() {
                return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ClippingNode.CanvasRenderCmd(this) : new cc.ClippingNode.WebGLRenderCmd(this);
            }
        });
        cc.ClippingNode.stencilBits = -1;
        var _p = cc.ClippingNode.prototype;
        cc.defineGetterSetter(_p, "stencil", _p.getStencil, _p.setStencil);
        cc.defineGetterSetter(_p, "alphaThreshold", _p.getAlphaThreshold, _p.setAlphaThreshold);
    }), {} ],
    27: [ (function(require, module, exports) {
        cc.ClippingNode.CanvasRenderCmd = function(renderable) {
            this._rootCtor(renderable);
            this._needDraw = false;
            this._rendererClipCmd = new cc.CustomRenderCmd(this, this._drawStencilCommand);
            this._rendererRestoreCmd = new cc.CustomRenderCmd(this, this._restoreCmdCallback);
        };
        var proto = cc.ClippingNode.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
        proto.constructor = cc.ClippingNode.CanvasRenderCmd;
        proto.resetProgramByStencil = function() {};
        proto.initStencilBits = function() {};
        proto.setStencil = function(stencil) {
            if (null == stencil) {
                return;
            }
            this._node._stencil = stencil;
            stencil instanceof cc.DrawNode || cc.errorID(6300);
        };
        proto._restoreCmdCallback = function(ctx) {
            var wrapper = ctx || cc._renderContext;
            wrapper.restore();
        };
        proto._drawStencilCommand = function(ctx, scaleX, scaleY) {
            var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
            wrapper.save();
            context.beginPath();
            wrapper.setTransform(this._worldTransform, scaleX, scaleY);
            var stencilBuffer = this._node._stencil._buffer;
            for (var index = 0; index < stencilBuffer.length; ++index) {
                var vertices = stencilBuffer[index].verts;
                if (vertices.length < 3) {
                    continue;
                }
                context.moveTo(vertices[0].x, -vertices[0].y);
                for (var vIndex = 1; vIndex < vertices.length; ++vIndex) {
                    context.lineTo(vertices[vIndex].x, -vertices[vIndex].y);
                }
            }
            context.clip();
        };
        proto.clippingVisit = function(parentCmd) {
            var node = this._node;
            parentCmd = parentCmd || this.getParentRenderCmd();
            this._propagateFlagsDown(parentCmd);
            if (!node._visible) {
                return;
            }
            parentCmd && (this._curLevel = parentCmd._curLevel + 1);
            this._syncStatus(parentCmd);
            node._stencil && cc.renderer.pushRenderCommand(this._rendererClipCmd);
            var children = node._children;
            var i, len = children.length;
            if (len > 0) {
                node.sortAllChildren();
                for (i = 0; i < len; i++) {
                    children[i].visit(node);
                }
            }
            node._stencil && cc.renderer.pushRenderCommand(this._rendererRestoreCmd);
            this._dirtyFlag = 0;
        };
    }), {} ],
    28: [ (function(require, module, exports) {
        function setProgram(node, program) {
            node.shaderProgram = program;
            var children = node.children;
            if (!children) {
                return;
            }
            for (var i = 0; i < children.length; i++) {
                setProgram(children[i], program);
            }
        }
        var _currentState = {
            stencilEnabled: false,
            depthWriteMask: true
        };
        cc.ClippingNode.WebGLRenderCmd = function(renderable) {
            this._rootCtor(renderable);
            this._needDraw = false;
            this._beforeVisitCmd = new cc.CustomRenderCmd(this, this._onBeforeVisit);
            this._afterDrawStencilCmd = new cc.CustomRenderCmd(this, this._onAfterDrawStencil);
            this._afterVisitCmd = new cc.CustomRenderCmd(this, this._onAfterVisit);
            this._previousState = null;
            this._state = {
                stencilEnabled: true,
                stencilWriteMask: 0,
                depthWriteMask: false,
                stencilFunc: 0,
                stencilRef: 0,
                stencilValueMask: 0
            };
        };
        var proto = cc.ClippingNode.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
        proto.constructor = cc.ClippingNode.WebGLRenderCmd;
        cc.ClippingNode.WebGLRenderCmd._init_once = null;
        cc.ClippingNode.WebGLRenderCmd._visit_once = null;
        cc.ClippingNode.WebGLRenderCmd._layer = -1;
        proto.initStencilBits = function() {
            cc.ClippingNode.WebGLRenderCmd._init_once = true;
            if (cc.ClippingNode.WebGLRenderCmd._init_once) {
                cc.ClippingNode.stencilBits = cc._renderContext.getParameter(cc._renderContext.STENCIL_BITS);
                cc.ClippingNode.stencilBits <= 0 && cc.logID(6301);
                cc.ClippingNode.WebGLRenderCmd._init_once = false;
            }
        };
        proto.transform = function(parentCmd, recursive) {
            var node = this._node;
            this.originTransform(parentCmd, recursive);
            if (node._stencil) {
                node._stencil._renderCmd.transform(this, true);
                node._stencil._dirtyFlag &= ~_ccsg.Node._dirtyFlags.transformDirty;
            }
        };
        proto.clippingVisit = function(parentCmd) {
            var node = this._node;
            parentCmd = parentCmd || this.getParentRenderCmd();
            this.visit(parentCmd);
            if (cc.ClippingNode.stencilBits < 1) {
                node._visitChildren();
                return;
            }
            if (!node._stencil || !node._stencil.visible) {
                node.inverted && node._visitChildren();
                return;
            }
            if (cc.ClippingNode.WebGLRenderCmd._layer + 1 === cc.ClippingNode.stencilBits) {
                cc.ClippingNode.WebGLRenderCmd._visit_once = true;
                if (cc.ClippingNode.WebGLRenderCmd._visit_once) {
                    cc.logID(6302, cc.ClippingNode.stencilBits);
                    cc.ClippingNode.WebGLRenderCmd._visit_once = false;
                }
                node._visitChildren();
                return;
            }
            cc.renderer.pushRenderCommand(this._beforeVisitCmd);
            node._stencil.visit(node);
            cc.renderer.pushRenderCommand(this._afterDrawStencilCmd);
            var locChildren = node._children;
            if (locChildren && locChildren.length > 0) {
                var childLen = locChildren.length;
                node.sortAllChildren();
                for (var i = 0; i < childLen; i++) {
                    locChildren[i].visit(node);
                }
            }
            cc.renderer.pushRenderCommand(this._afterVisitCmd);
            this._dirtyFlag = 0;
        };
        proto.setStencil = function(stencil) {
            var node = this._node;
            node._stencil && (node._stencil._parent = null);
            node._stencil = stencil;
            node._stencil && (node._stencil._parent = node);
        };
        proto._drawFullScreenQuadClearStencil = function() {
            var projStack = cc.math.projection_matrix_stack;
            projStack.push();
            projStack.top.identity();
            var modelViewStack = cc.math.modelview_matrix_stack;
            modelViewStack.push();
            modelViewStack.top.identity();
            cc._drawingUtil.drawSolidRect(cc.p(-1, -1), cc.p(1, 1), cc.color(255, 255, 255, 255));
            projStack.pop();
            modelViewStack.pop();
        };
        proto.resetProgramByStencil = function() {
            var node = this._node;
            if (node._stencil) {
                var program = node._originStencilProgram;
                setProgram(node._stencil, program);
            }
        };
        proto._onBeforeVisit = function(ctx) {
            var gl = ctx || cc._renderContext, node = this._node;
            cc.ClippingNode.WebGLRenderCmd._layer++;
            var mask_layer = 1 << cc.ClippingNode.WebGLRenderCmd._layer;
            var mask_layer_l = mask_layer - 1;
            var mask_layer_le = mask_layer | mask_layer_l;
            this._previousState = _currentState;
            gl.enable(gl.STENCIL_TEST);
            gl.stencilMask(mask_layer);
            gl.depthMask(false);
            gl.stencilFunc(gl.NEVER, mask_layer, mask_layer);
            gl.stencilOp(this._node.inverted ? gl.REPLACE : gl.ZERO, gl.KEEP, gl.KEEP);
            this._drawFullScreenQuadClearStencil();
            gl.stencilFunc(gl.NEVER, mask_layer, mask_layer);
            gl.stencilOp(this._node.inverted ? gl.ZERO : gl.REPLACE, gl.KEEP, gl.KEEP);
            if (node.alphaThreshold < 1) {
                var program = cc.shaderCache.programForKey(cc.macro.SHADER_POSITION_TEXTURECOLORALPHATEST);
                cc.gl.useProgram(program.getProgram());
                program.setUniformLocationWith1f(cc.macro.UNIFORM_ALPHA_TEST_VALUE_S, node.alphaThreshold);
                program.setUniformLocationWithMatrix4fv(cc.macro.UNIFORM_MVMATRIX_S, cc.renderer.mat4Identity.mat);
                setProgram(node._stencil, program);
            }
            this._state.stencilWriteMask = mask_layer;
            this._state.stencilRef = this._state.stencilValueMask = mask_layer_le;
            this._state.stencilFunc = gl.NEVER;
            _currentState = this._state;
        };
        proto._onAfterDrawStencil = function(ctx) {
            var gl = ctx || cc._renderContext;
            gl.depthMask(this._previousState.depthWriteMask);
            gl.stencilFunc(gl.EQUAL, this._state.stencilRef, this._state.stencilValueMask);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
            this._state.stencilFunc = gl.EQUAL;
        };
        proto._onAfterVisit = function(ctx) {
            var gl = ctx || cc._renderContext;
            var state = this._previousState;
            if (state.stencilEnabled) {
                gl.stencilFunc(state.stencilFunc, state.stencilRef, state.stencilValueMask);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                gl.stencilMask(state.stencilWriteMask);
            } else {
                gl.disable(gl.STENCIL_TEST);
            }
            _currentState = this._previousState;
            this._previousState = null;
            cc.ClippingNode.WebGLRenderCmd._layer--;
        };
    }), {} ],
    29: [ (function(require, module, exports) {
        cc.Codec = {
            name: "Jacob__Codec"
        };
        cc.Codec.unzip = function() {
            return cc.Codec.GZip.gunzip.apply(cc.Codec.GZip, arguments);
        };
        cc.Codec.unzipBase64 = function() {
            var buffer = cc.Codec.Base64.decode.apply(cc.Codec.Base64, arguments);
            try {
                return cc.Codec.GZip.gunzip.call(cc.Codec.GZip, buffer);
            } catch (e) {
                return buffer.slice(7);
            }
        };
        cc.Codec.unzipBase64AsArray = function(input, bytes) {
            bytes = bytes || 1;
            var dec = this.unzipBase64(input), ar = [], i, j, len;
            for (i = 0, len = dec.length / bytes; i < len; i++) {
                ar[i] = 0;
                for (j = bytes - 1; j >= 0; --j) {
                    ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
                }
            }
            return ar;
        };
        cc.Codec.unzipAsArray = function(input, bytes) {
            bytes = bytes || 1;
            var dec = this.unzip(input), ar = [], i, j, len;
            for (i = 0, len = dec.length / bytes; i < len; i++) {
                ar[i] = 0;
                for (j = bytes - 1; j >= 0; --j) {
                    ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
                }
            }
            return ar;
        };
    }), {} ],
    30: [ (function(require, module, exports) {
        cc.Codec.Base64 = {
            name: "Jacob__Codec__Base64"
        };
        cc.Codec.Base64._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        cc.Codec.Base64.decode = function Jacob__Codec__Base64__decode(input) {
            var output = [], chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            while (i < input.length) {
                enc1 = this._keyStr.indexOf(input.charAt(i++));
                enc2 = this._keyStr.indexOf(input.charAt(i++));
                enc3 = this._keyStr.indexOf(input.charAt(i++));
                enc4 = this._keyStr.indexOf(input.charAt(i++));
                chr1 = enc1 << 2 | enc2 >> 4;
                chr2 = (15 & enc2) << 4 | enc3 >> 2;
                chr3 = (3 & enc3) << 6 | enc4;
                output.push(String.fromCharCode(chr1));
                64 !== enc3 && output.push(String.fromCharCode(chr2));
                64 !== enc4 && output.push(String.fromCharCode(chr3));
            }
            output = output.join("");
            return output;
        };
        cc.Codec.Base64.decodeAsArray = function Jacob__Codec__Base64___decodeAsArray(input, bytes) {
            var dec = this.decode(input), ar = [], i, j, len;
            for (i = 0, len = dec.length / bytes; i < len; i++) {
                ar[i] = 0;
                for (j = bytes - 1; j >= 0; --j) {
                    ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
                }
            }
            return ar;
        };
    }), {} ],
    31: [ (function(require, module, exports) {
        cc.Codec.GZip = function Jacob__GZip(data) {
            this.data = data;
            this.debug = false;
            this.gpflags = void 0;
            this.files = 0;
            this.unzipped = [];
            this.buf32k = new Array(32768);
            this.bIdx = 0;
            this.modeZIP = false;
            this.bytepos = 0;
            this.bb = 1;
            this.bits = 0;
            this.nameBuf = [];
            this.fileout = void 0;
            this.literalTree = new Array(cc.Codec.GZip.LITERALS);
            this.distanceTree = new Array(32);
            this.treepos = 0;
            this.Places = null;
            this.len = 0;
            this.fpos = new Array(17);
            this.fpos[0] = 0;
            this.flens = void 0;
            this.fmax = void 0;
        };
        cc.Codec.GZip.gunzip = function(string) {
            string.constructor === Array || string.constructor === String;
            var gzip = new cc.Codec.GZip(string);
            return gzip.gunzip()[0][0];
        };
        cc.Codec.GZip.HufNode = function() {
            this.b0 = 0;
            this.b1 = 0;
            this.jump = null;
            this.jumppos = -1;
        };
        cc.Codec.GZip.LITERALS = 288;
        cc.Codec.GZip.NAMEMAX = 256;
        cc.Codec.GZip.bitReverse = [ 0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255 ];
        cc.Codec.GZip.cplens = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];
        cc.Codec.GZip.cplext = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99 ];
        cc.Codec.GZip.cpdist = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];
        cc.Codec.GZip.cpdext = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
        cc.Codec.GZip.border = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
        cc.Codec.GZip.prototype.gunzip = function() {
            this.outputArr = [];
            this.nextFile();
            return this.unzipped;
        };
        cc.Codec.GZip.prototype.readByte = function() {
            this.bits += 8;
            return this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1;
        };
        cc.Codec.GZip.prototype.byteAlign = function() {
            this.bb = 1;
        };
        cc.Codec.GZip.prototype.readBit = function() {
            var carry;
            this.bits++;
            carry = 1 & this.bb;
            this.bb >>= 1;
            if (0 === this.bb) {
                this.bb = this.readByte();
                carry = 1 & this.bb;
                this.bb = this.bb >> 1 | 128;
            }
            return carry;
        };
        cc.Codec.GZip.prototype.readBits = function(a) {
            var res = 0, i = a;
            while (i--) {
                res = res << 1 | this.readBit();
            }
            a && (res = cc.Codec.GZip.bitReverse[res] >> 8 - a);
            return res;
        };
        cc.Codec.GZip.prototype.flushBuffer = function() {
            this.bIdx = 0;
        };
        cc.Codec.GZip.prototype.addBuffer = function(a) {
            this.buf32k[this.bIdx++] = a;
            this.outputArr.push(String.fromCharCode(a));
            32768 === this.bIdx && (this.bIdx = 0);
        };
        cc.Codec.GZip.prototype.IsPat = function() {
            while (1) {
                if (this.fpos[this.len] >= this.fmax) {
                    return -1;
                }
                if (this.flens[this.fpos[this.len]] === this.len) {
                    return this.fpos[this.len]++;
                }
                this.fpos[this.len]++;
            }
        };
        cc.Codec.GZip.prototype.Rec = function() {
            var curplace = this.Places[this.treepos];
            var tmp;
            if (17 === this.len) {
                return -1;
            }
            this.treepos++;
            this.len++;
            tmp = this.IsPat();
            if (tmp >= 0) {
                curplace.b0 = tmp;
            } else {
                curplace.b0 = 32768;
                if (this.Rec()) {
                    return -1;
                }
            }
            tmp = this.IsPat();
            if (tmp >= 0) {
                curplace.b1 = tmp;
                curplace.jump = null;
            } else {
                curplace.b1 = 32768;
                curplace.jump = this.Places[this.treepos];
                curplace.jumppos = this.treepos;
                if (this.Rec()) {
                    return -1;
                }
            }
            this.len--;
            return 0;
        };
        cc.Codec.GZip.prototype.CreateTree = function(currentTree, numval, lengths, show) {
            var i;
            this.Places = currentTree;
            this.treepos = 0;
            this.flens = lengths;
            this.fmax = numval;
            for (i = 0; i < 17; i++) {
                this.fpos[i] = 0;
            }
            this.len = 0;
            if (this.Rec()) {
                return -1;
            }
            return 0;
        };
        cc.Codec.GZip.prototype.DecodeValue = function(currentTree) {
            var len, i, xtreepos = 0, X = currentTree[xtreepos], b;
            while (1) {
                b = this.readBit();
                if (b) {
                    if (!(32768 & X.b1)) {
                        return X.b1;
                    }
                    X = X.jump;
                    len = currentTree.length;
                    for (i = 0; i < len; i++) {
                        if (currentTree[i] === X) {
                            xtreepos = i;
                            break;
                        }
                    }
                } else {
                    if (!(32768 & X.b0)) {
                        return X.b0;
                    }
                    xtreepos++;
                    X = currentTree[xtreepos];
                }
            }
            return -1;
        };
        cc.Codec.GZip.prototype.DeflateLoop = function() {
            var last, c, type, i, len;
            do {
                last = this.readBit();
                type = this.readBits(2);
                if (0 === type) {
                    var blockLen, cSum;
                    this.byteAlign();
                    blockLen = this.readByte();
                    blockLen |= this.readByte() << 8;
                    cSum = this.readByte();
                    cSum |= this.readByte() << 8;
                    65535 & (blockLen ^ ~cSum) && document.write("BlockLen checksum mismatch\n");
                    while (blockLen--) {
                        c = this.readByte();
                        this.addBuffer(c);
                    }
                } else {
                    if (1 === type) {
                        var j;
                        while (1) {
                            j = cc.Codec.GZip.bitReverse[this.readBits(7)] >> 1;
                            if (j > 23) {
                                j = j << 1 | this.readBit();
                                if (j > 199) {
                                    j -= 128;
                                    j = j << 1 | this.readBit();
                                } else {
                                    j -= 48;
                                    j > 143 && (j += 136);
                                }
                            } else {
                                j += 256;
                            }
                            if (j < 256) {
                                this.addBuffer(j);
                            } else {
                                if (256 === j) {
                                    break;
                                }
                                var len, dist;
                                j -= 257;
                                len = this.readBits(cc.Codec.GZip.cplext[j]) + cc.Codec.GZip.cplens[j];
                                j = cc.Codec.GZip.bitReverse[this.readBits(5)] >> 3;
                                if (cc.Codec.GZip.cpdext[j] > 8) {
                                    dist = this.readBits(8);
                                    dist |= this.readBits(cc.Codec.GZip.cpdext[j] - 8) << 8;
                                } else {
                                    dist = this.readBits(cc.Codec.GZip.cpdext[j]);
                                }
                                dist += cc.Codec.GZip.cpdist[j];
                                for (j = 0; j < len; j++) {
                                    var c = this.buf32k[this.bIdx - dist & 32767];
                                    this.addBuffer(c);
                                }
                            }
                        }
                    } else {
                        if (2 === type) {
                            var j, n, literalCodes, distCodes, lenCodes;
                            var ll = new Array(320);
                            literalCodes = 257 + this.readBits(5);
                            distCodes = 1 + this.readBits(5);
                            lenCodes = 4 + this.readBits(4);
                            for (j = 0; j < 19; j++) {
                                ll[j] = 0;
                            }
                            for (j = 0; j < lenCodes; j++) {
                                ll[cc.Codec.GZip.border[j]] = this.readBits(3);
                            }
                            len = this.distanceTree.length;
                            for (i = 0; i < len; i++) {
                                this.distanceTree[i] = new cc.Codec.GZip.HufNode();
                            }
                            if (this.CreateTree(this.distanceTree, 19, ll, 0)) {
                                this.flushBuffer();
                                return 1;
                            }
                            n = literalCodes + distCodes;
                            i = 0;
                            var z = -1;
                            while (i < n) {
                                z++;
                                j = this.DecodeValue(this.distanceTree);
                                if (j < 16) {
                                    ll[i++] = j;
                                } else {
                                    if (16 === j) {
                                        var l;
                                        j = 3 + this.readBits(2);
                                        if (i + j > n) {
                                            this.flushBuffer();
                                            return 1;
                                        }
                                        l = i ? ll[i - 1] : 0;
                                        while (j--) {
                                            ll[i++] = l;
                                        }
                                    } else {
                                        j = 17 === j ? 3 + this.readBits(3) : 11 + this.readBits(7);
                                        if (i + j > n) {
                                            this.flushBuffer();
                                            return 1;
                                        }
                                        while (j--) {
                                            ll[i++] = 0;
                                        }
                                    }
                                }
                            }
                            len = this.literalTree.length;
                            for (i = 0; i < len; i++) {
                                this.literalTree[i] = new cc.Codec.GZip.HufNode();
                            }
                            if (this.CreateTree(this.literalTree, literalCodes, ll, 0)) {
                                this.flushBuffer();
                                return 1;
                            }
                            len = this.literalTree.length;
                            for (i = 0; i < len; i++) {
                                this.distanceTree[i] = new cc.Codec.GZip.HufNode();
                            }
                            var ll2 = new Array();
                            for (i = literalCodes; i < ll.length; i++) {
                                ll2[i - literalCodes] = ll[i];
                            }
                            if (this.CreateTree(this.distanceTree, distCodes, ll2, 0)) {
                                this.flushBuffer();
                                return 1;
                            }
                            while (1) {
                                j = this.DecodeValue(this.literalTree);
                                if (j >= 256) {
                                    var len, dist;
                                    j -= 256;
                                    if (0 === j) {
                                        break;
                                    }
                                    j--;
                                    len = this.readBits(cc.Codec.GZip.cplext[j]) + cc.Codec.GZip.cplens[j];
                                    j = this.DecodeValue(this.distanceTree);
                                    if (cc.Codec.GZip.cpdext[j] > 8) {
                                        dist = this.readBits(8);
                                        dist |= this.readBits(cc.Codec.GZip.cpdext[j] - 8) << 8;
                                    } else {
                                        dist = this.readBits(cc.Codec.GZip.cpdext[j]);
                                    }
                                    dist += cc.Codec.GZip.cpdist[j];
                                    while (len--) {
                                        var c = this.buf32k[this.bIdx - dist & 32767];
                                        this.addBuffer(c);
                                    }
                                } else {
                                    this.addBuffer(j);
                                }
                            }
                        }
                    }
                }
            } while (!last);
            this.flushBuffer();
            this.byteAlign();
            return 0;
        };
        cc.Codec.GZip.prototype.unzipFile = function(name) {
            var i;
            this.gunzip();
            for (i = 0; i < this.unzipped.length; i++) {
                if (this.unzipped[i][1] === name) {
                    return this.unzipped[i][0];
                }
            }
        };
        cc.Codec.GZip.prototype.nextFile = function() {
            this.outputArr = [];
            this.modeZIP = false;
            var tmp = [];
            tmp[0] = this.readByte();
            tmp[1] = this.readByte();
            if (120 === tmp[0] && 218 === tmp[1]) {
                this.DeflateLoop();
                this.unzipped[this.files] = [ this.outputArr.join(""), "geonext.gxt" ];
                this.files++;
            }
            if (31 === tmp[0] && 139 === tmp[1]) {
                this.skipdir();
                this.unzipped[this.files] = [ this.outputArr.join(""), "file" ];
                this.files++;
            }
            if (80 === tmp[0] && 75 === tmp[1]) {
                this.modeZIP = true;
                tmp[2] = this.readByte();
                tmp[3] = this.readByte();
                if (3 === tmp[2] && 4 === tmp[3]) {
                    tmp[0] = this.readByte();
                    tmp[1] = this.readByte();
                    this.gpflags = this.readByte();
                    this.gpflags |= this.readByte() << 8;
                    var method = this.readByte();
                    method |= this.readByte() << 8;
                    this.readByte();
                    this.readByte();
                    this.readByte();
                    this.readByte();
                    var compSize = this.readByte();
                    compSize |= this.readByte() << 8;
                    compSize |= this.readByte() << 16;
                    compSize |= this.readByte() << 24;
                    var size = this.readByte();
                    size |= this.readByte() << 8;
                    size |= this.readByte() << 16;
                    size |= this.readByte() << 24;
                    var filelen = this.readByte();
                    filelen |= this.readByte() << 8;
                    var extralen = this.readByte();
                    extralen |= this.readByte() << 8;
                    i = 0;
                    this.nameBuf = [];
                    while (filelen--) {
                        var c = this.readByte();
                        "/" === c | ":" === c ? i = 0 : i < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[i++] = String.fromCharCode(c));
                    }
                    this.fileout || (this.fileout = this.nameBuf);
                    var i = 0;
                    while (i < extralen) {
                        c = this.readByte();
                        i++;
                    }
                    if (8 === method) {
                        this.DeflateLoop();
                        this.unzipped[this.files] = [ this.outputArr.join(""), this.nameBuf.join("") ];
                        this.files++;
                    }
                    this.skipdir();
                }
            }
        };
        cc.Codec.GZip.prototype.skipdir = function() {
            var tmp = [];
            var compSize, size, os, i, c;
            if (8 & this.gpflags) {
                tmp[0] = this.readByte();
                tmp[1] = this.readByte();
                tmp[2] = this.readByte();
                tmp[3] = this.readByte();
                compSize = this.readByte();
                compSize |= this.readByte() << 8;
                compSize |= this.readByte() << 16;
                compSize |= this.readByte() << 24;
                size = this.readByte();
                size |= this.readByte() << 8;
                size |= this.readByte() << 16;
                size |= this.readByte() << 24;
            }
            this.modeZIP && this.nextFile();
            tmp[0] = this.readByte();
            if (8 !== tmp[0]) {
                return 0;
            }
            this.gpflags = this.readByte();
            this.readByte();
            this.readByte();
            this.readByte();
            this.readByte();
            this.readByte();
            os = this.readByte();
            if (4 & this.gpflags) {
                tmp[0] = this.readByte();
                tmp[2] = this.readByte();
                this.len = tmp[0] + 256 * tmp[1];
                for (i = 0; i < this.len; i++) {
                    this.readByte();
                }
            }
            if (8 & this.gpflags) {
                i = 0;
                this.nameBuf = [];
                while (c = this.readByte()) {
                    "7" !== c && ":" !== c || (i = 0);
                    i < cc.Codec.GZip.NAMEMAX - 1 && (this.nameBuf[i++] = c);
                }
            }
            if (16 & this.gpflags) {
                while (c = this.readByte()) {}
            }
            if (2 & this.gpflags) {
                this.readByte();
                this.readByte();
            }
            this.DeflateLoop();
            size = this.readByte();
            size |= this.readByte() << 8;
            size |= this.readByte() << 16;
            size |= this.readByte() << 24;
            this.modeZIP && this.nextFile();
        };
    }), {} ],
    32: [ (function(require, module, exports) {
        require("./ZipUtils");
        require("./base64");
        require("./gzip");
        require("./zlib.min");
    }), {
        "./ZipUtils": 29,
        "./base64": 30,
        "./gzip": 31,
        "./zlib.min": 33
    } ],
    33: [ (function(require, module, exports) {
        (function() {
            "use strict";
            function i(a) {
                throw a;
            }
            var r = void 0, v = !0, aa = this;
            function y(a, c) {
                var b = a.split("."), e = aa;
                !(b[0] in e) && e.execScript && e.execScript("var " + b[0]);
                for (var f; b.length && (f = b.shift()); ) {
                    b.length || c === r ? e = e[f] ? e[f] : e[f] = {} : e[f] = c;
                }
            }
            var H = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
            function ba(a) {
                if ("string" === typeof a) {
                    var c = a.split(""), b, e;
                    b = 0;
                    for (e = c.length; b < e; b++) {
                        c[b] = (255 & c[b].charCodeAt(0)) >>> 0;
                    }
                    a = c;
                }
                for (var f = 1, d = 0, g = a.length, h, m = 0; 0 < g; ) {
                    h = 1024 < g ? 1024 : g;
                    g -= h;
                    do {
                        f += a[m++], d += f;
                    } while (--h);
                    f %= 65521;
                    d %= 65521;
                }
                return (d << 16 | f) >>> 0;
            }
            function J(a, c) {
                this.index = "number" === typeof c ? c : 0;
                this.i = 0;
                this.buffer = a instanceof (H ? Uint8Array : Array) ? a : new (H ? Uint8Array : Array)(32768);
                2 * this.buffer.length <= this.index && i(Error("invalid index"));
                this.buffer.length <= this.index && this.f();
            }
            J.prototype.f = function() {
                var a = this.buffer, c, b = a.length, e = new (H ? Uint8Array : Array)(b << 1);
                if (H) {
                    e.set(a);
                } else {
                    for (c = 0; c < b; ++c) {
                        e[c] = a[c];
                    }
                }
                return this.buffer = e;
            };
            J.prototype.d = function(a, c, b) {
                var e = this.buffer, f = this.index, d = this.i, g = e[f], h;
                b && 1 < c && (a = 8 < c ? (N[255 & a] << 24 | N[a >>> 8 & 255] << 16 | N[a >>> 16 & 255] << 8 | N[a >>> 24 & 255]) >> 32 - c : N[a] >> 8 - c);
                if (8 > c + d) {
                    g = g << c | a, d += c;
                } else {
                    for (h = 0; h < c; ++h) {
                        g = g << 1 | a >> c - h - 1 & 1, 8 === ++d && (d = 0, e[f++] = N[g], g = 0, f === e.length && (e = this.f()));
                    }
                }
                e[f] = g;
                this.buffer = e;
                this.i = d;
                this.index = f;
            };
            J.prototype.finish = function() {
                var a = this.buffer, c = this.index, b;
                0 < this.i && (a[c] <<= 8 - this.i, a[c] = N[a[c]], c++);
                H ? b = a.subarray(0, c) : (a.length = c, b = a);
                return b;
            };
            var ca = new (H ? Uint8Array : Array)(256), ha;
            for (ha = 0; 256 > ha; ++ha) {
                for (var R = ha, ia = R, ja = 7, R = R >>> 1; R; R >>>= 1) {
                    ia <<= 1, ia |= 1 & R, --ja;
                }
                ca[ha] = (ia << ja & 255) >>> 0;
            }
            var N = ca;
            var ka = [ 0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117 ];
            H && new Uint32Array(ka);
            function la(a) {
                this.buffer = new (H ? Uint16Array : Array)(2 * a);
                this.length = 0;
            }
            la.prototype.getParent = function(a) {
                return 2 * ((a - 2) / 4 | 0);
            };
            la.prototype.push = function(a, c) {
                var b, e, f = this.buffer, d;
                b = this.length;
                f[this.length++] = c;
                for (f[this.length++] = a; 0 < b; ) {
                    if (e = this.getParent(b), !(f[b] > f[e])) {
                        break;
                    }
                    d = f[b], f[b] = f[e], f[e] = d, d = f[b + 1], f[b + 1] = f[e + 1], f[e + 1] = d, 
                    b = e;
                }
                return this.length;
            };
            la.prototype.pop = function() {
                var a, c, b = this.buffer, e, f, d;
                c = b[0];
                a = b[1];
                this.length -= 2;
                b[0] = b[this.length];
                b[1] = b[this.length + 1];
                for (d = 0; ;) {
                    f = 2 * d + 2;
                    if (f >= this.length) {
                        break;
                    }
                    f + 2 < this.length && b[f + 2] > b[f] && (f += 2);
                    if (!(b[f] > b[d])) {
                        break;
                    }
                    e = b[d], b[d] = b[f], b[f] = e, e = b[d + 1], b[d + 1] = b[f + 1], b[f + 1] = e;
                    d = f;
                }
                return {
                    index: a,
                    value: c,
                    length: this.length
                };
            };
            function S(a) {
                var c = a.length, b = 0, e = Number.POSITIVE_INFINITY, f, d, g, h, m, j, s, n, l;
                for (n = 0; n < c; ++n) {
                    a[n] > b && (b = a[n]), a[n] < e && (e = a[n]);
                }
                f = 1 << b;
                d = new (H ? Uint32Array : Array)(f);
                g = 1;
                h = 0;
                for (m = 2; g <= b; ) {
                    for (n = 0; n < c; ++n) {
                        if (a[n] === g) {
                            j = 0;
                            s = h;
                            for (l = 0; l < g; ++l) {
                                j = j << 1 | 1 & s, s >>= 1;
                            }
                            for (l = j; l < f; l += m) {
                                d[l] = g << 16 | n;
                            }
                            ++h;
                        }
                    }
                    ++g;
                    h <<= 1;
                    m <<= 1;
                }
                return [ d, b, e ];
            }
            function ma(a, c) {
                this.h = pa;
                this.w = 0;
                this.input = a;
                this.b = 0;
                c && (c.lazy && (this.w = c.lazy), "number" === typeof c.compressionType && (this.h = c.compressionType), 
                c.outputBuffer && (this.a = H && c.outputBuffer instanceof Array ? new Uint8Array(c.outputBuffer) : c.outputBuffer), 
                "number" === typeof c.outputIndex && (this.b = c.outputIndex));
                this.a || (this.a = new (H ? Uint8Array : Array)(32768));
            }
            var pa = 2, qa = {
                NONE: 0,
                r: 1,
                j: pa,
                N: 3
            }, ra = [], T;
            for (T = 0; 288 > T; T++) {
                switch (v) {
                  case 143 >= T:
                    ra.push([ T + 48, 8 ]);
                    break;

                  case 255 >= T:
                    ra.push([ T - 144 + 400, 9 ]);
                    break;

                  case 279 >= T:
                    ra.push([ T - 256 + 0, 7 ]);
                    break;

                  case 287 >= T:
                    ra.push([ T - 280 + 192, 8 ]);
                    break;

                  default:
                    i("invalid literal: " + T);
                }
            }
            ma.prototype.n = function() {
                var a, c, b, e, f = this.input;
                switch (this.h) {
                  case 0:
                    b = 0;
                    for (e = f.length; b < e; ) {
                        c = H ? f.subarray(b, b + 65535) : f.slice(b, b + 65535);
                        b += c.length;
                        var d = c, g = b === e, h = r, m = r, j = r, s = r, n = r, l = this.a, q = this.b;
                        if (H) {
                            for (l = new Uint8Array(this.a.buffer); l.length <= q + d.length + 5; ) {
                                l = new Uint8Array(l.length << 1);
                            }
                            l.set(this.a);
                        }
                        h = g ? 1 : 0;
                        l[q++] = 0 | h;
                        m = d.length;
                        j = ~m + 65536 & 65535;
                        l[q++] = 255 & m;
                        l[q++] = m >>> 8 & 255;
                        l[q++] = 255 & j;
                        l[q++] = j >>> 8 & 255;
                        if (H) {
                            l.set(d, q), q += d.length, l = l.subarray(0, q);
                        } else {
                            s = 0;
                            for (n = d.length; s < n; ++s) {
                                l[q++] = d[s];
                            }
                            l.length = q;
                        }
                        this.b = q;
                        this.a = l;
                    }
                    break;

                  case 1:
                    var E = new J(new Uint8Array(this.a.buffer), this.b);
                    E.d(1, 1, v);
                    E.d(1, 2, v);
                    var t = sa(this, f), z, K, A;
                    z = 0;
                    for (K = t.length; z < K; z++) {
                        if (A = t[z], J.prototype.d.apply(E, ra[A]), 256 < A) {
                            E.d(t[++z], t[++z], v), E.d(t[++z], 5), E.d(t[++z], t[++z], v);
                        } else {
                            if (256 === A) {
                                break;
                            }
                        }
                    }
                    this.a = E.finish();
                    this.b = this.a.length;
                    break;

                  case pa:
                    var x = new J(new Uint8Array(this.a), this.b), B, k, p, D, C, da = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], W, Ma, ea, Na, na, va = Array(19), Oa, $, oa, F, Pa;
                    B = pa;
                    x.d(1, 1, v);
                    x.d(B, 2, v);
                    k = sa(this, f);
                    W = ta(this.L, 15);
                    Ma = ua(W);
                    ea = ta(this.K, 7);
                    Na = ua(ea);
                    for (p = 286; 257 < p && 0 === W[p - 1]; p--) {}
                    for (D = 30; 1 < D && 0 === ea[D - 1]; D--) {}
                    var Qa = p, Ra = D, M = new (H ? Uint32Array : Array)(Qa + Ra), u, O, w, fa, L = new (H ? Uint32Array : Array)(316), I, G, P = new (H ? Uint8Array : Array)(19);
                    for (u = O = 0; u < Qa; u++) {
                        M[O++] = W[u];
                    }
                    for (u = 0; u < Ra; u++) {
                        M[O++] = ea[u];
                    }
                    if (!H) {
                        u = 0;
                        for (fa = P.length; u < fa; ++u) {
                            P[u] = 0;
                        }
                    }
                    u = I = 0;
                    for (fa = M.length; u < fa; u += O) {
                        for (O = 1; u + O < fa && M[u + O] === M[u]; ++O) {}
                        w = O;
                        if (0 === M[u]) {
                            if (3 > w) {
                                for (;0 < w--; ) {
                                    L[I++] = 0, P[0]++;
                                }
                            } else {
                                for (;0 < w; ) {
                                    G = 138 > w ? w : 138, G > w - 3 && G < w && (G = w - 3), 10 >= G ? (L[I++] = 17, 
                                    L[I++] = G - 3, P[17]++) : (L[I++] = 18, L[I++] = G - 11, P[18]++), w -= G;
                                }
                            }
                        } else {
                            if (L[I++] = M[u], P[M[u]]++, w--, 3 > w) {
                                for (;0 < w--; ) {
                                    L[I++] = M[u], P[M[u]]++;
                                }
                            } else {
                                for (;0 < w; ) {
                                    G = 6 > w ? w : 6, G > w - 3 && G < w && (G = w - 3), L[I++] = 16, L[I++] = G - 3, 
                                    P[16]++, w -= G;
                                }
                            }
                        }
                    }
                    a = H ? L.subarray(0, I) : L.slice(0, I);
                    na = ta(P, 7);
                    for (F = 0; 19 > F; F++) {
                        va[F] = na[da[F]];
                    }
                    for (C = 19; 4 < C && 0 === va[C - 1]; C--) {}
                    Oa = ua(na);
                    x.d(p - 257, 5, v);
                    x.d(D - 1, 5, v);
                    x.d(C - 4, 4, v);
                    for (F = 0; F < C; F++) {
                        x.d(va[F], 3, v);
                    }
                    F = 0;
                    for (Pa = a.length; F < Pa; F++) {
                        if ($ = a[F], x.d(Oa[$], na[$], v), 16 <= $) {
                            F++;
                            switch ($) {
                              case 16:
                                oa = 2;
                                break;

                              case 17:
                                oa = 3;
                                break;

                              case 18:
                                oa = 7;
                                break;

                              default:
                                i("invalid code: " + $);
                            }
                            x.d(a[F], oa, v);
                        }
                    }
                    var Sa = [ Ma, W ], Ta = [ Na, ea ], Q, Ua, ga, ya, Va, Wa, Xa, Ya;
                    Va = Sa[0];
                    Wa = Sa[1];
                    Xa = Ta[0];
                    Ya = Ta[1];
                    Q = 0;
                    for (Ua = k.length; Q < Ua; ++Q) {
                        if (ga = k[Q], x.d(Va[ga], Wa[ga], v), 256 < ga) {
                            x.d(k[++Q], k[++Q], v), ya = k[++Q], x.d(Xa[ya], Ya[ya], v), x.d(k[++Q], k[++Q], v);
                        } else {
                            if (256 === ga) {
                                break;
                            }
                        }
                    }
                    this.a = x.finish();
                    this.b = this.a.length;
                    break;

                  default:
                    i("invalid compression type");
                }
                return this.a;
            };
            function wa(a, c) {
                this.length = a;
                this.G = c;
            }
            function xa() {
                var a = za;
                switch (v) {
                  case 3 === a:
                    return [ 257, a - 3, 0 ];

                  case 4 === a:
                    return [ 258, a - 4, 0 ];

                  case 5 === a:
                    return [ 259, a - 5, 0 ];

                  case 6 === a:
                    return [ 260, a - 6, 0 ];

                  case 7 === a:
                    return [ 261, a - 7, 0 ];

                  case 8 === a:
                    return [ 262, a - 8, 0 ];

                  case 9 === a:
                    return [ 263, a - 9, 0 ];

                  case 10 === a:
                    return [ 264, a - 10, 0 ];

                  case 12 >= a:
                    return [ 265, a - 11, 1 ];

                  case 14 >= a:
                    return [ 266, a - 13, 1 ];

                  case 16 >= a:
                    return [ 267, a - 15, 1 ];

                  case 18 >= a:
                    return [ 268, a - 17, 1 ];

                  case 22 >= a:
                    return [ 269, a - 19, 2 ];

                  case 26 >= a:
                    return [ 270, a - 23, 2 ];

                  case 30 >= a:
                    return [ 271, a - 27, 2 ];

                  case 34 >= a:
                    return [ 272, a - 31, 2 ];

                  case 42 >= a:
                    return [ 273, a - 35, 3 ];

                  case 50 >= a:
                    return [ 274, a - 43, 3 ];

                  case 58 >= a:
                    return [ 275, a - 51, 3 ];

                  case 66 >= a:
                    return [ 276, a - 59, 3 ];

                  case 82 >= a:
                    return [ 277, a - 67, 4 ];

                  case 98 >= a:
                    return [ 278, a - 83, 4 ];

                  case 114 >= a:
                    return [ 279, a - 99, 4 ];

                  case 130 >= a:
                    return [ 280, a - 115, 4 ];

                  case 162 >= a:
                    return [ 281, a - 131, 5 ];

                  case 194 >= a:
                    return [ 282, a - 163, 5 ];

                  case 226 >= a:
                    return [ 283, a - 195, 5 ];

                  case 257 >= a:
                    return [ 284, a - 227, 5 ];

                  case 258 === a:
                    return [ 285, a - 258, 0 ];

                  default:
                    i("invalid length: " + a);
                }
            }
            var Aa = [], za, Ba;
            for (za = 3; 258 >= za; za++) {
                Ba = xa(), Aa[za] = Ba[2] << 24 | Ba[1] << 16 | Ba[0];
            }
            var Ca = H ? new Uint32Array(Aa) : Aa;
            function sa(a, c) {
                function b(a, c) {
                    var b = a.G, d = [], e = 0, f;
                    f = Ca[a.length];
                    d[e++] = 65535 & f;
                    d[e++] = f >> 16 & 255;
                    d[e++] = f >> 24;
                    var g;
                    switch (v) {
                      case 1 === b:
                        g = [ 0, b - 1, 0 ];
                        break;

                      case 2 === b:
                        g = [ 1, b - 2, 0 ];
                        break;

                      case 3 === b:
                        g = [ 2, b - 3, 0 ];
                        break;

                      case 4 === b:
                        g = [ 3, b - 4, 0 ];
                        break;

                      case 6 >= b:
                        g = [ 4, b - 5, 1 ];
                        break;

                      case 8 >= b:
                        g = [ 5, b - 7, 1 ];
                        break;

                      case 12 >= b:
                        g = [ 6, b - 9, 2 ];
                        break;

                      case 16 >= b:
                        g = [ 7, b - 13, 2 ];
                        break;

                      case 24 >= b:
                        g = [ 8, b - 17, 3 ];
                        break;

                      case 32 >= b:
                        g = [ 9, b - 25, 3 ];
                        break;

                      case 48 >= b:
                        g = [ 10, b - 33, 4 ];
                        break;

                      case 64 >= b:
                        g = [ 11, b - 49, 4 ];
                        break;

                      case 96 >= b:
                        g = [ 12, b - 65, 5 ];
                        break;

                      case 128 >= b:
                        g = [ 13, b - 97, 5 ];
                        break;

                      case 192 >= b:
                        g = [ 14, b - 129, 6 ];
                        break;

                      case 256 >= b:
                        g = [ 15, b - 193, 6 ];
                        break;

                      case 384 >= b:
                        g = [ 16, b - 257, 7 ];
                        break;

                      case 512 >= b:
                        g = [ 17, b - 385, 7 ];
                        break;

                      case 768 >= b:
                        g = [ 18, b - 513, 8 ];
                        break;

                      case 1024 >= b:
                        g = [ 19, b - 769, 8 ];
                        break;

                      case 1536 >= b:
                        g = [ 20, b - 1025, 9 ];
                        break;

                      case 2048 >= b:
                        g = [ 21, b - 1537, 9 ];
                        break;

                      case 3072 >= b:
                        g = [ 22, b - 2049, 10 ];
                        break;

                      case 4096 >= b:
                        g = [ 23, b - 3073, 10 ];
                        break;

                      case 6144 >= b:
                        g = [ 24, b - 4097, 11 ];
                        break;

                      case 8192 >= b:
                        g = [ 25, b - 6145, 11 ];
                        break;

                      case 12288 >= b:
                        g = [ 26, b - 8193, 12 ];
                        break;

                      case 16384 >= b:
                        g = [ 27, b - 12289, 12 ];
                        break;

                      case 24576 >= b:
                        g = [ 28, b - 16385, 13 ];
                        break;

                      case 32768 >= b:
                        g = [ 29, b - 24577, 13 ];
                        break;

                      default:
                        i("invalid distance");
                    }
                    f = g;
                    d[e++] = f[0];
                    d[e++] = f[1];
                    d[e++] = f[2];
                    var h, j;
                    h = 0;
                    for (j = d.length; h < j; ++h) {
                        l[q++] = d[h];
                    }
                    t[d[0]]++;
                    z[d[3]]++;
                    E = a.length + c - 1;
                    n = null;
                }
                var e, f, d, g, h, m = {}, j, s, n, l = H ? new Uint16Array(2 * c.length) : [], q = 0, E = 0, t = new (H ? Uint32Array : Array)(286), z = new (H ? Uint32Array : Array)(30), K = a.w, A;
                if (!H) {
                    for (d = 0; 285 >= d; ) {
                        t[d++] = 0;
                    }
                    for (d = 0; 29 >= d; ) {
                        z[d++] = 0;
                    }
                }
                t[256] = 1;
                e = 0;
                for (f = c.length; e < f; ++e) {
                    d = h = 0;
                    for (g = 3; d < g && e + d !== f; ++d) {
                        h = h << 8 | c[e + d];
                    }
                    m[h] === r && (m[h] = []);
                    j = m[h];
                    if (!(0 < E--)) {
                        for (;0 < j.length && 32768 < e - j[0]; ) {
                            j.shift();
                        }
                        if (e + 3 >= f) {
                            n && b(n, -1);
                            d = 0;
                            for (g = f - e; d < g; ++d) {
                                A = c[e + d], l[q++] = A, ++t[A];
                            }
                            break;
                        }
                        if (0 < j.length) {
                            var x = r, B = r, k = 0, p = r, D = r, C = r, da = r, W = c.length, D = 0, da = j.length;
                            a: for (;D < da; D++) {
                                x = j[da - D - 1];
                                p = 3;
                                if (3 < k) {
                                    for (C = k; 3 < C; C--) {
                                        if (c[x + C - 1] !== c[e + C - 1]) {
                                            continue a;
                                        }
                                    }
                                    p = k;
                                }
                                for (;258 > p && e + p < W && c[x + p] === c[e + p]; ) {
                                    ++p;
                                }
                                p > k && (B = x, k = p);
                                if (258 === p) {
                                    break;
                                }
                            }
                            s = new wa(k, e - B);
                            n ? n.length < s.length ? (A = c[e - 1], l[q++] = A, ++t[A], b(s, 0)) : b(n, -1) : s.length < K ? n = s : b(s, 0);
                        } else {
                            n ? b(n, -1) : (A = c[e], l[q++] = A, ++t[A]);
                        }
                    }
                    j.push(e);
                }
                l[q++] = 256;
                t[256]++;
                a.L = t;
                a.K = z;
                return H ? l.subarray(0, q) : l;
            }
            function ta(a, c) {
                function b(a) {
                    var c = z[a][K[a]];
                    c === n ? (b(a + 1), b(a + 1)) : --E[c];
                    ++K[a];
                }
                var e = a.length, f = new la(572), d = new (H ? Uint8Array : Array)(e), g, h, m, j, s;
                if (!H) {
                    for (j = 0; j < e; j++) {
                        d[j] = 0;
                    }
                }
                for (j = 0; j < e; ++j) {
                    0 < a[j] && f.push(j, a[j]);
                }
                g = Array(f.length / 2);
                h = new (H ? Uint32Array : Array)(f.length / 2);
                if (1 === g.length) {
                    return d[f.pop().index] = 1, d;
                }
                j = 0;
                for (s = f.length / 2; j < s; ++j) {
                    g[j] = f.pop(), h[j] = g[j].value;
                }
                var n = h.length, l = new (H ? Uint16Array : Array)(c), q = new (H ? Uint8Array : Array)(c), E = new (H ? Uint8Array : Array)(n), t = Array(c), z = Array(c), K = Array(c), A = (1 << c) - n, x = 1 << c - 1, B, k, p, D, C;
                l[c - 1] = n;
                for (k = 0; k < c; ++k) {
                    A < x ? q[k] = 0 : (q[k] = 1, A -= x), A <<= 1, l[c - 2 - k] = (l[c - 1 - k] / 2 | 0) + n;
                }
                l[0] = q[0];
                t[0] = Array(l[0]);
                z[0] = Array(l[0]);
                for (k = 1; k < c; ++k) {
                    l[k] > 2 * l[k - 1] + q[k] && (l[k] = 2 * l[k - 1] + q[k]), t[k] = Array(l[k]), 
                    z[k] = Array(l[k]);
                }
                for (B = 0; B < n; ++B) {
                    E[B] = c;
                }
                for (p = 0; p < l[c - 1]; ++p) {
                    t[c - 1][p] = h[p], z[c - 1][p] = p;
                }
                for (B = 0; B < c; ++B) {
                    K[B] = 0;
                }
                1 === q[c - 1] && (--E[0], ++K[c - 1]);
                for (k = c - 2; 0 <= k; --k) {
                    D = B = 0;
                    C = K[k + 1];
                    for (p = 0; p < l[k]; p++) {
                        D = t[k + 1][C] + t[k + 1][C + 1], D > h[B] ? (t[k][p] = D, z[k][p] = n, C += 2) : (t[k][p] = h[B], 
                        z[k][p] = B, ++B);
                    }
                    K[k] = 0;
                    1 === q[k] && b(k);
                }
                m = E;
                j = 0;
                for (s = g.length; j < s; ++j) {
                    d[g[j].index] = m[j];
                }
                return d;
            }
            function ua(a) {
                var c = new (H ? Uint16Array : Array)(a.length), b = [], e = [], f = 0, d, g, h, m;
                d = 0;
                for (g = a.length; d < g; d++) {
                    b[a[d]] = (0 | b[a[d]]) + 1;
                }
                d = 1;
                for (g = 16; d <= g; d++) {
                    e[d] = f, f += 0 | b[d], f > 1 << d && i("overcommitted"), f <<= 1;
                }
                65536 > f && i("undercommitted");
                d = 0;
                for (g = a.length; d < g; d++) {
                    f = e[a[d]];
                    e[a[d]] += 1;
                    h = c[d] = 0;
                    for (m = a[d]; h < m; h++) {
                        c[d] = c[d] << 1 | 1 & f, f >>>= 1;
                    }
                }
                return c;
            }
            function Da(a, c) {
                this.input = a;
                this.a = new (H ? Uint8Array : Array)(32768);
                this.h = U.j;
                var b = {}, e;
                !c && (c = {}) || "number" !== typeof c.compressionType || (this.h = c.compressionType);
                for (e in c) {
                    b[e] = c[e];
                }
                b.outputBuffer = this.a;
                this.z = new ma(this.input, b);
            }
            var U = qa;
            Da.prototype.n = function() {
                var a, c, b, e, f, d, g, h = 0;
                g = this.a;
                a = Ea;
                switch (a) {
                  case Ea:
                    c = Math.LOG2E * Math.log(32768) - 8;
                    break;

                  default:
                    i(Error("invalid compression method"));
                }
                b = c << 4 | a;
                g[h++] = b;
                switch (a) {
                  case Ea:
                    switch (this.h) {
                      case U.NONE:
                        f = 0;
                        break;

                      case U.r:
                        f = 1;
                        break;

                      case U.j:
                        f = 2;
                        break;

                      default:
                        i(Error("unsupported compression type"));
                    }
                    break;

                  default:
                    i(Error("invalid compression method"));
                }
                e = f << 6 | 0;
                g[h++] = e | 31 - (256 * b + e) % 31;
                d = ba(this.input);
                this.z.b = h;
                g = this.z.n();
                h = g.length;
                H && (g = new Uint8Array(g.buffer), g.length <= h + 4 && (this.a = new Uint8Array(g.length + 4), 
                this.a.set(g), g = this.a), g = g.subarray(0, h + 4));
                g[h++] = d >> 24 & 255;
                g[h++] = d >> 16 & 255;
                g[h++] = d >> 8 & 255;
                g[h++] = 255 & d;
                return g;
            };
            y("Zlib.Deflate", Da);
            y("Zlib.Deflate.compress", (function(a, c) {
                return new Da(a, c).n();
            }));
            y("Zlib.Deflate.CompressionType", U);
            y("Zlib.Deflate.CompressionType.NONE", U.NONE);
            y("Zlib.Deflate.CompressionType.FIXED", U.r);
            y("Zlib.Deflate.CompressionType.DYNAMIC", U.j);
            function V(a, c) {
                this.k = [];
                this.l = 32768;
                this.e = this.g = this.c = this.q = 0;
                this.input = H ? new Uint8Array(a) : a;
                this.s = !1;
                this.m = Fa;
                this.B = !1;
                !c && (c = {}) || (c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), 
                c.bufferType && (this.m = c.bufferType), c.resize && (this.B = c.resize));
                switch (this.m) {
                  case Ga:
                    this.b = 32768;
                    this.a = new (H ? Uint8Array : Array)(32768 + this.l + 258);
                    break;

                  case Fa:
                    this.b = 0;
                    this.a = new (H ? Uint8Array : Array)(this.l);
                    this.f = this.J;
                    this.t = this.H;
                    this.o = this.I;
                    break;

                  default:
                    i(Error("invalid inflate mode"));
                }
            }
            var Ga = 0, Fa = 1, Ha = {
                D: Ga,
                C: Fa
            };
            V.prototype.p = function() {
                for (;!this.s; ) {
                    var a = X(this, 3);
                    1 & a && (this.s = v);
                    a >>>= 1;
                    switch (a) {
                      case 0:
                        var c = this.input, b = this.c, e = this.a, f = this.b, d = r, g = r, h = r, m = e.length, j = r;
                        this.e = this.g = 0;
                        d = c[b++];
                        d === r && i(Error("invalid uncompressed block header: LEN (first byte)"));
                        g = d;
                        d = c[b++];
                        d === r && i(Error("invalid uncompressed block header: LEN (second byte)"));
                        g |= d << 8;
                        d = c[b++];
                        d === r && i(Error("invalid uncompressed block header: NLEN (first byte)"));
                        h = d;
                        d = c[b++];
                        d === r && i(Error("invalid uncompressed block header: NLEN (second byte)"));
                        h |= d << 8;
                        g === ~h && i(Error("invalid uncompressed block header: length verify"));
                        b + g > c.length && i(Error("input buffer is broken"));
                        switch (this.m) {
                          case Ga:
                            for (;f + g > e.length; ) {
                                j = m - f;
                                g -= j;
                                if (H) {
                                    e.set(c.subarray(b, b + j), f), f += j, b += j;
                                } else {
                                    for (;j--; ) {
                                        e[f++] = c[b++];
                                    }
                                }
                                this.b = f;
                                e = this.f();
                                f = this.b;
                            }
                            break;

                          case Fa:
                            for (;f + g > e.length; ) {
                                e = this.f({
                                    v: 2
                                });
                            }
                            break;

                          default:
                            i(Error("invalid inflate mode"));
                        }
                        if (H) {
                            e.set(c.subarray(b, b + g), f), f += g, b += g;
                        } else {
                            for (;g--; ) {
                                e[f++] = c[b++];
                            }
                        }
                        this.c = b;
                        this.b = f;
                        this.a = e;
                        break;

                      case 1:
                        this.o(Ia, Ja);
                        break;

                      case 2:
                        Ka(this);
                        break;

                      default:
                        i(Error("unknown BTYPE: " + a));
                    }
                }
                return this.t();
            };
            var La = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], Za = H ? new Uint16Array(La) : La, $a = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258 ], ab = H ? new Uint16Array($a) : $a, bb = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 ], cb = H ? new Uint8Array(bb) : bb, db = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ], eb = H ? new Uint16Array(db) : db, fb = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ], gb = H ? new Uint8Array(fb) : fb, hb = new (H ? Uint8Array : Array)(288), Y, ib;
            Y = 0;
            for (ib = hb.length; Y < ib; ++Y) {
                hb[Y] = 143 >= Y ? 8 : 255 >= Y ? 9 : 279 >= Y ? 7 : 8;
            }
            var Ia = S(hb), jb = new (H ? Uint8Array : Array)(30), kb, lb;
            kb = 0;
            for (lb = jb.length; kb < lb; ++kb) {
                jb[kb] = 5;
            }
            var Ja = S(jb);
            function X(a, c) {
                for (var b = a.g, e = a.e, f = a.input, d = a.c, g; e < c; ) {
                    g = f[d++], g === r && i(Error("input buffer is broken")), b |= g << e, e += 8;
                }
                g = b & (1 << c) - 1;
                a.g = b >>> c;
                a.e = e - c;
                a.c = d;
                return g;
            }
            function mb(a, c) {
                for (var b = a.g, e = a.e, f = a.input, d = a.c, g = c[0], h = c[1], m, j, s; e < h; ) {
                    m = f[d++], m === r && i(Error("input buffer is broken")), b |= m << e, e += 8;
                }
                j = g[b & (1 << h) - 1];
                s = j >>> 16;
                a.g = b >> s;
                a.e = e - s;
                a.c = d;
                return 65535 & j;
            }
            function Ka(a) {
                function c(a, b, c) {
                    var d, e, f, g;
                    for (g = 0; g < a; ) {
                        switch (d = mb(this, b), d) {
                          case 16:
                            for (f = 3 + X(this, 2); f--; ) {
                                c[g++] = e;
                            }
                            break;

                          case 17:
                            for (f = 3 + X(this, 3); f--; ) {
                                c[g++] = 0;
                            }
                            e = 0;
                            break;

                          case 18:
                            for (f = 11 + X(this, 7); f--; ) {
                                c[g++] = 0;
                            }
                            e = 0;
                            break;

                          default:
                            e = c[g++] = d;
                        }
                    }
                    return c;
                }
                var b = X(a, 5) + 257, e = X(a, 5) + 1, f = X(a, 4) + 4, d = new (H ? Uint8Array : Array)(Za.length), g, h, m, j;
                for (j = 0; j < f; ++j) {
                    d[Za[j]] = X(a, 3);
                }
                g = S(d);
                h = new (H ? Uint8Array : Array)(b);
                m = new (H ? Uint8Array : Array)(e);
                a.o(S(c.call(a, b, g, h)), S(c.call(a, e, g, m)));
            }
            V.prototype.o = function(a, c) {
                var b = this.a, e = this.b;
                this.u = a;
                for (var f = b.length - 258, d, g, h, m; 256 !== (d = mb(this, a)); ) {
                    if (256 > d) {
                        e >= f && (this.b = e, b = this.f(), e = this.b), b[e++] = d;
                    } else {
                        g = d - 257;
                        m = ab[g];
                        0 < cb[g] && (m += X(this, cb[g]));
                        d = mb(this, c);
                        h = eb[d];
                        0 < gb[d] && (h += X(this, gb[d]));
                        e >= f && (this.b = e, b = this.f(), e = this.b);
                        for (;m--; ) {
                            b[e] = b[e++ - h];
                        }
                    }
                }
                for (;8 <= this.e; ) {
                    this.e -= 8, this.c--;
                }
                this.b = e;
            };
            V.prototype.I = function(a, c) {
                var b = this.a, e = this.b;
                this.u = a;
                for (var f = b.length, d, g, h, m; 256 !== (d = mb(this, a)); ) {
                    if (256 > d) {
                        e >= f && (b = this.f(), f = b.length), b[e++] = d;
                    } else {
                        g = d - 257;
                        m = ab[g];
                        0 < cb[g] && (m += X(this, cb[g]));
                        d = mb(this, c);
                        h = eb[d];
                        0 < gb[d] && (h += X(this, gb[d]));
                        e + m > f && (b = this.f(), f = b.length);
                        for (;m--; ) {
                            b[e] = b[e++ - h];
                        }
                    }
                }
                for (;8 <= this.e; ) {
                    this.e -= 8, this.c--;
                }
                this.b = e;
            };
            V.prototype.f = function() {
                var a = new (H ? Uint8Array : Array)(this.b - 32768), c = this.b - 32768, b, e, f = this.a;
                if (H) {
                    a.set(f.subarray(32768, a.length));
                } else {
                    b = 0;
                    for (e = a.length; b < e; ++b) {
                        a[b] = f[b + 32768];
                    }
                }
                this.k.push(a);
                this.q += a.length;
                if (H) {
                    f.set(f.subarray(c, c + 32768));
                } else {
                    for (b = 0; 32768 > b; ++b) {
                        f[b] = f[c + b];
                    }
                }
                this.b = 32768;
                return f;
            };
            V.prototype.J = function(a) {
                var c, b = this.input.length / this.c + 1 | 0, e, f, d, g = this.input, h = this.a;
                a && ("number" === typeof a.v && (b = a.v), "number" === typeof a.F && (b += a.F));
                2 > b ? (e = (g.length - this.c) / this.u[2], d = 258 * (e / 2) | 0, f = d < h.length ? h.length + d : h.length << 1) : f = h.length * b;
                H ? (c = new Uint8Array(f), c.set(h)) : c = h;
                return this.a = c;
            };
            V.prototype.t = function() {
                var a = 0, c = this.a, b = this.k, e, f = new (H ? Uint8Array : Array)(this.q + (this.b - 32768)), d, g, h, m;
                if (0 === b.length) {
                    return H ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
                }
                d = 0;
                for (g = b.length; d < g; ++d) {
                    e = b[d];
                    h = 0;
                    for (m = e.length; h < m; ++h) {
                        f[a++] = e[h];
                    }
                }
                d = 32768;
                for (g = this.b; d < g; ++d) {
                    f[a++] = c[d];
                }
                this.k = [];
                return this.buffer = f;
            };
            V.prototype.H = function() {
                var a, c = this.b;
                H ? this.B ? (a = new Uint8Array(c), a.set(this.a.subarray(0, c))) : a = this.a.subarray(0, c) : (this.a.length > c && (this.a.length = c), 
                a = this.a);
                return this.buffer = a;
            };
            function nb(a, c) {
                var b, e;
                this.input = a;
                this.c = 0;
                !c && (c = {}) || (c.index && (this.c = c.index), c.verify && (this.M = c.verify));
                b = a[this.c++];
                e = a[this.c++];
                switch (15 & b) {
                  case Ea:
                    this.method = Ea;
                    break;

                  default:
                    i(Error("unsupported compression method"));
                }
                0 !== ((b << 8) + e) % 31 && i(Error("invalid fcheck flag:" + ((b << 8) + e) % 31));
                32 & e && i(Error("fdict flag is not supported"));
                this.A = new V(a, {
                    index: this.c,
                    bufferSize: c.bufferSize,
                    bufferType: c.bufferType,
                    resize: c.resize
                });
            }
            nb.prototype.p = function() {
                var a = this.input, c, b;
                c = this.A.p();
                this.c = this.A.c;
                this.M && (b = (a[this.c++] << 24 | a[this.c++] << 16 | a[this.c++] << 8 | a[this.c++]) >>> 0, 
                b !== ba(c) && i(Error("invalid adler-32 checksum")));
                return c;
            };
            y("Zlib.Inflate", nb);
            y("Zlib.Inflate.BufferType", Ha);
            Ha.ADAPTIVE = Ha.C;
            Ha.BLOCK = Ha.D;
            y("Zlib.Inflate.prototype.decompress", nb.prototype.p);
            var ob = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
            H && new Uint16Array(ob);
            var pb = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258 ];
            H && new Uint16Array(pb);
            var qb = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 ];
            H && new Uint8Array(qb);
            var rb = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];
            H && new Uint16Array(rb);
            var sb = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
            H && new Uint8Array(sb);
            var tb = new (H ? Uint8Array : Array)(288), Z, ub;
            Z = 0;
            for (ub = tb.length; Z < ub; ++Z) {
                tb[Z] = 143 >= Z ? 8 : 255 >= Z ? 9 : 279 >= Z ? 7 : 8;
            }
            S(tb);
            var vb = new (H ? Uint8Array : Array)(30), wb, xb;
            wb = 0;
            for (xb = vb.length; wb < xb; ++wb) {
                vb[wb] = 5;
            }
            S(vb);
            var Ea = 8;
        }).call(window);
        var _p = window;
        _p = window.Zlib = _p["Zlib"];
        _p.Deflate = _p["Deflate"];
        _p.Deflate.compress = _p.Deflate["compress"];
        _p.Inflate = _p["Inflate"];
        _p.Inflate.BufferType = _p.Inflate["BufferType"];
        _p.Inflate.prototype.decompress = _p.Inflate.prototype["decompress"];
    }), {} ],
    34: [ (function(require, module, exports) {
        cc.configuration = {
            ERROR: 0,
            STRING: 1,
            INT: 2,
            DOUBLE: 3,
            BOOLEAN: 4,
            _maxTextureSize: 0,
            _maxModelviewStackDepth: 0,
            _supportsPVRTC: false,
            _supportsNPOT: false,
            _supportsBGRA8888: false,
            _supportsDiscardFramebuffer: false,
            _supportsShareableVAO: false,
            _maxSamplesAllowed: 0,
            _maxTextureUnits: 0,
            _GlExtensions: "",
            _valueDict: {},
            _inited: false,
            _init: function() {
                var locValueDict = this._valueDict;
                locValueDict["cocos2d.x.version"] = cc.ENGINE_VERSION;
                locValueDict["cocos2d.x.compiled_with_profiler"] = false;
                locValueDict["cocos2d.x.compiled_with_gl_state_cache"] = cc.macro.ENABLE_GL_STATE_CACHE;
                this._inited = true;
            },
            getMaxTextureSize: function() {
                return this._maxTextureSize;
            },
            getMaxModelviewStackDepth: function() {
                return this._maxModelviewStackDepth;
            },
            getMaxTextureUnits: function() {
                return this._maxTextureUnits;
            },
            supportsNPOT: function() {
                return this._supportsNPOT;
            },
            supportsPVRTC: function() {
                return this._supportsPVRTC;
            },
            supportsETC: function() {
                return false;
            },
            supportsS3TC: function() {
                return false;
            },
            supportsATITC: function() {
                return false;
            },
            supportsBGRA8888: function() {
                return this._supportsBGRA8888;
            },
            supportsDiscardFramebuffer: function() {
                return this._supportsDiscardFramebuffer;
            },
            supportsShareableVAO: function() {
                return this._supportsShareableVAO;
            },
            checkForGLExtension: function(searchName) {
                return this._GlExtensions.indexOf(searchName) > -1;
            },
            getValue: function(key, default_value) {
                this._inited || this._init();
                var locValueDict = this._valueDict;
                if (locValueDict[key]) {
                    return locValueDict[key];
                }
                return default_value;
            },
            setValue: function(key, value) {
                this._valueDict[key] = value;
            },
            gatherGPUInfo: function() {
                if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                    return;
                }
                this._inited || this._init();
                var gl = cc._renderContext;
                var locValueDict = this._valueDict;
                locValueDict["gl.vendor"] = gl.getParameter(gl.VENDOR);
                locValueDict["gl.renderer"] = gl.getParameter(gl.RENDERER);
                locValueDict["gl.version"] = gl.getParameter(gl.VERSION);
                this._GlExtensions = "";
                var extArr = gl.getSupportedExtensions();
                for (var i = 0; i < extArr.length; i++) {
                    this._GlExtensions += extArr[i] + " ";
                }
                this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                locValueDict["gl.max_texture_size"] = this._maxTextureSize;
                this._maxTextureUnits = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                locValueDict["gl.max_texture_units"] = this._maxTextureUnits;
                this._supportsPVRTC = this.checkForGLExtension("GL_IMG_texture_compression_pvrtc");
                locValueDict["gl.supports_PVRTC"] = this._supportsPVRTC;
                this._supportsNPOT = false;
                locValueDict["gl.supports_NPOT"] = this._supportsNPOT;
                this._supportsBGRA8888 = this.checkForGLExtension("GL_IMG_texture_format_BGRA888");
                locValueDict["gl.supports_BGRA8888"] = this._supportsBGRA8888;
                this._supportsDiscardFramebuffer = this.checkForGLExtension("GL_EXT_discard_framebuffer");
                locValueDict["gl.supports_discard_framebuffer"] = this._supportsDiscardFramebuffer;
                this._supportsShareableVAO = this.checkForGLExtension("vertex_array_object");
                locValueDict["gl.supports_vertex_array_object"] = this._supportsShareableVAO;
                cc.checkGLErrorDebug();
            },
            loadConfigFile: function(url) {
                this._inited || this._init();
                var dict = cc.loader.getRes(url);
                if (!dict) {
                    throw new Error("Please load the resource first : " + url);
                }
                cc.assertID(dict, 1101, url);
                var getDatas = dict["data"];
                if (!getDatas) {
                    cc.logID(1100, url);
                    return;
                }
                for (var selKey in getDatas) {
                    this._valueDict[selKey] = getDatas[selKey];
                }
            }
        };
    }), {} ],
    35: [ (function(require, module, exports) {
        var EventTarget = require("./event/event-target");
        var Class = require("./platform/_CCClass");
        var AutoReleaseUtils = require("./load-pipeline/auto-release-utils");
        var ComponentScheduler = require("./component-scheduler");
        var NodeActivator = require("./node-activator");
        var EventListeners = require("./event/event-listeners");
        cc.g_NumberOfDraws = 0;
        cc.Director = Class.extend({
            ctor: function() {
                var self = this;
                EventTarget.call(self);
                self._landscape = false;
                self._nextDeltaTimeZero = false;
                self._paused = false;
                self._purgeDirectorInNextLoop = false;
                self._sendCleanupToScene = false;
                self._animationInterval = 0;
                self._oldAnimationInterval = 0;
                self._projection = 0;
                self._projectionDelegate = null;
                self._contentScaleFactor = 1;
                self._winSizeInPoints = null;
                self._openGLView = null;
                self._scenesStack = null;
                self._nextScene = null;
                self._loadingScene = "";
                self._runningScene = null;
                self._scene = null;
                self._totalFrames = 0;
                self._lastUpdate = Date.now();
                self._deltaTime = 0;
                self._dirtyRegion = null;
                self._scheduler = null;
                self._compScheduler = null;
                self._nodeActivator = null;
                self._actionManager = null;
                cc.game.on(cc.game.EVENT_SHOW, (function() {
                    self._lastUpdate = Date.now();
                }));
            },
            init: function() {
                this._oldAnimationInterval = this._animationInterval = 1 / cc.defaultFPS;
                this._scenesStack = [];
                this._projection = cc.Director.PROJECTION_DEFAULT;
                this._projectionDelegate = null;
                this._totalFrames = 0;
                this._lastUpdate = Date.now();
                this._paused = false;
                this._purgeDirectorInNextLoop = false;
                this._winSizeInPoints = cc.size(0, 0);
                this._openGLView = null;
                this._contentScaleFactor = 1;
                this._scheduler = new cc.Scheduler();
                if (cc.ActionManager) {
                    this._actionManager = new cc.ActionManager();
                    this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
                } else {
                    this._actionManager = null;
                }
                this.sharedInit();
                return true;
            },
            sharedInit: function() {
                this._compScheduler = new ComponentScheduler();
                this._nodeActivator = new NodeActivator();
                if (cc.AnimationManager) {
                    this._animationManager = new cc.AnimationManager();
                    this._scheduler.scheduleUpdate(this._animationManager, cc.Scheduler.PRIORITY_SYSTEM, false);
                } else {
                    this._animationManager = null;
                }
                if (cc.CollisionManager) {
                    this._collisionManager = new cc.CollisionManager();
                    this._scheduler.scheduleUpdate(this._collisionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
                } else {
                    this._collisionManager = null;
                }
                if (cc.PhysicsManager) {
                    this._physicsManager = new cc.PhysicsManager();
                    this._scheduler.scheduleUpdate(this._physicsManager, cc.Scheduler.PRIORITY_SYSTEM, false);
                } else {
                    this._physicsManager = null;
                }
                cc._widgetManager && cc._widgetManager.init(this);
            },
            calculateDeltaTime: function() {
                var now = Date.now();
                if (this._nextDeltaTimeZero) {
                    this._deltaTime = 0;
                    this._nextDeltaTimeZero = false;
                } else {
                    this._deltaTime = (now - this._lastUpdate) / 1e3;
                    cc.game.config[cc.game.CONFIG_KEY.debugMode] > 0 && this._deltaTime > 1 && (this._deltaTime = 1 / 60);
                }
                this._lastUpdate = now;
            },
            convertToGL: function(uiPoint) {
                var docElem = document.documentElement;
                var view = cc.view;
                var box = docElem.getBoundingClientRect();
                var left = box.left + window.pageXOffset - docElem.clientLeft;
                var top = box.top + window.pageYOffset - docElem.clientTop;
                var x = view._devicePixelRatio * (uiPoint.x - left);
                var y = view._devicePixelRatio * (top + box.height - uiPoint.y);
                return view._isRotated ? {
                    x: view._viewPortRect.width - y,
                    y: x
                } : {
                    x: x,
                    y: y
                };
            },
            convertToUI: function(glPoint) {
                var docElem = document.documentElement;
                var view = cc.view;
                var box = docElem.getBoundingClientRect();
                var left = box.left + window.pageXOffset - docElem.clientLeft;
                var top = box.top + window.pageYOffset - docElem.clientTop;
                var uiPoint = {
                    x: 0,
                    y: 0
                };
                if (view._isRotated) {
                    uiPoint.x = left + glPoint.y / view._devicePixelRatio;
                    uiPoint.y = top + box.height - (view._viewPortRect.width - glPoint.x) / view._devicePixelRatio;
                } else {
                    uiPoint.x = left + glPoint.x / view._devicePixelRatio;
                    uiPoint.y = top + box.height - glPoint.y / view._devicePixelRatio;
                }
                return uiPoint;
            },
            _visitScene: function() {
                if (this._runningScene) {
                    var renderer = cc.renderer;
                    if (renderer.childrenOrderDirty) {
                        renderer.clearRenderCommands();
                        cc.renderer.assignedZ = 0;
                        this._runningScene._renderCmd._curLevel = 0;
                        this._runningScene.visit();
                        renderer.resetFlag();
                    } else {
                        renderer.transformDirty() && renderer.transform();
                    }
                }
            },
            end: function() {
                this._purgeDirectorInNextLoop = true;
            },
            getContentScaleFactor: function() {
                return this._contentScaleFactor;
            },
            getWinSize: function() {
                return cc.size(this._winSizeInPoints);
            },
            getWinSizeInPixels: function() {
                return cc.size(this._winSizeInPoints.width * this._contentScaleFactor, this._winSizeInPoints.height * this._contentScaleFactor);
            },
            getVisibleSize: null,
            getVisibleOrigin: null,
            getZEye: null,
            pause: function() {
                if (this._paused) {
                    return;
                }
                this._oldAnimationInterval = this._animationInterval;
                this.setAnimationInterval(.25);
                this._paused = true;
            },
            popScene: function() {
                cc.assertID(this._runningScene, 1204);
                this._scenesStack.pop();
                var c = this._scenesStack.length;
                if (0 === c) {
                    this.end();
                } else {
                    this._sendCleanupToScene = true;
                    this._nextScene = this._scenesStack[c - 1];
                }
            },
            purgeCachedData: function() {
                cc.textureCache._clear();
            },
            purgeDirector: function() {
                this.getScheduler().unscheduleAll();
                this._compScheduler.unscheduleAll();
                this._nodeActivator.reset();
                cc.eventManager && cc.eventManager.setEnabled(false);
                if (this._runningScene) {
                    this._runningScene.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
                    this._runningScene.performRecursive(_ccsg.Node.performType.onExit);
                    this._runningScene.performRecursive(_ccsg.Node.performType.cleanup);
                    cc.renderer.clearRenderCommands();
                }
                this._runningScene = null;
                this._nextScene = null;
                this._scenesStack.length = 0;
                this.stopAnimation();
                this.purgeCachedData();
                cc.checkGLErrorDebug();
            },
            reset: function() {
                this.purgeDirector();
                cc.eventManager && cc.eventManager.setEnabled(true);
                this._actionManager && this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
                this._animationManager && this._scheduler.scheduleUpdate(this._animationManager, cc.Scheduler.PRIORITY_SYSTEM, false);
                this._collisionManager && this._scheduler.scheduleUpdate(this._collisionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
                this._physicsManager && this._scheduler.scheduleUpdate(this._physicsManager, cc.Scheduler.PRIORITY_SYSTEM, false);
                this.startAnimation();
            },
            pushScene: function(scene) {
                cc.assertID(scene, 1205);
                this._sendCleanupToScene = false;
                this._scenesStack.push(scene);
                this._nextScene = scene;
            },
            runSceneImmediate: function(scene, onBeforeLoadScene, onLaunched) {
                var id, node, game = cc.game;
                var persistNodes = game._persistRootNodes;
                scene instanceof cc.Scene && scene._load();
                for (id in persistNodes) {
                    node = persistNodes[id];
                    game._ignoreRemovePersistNode = node;
                    node.parent = null;
                    game._ignoreRemovePersistNode = null;
                }
                var oldScene = this._scene;
                var autoReleaseAssets = oldScene && oldScene.autoReleaseAssets && oldScene.dependAssets;
                AutoReleaseUtils.autoRelease(cc.loader, autoReleaseAssets, scene.dependAssets);
                cc.isValid(oldScene) && oldScene.destroy();
                this._scene = null;
                cc.Object._deferredDestroy();
                onBeforeLoadScene && onBeforeLoadScene();
                this.emit(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, scene);
                var sgScene = scene;
                if (scene instanceof cc.Scene) {
                    this._scene = scene;
                    sgScene = scene._sgNode;
                    for (id in persistNodes) {
                        node = persistNodes[id];
                        var existNode = scene.getChildByUuid(id);
                        if (existNode) {
                            var index = existNode.getSiblingIndex();
                            existNode._destroyImmediate();
                            node.parent = scene;
                            node.setSiblingIndex(index);
                        } else {
                            node.parent = scene;
                        }
                    }
                    scene._activate();
                }
                if (this._runningScene) {
                    var i = this._scenesStack.length;
                    this._scenesStack[Math.max(i - 1, 0)] = sgScene;
                    this._sendCleanupToScene = true;
                    this._nextScene = sgScene;
                } else {
                    this.pushScene(sgScene);
                    this.startAnimation();
                }
                this._nextScene && this.setNextScene();
                onLaunched && onLaunched(null, scene);
                this.emit(cc.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
            },
            runScene: function(scene, onBeforeLoadScene, onLaunched) {
                cc.assertID(scene, 1205);
                scene instanceof cc.Scene && scene._load();
                this.once(cc.Director.EVENT_AFTER_UPDATE, (function() {
                    this.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
                }));
            },
            _getSceneUuid: function(key) {
                var scenes = cc.game._sceneInfos;
                if ("string" === typeof key) {
                    key.endsWith(".fire") || (key += ".fire");
                    "/" === key[0] || key.startsWith("db://assets/") || (key = "/" + key);
                    for (var i = 0; i < scenes.length; i++) {
                        var info = scenes[i];
                        if (info.url.endsWith(key)) {
                            return info;
                        }
                    }
                } else {
                    if ("number" === typeof key) {
                        if (0 <= key && key < scenes.length) {
                            return scenes[key];
                        }
                        cc.errorID(1206, key);
                    } else {
                        cc.errorID(1207, key);
                    }
                }
                return null;
            },
            loadScene: function(sceneName, onLaunched, _onUnloaded) {
                if (this._loadingScene) {
                    cc.errorID(1208, sceneName, this._loadingScene);
                    return false;
                }
                var info = this._getSceneUuid(sceneName);
                if (info) {
                    var uuid = info.uuid;
                    this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
                    this._loadingScene = sceneName;
                    var self;
                    var groupName;
                    var ensureAsync;
                    this._loadSceneByUuid(uuid, onLaunched, _onUnloaded);
                    return true;
                }
                cc.errorID(1209, sceneName);
                return false;
            },
            preloadScene: function(sceneName, onLoaded) {
                var info = this._getSceneUuid(sceneName);
                if (info) {
                    this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
                    cc.loader.load({
                        uuid: info.uuid,
                        type: "uuid"
                    }, (function(error, asset) {
                        error && cc.errorID(1210, sceneName, error.message);
                        onLoaded && onLoaded(error, asset);
                    }));
                } else {
                    var error = 'Can not preload the scene "' + sceneName + '" because it is not in the build settings.';
                    onLoaded(new Error(error));
                    cc.error("preloadScene: " + error);
                }
            },
            _loadSceneByUuid: function(uuid, onLaunched, onUnloaded, dontRunScene) {
                cc.AssetLibrary.loadAsset(uuid, (function(error, sceneAsset) {
                    var self = cc.director;
                    self._loadingScene = "";
                    if (error) {
                        error = "Failed to load scene: " + error;
                        cc.error(error);
                    } else {
                        if (sceneAsset instanceof cc.SceneAsset) {
                            var scene = sceneAsset.scene;
                            scene._id = sceneAsset._uuid;
                            scene._name = sceneAsset._name;
                            self.runSceneImmediate(scene, onUnloaded, onLaunched);
                            return;
                        }
                        error = "The asset " + uuid + " is not a scene";
                        cc.error(error);
                    }
                    onLaunched && onLaunched(error);
                }));
            },
            resume: function() {
                if (!this._paused) {
                    return;
                }
                this.setAnimationInterval(this._oldAnimationInterval);
                this._lastUpdate = Date.now();
                this._lastUpdate || cc.logID(1200);
                this._paused = false;
                this._deltaTime = 0;
            },
            setContentScaleFactor: function(scaleFactor) {
                scaleFactor !== this._contentScaleFactor && (this._contentScaleFactor = scaleFactor);
            },
            setDepthTest: null,
            setClearColor: null,
            setDefaultValues: function() {},
            setNextDeltaTimeZero: function(nextDeltaTimeZero) {
                this._nextDeltaTimeZero = nextDeltaTimeZero;
            },
            setNextScene: function() {
                var runningIsTransition = false, newIsTransition = false;
                if (cc.TransitionScene) {
                    runningIsTransition = !!this._runningScene && this._runningScene instanceof cc.TransitionScene;
                    newIsTransition = !!this._nextScene && this._nextScene instanceof cc.TransitionScene;
                }
                if (!newIsTransition) {
                    var locRunningScene = this._runningScene;
                    if (locRunningScene) {
                        locRunningScene.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
                        locRunningScene.performRecursive(_ccsg.Node.performType.onExit);
                    }
                    this._sendCleanupToScene && locRunningScene && locRunningScene.performRecursive(_ccsg.Node.performType.cleanup);
                }
                this._runningScene = this._nextScene;
                cc.renderer.childrenOrderDirty = true;
                this._nextScene = null;
                if (!runningIsTransition && null !== this._runningScene) {
                    this._runningScene.performRecursive(_ccsg.Node.performType.onEnter);
                    this._runningScene.performRecursive(_ccsg.Node.performType.onEnterTransitionDidFinish);
                }
            },
            getDelegate: function() {
                return this._projectionDelegate;
            },
            setDelegate: function(delegate) {
                this._projectionDelegate = delegate;
            },
            setOpenGLView: null,
            setProjection: null,
            setViewport: null,
            getOpenGLView: null,
            getProjection: null,
            setAlphaBlending: null,
            isSendCleanupToScene: function() {
                return this._sendCleanupToScene;
            },
            getRunningScene: function() {
                return this._runningScene;
            },
            getScene: function() {
                return this._scene;
            },
            getAnimationInterval: function() {
                return this._animationInterval;
            },
            isDisplayStats: function() {
                return !!cc.profiler && cc.profiler.isShowingStats();
            },
            setDisplayStats: function(displayStats) {
                if (cc.profiler) {
                    displayStats ? cc.profiler.showStats() : cc.profiler.hideStats();
                    cc.game.config[cc.game.CONFIG_KEY.showFPS] = !!displayStats;
                }
            },
            isNextDeltaTimeZero: function() {
                return this._nextDeltaTimeZero;
            },
            isPaused: function() {
                return this._paused;
            },
            getTotalFrames: function() {
                return this._totalFrames;
            },
            popToRootScene: function() {
                this.popToSceneStackLevel(1);
            },
            popToSceneStackLevel: function(level) {
                cc.assertID(this._runningScene, 1203);
                var locScenesStack = this._scenesStack;
                var c = locScenesStack.length;
                if (0 === c) {
                    this.end();
                    return;
                }
                if (level > c) {
                    return;
                }
                while (c > level) {
                    var current = locScenesStack.pop();
                    if (current.running) {
                        current.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
                        current.performRecursive(_ccsg.Node.performType.onExit);
                    }
                    current.performRecursive(_ccsg.Node.performType.cleanup);
                    c--;
                }
                this._nextScene = locScenesStack[locScenesStack.length - 1];
                this._sendCleanupToScene = true;
            },
            getScheduler: function() {
                return this._scheduler;
            },
            setScheduler: function(scheduler) {
                this._scheduler !== scheduler && (this._scheduler = scheduler);
            },
            getActionManager: function() {
                return this._actionManager;
            },
            setActionManager: function(actionManager) {
                if (this._actionManager !== actionManager) {
                    this._actionManager && this._scheduler.unscheduleUpdate(this._actionManager);
                    this._actionManager = actionManager;
                    this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
                }
            },
            getAnimationManager: function() {
                return this._animationManager;
            },
            getCollisionManager: function() {
                return this._collisionManager;
            },
            getPhysicsManager: function() {
                return this._physicsManager;
            },
            getDeltaTime: function() {
                return this._deltaTime;
            }
        });
        cc.js.addon(cc.Director.prototype, EventTarget.prototype);
        cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
        cc.Director.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading";
        cc.Director.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch";
        cc.Director.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch";
        cc.Director.EVENT_BEFORE_UPDATE = "director_before_update";
        cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
        cc.Director.EVENT_BEFORE_VISIT = "director_before_visit";
        cc.Director.EVENT_AFTER_VISIT = "director_after_visit";
        cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
        cc.DisplayLinkDirector = cc.Director.extend({
            invalid: false,
            startAnimation: function() {
                this._nextDeltaTimeZero = true;
                this.invalid = false;
            },
            mainLoop: function() {
                if (this._purgeDirectorInNextLoop) {
                    this._purgeDirectorInNextLoop = false;
                    this.purgeDirector();
                } else {
                    if (!this.invalid) {
                        this.calculateDeltaTime();
                        if (!this._paused) {
                            this.emit(cc.Director.EVENT_BEFORE_UPDATE);
                            this._compScheduler.startPhase();
                            this._compScheduler.updatePhase(this._deltaTime);
                            this._scheduler.update(this._deltaTime);
                            this._compScheduler.lateUpdatePhase(this._deltaTime);
                            this.emit(cc.Director.EVENT_AFTER_UPDATE);
                            cc.Object._deferredDestroy();
                        }
                        this._nextScene && this.setNextScene();
                        this.emit(cc.Director.EVENT_BEFORE_VISIT);
                        this._visitScene();
                        this.emit(cc.Director.EVENT_AFTER_VISIT);
                        cc.g_NumberOfDraws = 0;
                        cc.renderer.clear();
                        cc.renderer.rendering(cc._renderContext);
                        this._totalFrames++;
                        this.emit(cc.Director.EVENT_AFTER_DRAW);
                        cc.eventManager.frameUpdateListeners();
                    }
                }
            },
            stopAnimation: function() {
                this.invalid = true;
            },
            setAnimationInterval: function(value) {
                this._animationInterval = value;
                if (!this.invalid) {
                    this.stopAnimation();
                    this.startAnimation();
                }
            },
            __fastOn: function(type, callback, target) {
                var listeners = this._bubblingListeners;
                listeners || (listeners = this._bubblingListeners = new EventListeners());
                listeners.add(type, callback, target);
            },
            __fastOff: function(type, callback, target) {
                var listeners = this._bubblingListeners;
                listeners && listeners.remove(type, callback, target);
            }
        });
        cc.Director.sharedDirector = null;
        cc.Director.firstUseDirector = true;
        cc.Director._getInstance = function() {
            if (cc.Director.firstUseDirector) {
                cc.Director.firstUseDirector = false;
                cc.Director.sharedDirector = new cc.DisplayLinkDirector();
                cc.Director.sharedDirector.init();
            }
            return cc.Director.sharedDirector;
        };
        cc.defaultFPS = 60;
        cc.Director.PROJECTION_2D = 0;
        cc.Director.PROJECTION_3D = 1;
        cc.Director.PROJECTION_CUSTOM = 3;
        cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_2D;
    }), {
        "./component-scheduler": 71,
        "./event/event-listeners": 111,
        "./event/event-target": 112,
        "./load-pipeline/auto-release-utils": 134,
        "./node-activator": 145,
        "./platform/_CCClass": 185
    } ],
    36: [ (function(require, module, exports) {
        require("./CCDirector");
        require("./CCGame");
        cc.game.once(cc.game.EVENT_RENDERER_INITED, (function() {
            if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                var _p = cc.Director.prototype;
                _p.getProjection = function(projection) {
                    return this._projection;
                };
                _p.setProjection = function(projection) {
                    this._projection = projection;
                    this.emit(cc.Director.EVENT_PROJECTION_CHANGED, this);
                };
                _p.setDepthTest = function() {};
                _p.setClearColor = function(clearColor) {
                    cc.renderer._clearColor = clearColor;
                    cc.renderer._clearFillStyle = "rgb(" + clearColor.r + "," + clearColor.g + "," + clearColor.b + ")";
                };
                _p.setOpenGLView = function(openGLView) {
                    this._winSizeInPoints.width = cc._canvas.width;
                    this._winSizeInPoints.height = cc._canvas.height;
                    this._openGLView = openGLView || cc.view;
                    cc.eventManager && cc.eventManager.setEnabled(true);
                };
                _p.getVisibleSize = function() {
                    return this.getWinSize();
                };
                _p.getVisibleOrigin = function() {
                    return cc.p(0, 0);
                };
            }
        }));
    }), {
        "./CCDirector": 35,
        "./CCGame": 40
    } ],
    37: [ (function(require, module, exports) {
        require("./CCDirector");
        require("./CCGame");
        require("../kazmath");
        var math = cc.math;
        cc.game.once(cc.game.EVENT_RENDERER_INITED, (function() {
            if (cc._renderType !== cc.game.RENDER_TYPE_WEBGL) {
                return;
            }
            cc.DirectorDelegate = cc._Class.extend({
                updateProjection: function() {}
            });
            var _p = cc.Director.prototype;
            var recursiveChild = function(node) {
                if (node && node._renderCmd) {
                    node._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                    var i, children = node._children;
                    for (i = 0; i < children.length; i++) {
                        recursiveChild(children[i]);
                    }
                }
            };
            cc.Director._getInstance().on(cc.Director.EVENT_PROJECTION_CHANGED, (function() {
                var stack = cc.director._scenesStack;
                for (var i = 0; i < stack.length; i++) {
                    recursiveChild(stack[i]);
                }
            }));
            _p.setProjection = function(projection) {
                var _t = this;
                var size = _t._winSizeInPoints;
                _t.setViewport();
                var view = _t._openGLView, ox = view._viewPortRect.x / view._scaleX, oy = view._viewPortRect.y / view._scaleY;
                switch (projection) {
                  case cc.Director.PROJECTION_2D:
                    math.glMatrixMode(math.KM_GL_PROJECTION);
                    math.glLoadIdentity();
                    var orthoMatrix = math.Matrix4.createOrthographicProjection(0, size.width, 0, size.height, -1024, 1024);
                    math.glMultMatrix(orthoMatrix);
                    math.glMatrixMode(math.KM_GL_MODELVIEW);
                    math.glLoadIdentity();
                    break;

                  case cc.Director.PROJECTION_3D:
                    var zeye = _t.getZEye();
                    var matrixPerspective = new math.Matrix4(), matrixLookup = new math.Matrix4();
                    math.glMatrixMode(math.KM_GL_PROJECTION);
                    math.glLoadIdentity();
                    matrixPerspective = math.Matrix4.createPerspectiveProjection(60, size.width / size.height, .1, 2 * zeye);
                    math.glMultMatrix(matrixPerspective);
                    var eye = new math.Vec3(-ox + size.width / 2, -oy + size.height / 2, zeye);
                    var center = new math.Vec3(-ox + size.width / 2, -oy + size.height / 2, 0);
                    var up = new math.Vec3(0, 1, 0);
                    matrixLookup.lookAt(eye, center, up);
                    math.glMultMatrix(matrixLookup);
                    math.glMatrixMode(math.KM_GL_MODELVIEW);
                    math.glLoadIdentity();
                    break;

                  case cc.Director.PROJECTION_CUSTOM:
                    _t._projectionDelegate && _t._projectionDelegate.updateProjection();
                    break;

                  default:
                    cc.logID(1201);
                }
                _t._projection = projection;
                _t.emit(cc.Director.EVENT_PROJECTION_CHANGED, _t);
                cc.gl.setProjectionMatrixDirty();
                cc.renderer.childrenOrderDirty = true;
            };
            _p.setDepthTest = function(on) {
                cc.renderer.setDepthTest(on);
            };
            _p.setClearColor = function(clearColor) {
                var locClearColor = cc.renderer._clearColor;
                locClearColor.r = clearColor.r / 255;
                locClearColor.g = clearColor.g / 255;
                locClearColor.b = clearColor.b / 255;
                locClearColor.a = clearColor.a / 255;
            };
            _p.setOpenGLView = function(openGLView) {
                var _t = this;
                _t._winSizeInPoints.width = cc._canvas.width;
                _t._winSizeInPoints.height = cc._canvas.height;
                _t._openGLView = openGLView || cc.view;
                var conf = cc.configuration;
                conf.gatherGPUInfo();
                _t.setGLDefaultValues();
                cc.eventManager && cc.eventManager.setEnabled(true);
            };
            _p.getVisibleSize = function() {
                return this._openGLView.getVisibleSize();
            };
            _p.getVisibleOrigin = function() {
                return this._openGLView.getVisibleOrigin();
            };
            _p.getZEye = function() {
                return this._winSizeInPoints.height / 1.1566;
            };
            _p.setViewport = function() {
                var view = this._openGLView;
                if (view) {
                    var locWinSizeInPoints = this._winSizeInPoints;
                    view.setViewPortInPoints(-view._viewPortRect.x / view._scaleX, -view._viewPortRect.y / view._scaleY, locWinSizeInPoints.width, locWinSizeInPoints.height);
                }
            };
            _p.getOpenGLView = function() {
                return this._openGLView;
            };
            _p.getProjection = function() {
                return this._projection;
            };
            _p.setAlphaBlending = function(on) {
                on ? cc.gl.blendFunc(cc.macro.BLEND_SRC, cc.macro.BLEND_DST) : cc.gl.blendFunc(cc.macro.ONE, cc.macro.ZERO);
            };
            _p.setGLDefaultValues = function() {
                var _t = this;
                _t.setAlphaBlending(true);
                _t.setProjection(_t._projection);
                cc._renderContext.clearColor(0, 0, 0, 0);
            };
        }));
    }), {
        "../kazmath": 244,
        "./CCDirector": 35,
        "./CCGame": 40
    } ],
    38: [ (function(require, module, exports) {
        cc.DrawingPrimitiveCanvas = cc._Class.extend({
            _cacheArray: [],
            ctor: function(renderContext) {
                this._renderContext = renderContext;
            },
            drawPoint: function(point, size) {
                size || (size = 1);
                var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
                var newPoint = cc.p(point.x * locScaleX, point.y * locScaleY);
                var ctx = this._renderContext.getContext();
                ctx.beginPath();
                ctx.arc(newPoint.x, -newPoint.y, size * locScaleX, 0, 2 * Math.PI, false);
                ctx.closePath();
                ctx.fill();
            },
            drawPoints: function(points, numberOfPoints, size) {
                if (null == points) {
                    return;
                }
                size || (size = 1);
                var locContext = this._renderContext.getContext(), locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
                locContext.beginPath();
                for (var i = 0, len = points.length; i < len; i++) {
                    locContext.arc(points[i].x * locScaleX, -points[i].y * locScaleY, size * locScaleX, 0, 2 * Math.PI, false);
                }
                locContext.closePath();
                locContext.fill();
            },
            drawLine: function(origin, destination) {
                var locContext = this._renderContext.getContext(), locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
                locContext.beginPath();
                locContext.moveTo(origin.x * locScaleX, -origin.y * locScaleY);
                locContext.lineTo(destination.x * locScaleX, -destination.y * locScaleY);
                locContext.closePath();
                locContext.stroke();
            },
            drawRect: function(origin, destination) {
                this.drawLine(cc.p(origin.x, origin.y), cc.p(destination.x, origin.y));
                this.drawLine(cc.p(destination.x, origin.y), cc.p(destination.x, destination.y));
                this.drawLine(cc.p(destination.x, destination.y), cc.p(origin.x, destination.y));
                this.drawLine(cc.p(origin.x, destination.y), cc.p(origin.x, origin.y));
            },
            drawSolidRect: function(origin, destination, color) {
                var vertices = [ origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y) ];
                this.drawSolidPoly(vertices, 4, color);
            },
            drawPoly: function(vertices, numOfVertices, closePolygon, fill) {
                fill = fill || false;
                if (null == vertices) {
                    return;
                }
                if (vertices.length < 3) {
                    throw new Error("Polygon's point must greater than 2");
                }
                var firstPoint = vertices[0], locContext = this._renderContext.getContext();
                var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
                locContext.beginPath();
                locContext.moveTo(firstPoint.x * locScaleX, -firstPoint.y * locScaleY);
                for (var i = 1, len = vertices.length; i < len; i++) {
                    locContext.lineTo(vertices[i].x * locScaleX, -vertices[i].y * locScaleY);
                }
                closePolygon && locContext.closePath();
                fill ? locContext.fill() : locContext.stroke();
            },
            drawSolidPoly: function(polygons, numberOfPoints, color) {
                this.setDrawColor(color.r, color.g, color.b, color.a);
                this.drawPoly(polygons, numberOfPoints, true, true);
            },
            drawCircle: function(center, radius, angle, segments, drawLineToCenter) {
                drawLineToCenter = drawLineToCenter || false;
                var locContext = this._renderContext.getContext();
                var locScaleX = cc.view.getScaleX(), locScaleY = cc.view.getScaleY();
                locContext.beginPath();
                var endAngle = angle - 2 * Math.PI;
                locContext.arc(0 | center.x * locScaleX, 0 | -(center.y * locScaleY), radius * locScaleX, -angle, -endAngle, false);
                drawLineToCenter && locContext.lineTo(0 | center.x * locScaleX, 0 | -(center.y * locScaleY));
                locContext.stroke();
            },
            drawQuadBezier: function(origin, control, destination, segments) {
                var vertices = this._cacheArray;
                vertices.length = 0;
                var t = 0;
                for (var i = 0; i < segments; i++) {
                    var x = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
                    var y = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
                    vertices.push(cc.p(x, y));
                    t += 1 / segments;
                }
                vertices.push(cc.p(destination.x, destination.y));
                this.drawPoly(vertices, segments + 1, false, false);
            },
            drawCubicBezier: function(origin, control1, control2, destination, segments) {
                var vertices = this._cacheArray;
                vertices.length = 0;
                var t = 0;
                for (var i = 0; i < segments; i++) {
                    var x = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
                    var y = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
                    vertices.push(cc.p(x, y));
                    t += 1 / segments;
                }
                vertices.push(cc.p(destination.x, destination.y));
                this.drawPoly(vertices, segments + 1, false, false);
            },
            drawCatmullRom: function(points, segments) {
                this.drawCardinalSpline(points, .5, segments);
            },
            drawCardinalSpline: function(config, tension, segments) {
                cc._renderContext.setStrokeStyle("rgba(255,255,255,1)");
                var points = this._cacheArray;
                points.length = 0;
                var p, lt;
                var deltaT = 1 / config.length;
                for (var i = 0; i < segments + 1; i++) {
                    var dt = i / segments;
                    if (1 === dt) {
                        p = config.length - 1;
                        lt = 1;
                    } else {
                        p = 0 | dt / deltaT;
                        lt = (dt - deltaT * p) / deltaT;
                    }
                    var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p - 0), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
                    points.push(newPos);
                }
                this.drawPoly(points, segments + 1, false, false);
            },
            drawImage: function(image, sourcePoint, sourceSize, destPoint, destSize) {
                var len = arguments.length;
                var ctx = this._renderContext.getContext();
                switch (len) {
                  case 2:
                    var height = image.height;
                    ctx.drawImage(image, sourcePoint.x, -(sourcePoint.y + height));
                    break;

                  case 3:
                    ctx.drawImage(image, sourcePoint.x, -(sourcePoint.y + sourceSize.height), sourceSize.width, sourceSize.height);
                    break;

                  case 5:
                    ctx.drawImage(image, sourcePoint.x, sourcePoint.y, sourceSize.width, sourceSize.height, destPoint.x, -(destPoint.y + destSize.height), destSize.width, destSize.height);
                    break;

                  default:
                    throw new Error("Argument must be non-nil");
                }
            },
            drawStar: function(ctx, radius, color) {
                var wrapper = ctx || this._renderContext;
                var context = wrapper.getContext();
                radius *= cc.view.getScaleX();
                var colorStr = "rgba(" + (0 | color.r) + "," + (0 | color.g) + "," + (0 | color.b);
                wrapper.setFillStyle(colorStr + ",1)");
                var subRadius = radius / 10;
                context.beginPath();
                context.moveTo(-radius, radius);
                context.lineTo(0, subRadius);
                context.lineTo(radius, radius);
                context.lineTo(subRadius, 0);
                context.lineTo(radius, -radius);
                context.lineTo(0, -subRadius);
                context.lineTo(-radius, -radius);
                context.lineTo(-subRadius, 0);
                context.lineTo(-radius, radius);
                context.closePath();
                context.fill();
                var rg = context.createRadialGradient(0, 0, subRadius, 0, 0, radius);
                rg.addColorStop(0, colorStr + ", 1)");
                rg.addColorStop(.3, colorStr + ", 0.8)");
                rg.addColorStop(1, colorStr + ", 0.0)");
                wrapper.setFillStyle(rg);
                context.beginPath();
                var startAngle_1 = 0;
                var endAngle_1 = cc.macro.PI2;
                context.arc(0, 0, radius - subRadius, startAngle_1, endAngle_1, false);
                context.closePath();
                context.fill();
            },
            drawColorBall: function(ctx, radius, color) {
                var wrapper = ctx || this._renderContext;
                var context = wrapper.getContext();
                radius *= cc.view.getScaleX();
                var colorStr = "rgba(" + (0 | color.r) + "," + (0 | color.g) + "," + (0 | color.b);
                var subRadius = radius / 10;
                var g1 = context.createRadialGradient(0, 0, subRadius, 0, 0, radius);
                g1.addColorStop(0, colorStr + ", 1)");
                g1.addColorStop(.3, colorStr + ", 0.8)");
                g1.addColorStop(.6, colorStr + ", 0.4)");
                g1.addColorStop(1, colorStr + ", 0.0)");
                wrapper.setFillStyle(g1);
                context.beginPath();
                var startAngle_1 = 0;
                var endAngle_1 = cc.macro.PI2;
                context.arc(0, 0, radius, startAngle_1, endAngle_1, false);
                context.closePath();
                context.fill();
            },
            fillText: function(strText, x, y) {
                this._renderContext.getContext().fillText(strText, x, -y);
            },
            setDrawColor: function(r, g, b, a) {
                this._renderContext.setFillStyle("rgba(" + r + "," + g + "," + b + "," + a / 255 + ")");
                this._renderContext.setStrokeStyle("rgba(" + r + "," + g + "," + b + "," + a / 255 + ")");
            },
            setPointSize: function(pointSize) {},
            setLineWidth: function(width) {
                this._renderContext.getContext().lineWidth = width * cc.view.getScaleX();
            }
        });
    }), {} ],
    39: [ (function(require, module, exports) {
        var macro = cc.macro;
        cc.DrawingPrimitiveWebGL = cc._Class.extend({
            _initialized: false,
            _shader: null,
            _colorLocation: "u_color",
            _pointSizeLocation: "u_pointSize",
            _pointSize: -1,
            ctor: function(ctx) {
                null == ctx && (ctx = cc._renderContext);
                if (!ctx instanceof WebGLRenderingContext) {
                    throw new Error("Can't initialise DrawingPrimitiveWebGL. context need is WebGLRenderingContext");
                }
                this._renderContext = ctx;
                this._colorArray = new Float32Array([ 1, 1, 1, 1 ]);
            },
            lazy_init: function() {
                var _t = this;
                if (!_t._initialized) {
                    _t._shader = cc.shaderCache.programForKey(macro.SHADER_POSITION_UCOLOR);
                    _t._shader._addUniformLocation(_t._colorLocation);
                    _t._shader._addUniformLocation(_t._pointSizeLocation);
                    _t._initialized = true;
                }
            },
            drawInit: function() {
                this._initialized = false;
            },
            drawPoint: function(point) {
                this.lazy_init();
                var glContext = this._renderContext;
                this._shader.use();
                this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
                this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
                this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
                var pointBuffer = glContext.createBuffer();
                glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                glContext.bufferData(glContext.ARRAY_BUFFER, new Float32Array([ point.x, point.y ]), glContext.STATIC_DRAW);
                glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                glContext.drawArrays(glContext.POINTS, 0, 1);
                glContext.deleteBuffer(pointBuffer);
                cc.incrementGLDraws(1);
            },
            drawPoints: function(points, numberOfPoints) {
                if (!points || 0 === points.length) {
                    return;
                }
                this.lazy_init();
                var glContext = this._renderContext;
                this._shader.use();
                this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
                this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
                this._shader.setUniformLocationWith1f(this._pointSizeLocation, this._pointSize);
                var pointBuffer = glContext.createBuffer();
                glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray(points), glContext.STATIC_DRAW);
                glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                glContext.drawArrays(glContext.POINTS, 0, points.length);
                glContext.deleteBuffer(pointBuffer);
                cc.incrementGLDraws(1);
            },
            _pointsToTypeArray: function(points) {
                var typeArr = new Float32Array(2 * points.length);
                for (var i = 0; i < points.length; i++) {
                    typeArr[2 * i] = points[i].x;
                    typeArr[2 * i + 1] = points[i].y;
                }
                return typeArr;
            },
            drawLine: function(origin, destination) {
                this.lazy_init();
                var glContext = this._renderContext;
                this._shader.use();
                this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
                this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
                var pointBuffer = glContext.createBuffer();
                glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray([ origin, destination ]), glContext.STATIC_DRAW);
                glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                glContext.drawArrays(glContext.LINES, 0, 2);
                glContext.deleteBuffer(pointBuffer);
                cc.incrementGLDraws(1);
            },
            drawRect: function(origin, destination) {
                this.drawLine(cc.p(origin.x, origin.y), cc.p(destination.x, origin.y));
                this.drawLine(cc.p(destination.x, origin.y), cc.p(destination.x, destination.y));
                this.drawLine(cc.p(destination.x, destination.y), cc.p(origin.x, destination.y));
                this.drawLine(cc.p(origin.x, destination.y), cc.p(origin.x, origin.y));
            },
            drawSolidRect: function(origin, destination, color) {
                var vertices = [ origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y) ];
                this.drawSolidPoly(vertices, 4, color);
            },
            drawPoly: function(vertices, numOfVertices, closePolygon) {
                this.lazy_init();
                var glContext = this._renderContext;
                this._shader.use();
                this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
                this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
                var pointBuffer = glContext.createBuffer();
                glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray(vertices), glContext.STATIC_DRAW);
                glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                closePolygon ? glContext.drawArrays(glContext.LINE_LOOP, 0, vertices.length) : glContext.drawArrays(glContext.LINE_STRIP, 0, vertices.length);
                glContext.deleteBuffer(pointBuffer);
                cc.incrementGLDraws(1);
            },
            drawSolidPoly: function(poli, numberOfPoints, color) {
                this.lazy_init();
                color && this.setDrawColor(color.r, color.g, color.b, color.a);
                var glContext = this._renderContext;
                this._shader.use();
                this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
                this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
                var pointBuffer = glContext.createBuffer();
                glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                glContext.bufferData(glContext.ARRAY_BUFFER, this._pointsToTypeArray(poli), glContext.STATIC_DRAW);
                glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                glContext.drawArrays(glContext.TRIANGLE_FAN, 0, poli.length);
                glContext.deleteBuffer(pointBuffer);
                cc.incrementGLDraws(1);
            },
            drawCircle: function(center, radius, angle, segments, drawLineToCenter) {
                this.lazy_init();
                var additionalSegment = 1;
                drawLineToCenter && additionalSegment++;
                var coef = 2 * Math.PI / segments;
                var vertices = new Float32Array(2 * (segments + 2));
                if (!vertices) {
                    return;
                }
                for (var i = 0; i <= segments; i++) {
                    var rads = i * coef;
                    var j = radius * Math.cos(rads + angle) + center.x;
                    var k = radius * Math.sin(rads + angle) + center.y;
                    vertices[2 * i] = j;
                    vertices[2 * i + 1] = k;
                }
                vertices[2 * (segments + 1)] = center.x;
                vertices[2 * (segments + 1) + 1] = center.y;
                var glContext = this._renderContext;
                this._shader.use();
                this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
                this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
                var pointBuffer = glContext.createBuffer();
                glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
                glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                glContext.drawArrays(glContext.LINE_STRIP, 0, segments + additionalSegment);
                glContext.deleteBuffer(pointBuffer);
                cc.incrementGLDraws(1);
            },
            drawQuadBezier: function(origin, control, destination, segments) {
                this.lazy_init();
                var vertices = new Float32Array(2 * (segments + 1));
                var t = 0;
                for (var i = 0; i < segments; i++) {
                    vertices[2 * i] = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
                    vertices[2 * i + 1] = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
                    t += 1 / segments;
                }
                vertices[2 * segments] = destination.x;
                vertices[2 * segments + 1] = destination.y;
                var glContext = this._renderContext;
                this._shader.use();
                this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
                this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
                var pointBuffer = glContext.createBuffer();
                glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
                glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                glContext.drawArrays(glContext.LINE_STRIP, 0, segments + 1);
                glContext.deleteBuffer(pointBuffer);
                cc.incrementGLDraws(1);
            },
            drawCubicBezier: function(origin, control1, control2, destination, segments) {
                this.lazy_init();
                var vertices = new Float32Array(2 * (segments + 1));
                var t = 0;
                for (var i = 0; i < segments; i++) {
                    vertices[2 * i] = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
                    vertices[2 * i + 1] = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
                    t += 1 / segments;
                }
                vertices[2 * segments] = destination.x;
                vertices[2 * segments + 1] = destination.y;
                var glContext = this._renderContext;
                this._shader.use();
                this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
                this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
                var pointBuffer = glContext.createBuffer();
                glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
                glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                glContext.drawArrays(glContext.LINE_STRIP, 0, segments + 1);
                glContext.deleteBuffer(pointBuffer);
                cc.incrementGLDraws(1);
            },
            drawCatmullRom: function(points, segments) {
                this.drawCardinalSpline(points, .5, segments);
            },
            drawCardinalSpline: function(config, tension, segments) {
                this.lazy_init();
                var vertices = new Float32Array(2 * (segments + 1));
                var p, lt, deltaT = 1 / config.length;
                for (var i = 0; i < segments + 1; i++) {
                    var dt = i / segments;
                    if (1 === dt) {
                        p = config.length - 1;
                        lt = 1;
                    } else {
                        p = 0 | dt / deltaT;
                        lt = (dt - deltaT * p) / deltaT;
                    }
                    var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
                    vertices[2 * i] = newPos.x;
                    vertices[2 * i + 1] = newPos.y;
                }
                var glContext = this._renderContext;
                this._shader.use();
                this._shader.setUniformForModelViewAndProjectionMatrixWithMat4();
                glContext.enableVertexAttribArray(macro.VERTEX_ATTRIB_POSITION);
                this._shader.setUniformLocationWith4fv(this._colorLocation, this._colorArray);
                var pointBuffer = glContext.createBuffer();
                glContext.bindBuffer(glContext.ARRAY_BUFFER, pointBuffer);
                glContext.bufferData(glContext.ARRAY_BUFFER, vertices, glContext.STATIC_DRAW);
                glContext.vertexAttribPointer(macro.VERTEX_ATTRIB_POSITION, 2, glContext.FLOAT, false, 0, 0);
                glContext.drawArrays(glContext.LINE_STRIP, 0, segments + 1);
                glContext.deleteBuffer(pointBuffer);
                cc.incrementGLDraws(1);
            },
            setDrawColor: function(r, g, b, a) {
                this._colorArray[0] = r / 255;
                this._colorArray[1] = g / 255;
                this._colorArray[2] = b / 255;
                this._colorArray[3] = a / 255;
            },
            setPointSize: function(pointSize) {
                this._pointSize = pointSize;
            },
            setLineWidth: function(width) {
                this._renderContext.lineWidth && this._renderContext.lineWidth(width);
            }
        });
    }), {} ],
    40: [ (function(require, module, exports) {
        var EventTarget = require("./event/event-target");
        var View;
        View = require("./platform/CCView");
        require("../audio/CCAudioEngine");
        var game = {
            EVENT_HIDE: "game_on_hide",
            EVENT_SHOW: "game_on_show",
            EVENT_GAME_INITED: "game_inited",
            EVENT_RENDERER_INITED: "renderer_inited",
            RENDER_TYPE_CANVAS: 0,
            RENDER_TYPE_WEBGL: 1,
            RENDER_TYPE_OPENGL: 2,
            _persistRootNodes: {},
            _ignoreRemovePersistNode: null,
            CONFIG_KEY: {
                width: "width",
                height: "height",
                engineDir: "engineDir",
                debugMode: "debugMode",
                exposeClassName: "exposeClassName",
                showFPS: "showFPS",
                frameRate: "frameRate",
                id: "id",
                renderMode: "renderMode",
                registerSystemEvent: "registerSystemEvent",
                jsList: "jsList",
                scenes: "scenes"
            },
            _paused: true,
            _configLoaded: false,
            _isCloning: false,
            _prepareCalled: false,
            _prepared: false,
            _rendererInitialized: false,
            _renderContext: null,
            _intervalId: null,
            _lastTime: null,
            _frameTime: null,
            _sceneInfos: [],
            frame: null,
            container: null,
            canvas: null,
            config: null,
            onStart: null,
            setFrameRate: function(frameRate) {
                var self = this, config = self.config, CONFIG_KEY = self.CONFIG_KEY;
                config[CONFIG_KEY.frameRate] = frameRate;
                self._intervalId && window.cancelAnimFrame(self._intervalId);
                self._intervalId = 0;
                self._paused = true;
                self._setAnimFrame();
                self._runMainLoop();
            },
            step: function() {
                cc.director.mainLoop();
            },
            pause: function() {
                if (this._paused) {
                    return;
                }
                this._paused = true;
                cc.audioEngine && cc.audioEngine._break();
                this._intervalId && window.cancelAnimFrame(this._intervalId);
                this._intervalId = 0;
            },
            resume: function() {
                if (!this._paused) {
                    return;
                }
                this._paused = false;
                cc.audioEngine && cc.audioEngine._restore();
                this._runMainLoop();
            },
            isPaused: function() {
                return this._paused;
            },
            restart: function() {
                cc.director.popToSceneStackLevel(0);
                cc.audioEngine && cc.audioEngine.uncacheAll();
                game.onStart();
            },
            end: function() {
                close();
            },
            prepare: function(cb) {
                var self = this, config = self.config, CONFIG_KEY = self.CONFIG_KEY;
                if (!this._configLoaded) {
                    this._loadConfig((function() {
                        self.prepare(cb);
                    }));
                    return;
                }
                if (this._prepared) {
                    cb && cb();
                    return;
                }
                if (this._prepareCalled) {
                    return;
                }
                if (cc._engineLoaded) {
                    this._prepareCalled = true;
                    this._initRenderer(config[CONFIG_KEY.width], config[CONFIG_KEY.height]);
                    cc.view = View ? View._getInstance() : null;
                    cc.director = cc.Director._getInstance();
                    cc.director.setOpenGLView && cc.director.setOpenGLView(cc.view);
                    cc.winSize = cc.director.getWinSize();
                    this._initEvents();
                    this._setAnimFrame();
                    this._runMainLoop();
                    var jsList = config[CONFIG_KEY.jsList];
                    if (jsList && jsList.length > 0) {
                        cc.loader.load(jsList, (function(err) {
                            if (err) {
                                throw new Error(JSON.stringify(err));
                            }
                            self._prepared = true;
                            cb && cb();
                            self.emit(self.EVENT_GAME_INITED);
                        }));
                    } else {
                        cb && cb();
                        self.emit(self.EVENT_GAME_INITED);
                    }
                    return;
                }
                cc.initEngine(this.config, (function() {
                    self.prepare(cb);
                }));
            },
            run: function(config, onStart) {
                if ("function" === typeof config) {
                    game.onStart = config;
                } else {
                    config && (game.config = config);
                    "function" === typeof onStart && (game.onStart = onStart);
                }
                this.prepare(game.onStart && game.onStart.bind(game));
            },
            addPersistRootNode: function(node) {
                if (!cc.Node.isNode(node) || !node.uuid) {
                    cc.warnID(3800);
                    return;
                }
                var id = node.uuid;
                if (!this._persistRootNodes[id]) {
                    var scene = cc.director._scene;
                    if (cc.isValid(scene)) {
                        if (node.parent) {
                            if (!(node.parent instanceof cc.Scene)) {
                                cc.warnID(3801);
                                return;
                            }
                            if (node.parent !== scene) {
                                cc.warnID(3802);
                                return;
                            }
                        } else {
                            node.parent = scene;
                        }
                        this._persistRootNodes[id] = node;
                        node._persistNode = true;
                    }
                }
            },
            removePersistRootNode: function(node) {
                if (node !== this._ignoreRemovePersistNode) {
                    var id = node.uuid || "";
                    if (node === this._persistRootNodes[id]) {
                        delete this._persistRootNodes[id];
                        node._persistNode = false;
                    }
                }
            },
            isPersistRootNode: function(node) {
                return node._persistNode;
            },
            _setAnimFrame: function() {
                this._lastTime = new Date();
                var frameRate = game.config[game.CONFIG_KEY.frameRate];
                this._frameTime = 1e3 / frameRate;
                if (60 !== frameRate && 30 !== frameRate) {
                    window.requestAnimFrame = this._stTime;
                    window.cancelAnimFrame = this._ctTime;
                } else {
                    window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime;
                    window.cancelAnimFrame = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.oCancelAnimationFrame || this._ctTime;
                }
            },
            _stTime: function(callback) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, game._frameTime - (currTime - game._lastTime));
                var id = window.setTimeout((function() {
                    callback();
                }), timeToCall);
                game._lastTime = currTime + timeToCall;
                return id;
            },
            _ctTime: function(id) {
                window.clearTimeout(id);
            },
            _runMainLoop: function() {
                var self = this, callback, config = self.config, CONFIG_KEY = self.CONFIG_KEY, director = cc.director, skip = true, frameRate = config[CONFIG_KEY.frameRate];
                director.setDisplayStats(config[CONFIG_KEY.showFPS]);
                callback = function() {
                    if (!self._paused) {
                        if (30 === frameRate && (skip = !skip)) {
                            self._intervalId = window.requestAnimFrame(callback);
                            return;
                        }
                        director.mainLoop();
                        self._intervalId = window.requestAnimFrame(callback);
                    }
                };
                self._intervalId = window.requestAnimFrame(callback);
                self._paused = false;
            },
            _loadConfig: function(cb) {
                if (this.config) {
                    this._initConfig(this.config);
                    cb && cb();
                    return;
                }
                if (document["ccConfig"]) {
                    this._initConfig(document["ccConfig"]);
                    cb && cb();
                    return;
                }
                var self = this;
                cc.loader.load("project.json", (function(err, data) {
                    err && cc.logID(3818);
                    self._initConfig(data || {});
                    cb && cb();
                }));
            },
            _initConfig: function(config) {
                var CONFIG_KEY = this.CONFIG_KEY;
                "number" !== typeof config[CONFIG_KEY.debugMode] && (config[CONFIG_KEY.debugMode] = 0);
                config[CONFIG_KEY.exposeClassName] = !!config[CONFIG_KEY.exposeClassName];
                "number" !== typeof config[CONFIG_KEY.frameRate] && (config[CONFIG_KEY.frameRate] = 60);
                "number" !== typeof config[CONFIG_KEY.renderMode] && (config[CONFIG_KEY.renderMode] = 0);
                "boolean" !== typeof config[CONFIG_KEY.registerSystemEvent] && (config[CONFIG_KEY.registerSystemEvent] = true);
                config[CONFIG_KEY.showFPS] = !(CONFIG_KEY.showFPS in config) || !!config[CONFIG_KEY.showFPS];
                config[CONFIG_KEY.engineDir] = config[CONFIG_KEY.engineDir] || "frameworks/cocos2d-html5";
                this._sceneInfos = config[CONFIG_KEY.scenes] || [];
                this.collisionMatrix = config.collisionMatrix || [];
                this.groupList = config.groupList || [];
                cc._initDebugSetting(config[CONFIG_KEY.debugMode]);
                this.config = config;
                this._configLoaded = true;
            },
            _initRenderer: function(width, height) {
                if (this._rendererInitialized) {
                    return;
                }
                if (!cc._supportRender) {
                    throw new Error("The renderer doesn't support the renderMode " + this.config[this.CONFIG_KEY.renderMode]);
                }
                var el = this.config[game.CONFIG_KEY.id], win = window, element = cc.$(el) || cc.$("#" + el), localCanvas, localContainer, localConStyle;
                if ("CANVAS" === element.tagName) {
                    width = width || element.width;
                    height = height || element.height;
                    this.canvas = cc._canvas = localCanvas = element;
                    this.container = cc.container = localContainer = document.createElement("DIV");
                    localCanvas.parentNode && localCanvas.parentNode.insertBefore(localContainer, localCanvas);
                } else {
                    "DIV" !== element.tagName && cc.warnID(3819);
                    width = width || element.clientWidth;
                    height = height || element.clientHeight;
                    this.canvas = cc._canvas = localCanvas = document.createElement("CANVAS");
                    this.container = cc.container = localContainer = document.createElement("DIV");
                    element.appendChild(localContainer);
                }
                localContainer.setAttribute("id", "Cocos2dGameContainer");
                localContainer.appendChild(localCanvas);
                this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode;
                localCanvas.addClass("gameCanvas");
                localCanvas.setAttribute("width", width || 480);
                localCanvas.setAttribute("height", height || 320);
                localCanvas.setAttribute("tabindex", 99);
                cc._renderType === game.RENDER_TYPE_WEBGL && (this._renderContext = cc._renderContext = cc.webglContext = cc.create3DContext(localCanvas, {
                    stencil: true,
                    alpha: true,
                    antialias: cc.sys.isMobile
                }));
                if (this._renderContext) {
                    cc.renderer = cc.rendererWebGL;
                    win.gl = this._renderContext;
                    cc.renderer.init();
                    cc._drawingUtil = new cc.DrawingPrimitiveWebGL(this._renderContext);
                    cc.textureCache._initializingRenderer();
                    cc.glExt = {};
                    cc.glExt.instanced_arrays = win.gl.getExtension("ANGLE_instanced_arrays");
                    cc.glExt.element_uint = win.gl.getExtension("OES_element_index_uint");
                } else {
                    cc._renderType = game.RENDER_TYPE_CANVAS;
                    cc.renderer = cc.rendererCanvas;
                    cc.renderer.init();
                    this._renderContext = cc._renderContext = new cc.CanvasContextWrapper(localCanvas.getContext("2d"));
                    cc._drawingUtil = cc.DrawingPrimitiveCanvas ? new cc.DrawingPrimitiveCanvas(this._renderContext) : null;
                }
                cc._gameDiv = localContainer;
                game.canvas.oncontextmenu = function() {
                    if (!cc._isContextMenuEnable) {
                        return false;
                    }
                };
                this.emit(this.EVENT_RENDERER_INITED, true);
                this._rendererInitialized = true;
            },
            _initEvents: function() {
                var win = window, hidden, visibilityChange, _undef = "undefined";
                this.config[this.CONFIG_KEY.registerSystemEvent] && cc.inputManager.registerSystemEvent(this.canvas);
                "undefined" !== typeof document.hidden ? hidden = "hidden" : "undefined" !== typeof document.mozHidden ? hidden = "mozHidden" : "undefined" !== typeof document.msHidden ? hidden = "msHidden" : "undefined" !== typeof document.webkitHidden && (hidden = "webkitHidden");
                var changeList = [ "visibilitychange", "mozvisibilitychange", "msvisibilitychange", "webkitvisibilitychange", "qbrowserVisibilityChange" ];
                var onHidden = function() {
                    game.emit(game.EVENT_HIDE, game);
                };
                var onShow = function() {
                    game.emit(game.EVENT_SHOW, game);
                };
                if (hidden) {
                    for (var i = 0; i < changeList.length; i++) {
                        document.addEventListener(changeList[i], (function(event) {
                            var visible = document[hidden];
                            visible = visible || event["hidden"];
                            visible ? onHidden() : onShow();
                        }), false);
                    }
                } else {
                    win.addEventListener("blur", onHidden, false);
                    win.addEventListener("focus", onShow, false);
                }
                navigator.userAgent.indexOf("MicroMessenger") > -1 && (win.onfocus = function() {
                    onShow();
                });
                if ("onpageshow" in window && "onpagehide" in window) {
                    win.addEventListener("pagehide", onHidden, false);
                    win.addEventListener("pageshow", onShow, false);
                }
                this.on(game.EVENT_HIDE, (function() {
                    game.pause();
                }));
                this.on(game.EVENT_SHOW, (function() {
                    game.resume();
                }));
            }
        };
        EventTarget.call(game);
        cc.js.addon(game, EventTarget.prototype);
        cc.game = module.exports = game;
    }), {
        "../audio/CCAudioEngine": 24,
        "./event/event-target": 112,
        "./platform/CCView": 183
    } ],
    41: [ (function(require, module, exports) {
        "use strict";
        var PrefabHelper = require("./utils/prefab-helper");
        var SgHelper = require("./utils/scene-graph-helper");
        var Flags = cc.Object.Flags;
        var Destroying = Flags.Destroying;
        var POSITION_CHANGED = "position-changed";
        var SIZE_CHANGED = "size-changed";
        var ANCHOR_CHANGED = "anchor-changed";
        var ROTATION_CHANGED = "rotation-changed";
        var SCALE_CHANGED = "scale-changed";
        var CHILD_ADDED = "child-added";
        var CHILD_REMOVED = "child-removed";
        var CHILD_REORDER = "child-reorder";
        var ERR_INVALID_NUMBER = false;
        var Misc = require("./utils/misc");
        var ActionManagerExist = !!cc.ActionManager;
        var emptyFunc = function() {};
        var EventType = cc.Enum({
            TOUCH_START: "touchstart",
            TOUCH_MOVE: "touchmove",
            TOUCH_END: "touchend",
            TOUCH_CANCEL: "touchcancel",
            MOUSE_DOWN: "mousedown",
            MOUSE_MOVE: "mousemove",
            MOUSE_ENTER: "mouseenter",
            MOUSE_LEAVE: "mouseleave",
            MOUSE_UP: "mouseup",
            MOUSE_WHEEL: "mousewheel"
        });
        var _touchEvents = [ EventType.TOUCH_START, EventType.TOUCH_MOVE, EventType.TOUCH_END, EventType.TOUCH_CANCEL ];
        var _mouseEvents = [ EventType.MOUSE_DOWN, EventType.MOUSE_ENTER, EventType.MOUSE_MOVE, EventType.MOUSE_LEAVE, EventType.MOUSE_UP, EventType.MOUSE_WHEEL ];
        var _currentHovered = null;
        var _touchStartHandler = function(touch, event) {
            var pos = touch.getLocation();
            var node = this.owner;
            if (node._hitTest(pos, this)) {
                event.type = EventType.TOUCH_START;
                event.touch = touch;
                event.bubbles = true;
                node.dispatchEvent(event);
                return true;
            }
            return false;
        };
        var _touchMoveHandler = function(touch, event) {
            var node = this.owner;
            event.type = EventType.TOUCH_MOVE;
            event.touch = touch;
            event.bubbles = true;
            node.dispatchEvent(event);
        };
        var _touchEndHandler = function(touch, event) {
            var pos = touch.getLocation();
            var node = this.owner;
            node._hitTest(pos, this) ? event.type = EventType.TOUCH_END : event.type = EventType.TOUCH_CANCEL;
            event.touch = touch;
            event.bubbles = true;
            node.dispatchEvent(event);
        };
        var _mouseDownHandler = function(event) {
            var pos = event.getLocation();
            var node = this.owner;
            if (node._hitTest(pos, this)) {
                event.type = EventType.MOUSE_DOWN;
                node.dispatchEvent(event);
                event.stopPropagation();
            }
        };
        var _mouseMoveHandler = function(event) {
            var pos = event.getLocation();
            var node = this.owner;
            if (node._hitTest(pos, this)) {
                event.stopPropagation();
                if (!this._previousIn) {
                    if (_currentHovered) {
                        event.type = EventType.MOUSE_LEAVE;
                        _currentHovered.dispatchEvent(event);
                        _currentHovered._mouseListener._previousIn = false;
                    }
                    _currentHovered = this.owner;
                    event.type = EventType.MOUSE_ENTER;
                    node.dispatchEvent(event);
                    this._previousIn = true;
                }
                event.type = EventType.MOUSE_MOVE;
                node.dispatchEvent(event);
            } else {
                if (this._previousIn) {
                    event.type = EventType.MOUSE_LEAVE;
                    node.dispatchEvent(event);
                    this._previousIn = false;
                    _currentHovered = null;
                }
            }
        };
        var _mouseUpHandler = function(event) {
            var pos = event.getLocation();
            var node = this.owner;
            if (node._hitTest(pos, this)) {
                event.type = EventType.MOUSE_UP;
                node.dispatchEvent(event);
                event.stopPropagation();
            }
        };
        var _mouseWheelHandler = function(event) {
            var pos = event.getLocation();
            var node = this.owner;
            if (node._hitTest(pos, this)) {
                event.type = EventType.MOUSE_WHEEL;
                node.dispatchEvent(event);
            }
        };
        function _searchMaskInParent(node) {
            var Mask = cc.Mask;
            if (Mask) {
                var index = 0;
                for (var curr = node; curr && cc.Node.isNode(curr); curr = curr._parent, ++index) {
                    if (curr.getComponent(Mask)) {
                        return {
                            index: index,
                            node: curr
                        };
                    }
                }
            }
            return null;
        }
        function updateOrder(node) {
            node._parent._delaySort();
            cc.eventManager._setDirtyForNode(node);
        }
        var Node = cc.Class({
            name: "cc.Node",
            extends: require("./utils/base-node"),
            properties: {
                _opacity: 255,
                _color: cc.Color.WHITE,
                _cascadeOpacityEnabled: true,
                _anchorPoint: cc.p(.5, .5),
                _contentSize: cc.size(0, 0),
                _rotationX: 0,
                _rotationY: 0,
                _scaleX: 1,
                _scaleY: 1,
                _position: cc.p(0, 0),
                _skewX: 0,
                _skewY: 0,
                _localZOrder: 0,
                _globalZOrder: 0,
                _opacityModifyRGB: false,
                groupIndex: {
                    default: 0,
                    type: cc.Integer
                },
                group: {
                    get: function() {
                        return cc.game.groupList[this.groupIndex] || "";
                    },
                    set: function(value) {
                        this.groupIndex = cc.game.groupList.indexOf(value);
                        this.emit("group-changed");
                    }
                },
                x: {
                    get: function() {
                        return this._position.x;
                    },
                    set: function(value) {
                        var localPosition = this._position;
                        if (value !== localPosition.x) {
                            var oldValue;
                            localPosition.x = value;
                            this._sgNode.setPositionX(value);
                            var capListeners = this._capturingListeners && this._capturingListeners._callbackTable[POSITION_CHANGED];
                            var bubListeners = this._bubblingListeners && this._bubblingListeners._callbackTable[POSITION_CHANGED];
                            (capListeners && capListeners.length > 0 || bubListeners && bubListeners.length > 0) && this.emit(POSITION_CHANGED);
                        }
                    }
                },
                y: {
                    get: function() {
                        return this._position.y;
                    },
                    set: function(value) {
                        var localPosition = this._position;
                        if (value !== localPosition.y) {
                            var oldValue;
                            localPosition.y = value;
                            this._sgNode.setPositionY(value);
                            var capListeners = this._capturingListeners && this._capturingListeners._callbackTable[POSITION_CHANGED];
                            var bubListeners = this._bubblingListeners && this._bubblingListeners._callbackTable[POSITION_CHANGED];
                            (capListeners && capListeners.length > 0 || bubListeners && bubListeners.length > 0) && this.emit(POSITION_CHANGED);
                        }
                    }
                },
                rotation: {
                    get: function() {
                        this._rotationX !== this._rotationY && cc.logID(1602);
                        return this._rotationX;
                    },
                    set: function(value) {
                        if (this._rotationX !== value || this._rotationY !== value) {
                            this._rotationX = this._rotationY = value;
                            this._sgNode.rotation = value;
                            this.emit(ROTATION_CHANGED);
                        }
                    }
                },
                rotationX: {
                    get: function() {
                        return this._rotationX;
                    },
                    set: function(value) {
                        if (this._rotationX !== value) {
                            this._rotationX = value;
                            this._sgNode.rotationX = value;
                            this.emit(ROTATION_CHANGED);
                        }
                    }
                },
                rotationY: {
                    get: function() {
                        return this._rotationY;
                    },
                    set: function(value) {
                        if (this._rotationY !== value) {
                            this._rotationY = value;
                            this._sgNode.rotationY = value;
                            this.emit(ROTATION_CHANGED);
                        }
                    }
                },
                scaleX: {
                    get: function() {
                        return this._scaleX;
                    },
                    set: function(value) {
                        if (this._scaleX !== value) {
                            this._scaleX = value;
                            this._sgNode.scaleX = value;
                            this.emit(SCALE_CHANGED);
                        }
                    }
                },
                scaleY: {
                    get: function() {
                        return this._scaleY;
                    },
                    set: function(value) {
                        if (this._scaleY !== value) {
                            this._scaleY = value;
                            this._sgNode.scaleY = value;
                            this.emit(SCALE_CHANGED);
                        }
                    }
                },
                skewX: {
                    get: function() {
                        return this._skewX;
                    },
                    set: function(value) {
                        this._skewX = value;
                        this._sgNode.skewX = value;
                    }
                },
                skewY: {
                    get: function() {
                        return this._skewY;
                    },
                    set: function(value) {
                        this._skewY = value;
                        this._sgNode.skewY = value;
                    }
                },
                opacity: {
                    get: function() {
                        return this._opacity;
                    },
                    set: function(value) {
                        if (this._opacity !== value) {
                            this._opacity = value;
                            this._sgNode.setOpacity(value);
                            if (!this._cascadeOpacityEnabled) {
                                var sizeProvider = this._sizeProvider;
                                sizeProvider instanceof _ccsg.Node && sizeProvider !== this._sgNode && sizeProvider.setOpacity(value);
                            }
                        }
                    },
                    range: [ 0, 255 ]
                },
                cascadeOpacity: {
                    get: function() {
                        return this._cascadeOpacityEnabled;
                    },
                    set: function(value) {
                        if (this._cascadeOpacityEnabled !== value) {
                            this._cascadeOpacityEnabled = value;
                            this._sgNode.cascadeOpacity = value;
                            var opacity = value ? 255 : this._opacity;
                            var sizeProvider = this._sizeProvider;
                            sizeProvider instanceof _ccsg.Node && sizeProvider.setOpacity(opacity);
                        }
                    }
                },
                color: {
                    get: function() {
                        return this._color.clone();
                    },
                    set: function(value) {
                        if (!this._color.equals(value)) {
                            this._color.fromColor(value);
                            255 !== value.a && cc.warnID(1626);
                            this._sizeProvider instanceof _ccsg.Node && this._sizeProvider.setColor(value);
                        }
                    }
                },
                anchorX: {
                    get: function() {
                        return this._anchorPoint.x;
                    },
                    set: function(value) {
                        var anchorPoint = this._anchorPoint;
                        if (anchorPoint.x !== value) {
                            anchorPoint.x = value;
                            var sizeProvider = this._sizeProvider;
                            sizeProvider instanceof _ccsg.Node && sizeProvider.setAnchorPoint(anchorPoint);
                            this.emit(ANCHOR_CHANGED);
                        }
                    }
                },
                anchorY: {
                    get: function() {
                        return this._anchorPoint.y;
                    },
                    set: function(value) {
                        var anchorPoint = this._anchorPoint;
                        if (anchorPoint.y !== value) {
                            anchorPoint.y = value;
                            var sizeProvider = this._sizeProvider;
                            sizeProvider instanceof _ccsg.Node && sizeProvider.setAnchorPoint(anchorPoint);
                            this.emit(ANCHOR_CHANGED);
                        }
                    }
                },
                width: {
                    get: function() {
                        if (this._sizeProvider) {
                            var w = this._sizeProvider._getWidth();
                            this._contentSize.width = w;
                            return w;
                        }
                        return this._contentSize.width;
                    },
                    set: function(value) {
                        if (value !== this._contentSize.width) {
                            var sizeProvider = this._sizeProvider;
                            sizeProvider && sizeProvider.setContentSize(value, sizeProvider._getHeight());
                            var clone;
                            this._contentSize.width = value;
                            this.emit(SIZE_CHANGED);
                        }
                    }
                },
                height: {
                    get: function() {
                        if (this._sizeProvider) {
                            var h = this._sizeProvider._getHeight();
                            this._contentSize.height = h;
                            return h;
                        }
                        return this._contentSize.height;
                    },
                    set: function(value) {
                        if (value !== this._contentSize.height) {
                            var sizeProvider = this._sizeProvider;
                            sizeProvider && sizeProvider.setContentSize(sizeProvider._getWidth(), value);
                            var clone;
                            this._contentSize.height = value;
                            this.emit(SIZE_CHANGED);
                        }
                    }
                },
                _ignoreAnchor: {
                    get: function() {
                        return this.__ignoreAnchor;
                    },
                    set: function(value) {
                        if (this.__ignoreAnchor !== value) {
                            this.__ignoreAnchor = value;
                            this._sgNode.ignoreAnchor = value;
                            var sizeProvider = this._sizeProvider;
                            sizeProvider instanceof _ccsg.Node && sizeProvider !== this._sgNode && (sizeProvider.ignoreAnchor = value);
                            this.emit(ANCHOR_CHANGED);
                        }
                    }
                },
                zIndex: {
                    get: function() {
                        return this._localZOrder;
                    },
                    set: function(value) {
                        if (this._localZOrder !== value) {
                            this._localZOrder = value;
                            this._sgNode.zIndex = value;
                            this._parent && updateOrder(this);
                        }
                    }
                }
            },
            ctor: function(name) {
                var sgNode = this._sgNode = new _ccsg.Node();
                cc.game._isCloning || (sgNode.cascadeOpacity = true);
                this._sizeProvider = null;
                this.__ignoreAnchor = false;
                this._reorderChildDirty = false;
                this._widget = null;
                this._touchListener = null;
                this._mouseListener = null;
            },
            statics: {
                isNode: function(obj) {
                    return obj instanceof Node && (obj.constructor === Node || !(obj instanceof cc.Scene));
                }
            },
            _onSetParent: function(value) {
                var sgNode = this._sgNode;
                sgNode.parent && sgNode.parent.removeChild(sgNode, false);
                if (value) {
                    value._sgNode.addChild(sgNode);
                    value._delaySort();
                }
            },
            _onSiblingIndexChanged: function(index) {
                var parent = this._parent;
                var siblings = parent._children;
                var i = 0, len = siblings.length, sibling;
                var zOrder;
                var nextSibling;
                for (;i < len; i++) {
                    sibling = siblings[i]._sgNode;
                    sibling._arrivalOrder = i;
                    cc.eventManager._setDirtyForNode(sibling);
                }
                cc.renderer.childrenOrderDirty = true;
                parent._sgNode._reorderChildDirty = true;
                parent._delaySort();
            },
            _onPreDestroy: function() {
                var destroyByParent = this._onPreDestroyBase();
                ActionManagerExist && cc.director.getActionManager().removeAllActionsFromTarget(this);
                _currentHovered === this && (_currentHovered = null);
                this._reorderChildDirty && cc.director.__fastOff(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
                cc.eventManager.removeListeners(this);
                destroyByParent || this._removeSgNode();
            },
            _onPostActivated: function(active) {
                var actionManager = ActionManagerExist ? cc.director.getActionManager() : null;
                if (active) {
                    actionManager && actionManager.resumeTarget(this);
                    cc.eventManager.resumeTarget(this);
                    if (this._touchListener) {
                        var mask = this._touchListener.mask = _searchMaskInParent(this);
                        this._mouseListener && (this._mouseListener.mask = mask);
                    } else {
                        this._mouseListener && (this._mouseListener.mask = _searchMaskInParent(this));
                    }
                } else {
                    actionManager && actionManager.pauseTarget(this);
                    cc.eventManager.pauseTarget(this);
                }
            },
            _onHierarchyChanged: function(oldParent) {
                this._onHierarchyChangedBase(oldParent);
                cc._widgetManager._nodesOrderDirty = true;
            },
            _onBatchCreated: function() {
                var prefabInfo = this._prefab;
                prefabInfo && prefabInfo.sync && !prefabInfo._synced && prefabInfo.root === this && PrefabHelper.syncWithPrefab(this);
                this._updateDummySgNode();
                this._parent && this._parent._sgNode.addChild(this._sgNode);
                if (!this._activeInHierarchy) {
                    ActionManagerExist && cc.director.getActionManager().pauseTarget(this);
                    cc.eventManager.pauseTarget(this);
                }
                var children = this._children;
                for (var i = 0, len = children.length; i < len; i++) {
                    children[i]._onBatchCreated();
                }
            },
            on: function(type, callback, target, useCapture) {
                var newAdded = false;
                if (_touchEvents.indexOf(type) !== -1) {
                    if (!this._touchListener) {
                        this._touchListener = cc.EventListener.create({
                            event: cc.EventListener.TOUCH_ONE_BY_ONE,
                            swallowTouches: true,
                            owner: this,
                            mask: _searchMaskInParent(this),
                            onTouchBegan: _touchStartHandler,
                            onTouchMoved: _touchMoveHandler,
                            onTouchEnded: _touchEndHandler
                        });
                        cc.eventManager.addListener(this._touchListener, this);
                        newAdded = true;
                    }
                } else {
                    if (_mouseEvents.indexOf(type) !== -1 && !this._mouseListener) {
                        this._mouseListener = cc.EventListener.create({
                            event: cc.EventListener.MOUSE,
                            _previousIn: false,
                            owner: this,
                            mask: _searchMaskInParent(this),
                            onMouseDown: _mouseDownHandler,
                            onMouseMove: _mouseMoveHandler,
                            onMouseUp: _mouseUpHandler,
                            onMouseScroll: _mouseWheelHandler
                        });
                        cc.eventManager.addListener(this._mouseListener, this);
                        newAdded = true;
                    }
                }
                newAdded && !this._activeInHierarchy && cc.director.getScheduler().schedule((function() {
                    this._activeInHierarchy || cc.eventManager.pauseTarget(this);
                }), this, 0, 0, 0, false);
                return this._EventTargetOn(type, callback, target, useCapture);
            },
            off: function(type, callback, target, useCapture) {
                this._EventTargetOff(type, callback, target, useCapture);
                _touchEvents.indexOf(type) !== -1 ? this._checkTouchListeners() : _mouseEvents.indexOf(type) !== -1 && this._checkMouseListeners();
            },
            targetOff: function(target) {
                this._EventTargetTargetOff(target);
                this._checkTouchListeners();
                this._checkMouseListeners();
            },
            pauseSystemEvents: function(recursive) {
                cc.eventManager.pauseTarget(this, recursive);
            },
            resumeSystemEvents: function(recursive) {
                cc.eventManager.resumeTarget(this, recursive);
            },
            _checkTouchListeners: function() {
                if (!(this._objFlags & Destroying) && this._touchListener) {
                    var i = 0;
                    if (this._bubblingListeners) {
                        for (;i < _touchEvents.length; ++i) {
                            if (this._bubblingListeners.has(_touchEvents[i])) {
                                return;
                            }
                        }
                    }
                    if (this._capturingListeners) {
                        for (;i < _touchEvents.length; ++i) {
                            if (this._capturingListeners.has(_touchEvents[i])) {
                                return;
                            }
                        }
                    }
                    cc.eventManager.removeListener(this._touchListener);
                    this._touchListener = null;
                }
            },
            _checkMouseListeners: function() {
                if (!(this._objFlags & Destroying) && this._mouseListener) {
                    var i = 0;
                    if (this._bubblingListeners) {
                        for (;i < _mouseEvents.length; ++i) {
                            if (this._bubblingListeners.has(_mouseEvents[i])) {
                                return;
                            }
                        }
                    }
                    if (this._capturingListeners) {
                        for (;i < _mouseEvents.length; ++i) {
                            if (this._capturingListeners.has(_mouseEvents[i])) {
                                return;
                            }
                        }
                    }
                    _currentHovered === this && (_currentHovered = null);
                    cc.eventManager.removeListener(this._mouseListener);
                    this._mouseListener = null;
                }
            },
            _hitTest: function(point, listener) {
                var w = this.width, h = this.height;
                var rect = cc.rect(0, 0, w, h);
                var trans = this.getNodeToWorldTransform();
                cc._rectApplyAffineTransformIn(rect, trans);
                var left = point.x - rect.x, right = rect.x + rect.width - point.x, bottom = point.y - rect.y, top = rect.y + rect.height - point.y;
                if (left >= 0 && right >= 0 && top >= 0 && bottom >= 0) {
                    if (listener && listener.mask) {
                        var mask = listener.mask;
                        var parent = this;
                        for (var i = 0; parent && i < mask.index; ++i, parent = parent.parent) {}
                        if (parent === mask.node) {
                            var comp = parent.getComponent(cc.Mask);
                            return !comp || !comp.enabledInHierarchy || comp._hitTest(point);
                        }
                        listener.mask = null;
                        return true;
                    }
                    return true;
                }
                return false;
            },
            _getCapturingTargets: function(type, array) {
                var parent = this.parent;
                while (parent) {
                    parent.hasEventListener(type, true) && array.push(parent);
                    parent = parent.parent;
                }
            },
            _getBubblingTargets: function(type, array) {
                var parent = this.parent;
                while (parent) {
                    parent.hasEventListener(type) && array.push(parent);
                    parent = parent.parent;
                }
            },
            isRunning: function() {
                return this._activeInHierarchy;
            },
            runAction: ActionManagerExist ? function(action) {
                if (!this.active) {
                    return;
                }
                cc.assertID(action, 1618);
                cc.macro.ENABLE_GC_FOR_NATIVE_OBJECTS || this._retainAction(action);
                cc.director.getActionManager().addAction(action, this, false);
                return action;
            } : emptyFunc,
            pauseAllActions: ActionManagerExist ? function() {
                cc.director.getActionManager().pauseTarget(this);
            } : emptyFunc,
            resumeAllActions: ActionManagerExist ? function() {
                cc.director.getActionManager().resumeTarget(this);
            } : emptyFunc,
            stopAllActions: ActionManagerExist ? function() {
                cc.director.getActionManager().removeAllActionsFromTarget(this);
            } : emptyFunc,
            stopAction: ActionManagerExist ? function(action) {
                cc.director.getActionManager().removeAction(action);
            } : emptyFunc,
            stopActionByTag: ActionManagerExist ? function(tag) {
                if (tag === cc.Action.TAG_INVALID) {
                    cc.logID(1612);
                    return;
                }
                cc.director.getActionManager().removeActionByTag(tag, this);
            } : emptyFunc,
            getActionByTag: ActionManagerExist ? function(tag) {
                if (tag === cc.Action.TAG_INVALID) {
                    cc.logID(1613);
                    return null;
                }
                return cc.director.getActionManager().getActionByTag(tag, this);
            } : function() {
                return null;
            },
            getNumberOfRunningActions: ActionManagerExist ? function() {
                return cc.director.getActionManager().getNumberOfRunningActionsInTarget(this);
            } : function() {
                return 0;
            },
            _retainAction: function(action) {},
            _releaseAllActions: function() {
                var i;
            },
            setTag: function(value) {
                this._tag = value;
                this._sgNode.tag = value;
            },
            getPosition: function() {
                return new cc.Vec2(this._position);
            },
            setPosition: function(newPosOrX, y) {
                var x;
                if ("undefined" === typeof y) {
                    x = newPosOrX.x;
                    y = newPosOrX.y;
                } else {
                    x = newPosOrX;
                }
                var locPosition = this._position;
                if (locPosition.x === x && locPosition.y === y) {
                    return;
                }
                var oldPosition;
                locPosition.x = x;
                locPosition.y = y;
                this._sgNode.setPosition(x, y);
                var capListeners = this._capturingListeners && this._capturingListeners._callbackTable[POSITION_CHANGED];
                var bubListeners = this._bubblingListeners && this._bubblingListeners._callbackTable[POSITION_CHANGED];
                (capListeners && capListeners.length > 0 || bubListeners && bubListeners.length > 0) && this.emit(POSITION_CHANGED);
            },
            getScale: function() {
                this._scaleX !== this._scaleY && cc.logID(1603);
                return this._scaleX;
            },
            setScale: function(scaleX, scaleY) {
                if ("object" === typeof scaleX) {
                    scaleY = scaleX.y;
                    scaleX = scaleX.x;
                } else {
                    scaleY = scaleY || 0 === scaleY ? scaleY : scaleX;
                }
                if (this._scaleX !== scaleX || this._scaleY !== scaleY) {
                    this._scaleX = scaleX;
                    this._scaleY = scaleY;
                    this._sgNode.setScale(scaleX, scaleY);
                    this.emit(SCALE_CHANGED);
                }
            },
            getContentSize: function(ignoreSizeProvider) {
                if (this._sizeProvider && !ignoreSizeProvider) {
                    var size = this._sizeProvider.getContentSize();
                    this._contentSize = size;
                    return cc.size(size);
                }
                return cc.size(this._contentSize);
            },
            setContentSize: function(size, height) {
                var locContentSize = this._contentSize;
                var clone;
                if (void 0 === height) {
                    if (size.width === locContentSize.width && size.height === locContentSize.height) {
                        return;
                    }
                    locContentSize.width = size.width;
                    locContentSize.height = size.height;
                } else {
                    if (size === locContentSize.width && height === locContentSize.height) {
                        return;
                    }
                    locContentSize.width = size;
                    locContentSize.height = height;
                }
                this._sizeProvider && this._sizeProvider.setContentSize(locContentSize);
                this.emit(SIZE_CHANGED);
            },
            setOpacityModifyRGB: function(opacityValue) {
                if (this._opacityModifyRGB !== opacityValue) {
                    this._opacityModifyRGB = opacityValue;
                    this._sgNode.setOpacityModifyRGB(opacityValue);
                    var sizeProvider = this._sizeProvider;
                    sizeProvider instanceof _ccsg.Node && sizeProvider !== this._sgNode && sizeProvider.setOpacityModifyRGB(opacityValue);
                }
            },
            isOpacityModifyRGB: function() {
                return this._opacityModifyRGB;
            },
            setGlobalZOrder: function(globalZOrder) {
                this._globalZOrder = globalZOrder;
                this._sgNode.setGlobalZOrder(globalZOrder);
            },
            getGlobalZOrder: function() {
                this._globalZOrder = this._sgNode.getGlobalZOrder();
                return this._globalZOrder;
            },
            getAnchorPoint: function() {
                return cc.p(this._anchorPoint);
            },
            setAnchorPoint: function(point, y) {
                var locAnchorPoint = this._anchorPoint;
                if (void 0 === y) {
                    if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) {
                        return;
                    }
                    locAnchorPoint.x = point.x;
                    locAnchorPoint.y = point.y;
                } else {
                    if (point === locAnchorPoint.x && y === locAnchorPoint.y) {
                        return;
                    }
                    locAnchorPoint.x = point;
                    locAnchorPoint.y = y;
                }
                var sizeProvider = this._sizeProvider;
                sizeProvider instanceof _ccsg.Node && sizeProvider.setAnchorPoint(locAnchorPoint);
                this.emit(ANCHOR_CHANGED);
            },
            getAnchorPointInPoints: function() {
                return this._sgNode.getAnchorPointInPoints();
            },
            getDisplayedOpacity: function() {
                return this._sgNode.getDisplayedOpacity();
            },
            _updateDisplayedOpacity: function(parentOpacity) {
                this._sgNode.updateDisplayedOpacity(parentOpacity);
            },
            getDisplayedColor: function() {
                return this._sgNode.getDisplayedColor();
            },
            getNodeToParentTransformAR: function() {
                var contentSize = this.getContentSize();
                var mat = this._sgNode.getNodeToParentTransform();
                if (!this._isSgTransformArToMe(contentSize)) {
                    var tx = this._anchorPoint.x * contentSize.width;
                    var ty = this._anchorPoint.y * contentSize.height;
                    var offset = cc.affineTransformMake(1, 0, 0, 1, tx, ty);
                    mat = cc.affineTransformConcatIn(offset, mat);
                }
                return mat;
            },
            getBoundingBox: function() {
                var size = this.getContentSize();
                var rect = cc.rect(0, 0, size.width, size.height);
                return cc._rectApplyAffineTransformIn(rect, this.getNodeToParentTransform());
            },
            getBoundingBoxToWorld: function() {
                var trans;
                this.parent && (trans = this.parent.getNodeToWorldTransformAR());
                return this._getBoundingBoxTo(trans);
            },
            _getBoundingBoxTo: function(parentTransformAR) {
                var size = this.getContentSize();
                var width = size.width;
                var height = size.height;
                var rect = cc.rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                var transAR = cc.affineTransformConcat(this.getNodeToParentTransformAR(), parentTransformAR);
                cc._rectApplyAffineTransformIn(rect, transAR);
                if (!this._children) {
                    return rect;
                }
                var locChildren = this._children;
                for (var i = 0; i < locChildren.length; i++) {
                    var child = locChildren[i];
                    if (child && child.active) {
                        var childRect = child._getBoundingBoxTo(transAR);
                        childRect && (rect = cc.rectUnion(rect, childRect));
                    }
                }
                return rect;
            },
            getNodeToParentTransform: function() {
                var contentSize = this.getContentSize();
                var mat = this._sgNode.getNodeToParentTransform();
                if (this._isSgTransformArToMe(contentSize)) {
                    var tx = -this._anchorPoint.x * contentSize.width;
                    var ty = -this._anchorPoint.y * contentSize.height;
                    var offset = cc.affineTransformMake(1, 0, 0, 1, tx, ty);
                    mat = cc.affineTransformConcatIn(offset, mat);
                }
                return mat;
            },
            getNodeToWorldTransform: function() {
                var contentSize = this.getContentSize();
                cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
                var mat = this._sgNode.getNodeToWorldTransform();
                if (this._isSgTransformArToMe(contentSize)) {
                    var tx = -this._anchorPoint.x * contentSize.width;
                    var ty = -this._anchorPoint.y * contentSize.height;
                    var offset = cc.affineTransformMake(1, 0, 0, 1, tx, ty);
                    mat = cc.affineTransformConcatIn(offset, mat);
                }
                return mat;
            },
            getNodeToWorldTransformAR: function() {
                var contentSize = this.getContentSize();
                cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
                var mat = this._sgNode.getNodeToWorldTransform();
                if (!this._isSgTransformArToMe(contentSize)) {
                    var tx = this._anchorPoint.x * contentSize.width;
                    var ty = this._anchorPoint.y * contentSize.height;
                    var offset = cc.affineTransformMake(1, 0, 0, 1, tx, ty);
                    mat = cc.affineTransformConcatIn(offset, mat);
                }
                return mat;
            },
            getParentToNodeTransform: function() {
                return this._sgNode.getParentToNodeTransform();
            },
            getWorldToNodeTransform: function() {
                cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
                return this._sgNode.getWorldToNodeTransform();
            },
            _isSgTransformArToMe: function(myContentSize) {
                var renderSize = this._sgNode.getContentSize();
                if (0 === renderSize.width && 0 === renderSize.height && (0 !== myContentSize.width || 0 !== myContentSize.height)) {
                    return true;
                }
                if (this._sgNode.isIgnoreAnchorPointForPosition()) {
                    return true;
                }
                return false;
            },
            convertToNodeSpace: function(worldPoint) {
                cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
                var nodePositionIgnoreAnchorPoint = this._sgNode.convertToNodeSpace(worldPoint);
                return cc.pAdd(nodePositionIgnoreAnchorPoint, cc.p(this._anchorPoint.x * this._contentSize.width, this._anchorPoint.y * this._contentSize.height));
            },
            convertToWorldSpace: function(nodePoint) {
                cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
                var x = nodePoint.x - this._anchorPoint.x * this._contentSize.width;
                var y = nodePoint.y - this._anchorPoint.y * this._contentSize.height;
                return cc.v2(this._sgNode.convertToWorldSpace(cc.v2(x, y)));
            },
            convertToNodeSpaceAR: function(worldPoint) {
                cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
                return this._sgNode.isIgnoreAnchorPointForPosition() ? cc.v2(this._sgNode.convertToNodeSpace(worldPoint)) : this._sgNode.convertToNodeSpaceAR(worldPoint);
            },
            convertToWorldSpaceAR: function(nodePoint) {
                cc._renderType === cc.game.RENDER_TYPE_CANVAS && cc.director._visitScene();
                return this._sgNode.isIgnoreAnchorPointForPosition() ? cc.v2(this._sgNode.convertToWorldSpace(nodePoint)) : cc.v2(this._sgNode.convertToWorldSpaceAR(nodePoint));
            },
            convertTouchToNodeSpace: function(touch) {
                return this.convertToNodeSpace(touch.getLocation());
            },
            convertTouchToNodeSpaceAR: function(touch) {
                return this.convertToNodeSpaceAR(touch.getLocation());
            },
            setNodeDirty: function() {
                this._sgNode.setNodeDirty();
            },
            addChild: function(child, localZOrder, tag) {
                localZOrder = void 0 === localZOrder ? child._localZOrder : localZOrder;
                var name, setTag = false;
                if ("undefined" === typeof tag) {
                    tag = void 0;
                    name = child._name;
                } else {
                    if (cc.js.isString(tag)) {
                        name = tag;
                        tag = void 0;
                    } else {
                        if (cc.js.isNumber(tag)) {
                            setTag = true;
                            name = "";
                        }
                    }
                }
                if (!cc.Node.isNode(child)) {
                    return cc.errorID(1634, cc.js.getClassName(child));
                }
                cc.assertID(child, 1606);
                cc.assertID(null === child._parent, 1605);
                child.parent = this;
                child.zIndex = localZOrder;
                setTag ? child.setTag(tag) : child.setName(name);
            },
            cleanup: function() {
                ActionManagerExist && cc.director.getActionManager().removeAllActionsFromTarget(this);
                cc.eventManager.removeListeners(this);
                var i, len = this._children.length, node;
                for (i = 0; i < len; ++i) {
                    node = this._children[i];
                    node && node.cleanup();
                }
            },
            sortAllChildren: function() {
                if (this._reorderChildDirty) {
                    this._reorderChildDirty = false;
                    var _children = this._children;
                    if (_children.length > 1) {
                        var len = _children.length, i, j, child;
                        for (i = 1; i < len; i++) {
                            child = _children[i];
                            j = i - 1;
                            while (j >= 0) {
                                if (child._localZOrder < _children[j]._localZOrder) {
                                    _children[j + 1] = _children[j];
                                } else {
                                    if (!(child._localZOrder === _children[j]._localZOrder && child._sgNode._arrivalOrder < _children[j]._sgNode._arrivalOrder)) {
                                        break;
                                    }
                                    _children[j + 1] = _children[j];
                                }
                                j--;
                            }
                            _children[j + 1] = child;
                        }
                        this.emit(CHILD_REORDER);
                    }
                    cc.director.__fastOff(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
                }
            },
            _delaySort: function() {
                if (!this._reorderChildDirty) {
                    this._reorderChildDirty = true;
                    cc.director.__fastOn(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
                }
            },
            _updateDummySgNode: function() {
                var self = this;
                var sgNode = self._sgNode;
                sgNode.setPosition(self._position);
                sgNode.setRotationX(self._rotationX);
                sgNode.setRotationY(self._rotationY);
                sgNode.setScale(self._scaleX, self._scaleY);
                sgNode.setSkewX(self._skewX);
                sgNode.setSkewY(self._skewY);
                sgNode.setIgnoreAnchorPointForPosition(self.__ignoreAnchor);
                var arrivalOrder = sgNode._arrivalOrder;
                sgNode.setLocalZOrder(self._localZOrder);
                sgNode._arrivalOrder = arrivalOrder;
                sgNode.setGlobalZOrder(self._globalZOrder);
                sgNode.setOpacity(self._opacity);
                sgNode.setOpacityModifyRGB(self._opacityModifyRGB);
                sgNode.setCascadeOpacityEnabled(self._cascadeOpacityEnabled);
                sgNode.setTag(self._tag);
            },
            _updateSgNode: function() {
                this._updateDummySgNode();
                var sgNode = this._sgNode;
                sgNode.setAnchorPoint(this._anchorPoint);
                sgNode.setVisible(this._active);
                sgNode.setColor(this._color);
                var actionManager = ActionManagerExist ? cc.director.getActionManager() : null;
                if (this._activeInHierarchy) {
                    actionManager && actionManager.resumeTarget(this);
                    cc.eventManager.resumeTarget(this);
                } else {
                    actionManager && actionManager.pauseTarget(this);
                    cc.eventManager.pauseTarget(this);
                }
            },
            _removeSgNode: SgHelper.removeSgNode,
            onRestore: false
        });
        var updateListeners;
        var SameNameGetSets = [ "parent", "tag", "skewX", "skewY", "position", "rotation", "rotationX", "rotationY", "scale", "scaleX", "scaleY", "opacity", "color" ];
        var DiffNameGetSets = {
            x: [ "getPositionX", "setPositionX" ],
            y: [ "getPositionY", "setPositionY" ],
            zIndex: [ "getLocalZOrder", "setLocalZOrder" ],
            opacityModifyRGB: [ "isOpacityModifyRGB", "setOpacityModifyRGB" ],
            cascadeOpacity: [ "isCascadeOpacityEnabled", "setCascadeOpacityEnabled" ]
        };
        Misc.propertyDefine(Node, SameNameGetSets, DiffNameGetSets);
        Node.EventType = EventType;
        cc.Node = module.exports = Node;
    }), {
        "./utils/base-node": 219,
        "./utils/misc": 223,
        "./utils/prefab-helper": 225,
        "./utils/scene-graph-helper": 226
    } ],
    42: [ (function(require, module, exports) {
        var NIL = function() {};
        cc.Scene = cc.Class({
            name: "cc.Scene",
            extends: require("./CCNode"),
            properties: {
                autoReleaseAssets: void 0
            },
            ctor: function() {
                var sgNode = this._sgNode = new _ccsg.Scene();
                sgNode.setAnchorPoint(0, 0);
                this._anchorPoint.x = 0;
                this._anchorPoint.y = 0;
                this._activeInHierarchy = false;
                this._inited = !cc.game._isCloning;
                this.dependAssets = null;
            },
            destroy: function() {
                this._super();
                this._activeInHierarchy = false;
            },
            _onHierarchyChanged: NIL,
            _instantiate: null,
            _load: function() {
                if (!this._inited) {
                    this._onBatchCreated();
                    this._inited = true;
                }
            },
            _activate: function(active) {
                active = false !== active;
                cc.director._nodeActivator.activateNode(this, active);
            }
        });
        module.exports = cc.Scene;
    }), {
        "./CCNode": 41
    } ],
    43: [ (function(require, module, exports) {
        var MAX_POOL_SIZE = 20;
        var ListEntry = function(prev, next, callback, target, priority, paused, markedForDeletion) {
            this.prev = prev;
            this.next = next;
            this.callback = callback;
            this.target = target;
            this.priority = priority;
            this.paused = paused;
            this.markedForDeletion = markedForDeletion;
            this.isUpdate = !callback;
        };
        var _listEntries = [];
        ListEntry.get = function(prev, next, callback, target, priority, paused, markedForDeletion) {
            var result = _listEntries.pop();
            if (result) {
                result.prev = prev;
                result.next = next;
                result.callback = callback;
                result.target = target;
                result.priority = priority;
                result.paused = paused;
                result.markedForDeletion = markedForDeletion;
                result.isUpdate = !callback;
            } else {
                result = new ListEntry(prev, next, callback, target, priority, paused, markedForDeletion);
            }
            return result;
        };
        ListEntry.put = function(entry) {
            if (_listEntries.length < MAX_POOL_SIZE) {
                entry.prev = entry.next = entry.callback = entry.target = null;
                _listEntries.push(entry);
            }
        };
        var HashUpdateEntry = function(list, entry, target, callback) {
            this.list = list;
            this.entry = entry;
            this.target = target;
            this.callback = callback;
        };
        var _hashUpdateEntries = [];
        HashUpdateEntry.get = function(list, entry, target, callback) {
            var result = _hashUpdateEntries.pop();
            if (result) {
                result.list = list;
                result.entry = entry;
                result.target = target;
                result.callback = callback;
            } else {
                result = new HashUpdateEntry(list, entry, target, callback);
            }
            return result;
        };
        HashUpdateEntry.put = function(entry) {
            if (_hashUpdateEntries.length < MAX_POOL_SIZE) {
                entry.list = entry.entry = entry.target = entry.callback = null;
                _hashUpdateEntries.push(entry);
            }
        };
        var HashTimerEntry = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
            var _t = this;
            _t.timers = timers;
            _t.target = target;
            _t.timerIndex = timerIndex;
            _t.currentTimer = currentTimer;
            _t.currentTimerSalvaged = currentTimerSalvaged;
            _t.paused = paused;
        };
        var _hashTimerEntries = [];
        HashTimerEntry.get = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
            var result = _hashTimerEntries.pop();
            if (result) {
                result.timers = timers;
                result.target = target;
                result.timerIndex = timerIndex;
                result.currentTimer = currentTimer;
                result.currentTimerSalvaged = currentTimerSalvaged;
                result.paused = paused;
            } else {
                result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused);
            }
            return result;
        };
        HashTimerEntry.put = function(entry) {
            if (_hashTimerEntries.length < MAX_POOL_SIZE) {
                entry.timers = entry.target = entry.currentTimer = null;
                _hashTimerEntries.push(entry);
            }
        };
        function CallbackTimer() {
            this._scheduler = null;
            this._elapsed = -1;
            this._runForever = false;
            this._useDelay = false;
            this._timesExecuted = 0;
            this._repeat = 0;
            this._delay = 0;
            this._interval = 0;
            this._target = null;
            this._callback = null;
        }
        var proto = CallbackTimer.prototype;
        proto.initWithCallback = function(scheduler, callback, target, seconds, repeat, delay) {
            this._scheduler = scheduler;
            this._target = target;
            this._callback = callback;
            this._elapsed = -1;
            this._interval = seconds;
            this._delay = delay;
            this._useDelay = this._delay > 0;
            this._repeat = repeat;
            this._runForever = this._repeat === cc.macro.REPEAT_FOREVER;
            return true;
        };
        proto.getInterval = function() {
            return this._interval;
        };
        proto.setInterval = function(interval) {
            this._interval = interval;
        };
        proto.update = function(dt) {
            if (this._elapsed === -1) {
                this._elapsed = 0;
                this._timesExecuted = 0;
            } else {
                this._elapsed += dt;
                if (this._runForever && !this._useDelay) {
                    if (this._elapsed >= this._interval) {
                        this.trigger();
                        this._elapsed = 0;
                    }
                } else {
                    if (this._useDelay) {
                        if (this._elapsed >= this._delay) {
                            this.trigger();
                            this._elapsed -= this._delay;
                            this._timesExecuted += 1;
                            this._useDelay = false;
                        }
                    } else {
                        if (this._elapsed >= this._interval) {
                            this.trigger();
                            this._elapsed = 0;
                            this._timesExecuted += 1;
                        }
                    }
                    this._callback && !this._runForever && this._timesExecuted > this._repeat && this.cancel();
                }
            }
        };
        proto.getCallback = function() {
            return this._callback;
        };
        proto.trigger = function() {
            this._target && this._callback && this._callback.call(this._target, this._elapsed);
        };
        proto.cancel = function() {
            this._scheduler.unschedule(this._callback, this._target);
        };
        var _timers = [];
        CallbackTimer.get = function() {
            return _timers.pop() || new CallbackTimer();
        };
        CallbackTimer.put = function(timer) {
            if (_timers.length < MAX_POOL_SIZE) {
                timer._scheduler = timer._target = timer._callback = null;
                _timers.push(timer);
            }
        };
        var getTargetId = function(target) {
            return target.__instanceId || target.uuid;
        };
        cc.Scheduler = cc._Class.extend({
            ctor: function() {
                this._timeScale = 1;
                this._updatesNegList = [];
                this._updates0List = [];
                this._updatesPosList = [];
                this._hashForUpdates = {};
                this._hashForTimers = {};
                this._currentTarget = null;
                this._currentTargetSalvaged = false;
                this._updateHashLocked = false;
                this._arrayForTimers = [];
            },
            _removeHashElement: function(element) {
                delete this._hashForTimers[getTargetId(element.target)];
                var arr = this._arrayForTimers;
                for (var i = 0, l = arr.length; i < l; i++) {
                    if (arr[i] === element) {
                        arr.splice(i, 1);
                        break;
                    }
                }
                HashTimerEntry.put(element);
            },
            _removeUpdateFromHash: function(entry) {
                var targetId = getTargetId(entry.target);
                var self = this, element = self._hashForUpdates[targetId];
                if (element) {
                    var list = element.list, listEntry = element.entry;
                    for (var i = 0, l = list.length; i < l; i++) {
                        if (list[i] === listEntry) {
                            list.splice(i, 1);
                            break;
                        }
                    }
                    delete self._hashForUpdates[targetId];
                    ListEntry.put(listEntry);
                    HashUpdateEntry.put(element);
                }
            },
            _priorityIn: function(ppList, listElement, priority) {
                for (var i = 0; i < ppList.length; i++) {
                    if (priority < ppList[i].priority) {
                        ppList.splice(i, 0, listElement);
                        return;
                    }
                }
                ppList.push(listElement);
            },
            _appendIn: function(ppList, listElement) {
                ppList.push(listElement);
            },
            setTimeScale: function(timeScale) {
                this._timeScale = timeScale;
            },
            getTimeScale: function() {
                return this._timeScale;
            },
            update: function(dt) {
                this._updateHashLocked = true;
                1 !== this._timeScale && (dt *= this._timeScale);
                var i, list, len, entry;
                for (i = 0, list = this._updatesNegList, len = list.length; i < len; i++) {
                    entry = list[i];
                    entry.paused || entry.markedForDeletion || (entry.isUpdate ? entry.target.update(dt) : entry.callback.call(entry.target, dt));
                }
                for (i = 0, list = this._updates0List, len = list.length; i < len; i++) {
                    entry = list[i];
                    entry.paused || entry.markedForDeletion || (entry.isUpdate ? entry.target.update(dt) : entry.callback.call(entry.target, dt));
                }
                for (i = 0, list = this._updatesPosList, len = list.length; i < len; i++) {
                    entry = list[i];
                    entry.paused || entry.markedForDeletion || (entry.isUpdate ? entry.target.update(dt) : entry.callback.call(entry.target, dt));
                }
                var elt, arr = this._arrayForTimers;
                for (i = 0; i < arr.length; i++) {
                    elt = arr[i];
                    this._currentTarget = elt;
                    this._currentTargetSalvaged = false;
                    if (!elt.paused) {
                        for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) {
                            elt.currentTimer = elt.timers[elt.timerIndex];
                            elt.currentTimerSalvaged = false;
                            elt.currentTimer.update(dt);
                            elt.currentTimer = null;
                        }
                    }
                    if (this._currentTargetSalvaged && 0 === this._currentTarget.timers.length) {
                        this._removeHashElement(this._currentTarget);
                        --i;
                    }
                }
                for (i = 0, list = this._updatesNegList; i < list.length; ) {
                    entry = list[i];
                    entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
                }
                for (i = 0, list = this._updates0List; i < list.length; ) {
                    entry = list[i];
                    entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
                }
                for (i = 0, list = this._updatesPosList; i < list.length; ) {
                    entry = list[i];
                    entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
                }
                this._updateHashLocked = false;
                this._currentTarget = null;
            },
            scheduleCallbackForTarget: function(target, callback_fn, interval, repeat, delay, paused) {
                this.schedule(callback_fn, target, interval, repeat, delay, paused);
            },
            schedule: function(callback, target, interval, repeat, delay, paused) {
                "use strict";
                if ("function" !== typeof callback) {
                    var tmp = callback;
                    callback = target;
                    target = tmp;
                }
                if (4 === arguments.length || 5 === arguments.length) {
                    paused = repeat;
                    repeat = cc.macro.REPEAT_FOREVER;
                    delay = 0;
                }
                cc.assertID(target, 1502);
                var instanceId = getTargetId(target);
                cc.assertID(instanceId, 1510);
                var element = this._hashForTimers[instanceId];
                if (element) {
                    cc.assert(element.paused === paused, "");
                } else {
                    element = HashTimerEntry.get(null, target, 0, null, null, paused);
                    this._arrayForTimers.push(element);
                    this._hashForTimers[instanceId] = element;
                }
                var timer, i;
                if (null == element.timers) {
                    element.timers = [];
                } else {
                    for (i = 0; i < element.timers.length; ++i) {
                        timer = element.timers[i];
                        if (timer && callback === timer._callback) {
                            cc.logID(1507, timer.getInterval(), interval);
                            timer._interval = interval;
                            return;
                        }
                    }
                }
                timer = CallbackTimer.get();
                timer.initWithCallback(this, callback, target, interval, repeat, delay);
                element.timers.push(timer);
            },
            scheduleUpdate: function(target, priority, paused, updateFunc) {
                var targetId = getTargetId(target);
                cc.assertID(targetId, 1510);
                var hashElement = this._hashForUpdates[targetId];
                if (hashElement && hashElement.entry) {
                    if (hashElement.entry.priority === priority) {
                        hashElement.entry.markedForDeletion = false;
                        hashElement.entry.paused = paused;
                        return;
                    }
                    if (this._updateHashLocked) {
                        cc.logID(1506);
                        hashElement.entry.markedForDeletion = false;
                        hashElement.entry.paused = paused;
                        return;
                    }
                    this.unscheduleUpdate(target);
                }
                var listElement = ListEntry.get(null, null, updateFunc, target, priority, paused, false);
                var ppList;
                if (0 === priority) {
                    ppList = this._updates0List;
                    this._appendIn(ppList, listElement);
                } else {
                    ppList = priority < 0 ? this._updatesNegList : this._updatesPosList;
                    this._priorityIn(ppList, listElement, priority);
                }
                this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
            },
            unschedule: function(callback, target) {
                if (!target || !callback) {
                    return;
                }
                var targetId = getTargetId(target);
                cc.assertID(targetId, 1510);
                var self = this, element = self._hashForTimers[targetId];
                if (element) {
                    var timers = element.timers;
                    for (var i = 0, li = timers.length; i < li; i++) {
                        var timer = timers[i];
                        if (callback === timer._callback) {
                            timer !== element.currentTimer || element.currentTimerSalvaged || (element.currentTimerSalvaged = true);
                            timers.splice(i, 1);
                            CallbackTimer.put(timer);
                            element.timerIndex >= i && element.timerIndex--;
                            0 === timers.length && (self._currentTarget === element ? self._currentTargetSalvaged = true : self._removeHashElement(element));
                            return;
                        }
                    }
                }
            },
            unscheduleUpdate: function(target) {
                if (!target) {
                    return;
                }
                var targetId = getTargetId(target);
                cc.assertID(targetId, 1510);
                var element = this._hashForUpdates[targetId];
                element && (this._updateHashLocked ? element.entry.markedForDeletion = true : this._removeUpdateFromHash(element.entry));
            },
            unscheduleAllForTarget: function(target) {
                if (!target) {
                    return;
                }
                var targetId = getTargetId(target);
                cc.assertID(targetId, 1510);
                var element = this._hashForTimers[targetId];
                if (element) {
                    var timers = element.timers;
                    timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged && (element.currentTimerSalvaged = true);
                    for (var i = 0, l = timers.length; i < l; i++) {
                        CallbackTimer.put(timers[i]);
                    }
                    timers.length = 0;
                    this._currentTarget === element ? this._currentTargetSalvaged = true : this._removeHashElement(element);
                }
                this.unscheduleUpdate(target);
            },
            unscheduleAll: function() {
                this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
            },
            unscheduleAllWithMinPriority: function(minPriority) {
                var i, element, arr = this._arrayForTimers;
                for (i = arr.length - 1; i >= 0; i--) {
                    element = arr[i];
                    this.unscheduleAllForTarget(element.target);
                }
                var entry;
                var temp_length = 0;
                if (minPriority < 0) {
                    for (i = 0; i < this._updatesNegList.length; ) {
                        temp_length = this._updatesNegList.length;
                        entry = this._updatesNegList[i];
                        entry && entry.priority >= minPriority && this.unscheduleUpdate(entry.target);
                        temp_length == this._updatesNegList.length && i++;
                    }
                }
                if (minPriority <= 0) {
                    for (i = 0; i < this._updates0List.length; ) {
                        temp_length = this._updates0List.length;
                        entry = this._updates0List[i];
                        entry && this.unscheduleUpdate(entry.target);
                        temp_length == this._updates0List.length && i++;
                    }
                }
                for (i = 0; i < this._updatesPosList.length; ) {
                    temp_length = this._updatesPosList.length;
                    entry = this._updatesPosList[i];
                    entry && entry.priority >= minPriority && this.unscheduleUpdate(entry.target);
                    temp_length == this._updatesPosList.length && i++;
                }
            },
            isScheduled: function(callback, target) {
                cc.assertID(callback, 1508);
                cc.assertID(target, 1509);
                var targetId = getTargetId(target);
                cc.assertID(targetId, 1510);
                var element = this._hashForTimers[targetId];
                if (!element) {
                    return false;
                }
                if (null == element.timers) {
                    return false;
                }
                var timers = element.timers;
                for (var i = 0; i < timers.length; ++i) {
                    var timer = timers[i];
                    if (callback === timer._callback) {
                        return true;
                    }
                }
                return false;
            },
            pauseAllTargets: function() {
                return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
            },
            pauseAllTargetsWithMinPriority: function(minPriority) {
                var idsWithSelectors = [];
                var self = this, element, locArrayForTimers = self._arrayForTimers;
                var i, li;
                for (i = 0, li = locArrayForTimers.length; i < li; i++) {
                    element = locArrayForTimers[i];
                    if (element) {
                        element.paused = true;
                        idsWithSelectors.push(element.target);
                    }
                }
                var entry;
                if (minPriority < 0) {
                    for (i = 0; i < this._updatesNegList.length; i++) {
                        entry = this._updatesNegList[i];
                        if (entry && entry.priority >= minPriority) {
                            entry.paused = true;
                            idsWithSelectors.push(entry.target);
                        }
                    }
                }
                if (minPriority <= 0) {
                    for (i = 0; i < this._updates0List.length; i++) {
                        entry = this._updates0List[i];
                        if (entry) {
                            entry.paused = true;
                            idsWithSelectors.push(entry.target);
                        }
                    }
                }
                for (i = 0; i < this._updatesPosList.length; i++) {
                    entry = this._updatesPosList[i];
                    if (entry && entry.priority >= minPriority) {
                        entry.paused = true;
                        idsWithSelectors.push(entry.target);
                    }
                }
                return idsWithSelectors;
            },
            resumeTargets: function(targetsToResume) {
                if (!targetsToResume) {
                    return;
                }
                for (var i = 0; i < targetsToResume.length; i++) {
                    this.resumeTarget(targetsToResume[i]);
                }
            },
            pauseTarget: function(target) {
                cc.assertID(target, 1503);
                var targetId = getTargetId(target);
                cc.assertID(targetId, 1510);
                var self = this, element = self._hashForTimers[targetId];
                element && (element.paused = true);
                var elementUpdate = self._hashForUpdates[targetId];
                elementUpdate && (elementUpdate.entry.paused = true);
            },
            resumeTarget: function(target) {
                cc.assertID(target, 1504);
                var targetId = getTargetId(target);
                cc.assertID(targetId, 1510);
                var self = this, element = self._hashForTimers[targetId];
                element && (element.paused = false);
                var elementUpdate = self._hashForUpdates[targetId];
                elementUpdate && (elementUpdate.entry.paused = false);
            },
            isTargetPaused: function(target) {
                cc.assertID(target, 1505);
                var targetId = getTargetId(target);
                cc.assertID(targetId, 1510);
                var element = this._hashForTimers[targetId];
                if (element) {
                    return element.paused;
                }
                var elementUpdate = this._hashForUpdates[targetId];
                if (elementUpdate) {
                    return elementUpdate.entry.paused;
                }
                return false;
            },
            scheduleUpdateForTarget: function(target, priority, paused) {
                this.scheduleUpdate(target, priority, paused);
            },
            unscheduleCallbackForTarget: function(target, callback) {
                this.unschedule(callback, target);
            },
            unscheduleUpdateForTarget: function(target) {
                this.unscheduleUpdate(target);
            },
            unscheduleAllCallbacksForTarget: function(target) {
                this.unscheduleAllForTarget(target);
            },
            unscheduleAllCallbacks: function() {
                this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
            },
            unscheduleAllCallbacksWithMinPriority: function(minPriority) {
                this.unscheduleAllWithMinPriority(minPriority);
            }
        });
        cc.Scheduler.PRIORITY_SYSTEM = 1 << 31;
        cc.Scheduler.PRIORITY_NON_SYSTEM = cc.Scheduler.PRIORITY_SYSTEM + 1;
    }), {} ],
    44: [ (function(require, module, exports) {
        var RawAsset = require("./CCRawAsset");
        cc.Asset = cc.Class({
            name: "cc.Asset",
            extends: RawAsset,
            properties: {
                rawUrl: {
                    get: function() {
                        if (this._rawFiles) {
                            if (cc.AssetLibrary) {
                                return cc.AssetLibrary.getImportedDir(this._uuid) + "/" + this._uuid + "/" + this._rawFiles[0];
                            }
                            cc.errorID(6400);
                        }
                        return "";
                    },
                    visible: false
                },
                rawUrls: {
                    get: function() {
                        if (this._rawFiles) {
                            if (cc.AssetLibrary) {
                                var dir = cc.AssetLibrary.getImportedDir(this._uuid) + "/" + this._uuid + "/";
                                return this._rawFiles.map((function(filename) {
                                    return dir + filename;
                                }));
                            }
                            cc.errorID(6401);
                        }
                        return [];
                    },
                    visible: false
                },
                _rawFiles: null
            },
            statics: {
                deserialize: function(data) {
                    return cc.deserialize(data);
                },
                preventDeferredLoadDependents: false
            },
            serialize: function() {
                return Editor.serialize(this);
            },
            createNode: null,
            _setRawFiles: function(rawFiles) {
                this._rawFiles = rawFiles.length > 0 ? rawFiles : null;
            },
            _preloadRawFiles: null
        });
        module.exports = cc.Asset;
    }), {
        "./CCRawAsset": 50
    } ],
    45: [ (function(require, module, exports) {
        var AudioClip = cc.Class({
            name: "cc.AudioClip",
            extends: cc.RawAsset
        });
        cc.AudioClip = AudioClip;
        module.exports = AudioClip;
    }), {} ],
    46: [ (function(require, module, exports) {
        var BitmapFont = cc.Class({
            name: "cc.BitmapFont",
            extends: cc.Font,
            properties: {
                fntDataStr: {
                    default: ""
                },
                spriteFrame: {
                    default: null,
                    type: cc.SpriteFrame
                },
                fontSize: {
                    default: -1
                },
                _fntConfig: null
            }
        });
        cc.BitmapFont = BitmapFont;
        module.exports = BitmapFont;
    }), {} ],
    47: [ (function(require, module, exports) {
        var Font = cc.Class({
            name: "cc.Font",
            extends: cc.Asset
        });
        cc.Font = Font;
        module.exports = Font;
    }), {} ],
    48: [ (function(require, module, exports) {
        var LabelAtlas = cc.Class({
            name: "cc.LabelAtlas",
            extends: cc.BitmapFont
        });
        cc.LabelAtlas = LabelAtlas;
        module.exports = LabelAtlas;
    }), {} ],
    49: [ (function(require, module, exports) {
        var Prefab = cc.Class({
            name: "cc.Prefab",
            extends: cc.Asset,
            properties: {
                data: null,
                asyncLoadAssets: void 0,
                _createFunction: {
                    default: null,
                    serializable: false
                }
            },
            createNode: false,
            compileCreateFunction: function() {
                var jit = require("../platform/instantiate-jit");
                this._createFunction = jit.compile(this.data);
            },
            _doInstantiate: function(rootToRedirect) {
                this.data._prefab ? this.data._prefab._synced = true : cc.warnID(3700);
                this._createFunction || this.compileCreateFunction();
                return this._createFunction(rootToRedirect);
            },
            _instantiate: function() {
                var node = this._doInstantiate();
                this.data._instantiate(node);
                return node;
            }
        });
        cc.Prefab = module.exports = Prefab;
        cc.js.obsolete(cc, "cc._Prefab", "Prefab");
    }), {
        "../platform/instantiate-jit": 191
    } ],
    50: [ (function(require, module, exports) {
        var CCObject = require("../platform/CCObject");
        cc.RawAsset = cc.Class({
            name: "cc.RawAsset",
            extends: CCObject,
            ctor: function() {
                Object.defineProperty(this, "_uuid", {
                    value: "",
                    writable: true
                });
            },
            statics: {
                createNodeByInfo: null
            }
        });
        Object.defineProperty(cc.RawAsset, "isRawAssetType", {
            value: function(ctor) {
                return cc.isChildClassOf(ctor, cc.RawAsset) && !cc.isChildClassOf(ctor, cc.Asset);
            }
        });
        module.exports = cc.RawAsset;
    }), {
        "../platform/CCObject": 179
    } ],
    51: [ (function(require, module, exports) {
        var Scene = cc.Class({
            name: "cc.SceneAsset",
            extends: cc.Asset,
            properties: {
                scene: null,
                asyncLoadAssets: void 0
            }
        });
        cc.SceneAsset = Scene;
        module.exports = Scene;
    }), {} ],
    52: [ (function(require, module, exports) {
        var Script = cc.Class({
            name: "cc.Script",
            extends: cc.Asset
        });
        cc._Script = Script;
        var JavaScript = cc.Class({
            name: "cc.JavaScript",
            extends: Script
        });
        cc._JavaScript = JavaScript;
        var CoffeeScript = cc.Class({
            name: "cc.CoffeeScript",
            extends: Script
        });
        cc._CoffeeScript = CoffeeScript;
        var TypeScript = cc.Class({
            name: "cc.TypeScript",
            extends: Script
        });
        cc._TypeScript = TypeScript;
    }), {} ],
    53: [ (function(require, module, exports) {
        var SpriteAtlas = cc.Class({
            name: "cc.SpriteAtlas",
            extends: cc.Asset,
            properties: {
                _spriteFrames: {
                    default: {}
                }
            },
            getTexture: function() {
                var keys = Object.keys(this._spriteFrames);
                if (keys.length > 0) {
                    var spriteFrame = this._spriteFrames[keys[0]];
                    return spriteFrame ? spriteFrame.getTexture() : null;
                }
                return null;
            },
            getSpriteFrame: function(key) {
                return this._spriteFrames[key];
            },
            getSpriteFrames: function() {
                var frames = [];
                var spriteFrames = this._spriteFrames;
                for (var key in spriteFrames) {
                    frames.push(spriteFrames[key]);
                }
                return frames;
            }
        });
        cc.SpriteAtlas = SpriteAtlas;
        module.exports = SpriteAtlas;
    }), {} ],
    54: [ (function(require, module, exports) {
        var TTFFont = cc.Class({
            name: "cc.TTFFont",
            extends: cc.Font
        });
        cc.TTFFont = TTFFont;
        module.exports = TTFFont;
    }), {} ],
    55: [ (function(require, module, exports) {
        require("./CCRawAsset");
        require("./CCAsset");
        require("./CCFont");
        require("./CCPrefab");
        require("./CCAudioClip");
        require("./CCScripts");
        require("./CCSceneAsset");
        require("../sprites/CCSpriteFrame");
        require("../textures/CCTexture2D");
        require("./CCTTFFont");
        require("./CCSpriteAtlas");
        require("./CCBitmapFont");
        require("./CCLabelAtlas");
    }), {
        "../sprites/CCSpriteFrame": 211,
        "../textures/CCTexture2D": 213,
        "./CCAsset": 44,
        "./CCAudioClip": 45,
        "./CCBitmapFont": 46,
        "./CCFont": 47,
        "./CCLabelAtlas": 48,
        "./CCPrefab": 49,
        "./CCRawAsset": 50,
        "./CCSceneAsset": 51,
        "./CCScripts": 52,
        "./CCSpriteAtlas": 53,
        "./CCTTFFont": 54
    } ],
    56: [ (function(require, module, exports) {
        cc._tmp.PrototypeCCNode = function() {
            var _p = _ccsg.Node.prototype;
            cc.defineGetterSetter(_p, "x", _p.getPositionX, _p.setPositionX);
            cc.defineGetterSetter(_p, "y", _p.getPositionY, _p.setPositionY);
            cc.defineGetterSetter(_p, "width", _p._getWidth, _p._setWidth);
            cc.defineGetterSetter(_p, "height", _p._getHeight, _p._setHeight);
            cc.defineGetterSetter(_p, "anchorX", _p._getAnchorX, _p._setAnchorX);
            cc.defineGetterSetter(_p, "anchorY", _p._getAnchorY, _p._setAnchorY);
            cc.defineGetterSetter(_p, "skewX", _p.getSkewX, _p.setSkewX);
            cc.defineGetterSetter(_p, "skewY", _p.getSkewY, _p.setSkewY);
            cc.defineGetterSetter(_p, "zIndex", _p.getLocalZOrder, _p.setLocalZOrder);
            cc.defineGetterSetter(_p, "vertexZ", _p.getVertexZ, _p.setVertexZ);
            cc.defineGetterSetter(_p, "rotation", _p.getRotation, _p.setRotation);
            cc.defineGetterSetter(_p, "rotationX", _p.getRotationX, _p.setRotationX);
            cc.defineGetterSetter(_p, "rotationY", _p.getRotationY, _p.setRotationY);
            cc.defineGetterSetter(_p, "scale", _p.getScale, _p.setScale);
            cc.defineGetterSetter(_p, "scaleX", _p.getScaleX, _p.setScaleX);
            cc.defineGetterSetter(_p, "scaleY", _p.getScaleY, _p.setScaleY);
            cc.defineGetterSetter(_p, "children", _p.getChildren);
            cc.defineGetterSetter(_p, "childrenCount", _p.getChildrenCount);
            cc.defineGetterSetter(_p, "parent", _p.getParent, _p.setParent);
            cc.defineGetterSetter(_p, "visible", _p.isVisible, _p.setVisible);
            cc.defineGetterSetter(_p, "running", _p.isRunning);
            cc.defineGetterSetter(_p, "ignoreAnchor", _p.isIgnoreAnchorPointForPosition, _p.setIgnoreAnchorPointForPosition);
            cc.defineGetterSetter(_p, "scheduler", _p.getScheduler, _p.setScheduler);
            cc.defineGetterSetter(_p, "shaderProgram", _p.getShaderProgram, _p.setShaderProgram);
            cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
            cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB);
            cc.defineGetterSetter(_p, "cascadeOpacity", _p.isCascadeOpacityEnabled, _p.setCascadeOpacityEnabled);
            cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
            cc.defineGetterSetter(_p, "cascadeColor", _p.isCascadeColorEnabled, _p.setCascadeColorEnabled);
        };
    }), {} ],
    57: [ (function(require, module, exports) {
        var ActionManagerExist = !!cc.ActionManager;
        var emptyFunc = function() {};
        cc.s_globalOrderOfArrival = 1;
        _ccsg.Node = cc.Class({
            name: "ccsg.Node",
            properties: {
                _running: false,
                _localZOrder: 0,
                _globalZOrder: 0,
                _arrivalOrder: 0,
                _reorderChildDirty: false,
                _vertexZ: 0,
                _customZ: void 0,
                _rotationX: 0,
                _rotationY: 0,
                _scaleX: 1,
                _scaleY: 1,
                _position: cc.p(0, 0),
                _skewX: 0,
                _skewY: 0,
                _children: [],
                _visible: true,
                _anchorPoint: cc.p(0, 0),
                _contentSize: cc.size(0, 0),
                _parent: null,
                _ignoreAnchorPointForPosition: false,
                tag: cc.macro.NODE_TAG_INVALID,
                _showNode: false,
                _name: "",
                _realOpacity: 255,
                _realColor: cc.Color.WHITE,
                _cascadeColorEnabled: false,
                _cascadeOpacityEnabled: false,
                _isTransitionFinished: false,
                _actionManager: null,
                _scheduler: null,
                _renderCmd: null
            },
            ctor: function() {
                this.__instanceId = cc.ClassManager.getNewInstanceId();
                this._renderCmd = this._createRenderCmd();
            },
            init: function() {
                return true;
            },
            attr: function(attrs) {
                for (var key in attrs) {
                    this[key] = attrs[key];
                }
            },
            getSkewX: function() {
                return this._skewX;
            },
            setSkewX: function(newSkewX) {
                this._skewX = newSkewX;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
            },
            getSkewY: function() {
                return this._skewY;
            },
            setSkewY: function(newSkewY) {
                this._skewY = newSkewY;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
            },
            setLocalZOrder: function(localZOrder) {
                this._parent ? this._parent.reorderChild(this, localZOrder) : this._localZOrder = localZOrder;
                cc.eventManager._setDirtyForNode(this);
            },
            _setLocalZOrder: function(localZOrder) {
                this._localZOrder = localZOrder;
            },
            getLocalZOrder: function() {
                return this._localZOrder;
            },
            getZOrder: function() {
                cc.logID(1600);
                return this.getLocalZOrder();
            },
            setZOrder: function(z) {
                cc.logID(1601);
                this.setLocalZOrder(z);
            },
            setGlobalZOrder: function(globalZOrder) {
                if (this._globalZOrder !== globalZOrder) {
                    this._globalZOrder = globalZOrder;
                    cc.eventManager._setDirtyForNode(this);
                }
            },
            getGlobalZOrder: function() {
                return this._globalZOrder;
            },
            getVertexZ: function() {
                return this._vertexZ;
            },
            setVertexZ: function(Var) {
                this._customZ = this._vertexZ = Var;
            },
            getRotation: function() {
                this._rotationX !== this._rotationY && cc.logID(1602);
                return this._rotationX;
            },
            setRotation: function(newRotation) {
                this._rotationX = this._rotationY = newRotation;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
            },
            getRotationX: function() {
                return this._rotationX;
            },
            setRotationX: function(rotationX) {
                this._rotationX = rotationX;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
            },
            getRotationY: function() {
                return this._rotationY;
            },
            setRotationY: function(rotationY) {
                this._rotationY = rotationY;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
            },
            getScale: function() {
                this._scaleX !== this._scaleY && cc.logID(1603);
                return this._scaleX;
            },
            setScale: function(scale, scaleY) {
                this._scaleX = scale;
                this._scaleY = scaleY || 0 === scaleY ? scaleY : scale;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
            },
            getScaleX: function() {
                return this._scaleX;
            },
            setScaleX: function(newScaleX) {
                this._scaleX = newScaleX;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
            },
            getScaleY: function() {
                return this._scaleY;
            },
            setScaleY: function(newScaleY) {
                this._scaleY = newScaleY;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
            },
            setPosition: function(newPosOrxValue, yValue) {
                var locPosition = this._position;
                if (void 0 === yValue) {
                    if (locPosition.x === newPosOrxValue.x && locPosition.y === newPosOrxValue.y) {
                        return;
                    }
                    locPosition.x = newPosOrxValue.x;
                    locPosition.y = newPosOrxValue.y;
                } else {
                    if (locPosition.x === newPosOrxValue && locPosition.y === yValue) {
                        return;
                    }
                    locPosition.x = newPosOrxValue;
                    locPosition.y = yValue;
                }
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
            },
            getPosition: function() {
                return cc.p(this._position);
            },
            getPositionX: function() {
                return this._position.x;
            },
            setPositionX: function(x) {
                this._position.x = x;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
            },
            getPositionY: function() {
                return this._position.y;
            },
            setPositionY: function(y) {
                this._position.y = y;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
            },
            getChildrenCount: function() {
                return this._children.length;
            },
            getChildren: function() {
                return this._children;
            },
            isVisible: function() {
                return this._visible;
            },
            setVisible: function(visible) {
                if (this._visible !== visible) {
                    this._visible = visible;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                    cc.renderer.childrenOrderDirty = true;
                }
            },
            getAnchorPoint: function() {
                return cc.p(this._anchorPoint);
            },
            setAnchorPoint: function(point, y) {
                var locAnchorPoint = this._anchorPoint;
                if (void 0 === y) {
                    if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) {
                        return;
                    }
                    locAnchorPoint.x = point.x;
                    locAnchorPoint.y = point.y;
                } else {
                    if (point === locAnchorPoint.x && y === locAnchorPoint.y) {
                        return;
                    }
                    locAnchorPoint.x = point;
                    locAnchorPoint.y = y;
                }
                this._renderCmd._updateAnchorPointInPoint();
            },
            _getAnchorX: function() {
                return this._anchorPoint.x;
            },
            _setAnchorX: function(x) {
                if (this._anchorPoint.x === x) {
                    return;
                }
                this._anchorPoint.x = x;
                this._renderCmd._updateAnchorPointInPoint();
            },
            _getAnchorY: function() {
                return this._anchorPoint.y;
            },
            _setAnchorY: function(y) {
                if (this._anchorPoint.y === y) {
                    return;
                }
                this._anchorPoint.y = y;
                this._renderCmd._updateAnchorPointInPoint();
            },
            getAnchorPointInPoints: function() {
                return this._renderCmd.getAnchorPointInPoints();
            },
            _getWidth: function() {
                return this._contentSize.width;
            },
            _setWidth: function(width) {
                this._contentSize.width = width;
                this._renderCmd._updateAnchorPointInPoint();
            },
            _getHeight: function() {
                return this._contentSize.height;
            },
            _setHeight: function(height) {
                this._contentSize.height = height;
                this._renderCmd._updateAnchorPointInPoint();
            },
            getContentSize: function() {
                return cc.size(this._contentSize);
            },
            setContentSize: function(size, height) {
                var locContentSize = this._contentSize;
                if (void 0 === height) {
                    if (size.width === locContentSize.width && size.height === locContentSize.height) {
                        return;
                    }
                    locContentSize.width = size.width;
                    locContentSize.height = size.height;
                } else {
                    if (size === locContentSize.width && height === locContentSize.height) {
                        return;
                    }
                    locContentSize.width = size;
                    locContentSize.height = height;
                }
                this._renderCmd._updateAnchorPointInPoint();
            },
            isRunning: function() {
                return this._running;
            },
            getParent: function() {
                return this._parent;
            },
            setParent: function(parent) {
                this._parent = parent;
                var dirtyFlags = _ccsg.Node._dirtyFlags;
                this._renderCmd.setDirtyFlag(dirtyFlags.transformDirty | dirtyFlags.opacityDirty);
            },
            isIgnoreAnchorPointForPosition: function() {
                return this._ignoreAnchorPointForPosition;
            },
            setIgnoreAnchorPointForPosition: function(newValue) {
                if (newValue !== this._ignoreAnchorPointForPosition) {
                    this._ignoreAnchorPointForPosition = newValue;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                }
            },
            getTag: function() {
                return this.tag;
            },
            setTag: function(tag) {
                this.tag = tag;
            },
            setName: function(name) {
                this._name = name;
            },
            getName: function() {
                return this._name;
            },
            updateOrderOfArrival: function() {
                this._arrivalOrder = ++cc.s_globalOrderOfArrival;
            },
            getScheduler: function() {
                return this._scheduler || cc.director.getScheduler();
            },
            setScheduler: function(scheduler) {
                if (this._scheduler !== scheduler) {
                    this.unscheduleAllCallbacks();
                    this._scheduler = scheduler;
                }
            },
            boundingBox: function() {
                cc.logID(1608);
                return this.getBoundingBox();
            },
            getBoundingBox: function() {
                var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
                return cc._rectApplyAffineTransformIn(rect, this.getNodeToParentTransform());
            },
            cleanup: function() {
                this.stopAllActions();
                this.unscheduleAllCallbacks();
                cc.eventManager.removeListeners(this);
            },
            getChildByTag: function(aTag) {
                var __children = this._children;
                if (null !== __children) {
                    for (var i = 0; i < __children.length; i++) {
                        var node = __children[i];
                        if (node && node.tag === aTag) {
                            return node;
                        }
                    }
                }
                return null;
            },
            getChildByName: function(name) {
                if (!name) {
                    cc.log("Invalid name");
                    return null;
                }
                var locChildren = this._children;
                for (var i = 0, len = locChildren.length; i < len; i++) {
                    if (locChildren[i]._name === name) {
                        return locChildren[i];
                    }
                }
                return null;
            },
            addChild: function(child, localZOrder, tag) {
                localZOrder = void 0 === localZOrder ? child._localZOrder : localZOrder;
                var name, setTag = false;
                if (void 0 === tag) {
                    name = child._name;
                } else {
                    if ("string" === typeof tag) {
                        name = tag;
                        tag = void 0;
                    } else {
                        if ("number" === typeof tag) {
                            setTag = true;
                            name = "";
                        }
                    }
                }
                cc.assertID(child, 1606);
                cc.assertID(null === child._parent, 1605);
                this._addChildHelper(child, localZOrder, tag, name, setTag);
            },
            _addChildHelper: function(child, localZOrder, tag, name, setTag) {
                this._children || (this._children = []);
                this._insertChild(child, localZOrder);
                setTag ? child.setTag(tag) : child.setName(name);
                child.setParent(this);
                child.updateOrderOfArrival();
                if (this._running) {
                    child.performRecursive(_ccsg.Node.performType.onEnter);
                    this._isTransitionFinished && child.performRecursive(_ccsg.Node.performType.onEnterTransitionDidFinish);
                }
                child._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
                this._cascadeColorEnabled && child._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty);
                this._cascadeOpacityEnabled && child._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.opacityDirty);
            },
            removeFromParent: function(cleanup) {
                if (this._parent) {
                    void 0 === cleanup && (cleanup = true);
                    this._parent.removeChild(this, cleanup);
                }
            },
            removeFromParentAndCleanup: function(cleanup) {
                cc.logID(1607);
                this.removeFromParent(cleanup);
            },
            removeChild: function(child, cleanup) {
                if (0 === this._children.length) {
                    return;
                }
                void 0 === cleanup && (cleanup = true);
                this._children.indexOf(child) > -1 && this._detachChild(child, cleanup);
                cc.renderer.childrenOrderDirty = true;
            },
            removeChildByTag: function(tag, cleanup) {
                tag === cc.macro.NODE_TAG_INVALID && cc.logID(1609);
                var child = this.getChildByTag(tag);
                child ? this.removeChild(child, cleanup) : cc.logID(1610, tag);
            },
            removeAllChildrenWithCleanup: function(cleanup) {
                this.removeAllChildren(cleanup);
            },
            removeAllChildren: function(cleanup) {
                var __children = this._children;
                if (null !== __children) {
                    void 0 === cleanup && (cleanup = true);
                    for (var i = 0; i < __children.length; i++) {
                        var node = __children[i];
                        if (node) {
                            if (this._running) {
                                node.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
                                node.performRecursive(_ccsg.Node.performType.onExit);
                            }
                            cleanup && node.performRecursive(_ccsg.Node.performType.cleanup);
                            node.parent = null;
                            node._renderCmd.detachFromParent();
                        }
                    }
                    this._children.length = 0;
                    cc.renderer.childrenOrderDirty = true;
                }
            },
            _detachChild: function(child, doCleanup) {
                if (this._running) {
                    child.performRecursive(_ccsg.Node.performType.onExitTransitionDidStart);
                    child.performRecursive(_ccsg.Node.performType.onExit);
                }
                doCleanup && child.performRecursive(_ccsg.Node.performType.cleanup);
                child.parent = null;
                child._renderCmd.detachFromParent();
                cc.js.array.remove(this._children, child);
            },
            _insertChild: function(child, z) {
                cc.renderer.childrenOrderDirty = this._reorderChildDirty = true;
                this._children.push(child);
                child._setLocalZOrder(z);
            },
            setNodeDirty: function() {
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.transformDirty);
            },
            reorderChild: function(child, zOrder) {
                cc.assertID(child, 1617);
                if (this._children.indexOf(child) === -1) {
                    cc.logID(1635);
                    return;
                }
                if (zOrder === child.zIndex) {
                    return;
                }
                cc.renderer.childrenOrderDirty = this._reorderChildDirty = true;
                child.updateOrderOfArrival();
                child._setLocalZOrder(zOrder);
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.orderDirty);
            },
            sortAllChildren: function() {
                if (this._reorderChildDirty) {
                    var _children = this._children;
                    var len = _children.length, i, j, tmp;
                    for (i = 1; i < len; i++) {
                        tmp = _children[i];
                        j = i - 1;
                        while (j >= 0) {
                            if (tmp._localZOrder < _children[j]._localZOrder) {
                                _children[j + 1] = _children[j];
                            } else {
                                if (!(tmp._localZOrder === _children[j]._localZOrder && tmp._arrivalOrder < _children[j]._arrivalOrder)) {
                                    break;
                                }
                                _children[j + 1] = _children[j];
                            }
                            j--;
                        }
                        _children[j + 1] = tmp;
                    }
                    this._reorderChildDirty = false;
                }
            },
            draw: function(ctx) {},
            transformAncestors: function() {
                if (null !== this._parent) {
                    this._parent.transformAncestors();
                    this._parent.transform();
                }
            },
            onEnter: function() {
                this._isTransitionFinished = false;
                this._running = true;
                this.resume();
            },
            performRecursive: function(callbackType) {
                var nodeCallbackType = _ccsg.Node.performType;
                if (callbackType >= nodeCallbackType.max) {
                    return;
                }
                var index = 0;
                var children, child, curr, i, len;
                var stack = _ccsg.Node._performStacks[_ccsg.Node._performing];
                if (!stack) {
                    stack = [];
                    _ccsg.Node._performStacks.push(stack);
                }
                stack.length = 0;
                _ccsg.Node._performing++;
                curr = stack[0] = this;
                while (curr) {
                    children = curr._children;
                    if (children && children.length > 0) {
                        for (i = 0, len = children.length; i < len; ++i) {
                            child = children[i];
                            stack.push(child);
                        }
                    }
                    index++;
                    curr = stack[index];
                }
                switch (callbackType) {
                  case nodeCallbackType.onEnter:
                    for (i = stack.length - 1; i >= 0; --i) {
                        curr = stack[i];
                        stack[i] = null;
                        if (!curr) {
                            continue;
                        }
                        curr.onEnter();
                    }
                    break;

                  case nodeCallbackType.onExit:
                    for (i = stack.length - 1; i >= 0; --i) {
                        curr = stack[i];
                        stack[i] = null;
                        if (!curr) {
                            continue;
                        }
                        curr.onExit();
                    }
                    break;

                  case nodeCallbackType.onEnterTransitionDidFinish:
                    for (i = stack.length - 1; i >= 0; --i) {
                        curr = stack[i];
                        stack[i] = null;
                        if (!curr) {
                            continue;
                        }
                        curr.onEnterTransitionDidFinish();
                    }
                    break;

                  case nodeCallbackType.cleanup:
                    for (i = stack.length - 1; i >= 0; --i) {
                        curr = stack[i];
                        stack[i] = null;
                        if (!curr) {
                            continue;
                        }
                        curr.cleanup();
                    }
                    break;

                  case nodeCallbackType.onExitTransitionDidStart:
                    for (i = stack.length - 1; i >= 0; --i) {
                        curr = stack[i];
                        stack[i] = null;
                        if (!curr) {
                            continue;
                        }
                        curr.onExitTransitionDidStart();
                    }
                }
                _ccsg.Node._performing--;
            },
            onEnterTransitionDidFinish: function() {
                this._isTransitionFinished = true;
            },
            onExitTransitionDidStart: function() {},
            onExit: function() {
                this._running = false;
                this.pause();
            },
            runAction: ActionManagerExist ? function(action) {
                cc.assertID(action, 1618);
                cc.director.getActionManager().addAction(action, this, !this._running);
                return action;
            } : emptyFunc,
            stopAllActions: ActionManagerExist ? function() {
                cc.director.getActionManager().removeAllActionsFromTarget(this);
            } : emptyFunc,
            stopAction: ActionManagerExist ? function(action) {
                cc.director.getActionManager().removeAction(action);
            } : emptyFunc,
            stopActionByTag: ActionManagerExist ? function(tag) {
                if (tag === cc.Action.TAG_INVALID) {
                    cc.logID(1612);
                    return;
                }
                cc.director.getActionManager().removeActionByTag(tag, this);
            } : emptyFunc,
            getActionByTag: ActionManagerExist ? function(tag) {
                if (tag === cc.Action.TAG_INVALID) {
                    cc.logID(1613);
                    return null;
                }
                return cc.director.getActionManager().getActionByTag(tag, this);
            } : function() {
                return null;
            },
            getNumberOfRunningActions: ActionManagerExist ? function() {
                return cc.director.getActionManager().getNumberOfRunningActionsInTarget(this);
            } : function() {
                return 0;
            },
            scheduleUpdate: function() {
                this.scheduleUpdateWithPriority(0);
            },
            scheduleUpdateWithPriority: function(priority) {
                this.scheduler.scheduleUpdate(this, priority, !this._running);
            },
            unscheduleUpdate: function() {
                this.scheduler.unscheduleUpdate(this);
            },
            schedule: function(callback, interval, repeat, delay, key) {
                var len = arguments.length;
                if ("function" === typeof callback) {
                    if (1 === len) {
                        interval = 0;
                        repeat = cc.macro.REPEAT_FOREVER;
                        delay = 0;
                        key = this.__instanceId;
                    } else {
                        if (2 === len) {
                            if ("number" === typeof interval) {
                                repeat = cc.macro.REPEAT_FOREVER;
                                delay = 0;
                                key = this.__instanceId;
                            } else {
                                key = interval;
                                interval = 0;
                                repeat = cc.macro.REPEAT_FOREVER;
                                delay = 0;
                            }
                        } else {
                            if (3 === len) {
                                if ("string" === typeof repeat) {
                                    key = repeat;
                                    repeat = cc.macro.REPEAT_FOREVER;
                                } else {
                                    key = this.__instanceId;
                                }
                                delay = 0;
                            } else {
                                4 === len && (key = this.__instanceId);
                            }
                        }
                    }
                } else {
                    if (1 === len) {
                        interval = 0;
                        repeat = cc.macro.REPEAT_FOREVER;
                        delay = 0;
                    } else {
                        if (2 === len) {
                            repeat = cc.macro.REPEAT_FOREVER;
                            delay = 0;
                        }
                    }
                }
                cc.assertID(callback, 1619);
                cc.assertID(interval >= 0, 1620);
                interval = interval || 0;
                repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat;
                delay = delay || 0;
                this.scheduler.schedule(callback, this, interval, repeat, delay, !this._running, key);
            },
            scheduleOnce: function(callback, delay, key) {
                void 0 === key && (key = this.__instanceId);
                this.schedule(callback, 0, 0, delay, key);
            },
            unschedule: function(callback_fn) {
                if (!callback_fn) {
                    return;
                }
                this.scheduler.unschedule(callback_fn, this);
            },
            unscheduleAllCallbacks: function() {
                this.scheduler.unscheduleAllForTarget(this);
            },
            resumeSchedulerAndActions: function() {
                cc.logID(1614);
                this.resume();
            },
            resume: function() {
                this.scheduler.resumeTarget(this);
                ActionManagerExist && cc.director.getActionManager().resumeTarget(this);
                cc.eventManager.resumeTarget(this);
            },
            pauseSchedulerAndActions: function() {
                cc.logID(1615);
                this.pause();
            },
            pause: function() {
                this.scheduler.pauseTarget(this);
                ActionManagerExist && cc.director.getActionManager().pauseTarget(this);
                cc.eventManager.pauseTarget(this);
            },
            getParentToNodeTransform: function() {
                return this._renderCmd.getParentToNodeTransform();
            },
            parentToNodeTransform: function() {
                return this.getParentToNodeTransform();
            },
            getNodeToWorldTransform: function() {
                var t = this.getNodeToParentTransform();
                for (var p = this._parent; null !== p; p = p.parent) {
                    t = cc.affineTransformConcat(t, p.getNodeToParentTransform());
                }
                return t;
            },
            nodeToWorldTransform: function() {
                return this.getNodeToWorldTransform();
            },
            getWorldToNodeTransform: function() {
                return cc.affineTransformInvert(this.getNodeToWorldTransform());
            },
            worldToNodeTransform: function() {
                return this.getWorldToNodeTransform();
            },
            convertToNodeSpace: function(worldPoint) {
                return cc.pointApplyAffineTransform(worldPoint, this.getWorldToNodeTransform());
            },
            convertToWorldSpace: function(nodePoint) {
                nodePoint = nodePoint || cc.v2(0, 0);
                return cc.pointApplyAffineTransform(nodePoint, this.getNodeToWorldTransform());
            },
            convertToNodeSpaceAR: function(worldPoint) {
                return cc.pSub(this.convertToNodeSpace(worldPoint), this._renderCmd.getAnchorPointInPoints());
            },
            convertToWorldSpaceAR: function(nodePoint) {
                nodePoint = nodePoint || cc.v2(0, 0);
                var pt = cc.pAdd(nodePoint, this._renderCmd.getAnchorPointInPoints());
                return this.convertToWorldSpace(pt);
            },
            _convertToWindowSpace: function(nodePoint) {
                var worldPoint = this.convertToWorldSpace(nodePoint);
                return cc.director.convertToUI(worldPoint);
            },
            convertTouchToNodeSpace: function(touch) {
                var point = touch.getLocation();
                return this.convertToNodeSpace(point);
            },
            convertTouchToNodeSpaceAR: function(touch) {
                var point = cc.director.convertToGL(touch.getLocation());
                return this.convertToNodeSpaceAR(point);
            },
            updateTransform: function() {
                var children = this._children, node;
                for (var i = 0; i < children.length; i++) {
                    var node = children[i];
                    node && node.updateTransform();
                }
            },
            retain: function() {},
            release: function() {},
            visit: function(parent) {
                var cmd = this._renderCmd, parentCmd = parent ? parent._renderCmd : null;
                if (!this._visible) {
                    cmd._propagateFlagsDown(parentCmd);
                    return;
                }
                var renderer = cc.renderer;
                cmd.visit(parentCmd);
                var i, children = this._children, len = children.length, child;
                if (len > 0) {
                    this._reorderChildDirty && this.sortAllChildren();
                    for (i = 0; i < len; i++) {
                        child = children[i];
                        if (!(child._localZOrder < 0)) {
                            break;
                        }
                        child.visit(this);
                    }
                    renderer.pushRenderCommand(cmd);
                    for (;i < len; i++) {
                        children[i].visit(this);
                    }
                } else {
                    renderer.pushRenderCommand(cmd);
                }
                cmd._dirtyFlag = 0;
            },
            transform: function(parentCmd, recursive) {
                this._renderCmd.transform(parentCmd, recursive);
            },
            nodeToParentTransform: function() {
                return this.getNodeToParentTransform();
            },
            getNodeToParentTransform: function(ancestor) {
                var t = this._renderCmd.getNodeToParentTransform();
                if (ancestor) {
                    var T = {
                        a: t.a,
                        b: t.b,
                        c: t.c,
                        d: t.d,
                        tx: t.tx,
                        ty: t.ty
                    };
                    for (var p = this._parent; null != p && p != ancestor; p = p.getParent()) {
                        cc.affineTransformConcatIn(T, p.getNodeToParentTransform());
                    }
                    return T;
                }
                return t;
            },
            getNodeToParentAffineTransform: function(ancestor) {
                return this.getNodeToParentTransform(ancestor);
            },
            getShaderProgram: function() {
                return this._renderCmd.getShaderProgram();
            },
            setShaderProgram: function(newShaderProgram) {
                this._renderCmd.setShaderProgram(newShaderProgram);
            },
            getGLServerState: function() {
                return 0;
            },
            setGLServerState: function(state) {},
            getBoundingBoxToWorld: function() {
                var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
                var trans = this.getNodeToWorldTransform();
                cc._rectApplyAffineTransformIn(rect, trans);
                if (!this._children) {
                    return rect;
                }
                var locChildren = this._children;
                for (var i = 0; i < locChildren.length; i++) {
                    var child = locChildren[i];
                    if (child && child._visible) {
                        var childRect = child._getBoundingBoxToCurrentNode(trans);
                        childRect && (rect = cc.rectUnion(rect, childRect));
                    }
                }
                return rect;
            },
            _getBoundingBoxToCurrentNode: function(parentTransform) {
                var rect = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
                var trans = void 0 === parentTransform ? this.getNodeToParentTransform() : cc.affineTransformConcat(this.getNodeToParentTransform(), parentTransform);
                cc._rectApplyAffineTransformIn(rect, trans);
                if (!this._children) {
                    return rect;
                }
                var locChildren = this._children;
                for (var i = 0; i < locChildren.length; i++) {
                    var child = locChildren[i];
                    if (child && child._visible) {
                        var childRect = child._getBoundingBoxToCurrentNode(trans);
                        childRect && (rect = cc.rectUnion(rect, childRect));
                    }
                }
                return rect;
            },
            getOpacity: function() {
                return this._realOpacity;
            },
            getDisplayedOpacity: function() {
                return this._renderCmd.getDisplayedOpacity();
            },
            setOpacity: function(opacity) {
                this._realOpacity = opacity;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.opacityDirty);
            },
            updateDisplayedOpacity: function(parentOpacity) {
                this._renderCmd._updateDisplayOpacity(parentOpacity);
            },
            isCascadeOpacityEnabled: function() {
                return this._cascadeOpacityEnabled;
            },
            setCascadeOpacityEnabled: function(cascadeOpacityEnabled) {
                if (this._cascadeOpacityEnabled === cascadeOpacityEnabled) {
                    return;
                }
                this._cascadeOpacityEnabled = cascadeOpacityEnabled;
                this._renderCmd.setCascadeOpacityEnabledDirty();
            },
            getColor: function() {
                var locRealColor = this._realColor;
                return cc.color(locRealColor.r, locRealColor.g, locRealColor.b, locRealColor.a);
            },
            getDisplayedColor: function() {
                return this._renderCmd.getDisplayedColor();
            },
            setColor: function(color) {
                var locRealColor = this._realColor;
                locRealColor.r = color.r;
                locRealColor.g = color.g;
                locRealColor.b = color.b;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty);
            },
            updateDisplayedColor: function(parentColor) {
                this._renderCmd._updateDisplayColor(parentColor);
            },
            isCascadeColorEnabled: function() {
                return this._cascadeColorEnabled;
            },
            setCascadeColorEnabled: function(cascadeColorEnabled) {
                if (this._cascadeColorEnabled === cascadeColorEnabled) {
                    return;
                }
                this._cascadeColorEnabled = cascadeColorEnabled;
                this._renderCmd.setCascadeColorEnabledDirty();
            },
            setOpacityModifyRGB: function(opacityValue) {},
            isOpacityModifyRGB: function() {
                return false;
            },
            _createRenderCmd: function() {
                return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new _ccsg.Node.CanvasRenderCmd(this) : new _ccsg.Node.WebGLRenderCmd(this);
            }
        });
        _ccsg.Node.extend = cc._Class.extend;
        _ccsg.Node.prototype.ctor = _ccsg.Node;
        _ccsg.Node.performType = {
            onEnter: 1,
            onExit: 2,
            cleanup: 3,
            onEnterTransitionDidFinish: 4,
            onExitTransitionDidStart: 5,
            max: 6
        };
        _ccsg.Node._performStacks = [ [] ];
        _ccsg.Node._performing = 0;
        cc.assertID("function" === typeof cc._tmp.PrototypeCCNode, 3200, "BaseNodesPropertyDefine.js");
        cc._tmp.PrototypeCCNode();
        delete cc._tmp.PrototypeCCNode;
    }), {} ],
    58: [ (function(require, module, exports) {
        cc.CustomRenderCmd = function(target, func) {
            this._needDraw = true;
            this._target = target;
            this._callback = func;
        };
        cc.CustomRenderCmd.prototype.rendering = function(ctx, scaleX, scaleY) {
            if (!this._callback) {
                return;
            }
            this._callback.call(this._target, ctx, scaleX, scaleY);
        };
        var dirtyFlags = _ccsg.Node._dirtyFlags = {
            transformDirty: 1,
            visibleDirty: 2,
            colorDirty: 4,
            opacityDirty: 8,
            cacheDirty: 16,
            orderDirty: 32,
            textDirty: 64,
            gradientDirty: 128,
            textureDirty: 256,
            contentDirty: 512,
            COUNT: 9
        };
        cc.js.get(dirtyFlags, "all", (function() {
            var count = dirtyFlags.COUNT;
            return (1 << count) - 1;
        }), false);
        _ccsg.Node._requestDirtyFlag = function(key) {
            cc.assertID(!dirtyFlags[key], 1622, key);
            var count = dirtyFlags.COUNT;
            var value = 1 << count;
            dirtyFlags[key] = value;
            dirtyFlags.COUNT++;
            return value;
        };
        var ONE_DEGREE = Math.PI / 180;
        function transformChildTree(root) {
            var index = 1;
            var children, child, curr, parentCmd, i, len;
            var stack = _ccsg.Node._performStacks[_ccsg.Node._performing];
            if (!stack) {
                stack = [];
                _ccsg.Node._performStacks.push(stack);
            }
            stack.length = 0;
            _ccsg.Node._performing++;
            stack[0] = root;
            while (index) {
                index--;
                curr = stack[index];
                stack[index] = null;
                if (!curr) {
                    continue;
                }
                children = curr._children;
                if (children && children.length > 0) {
                    parentCmd = curr._renderCmd;
                    for (i = 0, len = children.length; i < len; ++i) {
                        child = children[i];
                        stack[index] = child;
                        index++;
                        child._renderCmd.transform(parentCmd);
                    }
                }
            }
            _ccsg.Node._performing--;
        }
        _ccsg.Node.RenderCmd = function(renderable) {
            this._node = renderable;
            this._anchorPointInPoints = new cc.Vec2(0, 0);
            this._needDraw = false;
            this._dirtyFlag = 1;
            this._curLevel = -1;
            this._displayedColor = new cc.Color(255, 255, 255, 255);
            this._displayedOpacity = 255;
            this._cascadeColorEnabledDirty = false;
            this._cascadeOpacityEnabledDirty = false;
            this._transform = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                tx: 0,
                ty: 0
            };
            this._worldTransform = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                tx: 0,
                ty: 0
            };
            this._inverse = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                tx: 0,
                ty: 0
            };
            this._transformUpdated = false;
            cc.renderer.pushDirtyNode(this);
        };
        _ccsg.Node.RenderCmd.prototype = {
            constructor: _ccsg.Node.RenderCmd,
            _ctor: _ccsg.Node.RenderCmd,
            getAnchorPointInPoints: function() {
                return cc.p(this._anchorPointInPoints);
            },
            getDisplayedColor: function() {
                var tmpColor = this._displayedColor;
                return cc.color(tmpColor.r, tmpColor.g, tmpColor.b, tmpColor.a);
            },
            getDisplayedOpacity: function() {
                return this._displayedOpacity;
            },
            setCascadeColorEnabledDirty: function() {
                this._cascadeColorEnabledDirty = true;
                this.setDirtyFlag(dirtyFlags.colorDirty);
            },
            setCascadeOpacityEnabledDirty: function() {
                this._cascadeOpacityEnabledDirty = true;
                this.setDirtyFlag(dirtyFlags.opacityDirty);
            },
            getParentToNodeTransform: function() {
                this._dirtyFlag & dirtyFlags.transformDirty && cc.affineTransformInvertOut(this.getNodeToParentTransform(), this._inverse);
                return this._inverse;
            },
            detachFromParent: function() {},
            _updateAnchorPointInPoint: function() {
                var locAPP = this._anchorPointInPoints, locSize = this._node._contentSize, locAnchorPoint = this._node._anchorPoint;
                locAPP.x = locSize.width * locAnchorPoint.x;
                locAPP.y = locSize.height * locAnchorPoint.y;
                this.setDirtyFlag(dirtyFlags.transformDirty);
            },
            setDirtyFlag: function(dirtyFlag) {
                0 === this._dirtyFlag && 0 !== dirtyFlag && cc.renderer.pushDirtyNode(this);
                this._dirtyFlag |= dirtyFlag;
            },
            getParentRenderCmd: function() {
                if (this._node && this._node._parent && this._node._parent._renderCmd) {
                    return this._node._parent._renderCmd;
                }
                return null;
            },
            transform: function(parentCmd, recursive) {
                var node = this._node, pt = parentCmd ? parentCmd._worldTransform : null, t = this._transform, wt = this._worldTransform;
                if (!this._transformUpdated) {
                    var hasRotation = node._rotationX || node._rotationY;
                    var hasSkew = node._skewX || node._skewY;
                    var sx = node._scaleX, sy = node._scaleY;
                    var appX = this._anchorPointInPoints.x, appY = this._anchorPointInPoints.y;
                    var a = 1, b = 0, c = 0, d = 1;
                    if (hasRotation || hasSkew) {
                        t.tx = node._position.x;
                        t.ty = node._position.y;
                        if (hasRotation) {
                            var rotationRadiansX = node._rotationX * ONE_DEGREE;
                            c = Math.sin(rotationRadiansX);
                            d = Math.cos(rotationRadiansX);
                            if (node._rotationY === node._rotationX) {
                                a = d;
                                b = -c;
                            } else {
                                var rotationRadiansY = node._rotationY * ONE_DEGREE;
                                a = Math.cos(rotationRadiansY);
                                b = -Math.sin(rotationRadiansY);
                            }
                        }
                        t.a = a *= sx;
                        t.b = b *= sx;
                        t.c = c *= sy;
                        t.d = d *= sy;
                        if (hasSkew) {
                            var skx = Math.tan(node._skewX * ONE_DEGREE);
                            var sky = Math.tan(node._skewY * ONE_DEGREE);
                            skx === 1 / 0 && (skx = 99999999);
                            sky === 1 / 0 && (sky = 99999999);
                            t.a = a + c * sky;
                            t.b = b + d * sky;
                            t.c = c + a * skx;
                            t.d = d + b * skx;
                        }
                        if (appX || appY) {
                            t.tx -= t.a * appX + t.c * appY;
                            t.ty -= t.b * appX + t.d * appY;
                            if (node._ignoreAnchorPointForPosition) {
                                t.tx += appX;
                                t.ty += appY;
                            }
                        }
                    } else {
                        t.a = sx;
                        t.b = 0;
                        t.c = 0;
                        t.d = sy;
                        t.tx = node._position.x;
                        t.ty = node._position.y;
                        if (appX || appY) {
                            t.tx -= t.a * appX;
                            t.ty -= t.d * appY;
                            if (node._ignoreAnchorPointForPosition) {
                                t.tx += appX;
                                t.ty += appY;
                            }
                        }
                    }
                }
                if (pt) {
                    wt.a = t.a * pt.a + t.b * pt.c;
                    wt.b = t.a * pt.b + t.b * pt.d;
                    wt.c = t.c * pt.a + t.d * pt.c;
                    wt.d = t.c * pt.b + t.d * pt.d;
                    wt.tx = t.tx * pt.a + t.ty * pt.c + pt.tx;
                    wt.ty = t.tx * pt.b + t.ty * pt.d + pt.ty;
                } else {
                    wt.a = t.a;
                    wt.b = t.b;
                    wt.c = t.c;
                    wt.d = t.d;
                    wt.tx = t.tx;
                    wt.ty = t.ty;
                }
                if (this._currentRegion) {
                    this._updateCurrentRegions();
                    this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.DirtyDouble);
                }
                recursive && transformChildTree(node);
            },
            getNodeToParentTransform: function() {
                this._dirtyFlag & dirtyFlags.transformDirty && this.transform();
                return this._transform;
            },
            setNodeToParentTransform: function(transform) {
                if (transform) {
                    this._transform = transform;
                    this._transformUpdated = true;
                } else {
                    this._transformUpdated = false;
                }
                this.setDirtyFlag(dirtyFlags.transformDirty);
            },
            _propagateFlagsDown: function(parentCmd) {
                var locFlag = this._dirtyFlag;
                var parentNode = parentCmd ? parentCmd._node : null;
                parentNode && parentNode._cascadeColorEnabled && parentCmd._dirtyFlag & dirtyFlags.colorDirty && (locFlag |= dirtyFlags.colorDirty);
                parentNode && parentNode._cascadeOpacityEnabled && parentCmd._dirtyFlag & dirtyFlags.opacityDirty && (locFlag |= dirtyFlags.opacityDirty);
                parentCmd && parentCmd._dirtyFlag & dirtyFlags.transformDirty && (locFlag |= dirtyFlags.transformDirty);
                this._dirtyFlag = locFlag;
            },
            visit: function(parentCmd) {
                var node = this._node, renderer = cc.renderer;
                parentCmd = parentCmd || this.getParentRenderCmd();
                parentCmd && (this._curLevel = parentCmd._curLevel + 1);
                this._propagateFlagsDown(parentCmd);
                if (isNaN(node._customZ)) {
                    node._vertexZ = renderer.assignedZ;
                    renderer.assignedZ += renderer.assignedZStep;
                }
                this._syncStatus(parentCmd);
            },
            _updateDisplayColor: function(parentColor) {
                var node = this._node;
                var locDispColor = this._displayedColor, locRealColor = node._realColor;
                var i, len, selChildren, item;
                this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
                if (this._cascadeColorEnabledDirty && !node._cascadeColorEnabled) {
                    locDispColor.r = locRealColor.r;
                    locDispColor.g = locRealColor.g;
                    locDispColor.b = locRealColor.b;
                    var whiteColor = new cc.Color(255, 255, 255, 255);
                    selChildren = node._children;
                    for (i = 0, len = selChildren.length; i < len; i++) {
                        item = selChildren[i];
                        item && item._renderCmd && item._renderCmd._updateDisplayColor(whiteColor);
                    }
                    this._cascadeColorEnabledDirty = false;
                } else {
                    if (void 0 === parentColor) {
                        var locParent = node._parent;
                        parentColor = locParent && locParent._cascadeColorEnabled ? locParent.getDisplayedColor() : cc.Color.WHITE;
                    }
                    locDispColor.r = 0 | locRealColor.r * parentColor.r / 255;
                    locDispColor.g = 0 | locRealColor.g * parentColor.g / 255;
                    locDispColor.b = 0 | locRealColor.b * parentColor.b / 255;
                    if (node._cascadeColorEnabled) {
                        selChildren = node._children;
                        for (i = 0, len = selChildren.length; i < len; i++) {
                            item = selChildren[i];
                            if (item && item._renderCmd) {
                                item._renderCmd._updateDisplayColor(locDispColor);
                                item._renderCmd._updateColor();
                            }
                        }
                    }
                }
                this._dirtyFlag &= ~dirtyFlags.colorDirty;
            },
            _updateDisplayOpacity: function(parentOpacity) {
                var node = this._node;
                var i, len, selChildren, item;
                this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
                if (this._cascadeOpacityEnabledDirty && !node._cascadeOpacityEnabled) {
                    this._displayedOpacity = node._realOpacity;
                    selChildren = node._children;
                    for (i = 0, len = selChildren.length; i < len; i++) {
                        item = selChildren[i];
                        item && item._renderCmd && item._renderCmd._updateDisplayOpacity(255);
                    }
                    this._cascadeOpacityEnabledDirty = false;
                } else {
                    if (void 0 === parentOpacity) {
                        var locParent = node._parent;
                        parentOpacity = 255;
                        locParent && locParent._cascadeOpacityEnabled && (parentOpacity = locParent.getDisplayedOpacity());
                    }
                    this._displayedOpacity = node._realOpacity * parentOpacity / 255;
                    if (node._cascadeOpacityEnabled) {
                        selChildren = node._children;
                        for (i = 0, len = selChildren.length; i < len; i++) {
                            item = selChildren[i];
                            if (item && item._renderCmd) {
                                item._renderCmd._updateDisplayOpacity(this._displayedOpacity);
                                item._renderCmd._updateColor();
                            }
                        }
                    }
                }
                this._dirtyFlag &= ~dirtyFlags.opacityDirty;
            },
            _syncDisplayColor: function(parentColor) {
                var node = this._node, locDispColor = this._displayedColor, locRealColor = node._realColor;
                if (void 0 === parentColor) {
                    var locParent = node._parent;
                    parentColor = locParent && locParent._cascadeColorEnabled ? locParent.getDisplayedColor() : cc.Color.WHITE;
                }
                locDispColor.r = 0 | locRealColor.r * parentColor.r / 255;
                locDispColor.g = 0 | locRealColor.g * parentColor.g / 255;
                locDispColor.b = 0 | locRealColor.b * parentColor.b / 255;
            },
            _syncDisplayOpacity: function(parentOpacity) {
                var node = this._node;
                if (void 0 === parentOpacity) {
                    var locParent = node._parent;
                    parentOpacity = 255;
                    locParent && locParent._cascadeOpacityEnabled && (parentOpacity = locParent.getDisplayedOpacity());
                }
                this._displayedOpacity = node._realOpacity * parentOpacity / 255;
            },
            _updateColor: function() {},
            updateStatus: function() {
                var locFlag = this._dirtyFlag;
                var colorDirty = locFlag & dirtyFlags.colorDirty, opacityDirty = locFlag & dirtyFlags.opacityDirty;
                if (locFlag & dirtyFlags.contentDirty) {
                    this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
                    this._dirtyFlag &= ~dirtyFlags.contentDirty;
                }
                colorDirty && this._updateDisplayColor();
                opacityDirty && this._updateDisplayOpacity();
                (colorDirty || opacityDirty) && this._updateColor();
                if (locFlag & dirtyFlags.transformDirty) {
                    this.transform(this.getParentRenderCmd(), true);
                    this._dirtyFlag &= ~dirtyFlags.transformDirty;
                }
            },
            _syncStatus: function(parentCmd) {
                var locFlag = this._dirtyFlag;
                var colorDirty = locFlag & dirtyFlags.colorDirty, opacityDirty = locFlag & dirtyFlags.opacityDirty;
                colorDirty && this._syncDisplayColor();
                opacityDirty && this._syncDisplayOpacity();
                (colorDirty || opacityDirty) && this._updateColor();
                locFlag & dirtyFlags.transformDirty && this.transform(parentCmd);
            }
        };
        _ccsg.Node.RenderCmd.prototype.originTransform = _ccsg.Node.RenderCmd.prototype.transform;
        _ccsg.Node.RenderCmd.prototype.originUpdateStatus = _ccsg.Node.RenderCmd.prototype.updateStatus;
        _ccsg.Node.RenderCmd.prototype._originSyncStatus = _ccsg.Node.RenderCmd.prototype._syncStatus;
        _ccsg.Node.CanvasRenderCmd = function(renderable) {
            this._ctor(renderable);
            this._currentRegion = new cc.Region();
            this._oldRegion = new cc.Region();
            this._regionFlag = 0;
        };
        _ccsg.Node.CanvasRenderCmd.RegionStatus = {
            NotDirty: 0,
            Dirty: 1,
            DirtyDouble: 2
        };
        var proto = _ccsg.Node.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.RenderCmd.prototype);
        proto.constructor = _ccsg.Node.CanvasRenderCmd;
        proto._rootCtor = _ccsg.Node.CanvasRenderCmd;
        proto._notifyRegionStatus = function(status) {
            this._needDraw && this._regionFlag < status && (this._regionFlag = status);
        };
        var localBB = new cc.Rect();
        proto.getLocalBB = function() {
            var node = this._node;
            localBB.x = localBB.y = 0;
            localBB.width = node._contentSize.width;
            localBB.height = node._contentSize.height;
            return localBB;
        };
        proto._updateCurrentRegions = function() {
            var temp = this._currentRegion;
            this._currentRegion = this._oldRegion;
            this._oldRegion = temp;
            _ccsg.Node.CanvasRenderCmd.RegionStatus.DirtyDouble !== this._regionFlag || this._currentRegion.isEmpty() || this._oldRegion.union(this._currentRegion);
            this._currentRegion.updateRegion(this.getLocalBB(), this._worldTransform);
        };
        proto.detachFromParent = function() {
            var selChildren = this._node._children, item;
            for (var i = 0, len = selChildren.length; i < len; i++) {
                item = selChildren[i];
                item && item._renderCmd && item._renderCmd.detachFromParent();
            }
        };
        proto.setShaderProgram = function(shaderProgram) {};
        proto.getShaderProgram = function() {
            return null;
        };
        _ccsg.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc = function(blendFunc) {
            return blendFunc ? blendFunc.src === cc.macro.SRC_ALPHA && blendFunc.dst === cc.macro.ONE || blendFunc.src === cc.macro.ONE && blendFunc.dst === cc.macro.ONE ? "lighter" : blendFunc.src === cc.macro.ZERO && blendFunc.dst === cc.macro.SRC_ALPHA ? "destination-in" : blendFunc.src === cc.macro.ZERO && blendFunc.dst === cc.macro.ONE_MINUS_SRC_ALPHA ? "destination-out" : "source-over" : "source-over";
        };
    }), {} ],
    59: [ (function(require, module, exports) {
        _ccsg.Node.WebGLRenderCmd = function(renderable) {
            this._ctor(renderable);
            this._shaderProgram = null;
        };
        var proto = _ccsg.Node.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.RenderCmd.prototype);
        proto.constructor = _ccsg.Node.WebGLRenderCmd;
        proto._rootCtor = _ccsg.Node.WebGLRenderCmd;
        proto._updateColor = function() {};
        proto.setShaderProgram = function(shaderProgram) {
            this._shaderProgram = shaderProgram;
        };
        proto.getShaderProgram = function() {
            return this._shaderProgram;
        };
    }), {} ],
    60: [ (function(require, module, exports) {
        var TOP = 1;
        var MID = 2;
        var BOT = 4;
        var LEFT = 8;
        var CENTER = 16;
        var RIGHT = 32;
        var HORIZONTAL = LEFT | CENTER | RIGHT;
        var VERTICAL = TOP | MID | BOT;
        function getReadonlyNodeSize(parent) {
            return parent instanceof cc.Scene ? cc.visibleRect : !parent._sizeProvider || parent._sizeProvider instanceof _ccsg.Node ? parent._contentSize : parent.getContentSize();
        }
        function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
            var scaleX = widgetNode._parent._scaleX;
            var scaleY = widgetNode._parent._scaleY;
            var translateX = 0;
            var translateY = 0;
            for (var node = widgetNode._parent; ;) {
                var pos = node._position;
                translateX += pos.x;
                translateY += pos.y;
                node = node._parent;
                if (!node) {
                    out_inverseTranslate.x = out_inverseTranslate.y = 0;
                    out_inverseScale.x = out_inverseScale.y = 1;
                    return;
                }
                if (node === target) {
                    break;
                }
                var sx = node._scaleX;
                var sy = node._scaleY;
                translateX *= sx;
                translateY *= sy;
                scaleX *= sx;
                scaleY *= sy;
            }
            out_inverseScale.x = 0 !== scaleX ? 1 / scaleX : 1;
            out_inverseScale.y = 0 !== scaleY ? 1 / scaleY : 1;
            out_inverseTranslate.x = -translateX;
            out_inverseTranslate.y = -translateY;
        }
        var tInverseTranslate = cc.Vec2.ZERO;
        var tInverseScale = cc.Vec2.ONE;
        function align(node, widget) {
            var hasTarget = widget._target;
            var target;
            var inverseTranslate, inverseScale;
            if (hasTarget) {
                target = hasTarget;
                inverseTranslate = tInverseTranslate;
                inverseScale = tInverseScale;
                computeInverseTransForTarget(node, target, inverseTranslate, inverseScale);
            } else {
                target = node._parent;
            }
            var targetSize = getReadonlyNodeSize(target);
            var targetAnchor = target._anchorPoint;
            var isRoot = target instanceof cc.Scene;
            var x = node._position.x, y = node._position.y;
            var anchor = node._anchorPoint;
            if (widget._alignFlags & HORIZONTAL) {
                var localLeft, localRight, targetWidth = targetSize.width;
                if (isRoot) {
                    localLeft = cc.visibleRect.left.x;
                    localRight = cc.visibleRect.right.x;
                } else {
                    localLeft = -targetAnchor.x * targetWidth;
                    localRight = localLeft + targetWidth;
                }
                localLeft += widget._isAbsLeft ? widget._left : widget._left * targetWidth;
                localRight -= widget._isAbsRight ? widget._right : widget._right * targetWidth;
                if (hasTarget) {
                    localLeft += inverseTranslate.x;
                    localLeft *= inverseScale.x;
                    localRight += inverseTranslate.x;
                    localRight *= inverseScale.x;
                }
                var width, anchorX = anchor.x, scaleX = node._scaleX;
                if (scaleX < 0) {
                    anchorX = 1 - anchorX;
                    scaleX = -scaleX;
                }
                if (widget.isStretchWidth) {
                    width = localRight - localLeft;
                    0 !== scaleX && (node.width = width / scaleX);
                    x = localLeft + anchorX * width;
                } else {
                    width = node.width * scaleX;
                    if (widget.isAlignHorizontalCenter) {
                        var localHorizontalCenter = widget._isAbsHorizontalCenter ? widget._horizontalCenter : widget._horizontalCenter * targetWidth;
                        var targetCenter = (.5 - targetAnchor.x) * targetSize.width;
                        if (hasTarget) {
                            localHorizontalCenter *= inverseScale.x;
                            targetCenter += inverseTranslate.x;
                            targetCenter *= inverseScale.x;
                        }
                        x = targetCenter + (anchorX - .5) * width + localHorizontalCenter;
                    } else {
                        x = widget.isAlignLeft ? localLeft + anchorX * width : localRight + (anchorX - 1) * width;
                    }
                }
            }
            if (widget._alignFlags & VERTICAL) {
                var localTop, localBottom, targetHeight = targetSize.height;
                if (isRoot) {
                    localBottom = cc.visibleRect.bottom.y;
                    localTop = cc.visibleRect.top.y;
                } else {
                    localBottom = -targetAnchor.y * targetHeight;
                    localTop = localBottom + targetHeight;
                }
                localBottom += widget._isAbsBottom ? widget._bottom : widget._bottom * targetHeight;
                localTop -= widget._isAbsTop ? widget._top : widget._top * targetHeight;
                if (hasTarget) {
                    localBottom += inverseTranslate.y;
                    localBottom *= inverseScale.y;
                    localTop += inverseTranslate.y;
                    localTop *= inverseScale.y;
                }
                var height, anchorY = anchor.y, scaleY = node._scaleY;
                if (scaleY < 0) {
                    anchorY = 1 - anchorY;
                    scaleY = -scaleY;
                }
                if (widget.isStretchHeight) {
                    height = localTop - localBottom;
                    0 !== scaleY && (node.height = height / scaleY);
                    y = localBottom + anchorY * height;
                } else {
                    height = node.height * scaleY;
                    if (widget.isAlignVerticalCenter) {
                        var localVerticalCenter = widget._isAbsVerticalCenter ? widget._verticalCenter : widget._verticalCenter * targetHeight;
                        var targetMiddle = (.5 - targetAnchor.y) * targetSize.height;
                        if (hasTarget) {
                            localVerticalCenter *= inverseScale.y;
                            targetMiddle += inverseTranslate.y;
                            targetMiddle *= inverseScale.y;
                        }
                        y = targetMiddle + (anchorY - .5) * height + localVerticalCenter;
                    } else {
                        y = widget.isAlignBottom ? localBottom + anchorY * height : localTop + (anchorY - 1) * height;
                    }
                }
            }
            node.setPosition(x, y);
        }
        function visitNode(node) {
            var widget = node._widget;
            if (widget) {
                var target = widget._target;
                if (target) {
                    var isParent = node !== target && node.isChildOf(target);
                    if (!isParent) {
                        cc.errorID(6500);
                        widget._target = null;
                    }
                }
                align(node, widget);
                widget.isAlignOnce ? widget.enabled = false : activeWidgets.push(widget);
            }
            var children = node._children;
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                child._active && visitNode(child);
            }
        }
        var animationState;
        function refreshScene() {
            var nowPreviewing;
            var scene = cc.director.getScene();
            if (scene) {
                widgetManager.isAligning = true;
                if (widgetManager._nodesOrderDirty) {
                    activeWidgets.length = 0;
                    visitNode(scene);
                    widgetManager._nodesOrderDirty = false;
                } else {
                    var i, widget, iterator = widgetManager._activeWidgetsIterator;
                    var editingNode;
                    var node;
                    for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) {
                        widget = activeWidgets[iterator.i];
                        align(widget.node, widget);
                    }
                }
                widgetManager.isAligning = false;
            }
        }
        var adjustWidgetToAllowMovingInEditor = false;
        var adjustWidgetToAllowResizingInEditor = false;
        var activeWidgets = [];
        function updateAlignment(node) {
            var parent = node._parent;
            cc.Node.isNode(parent) && updateAlignment(parent);
            var widget = node._widget || node.getComponent(cc.Widget);
            widget && align(node, widget);
        }
        var widgetManager = cc._widgetManager = module.exports = {
            _AlignFlags: {
                TOP: TOP,
                MID: MID,
                BOT: BOT,
                LEFT: LEFT,
                CENTER: CENTER,
                RIGHT: RIGHT
            },
            isAligning: false,
            _nodesOrderDirty: false,
            _activeWidgetsIterator: new cc.js.array.MutableForwardIterator(activeWidgets),
            init: function(director) {
                director.on(cc.Director.EVENT_BEFORE_VISIT, refreshScene);
            },
            add: function(widget) {
                widget.node._widget = widget;
                this._nodesOrderDirty = true;
            },
            remove: function(widget) {
                widget.node._widget = null;
                this._activeWidgetsIterator.remove(widget);
            },
            updateAlignment: updateAlignment
        };
    }), {} ],
    61: [ (function(require, module, exports) {
        require("./CCSGCameraNode");
        var tempTransform = cc.affineTransformMake();
        var Camera = cc.Class({
            name: "cc.Camera",
            extends: cc._RendererUnderSG,
            editor: false,
            properties: {
                _targets: {
                    default: [],
                    type: cc.Node,
                    visible: true
                },
                zoomRatio: 1
            },
            statics: {
                main: null
            },
            _createSgNode: function() {
                if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                    cc.errorID(8301);
                    var sgNode = new _ccsg.Node();
                    sgNode.setTransform = sgNode.addTarget = sgNode.removeTarget = function() {};
                    return sgNode;
                }
                return new _ccsg.CameraNode();
            },
            _initSgNode: function() {},
            _addSgTargetInSg: function(target) {
                target instanceof cc.Node ? this._sgNode.addTarget(target._sgNode) : target instanceof _ccsg.Node && this._sgNode.addTarget(target);
            },
            _removeTargetInSg: function(target) {
                target instanceof cc.Node ? this._sgNode.removeTarget(target._sgNode) : target instanceof _ccsg.Node && this._sgNode.removeTarget(target);
            },
            onEnable: function() {
                if (Camera.main) {
                    cc.errorID(8300);
                    return;
                }
                Camera.main = this;
                var targets = this._targets;
                for (var i = 0, l = targets.length; i < l; i++) {
                    this._addSgTargetInSg(targets[i]);
                }
            },
            onDisable: function() {
                if (Camera.main !== this) {
                    return;
                }
                Camera.main = null;
                var targets = this._targets;
                for (var i = 0, l = targets.length; i < l; i++) {
                    this._removeTargetInSg(targets[i]);
                }
            },
            addTarget: function(target) {
                if (this._targets.indexOf(target) !== -1) {
                    return;
                }
                this._addSgTargetInSg(target);
                this._targets.push(target);
            },
            removeTarget: function(target) {
                if (this._targets.indexOf(target) === -1) {
                    return;
                }
                this._removeTargetInSg(target);
                cc.js.array.remove(this._targets, target);
            },
            getTargets: function() {
                return this._targets;
            },
            calculateCameraTransformIn: function(transform) {
                var node = this.node;
                var wt = node.getNodeToWorldTransform();
                var rotation = .5 * -(Math.atan2(wt.b, wt.a) + Math.atan2(-wt.c, wt.d));
                var a = 1, b = 0, c = 0, d = 1;
                if (rotation) {
                    c = Math.sin(rotation);
                    d = Math.cos(rotation);
                    a = d;
                    b = -c;
                }
                var zoomRatio = this.zoomRatio;
                a *= zoomRatio;
                b *= zoomRatio;
                c *= zoomRatio;
                d *= zoomRatio;
                var center = cc.visibleRect.center;
                transform.tx = center.x - (a * wt.tx + c * wt.ty);
                transform.ty = center.y - (b * wt.tx + d * wt.ty);
                transform.a = a;
                transform.b = b;
                transform.c = c;
                transform.d = d;
            },
            lateUpdate: function() {
                var t = tempTransform;
                this.calculateCameraTransformIn(t);
                this._sgNode.setTransform(t.a, t.b, t.c, t.d, t.tx, t.ty);
            }
        });
        module.exports = cc.Camera = Camera;
    }), {
        "./CCSGCameraNode": 62
    } ],
    62: [ (function(require, module, exports) {
        var CameraNode = _ccsg.Node.extend({
            ctor: function() {
                this._super();
                this._mat = new cc.math.Matrix4();
                this._mat.identity();
                this._beforeVisitCmd = new cc.CustomRenderCmd(this, this._onBeforeVisit);
                this._afterVisitCmd = new cc.CustomRenderCmd(this, this._onAfterVisit);
            },
            setTransform: function(a, b, c, d, tx, ty) {
                var mat = this._mat.mat;
                mat[0] = a;
                mat[1] = b;
                mat[4] = c;
                mat[5] = d;
                mat[12] = tx;
                mat[13] = ty;
            },
            addTarget: function(target) {
                if (target._cameraInfo) {
                    return;
                }
                target._cameraInfo = {
                    sgCameraNode: this,
                    originVisit: target.visit
                };
                target.visit = this._visit;
            },
            removeTarget: function(target) {
                var info = target._cameraInfo;
                if (!info) {
                    return;
                }
                target.visit = info.originVisit;
                target._cameraInfo = void 0;
            },
            _visit: function(parent) {
                var info = this._cameraInfo;
                var sgCameraNode = info.sgCameraNode;
                cc.renderer.pushRenderCommand(sgCameraNode._beforeVisitCmd);
                info.originVisit.call(this, parent);
                cc.renderer.pushRenderCommand(sgCameraNode._afterVisitCmd);
            },
            _onBeforeVisit: function() {
                cc.renderer._breakBatch();
                cc.math.glMatrixMode(cc.math.KM_GL_PROJECTION);
                cc.current_stack.push();
                cc.current_stack.top.multiply(this._mat);
            },
            _onAfterVisit: function() {
                cc.renderer._breakBatch();
                cc.math.glMatrixMode(cc.math.KM_GL_PROJECTION);
                cc.current_stack.pop();
            }
        });
        module.exports = _ccsg.CameraNode = CameraNode;
    }), {} ],
    63: [ (function(require, module, exports) {
        cc.Collider.Box = cc.Class({
            properties: {
                _offset: cc.v2(0, 0),
                _size: cc.size(100, 100),
                offset: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.offset",
                    get: function() {
                        return this._offset;
                    },
                    set: function(value) {
                        this._offset = value;
                    },
                    type: cc.Vec2
                },
                size: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.size",
                    get: function() {
                        return this._size;
                    },
                    set: function(value) {
                        this._size.width = value.width < 0 ? 0 : value.width;
                        this._size.height = value.height < 0 ? 0 : value.height;
                    },
                    type: cc.Size
                }
            },
            resetInEditor: false
        });
        var BoxCollider = cc.Class({
            name: "cc.BoxCollider",
            extends: cc.Collider,
            mixins: [ cc.Collider.Box ],
            editor: false
        });
        cc.BoxCollider = module.exports = BoxCollider;
    }), {} ],
    64: [ (function(require, module, exports) {
        cc.Collider.Circle = cc.Class({
            properties: {
                _offset: cc.v2(0, 0),
                _radius: 50,
                offset: {
                    get: function() {
                        return this._offset;
                    },
                    set: function(value) {
                        this._offset = value;
                    },
                    type: cc.Vec2
                },
                radius: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.radius",
                    get: function() {
                        return this._radius;
                    },
                    set: function(value) {
                        this._radius = value < 0 ? 0 : value;
                    }
                }
            },
            resetInEditor: false
        });
        var CircleCollider = cc.Class({
            name: "cc.CircleCollider",
            extends: cc.Collider,
            mixins: [ cc.Collider.Circle ],
            editor: false
        });
        cc.CircleCollider = module.exports = CircleCollider;
    }), {} ],
    65: [ (function(require, module, exports) {
        var Collider = cc.Class({
            name: "cc.Collider",
            extends: cc.Component,
            properties: {
                editing: {
                    default: false,
                    serializable: false,
                    tooltip: "i18n:COMPONENT.collider.editing"
                },
                tag: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.tag",
                    default: 0,
                    range: [ 0, 1e7 ],
                    type: cc.Integer
                }
            },
            onDisable: function() {
                cc.director.getCollisionManager().removeCollider(this);
            },
            onEnable: function() {
                cc.director.getCollisionManager().addCollider(this);
            }
        });
        cc.Collider = module.exports = Collider;
    }), {} ],
    66: [ (function(require, module, exports) {
        var Contact = require("./CCContact");
        var CollisionType = Contact.CollisionType;
        var tempRect = cc.rect();
        var tempVec2 = cc.v2();
        var CollisionManager = cc.Class({
            mixins: [ cc.EventTarget ],
            properties: {
                enabled: false,
                enabledDrawBoundingBox: false
            },
            ctor: function() {
                this.__instanceId = cc.ClassManager.getNewInstanceId();
                this._contacts = [];
                this._colliders = [];
                this._debugDrawer = null;
                this._enabledDebugDraw = false;
            },
            update: function(dt) {
                if (!this.enabled) {
                    return;
                }
                var i, l;
                var colliders = this._colliders;
                for (i = 0, l = colliders.length; i < l; i++) {
                    this.updateCollider(colliders[i]);
                }
                var contacts = this._contacts;
                var results = [];
                for (i = 0, l = contacts.length; i < l; i++) {
                    var collisionType = contacts[i].updateState();
                    if (collisionType === CollisionType.None) {
                        continue;
                    }
                    results.push([ collisionType, contacts[i] ]);
                }
                for (i = 0, l = results.length; i < l; i++) {
                    var result = results[i];
                    this._doCollide(result[0], result[1]);
                }
                this.drawColliders();
            },
            _doCollide: function(collisionType, contact) {
                var contactFunc;
                switch (collisionType) {
                  case CollisionType.CollisionEnter:
                    contactFunc = "onCollisionEnter";
                    break;

                  case CollisionType.CollisionStay:
                    contactFunc = "onCollisionStay";
                    break;

                  case CollisionType.CollisionExit:
                    contactFunc = "onCollisionExit";
                }
                var collider1 = contact.collider1;
                var collider2 = contact.collider2;
                var comps1 = collider1.node._components;
                var comps2 = collider2.node._components;
                var i, l, comp;
                for (i = 0, l = comps1.length; i < l; i++) {
                    comp = comps1[i];
                    comp[contactFunc] && comp[contactFunc](collider2, collider1);
                }
                for (i = 0, l = comps2.length; i < l; i++) {
                    comp = comps2[i];
                    comp[contactFunc] && comp[contactFunc](collider1, collider2);
                }
            },
            shouldCollide: function(c1, c2) {
                var node1 = c1.node, node2 = c2.node;
                var collisionMatrix = cc.game.collisionMatrix;
                return node1 !== node2 && collisionMatrix[node1.groupIndex][node2.groupIndex];
            },
            initCollider: function(collider) {
                if (!collider.world) {
                    var world = collider.world = {};
                    world.aabb = cc.rect();
                    world.preAabb = cc.rect();
                    world.radius = 0;
                    if (collider instanceof cc.BoxCollider) {
                        world.position = null;
                        world.points = [ cc.v2(), cc.v2(), cc.v2(), cc.v2() ];
                    } else {
                        if (collider instanceof cc.PolygonCollider) {
                            world.position = null;
                            world.points = collider.points.map((function(p) {
                                return cc.v2(p.x, p.y);
                            }));
                        } else {
                            if (collider instanceof cc.CircleCollider) {
                                world.position = cc.v2();
                                world.points = null;
                            }
                        }
                    }
                }
            },
            updateCollider: function(collider) {
                var offset = collider.offset;
                var world = collider.world;
                var aabb = world.aabb;
                var t = world.transform = collider.node.getNodeToWorldTransformAR();
                var preAabb = world.preAabb;
                preAabb.x = aabb.x;
                preAabb.y = aabb.y;
                preAabb.width = aabb.width;
                preAabb.height = aabb.height;
                if (collider instanceof cc.BoxCollider) {
                    var size = collider.size;
                    tempRect.x = offset.x - size.width / 2;
                    tempRect.y = offset.y - size.height / 2;
                    tempRect.width = size.width;
                    tempRect.height = size.height;
                    var wps = world.points;
                    var wp0 = wps[0];
                    var wp1 = wps[1];
                    var wp2 = wps[2];
                    var wp3 = wps[3];
                    cc.obbApplyAffineTransform(tempRect, t, wp0, wp1, wp2, wp3);
                    var minx = Math.min(wp0.x, wp1.x, wp2.x, wp3.x);
                    var miny = Math.min(wp0.y, wp1.y, wp2.y, wp3.y);
                    var maxx = Math.max(wp0.x, wp1.x, wp2.x, wp3.x);
                    var maxy = Math.max(wp0.y, wp1.y, wp2.y, wp3.y);
                    aabb.x = minx;
                    aabb.y = miny;
                    aabb.width = maxx - minx;
                    aabb.height = maxy - miny;
                } else {
                    if (collider instanceof cc.CircleCollider) {
                        var p = cc.pointApplyAffineTransform(collider.offset, t);
                        world.position.x = p.x;
                        world.position.y = p.y;
                        t.tx = t.ty = 0;
                        tempVec2.x = collider.radius;
                        tempVec2.y = 0;
                        var tempP = cc.pointApplyAffineTransform(tempVec2, t);
                        var d = Math.sqrt(tempP.x * tempP.x + tempP.y * tempP.y);
                        world.radius = d;
                        aabb.x = p.x - d;
                        aabb.y = p.y - d;
                        aabb.width = 2 * d;
                        aabb.height = 2 * d;
                    } else {
                        if (collider instanceof cc.PolygonCollider) {
                            var points = collider.points;
                            var worldPoints = world.points;
                            worldPoints.length = points.length;
                            var minx = 1e6, miny = 1e6, maxx = -1e6, maxy = -1e6;
                            for (var i = 0, l = points.length; i < l; i++) {
                                worldPoints[i] || (worldPoints[i] = cc.v2());
                                tempVec2.x = points[i].x + offset.x;
                                tempVec2.y = points[i].y + offset.y;
                                var p = cc.pointApplyAffineTransform(tempVec2, t);
                                worldPoints[i].x = p.x;
                                worldPoints[i].y = p.y;
                                p.x > maxx && (maxx = p.x);
                                p.x < minx && (minx = p.x);
                                p.y > maxy && (maxy = p.y);
                                p.y < miny && (miny = p.y);
                            }
                            aabb.x = minx;
                            aabb.y = miny;
                            aabb.width = maxx - minx;
                            aabb.height = maxy - miny;
                        }
                    }
                }
            },
            addCollider: function(collider) {
                var colliders = this._colliders;
                var index = colliders.indexOf(collider);
                if (index === -1) {
                    for (var i = 0, l = colliders.length; i < l; i++) {
                        var other = colliders[i];
                        if (this.shouldCollide(collider, other)) {
                            var contact = new Contact(collider, other);
                            this._contacts.push(contact);
                        }
                    }
                    colliders.push(collider);
                    this.initCollider(collider);
                }
                collider.node.on("group-changed", this.onNodeGroupChanged, this);
            },
            removeCollider: function(collider) {
                var colliders = this._colliders;
                var index = colliders.indexOf(collider);
                if (index >= 0) {
                    colliders.splice(index, 1);
                    var contacts = this._contacts;
                    for (var i = contacts.length - 1; i >= 0; i--) {
                        var contact = contacts[i];
                        if (contact.collider1 === collider || contact.collider2 === collider) {
                            contact.touching && this._doCollide(CollisionType.CollisionExit, contact);
                            contacts.splice(i, 1);
                        }
                    }
                    collider.node.off("group-changed", this.onNodeGroupChanged, this);
                } else {
                    cc.errorID(6600);
                }
            },
            attachDebugDrawToCamera: function(camera) {
                if (!this._debugDrawer) {
                    return;
                }
                camera.addTarget(this._debugDrawer);
            },
            detachDebugDrawFromCamera: function(camera) {
                if (!this._debugDrawer) {
                    return;
                }
                camera.removeTarget(this._debugDrawer);
            },
            onNodeGroupChanged: function(event) {
                var node = event.currentTarget;
                var colliders = node.getComponents(cc.Collider);
                for (var i = 0, l = colliders.length; i < l; i++) {
                    this.removeCollider(colliders[i]);
                    this.addCollider(colliders[i]);
                }
            },
            drawColliders: function() {
                var debugDrawer = this._debugDrawer;
                if (!this._enabledDebugDraw || !debugDrawer) {
                    return;
                }
                debugDrawer.clear();
                var colliders = this._colliders;
                for (var i = 0, l = colliders.length; i < l; i++) {
                    var collider = colliders[i];
                    if (collider instanceof cc.BoxCollider || collider instanceof cc.PolygonCollider) {
                        var ps = collider.world.points;
                        if (ps.length > 0) {
                            debugDrawer.strokeColor = cc.Color.WHITE;
                            debugDrawer.moveTo(ps[0].x, ps[0].y);
                            for (var j = 1; j < ps.length; j++) {
                                debugDrawer.lineTo(ps[j].x, ps[j].y);
                            }
                            debugDrawer.close();
                            debugDrawer.stroke();
                        }
                    } else {
                        if (collider instanceof cc.CircleCollider) {
                            debugDrawer.circle(collider.world.position.x, collider.world.position.y, collider.world.radius);
                            debugDrawer.stroke();
                        }
                    }
                    if (this.enabledDrawBoundingBox) {
                        var aabb = collider.world.aabb;
                        debugDrawer.strokeColor = cc.Color.BLUE;
                        debugDrawer.moveTo(aabb.xMin, aabb.yMin);
                        debugDrawer.lineTo(aabb.xMin, aabb.yMax);
                        debugDrawer.lineTo(aabb.xMax, aabb.yMax);
                        debugDrawer.lineTo(aabb.xMax, aabb.yMin);
                        debugDrawer.close();
                        debugDrawer.stroke();
                    }
                }
            },
            onSceneLaunched: function() {
                if (this._enabledDebugDraw && this._debugDrawer) {
                    this._debugDrawer.removeFromParent();
                    cc.director.getScene()._sgNode.addChild(this._debugDrawer);
                }
            }
        });
        cc.js.getset(CollisionManager.prototype, "enabledDebugDraw", (function() {
            return this._enabledDebugDraw;
        }), (function(value) {
            if (value && !this._enabledDebugDraw) {
                if (!this._debugDrawer) {
                    this._debugDrawer = new _ccsg.GraphicsNode();
                    this._debugDrawer.retain();
                }
                cc.director.getScene()._sgNode.addChild(this._debugDrawer);
                cc.director.on(cc.Director.EVENT_AFTER_SCENE_LAUNCH, this.onSceneLaunched, this);
            } else {
                if (!value && this._enabledDebugDraw) {
                    this._debugDrawer.clear();
                    this._debugDrawer.removeFromParent(false);
                    cc.director.off(cc.Director.EVENT_AFTER_SCENE_LAUNCH, this.onSceneLaunched, this);
                }
            }
            this._enabledDebugDraw = value;
        }));
        cc.CollisionManager = module.exports = CollisionManager;
    }), {
        "./CCContact": 67
    } ],
    67: [ (function(require, module, exports) {
        var Intersection = require("./CCIntersection");
        var CollisionType = cc.Enum({
            None: 0,
            CollisionEnter: 1,
            CollisionStay: 2,
            CollisionExit: 3
        });
        function Contact(collider1, collider2) {
            this.collider1 = collider1;
            this.collider2 = collider2;
            this.touching = false;
            var isCollider1Polygon = collider1 instanceof cc.BoxCollider || collider1 instanceof cc.PolygonCollider;
            var isCollider2Polygon = collider2 instanceof cc.BoxCollider || collider2 instanceof cc.PolygonCollider;
            var isCollider1Circle = collider1 instanceof cc.CircleCollider;
            var isCollider2Circle = collider2 instanceof cc.CircleCollider;
            if (isCollider1Polygon && isCollider2Polygon) {
                this.testFunc = Intersection.polygonPolygon;
            } else {
                if (isCollider1Circle && isCollider2Circle) {
                    this.testFunc = Intersection.circleCircle;
                } else {
                    if (isCollider1Polygon && isCollider2Circle) {
                        this.testFunc = Intersection.polygonCircle;
                    } else {
                        if (isCollider1Circle && isCollider2Polygon) {
                            this.testFunc = Intersection.polygonCircle;
                            this.collider1 = collider2;
                            this.collider2 = collider1;
                        } else {
                            cc.errorID(6601, cc.js.getClassName(collider1), cc.js.getClassName(collider2));
                        }
                    }
                }
            }
        }
        Contact.prototype.test = function() {
            var world1 = this.collider1.world;
            var world2 = this.collider2.world;
            if (!world1.aabb.intersects(world2.aabb)) {
                return false;
            }
            if (this.testFunc === Intersection.polygonPolygon) {
                return this.testFunc(world1.points, world2.points);
            }
            if (this.testFunc === Intersection.circleCircle) {
                return this.testFunc(world1, world2);
            }
            if (this.testFunc === Intersection.polygonCircle) {
                return this.testFunc(world1.points, world2);
            }
            return false;
        };
        Contact.prototype.updateState = function() {
            var result = this.test();
            var type = CollisionType.None;
            if (result && !this.touching) {
                this.touching = true;
                type = CollisionType.CollisionEnter;
            } else {
                if (result && this.touching) {
                    type = CollisionType.CollisionStay;
                } else {
                    if (!result && this.touching) {
                        this.touching = false;
                        type = CollisionType.CollisionExit;
                    }
                }
            }
            return type;
        };
        Contact.CollisionType = CollisionType;
        module.exports = Contact;
    }), {
        "./CCIntersection": 68
    } ],
    68: [ (function(require, module, exports) {
        var Intersection = {};
        function lineLine(a1, a2, b1, b2) {
            var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
            var ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
            var u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
            if (0 !== u_b) {
                var ua = ua_t / u_b;
                var ub = ub_t / u_b;
                if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
                    return true;
                }
            }
            return false;
        }
        Intersection.lineLine = lineLine;
        function lineRect(a1, a2, b) {
            var r0 = new cc.Vec2(b.x, b.y);
            var r1 = new cc.Vec2(b.x, b.yMax);
            var r2 = new cc.Vec2(b.xMax, b.yMax);
            var r3 = new cc.Vec2(b.xMax, b.y);
            if (lineLine(a1, a2, r0, r1)) {
                return true;
            }
            if (lineLine(a1, a2, r1, r2)) {
                return true;
            }
            if (lineLine(a1, a2, r2, r3)) {
                return true;
            }
            if (lineLine(a1, a2, r3, r0)) {
                return true;
            }
            return false;
        }
        Intersection.lineRect = lineRect;
        function linePolygon(a1, a2, b) {
            var length = b.length;
            for (var i = 0; i < length; ++i) {
                var b1 = b[i];
                var b2 = b[(i + 1) % length];
                if (lineLine(a1, a2, b1, b2)) {
                    return true;
                }
            }
            return false;
        }
        Intersection.linePolygon = linePolygon;
        function rectRect(a, b) {
            var a_min_x = a.x;
            var a_min_y = a.y;
            var a_max_x = a.x + a.width;
            var a_max_y = a.y + a.height;
            var b_min_x = b.x;
            var b_min_y = b.y;
            var b_max_x = b.x + b.width;
            var b_max_y = b.y + b.height;
            return a_min_x <= b_max_x && a_max_x >= b_min_x && a_min_y <= b_max_y && a_max_y >= b_min_y;
        }
        Intersection.rectRect = rectRect;
        function rectPolygon(a, b) {
            var i, l;
            var r0 = new cc.Vec2(a.x, a.y);
            var r1 = new cc.Vec2(a.x, a.yMax);
            var r2 = new cc.Vec2(a.xMax, a.yMax);
            var r3 = new cc.Vec2(a.xMax, a.y);
            if (linePolygon(r0, r1, b)) {
                return true;
            }
            if (linePolygon(r1, r2, b)) {
                return true;
            }
            if (linePolygon(r2, r3, b)) {
                return true;
            }
            if (linePolygon(r3, r0, b)) {
                return true;
            }
            for (i = 0, l = b.length; i < l; ++i) {
                if (pointInPolygon(b[i], a)) {
                    return true;
                }
            }
            if (pointInPolygon(r0, b)) {
                return true;
            }
            if (pointInPolygon(r1, b)) {
                return true;
            }
            if (pointInPolygon(r2, b)) {
                return true;
            }
            if (pointInPolygon(r3, b)) {
                return true;
            }
            return false;
        }
        Intersection.rectPolygon = rectPolygon;
        function polygonPolygon(a, b) {
            var i, l;
            for (i = 0, l = a.length; i < l; ++i) {
                var a1 = a[i];
                var a2 = a[(i + 1) % l];
                if (linePolygon(a1, a2, b)) {
                    return true;
                }
            }
            for (i = 0, l = b.length; i < l; ++i) {
                if (pointInPolygon(b[i], a)) {
                    return true;
                }
            }
            for (i = 0, l = a.length; i < l; ++i) {
                if (pointInPolygon(a[i], b)) {
                    return true;
                }
            }
            return false;
        }
        Intersection.polygonPolygon = polygonPolygon;
        function circleCircle(a, b) {
            var distance = a.position.sub(b.position).mag();
            return distance < a.radius + b.radius;
        }
        Intersection.circleCircle = circleCircle;
        function polygonCircle(polygon, circle) {
            var position = circle.position;
            if (pointInPolygon(position, polygon)) {
                return true;
            }
            for (var i = 0, l = polygon.length; i < l; i++) {
                var start = 0 === i ? polygon[polygon.length - 1] : polygon[i - 1];
                var end = polygon[i];
                if (pointLineDistance(position, start, end, true) < circle.radius) {
                    return true;
                }
            }
            return false;
        }
        Intersection.polygonCircle = polygonCircle;
        function pointInPolygon(point, polygon) {
            var inside = false;
            var x = point.x;
            var y = point.y;
            var length = polygon.length;
            for (var i = 0, j = length - 1; i < length; j = i++) {
                var xi = polygon[i].x, yi = polygon[i].y, xj = polygon[j].x, yj = polygon[j].y, intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
                intersect && (inside = !inside);
            }
            return inside;
        }
        Intersection.pointInPolygon = pointInPolygon;
        function pointLineDistance(point, start, end, isSegment) {
            var dx = end.x - start.x;
            var dy = end.y - start.y;
            var d = dx * dx + dy * dy;
            var t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / d;
            var p;
            p = isSegment ? d ? t < 0 ? start : t > 1 ? end : cc.v2(start.x + t * dx, start.y + t * dy) : start : cc.v2(start.x + t * dx, start.y + t * dy);
            dx = point.x - p.x;
            dy = point.y - p.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        Intersection.pointLineDistance = pointLineDistance;
        cc.Intersection = module.exports = Intersection;
    }), {} ],
    69: [ (function(require, module, exports) {
        cc.Collider.Polygon = cc.Class({
            properties: {
                threshold: {
                    default: 1,
                    serializable: false,
                    visible: false
                },
                _offset: cc.v2(0, 0),
                offset: {
                    get: function() {
                        return this._offset;
                    },
                    set: function(value) {
                        this._offset = value;
                    },
                    type: cc.Vec2
                },
                points: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.points",
                    default: function() {
                        return [ cc.v2(-50, -50), cc.v2(50, -50), cc.v2(50, 50), cc.v2(-50, 50) ];
                    },
                    type: [ cc.Vec2 ]
                }
            },
            resetInEditor: false,
            resetPointsByContour: false
        });
        var PolygonCollider = cc.Class({
            name: "cc.PolygonCollider",
            extends: cc.Collider,
            mixins: [ cc.Collider.Polygon ],
            editor: false
        });
        cc.PolygonCollider = module.exports = PolygonCollider;
    }), {} ],
    70: [ (function(require, module, exports) {
        require("./CCCollisionManager");
        require("./CCCollider");
        require("./CCBoxCollider");
        require("./CCCircleCollider");
        require("./CCPolygonCollider");
    }), {
        "./CCBoxCollider": 63,
        "./CCCircleCollider": 64,
        "./CCCollider": 65,
        "./CCCollisionManager": 66,
        "./CCPolygonCollider": 69
    } ],
    71: [ (function(require, module, exports) {
        require("./platform/CCClass");
        var Flags = require("./platform/CCObject").Flags;
        var JsArray = require("./platform/js").array;
        var IsStartCalled = Flags.IsStartCalled;
        var IsOnEnableCalled = Flags.IsOnEnableCalled;
        var IsEditorOnEnableCalled = Flags.IsEditorOnEnableCalled;
        var callerFunctor = false;
        var callOnEnableInTryCatch = false;
        var callStartInTryCatch = false;
        var callUpdateInTryCatch = false;
        var callLateUpdateInTryCatch = false;
        var callOnDisableInTryCatch = false;
        function sortedIndex(array, comp) {
            var order = comp.constructor._executionOrder;
            var id = comp.__instanceId;
            for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
                var test = array[m];
                var testOrder = test.constructor._executionOrder;
                if (testOrder > order) {
                    h = m - 1;
                } else {
                    if (testOrder < order) {
                        l = m + 1;
                    } else {
                        var testId = test.__instanceId;
                        if (testId > id) {
                            h = m - 1;
                        } else {
                            if (!(testId < id)) {
                                return m;
                            }
                            l = m + 1;
                        }
                    }
                }
            }
            return ~l;
        }
        function stableRemoveInactive(iterator, flagToClear) {
            var array = iterator.array;
            var next = iterator.i + 1;
            while (next < array.length) {
                var comp = array[next];
                if (comp._enabled && comp.node._activeInHierarchy) {
                    ++next;
                } else {
                    iterator.removeAt(next);
                    flagToClear && (comp._objFlags &= ~flagToClear);
                }
            }
        }
        var LifeCycleInvoker = cc.Class({
            __ctor__: function(invokeFunc) {
                var Iterator = JsArray.MutableForwardIterator;
                this._zero = new Iterator([]);
                this._neg = new Iterator([]);
                this._pos = new Iterator([]);
                this._invoke = invokeFunc;
            },
            statics: {
                stableRemoveInactive: stableRemoveInactive
            },
            add: null,
            remove: null,
            invoke: null
        });
        function compareOrder(a, b) {
            return a.constructor._executionOrder - b.constructor._executionOrder;
        }
        var OneOffInvoker = cc.Class({
            extends: LifeCycleInvoker,
            add: function(comp) {
                var order = comp.constructor._executionOrder;
                (0 === order ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
            },
            remove: function(comp) {
                var order = comp.constructor._executionOrder;
                (0 === order ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
            },
            cancelInactive: function(flagToClear) {
                stableRemoveInactive(this._zero, flagToClear);
                stableRemoveInactive(this._neg, flagToClear);
                stableRemoveInactive(this._pos, flagToClear);
            },
            invoke: function() {
                var compsNeg = this._neg;
                if (compsNeg.array.length > 0) {
                    compsNeg.array.sort(compareOrder);
                    this._invoke(compsNeg);
                    compsNeg.array.length = 0;
                }
                this._invoke(this._zero);
                this._zero.array.length = 0;
                var compsPos = this._pos;
                if (compsPos.array.length > 0) {
                    compsPos.array.sort(compareOrder);
                    this._invoke(compsPos);
                    compsPos.array.length = 0;
                }
            }
        });
        var ReusableInvoker = cc.Class({
            extends: LifeCycleInvoker,
            add: function(comp) {
                var order = comp.constructor._executionOrder;
                if (0 === order) {
                    this._zero.array.push(comp);
                } else {
                    var array = order < 0 ? this._neg.array : this._pos.array;
                    var i = sortedIndex(array, comp);
                    i < 0 ? array.splice(~i, 0, comp) : cc.error("component already added");
                }
            },
            remove: function(comp) {
                var order = comp.constructor._executionOrder;
                if (0 === order) {
                    this._zero.fastRemove(comp);
                } else {
                    var iterator = order < 0 ? this._neg : this._pos;
                    var i = sortedIndex(iterator.array, comp);
                    i >= 0 && iterator.removeAt(i);
                }
            },
            invoke: function(dt) {
                this._neg.array.length > 0 && this._invoke(this._neg, dt);
                this._invoke(this._zero, dt);
                this._pos.array.length > 0 && this._invoke(this._pos, dt);
            }
        });
        function enableInEditor(comp) {
            if (!(comp._objFlags & IsEditorOnEnableCalled)) {
                cc.engine.emit("component-enabled", comp.uuid);
                comp._objFlags |= IsEditorOnEnableCalled;
            }
        }
        function createInvokeImpl(code, useDt) {
            var body = "var a=it.array;for(it.i=0;it.i<a.length;++it.i){var c=a[it.i];" + code + "}";
            return useDt ? Function("it", "dt", body) : Function("it", body);
        }
        function ctor() {
            this.startInvoker = new OneOffInvoker(createInvokeImpl("c.start();c._objFlags|=" + IsStartCalled));
            this.updateInvoker = new ReusableInvoker(createInvokeImpl("c.update(dt)", true));
            this.lateUpdateInvoker = new ReusableInvoker(createInvokeImpl("c.lateUpdate(dt)", true));
            this.scheduleInNextFrame = [];
            this._updating = false;
        }
        var ComponentScheduler = cc.Class({
            ctor: ctor,
            unscheduleAll: ctor,
            statics: {
                LifeCycleInvoker: LifeCycleInvoker,
                OneOffInvoker: OneOffInvoker,
                createInvokeImpl: createInvokeImpl,
                invokeOnEnable: function(iterator) {
                    var compScheduler = cc.director._compScheduler;
                    var array = iterator.array;
                    for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                        var comp = array[iterator.i];
                        if (comp._enabled) {
                            comp.onEnable();
                            var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
                            deactivatedDuringOnEnable || compScheduler._onEnabled(comp);
                        }
                    }
                }
            },
            _onEnabled: function(comp) {
                cc.director.getScheduler().resumeTarget(comp);
                comp._objFlags |= IsOnEnableCalled;
                if (this._updating) {
                    this.scheduleInNextFrame.push(comp);
                    return;
                }
                this._scheduleImmediate(comp);
            },
            _onDisabled: function(comp) {
                cc.director.getScheduler().pauseTarget(comp);
                comp._objFlags &= ~IsOnEnableCalled;
                var index = this.scheduleInNextFrame.indexOf(comp);
                if (index >= 0) {
                    JsArray.fastRemoveAt(this.scheduleInNextFrame, index);
                    return;
                }
                !comp.start || comp._objFlags & IsStartCalled || this.startInvoker.remove(comp);
                comp.update && this.updateInvoker.remove(comp);
                comp.lateUpdate && this.lateUpdateInvoker.remove(comp);
            },
            enableComp: function(comp, invoker) {
                if (!(comp._objFlags & IsOnEnableCalled)) {
                    if (comp.onEnable) {
                        if (invoker) {
                            invoker.add(comp);
                            return;
                        }
                        comp.onEnable();
                        var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
                        if (deactivatedDuringOnEnable) {
                            return;
                        }
                    }
                    this._onEnabled(comp);
                }
            },
            disableComp: function(comp) {
                if (comp._objFlags & IsOnEnableCalled) {
                    comp.onDisable && comp.onDisable();
                    this._onDisabled(comp);
                }
            },
            _scheduleImmediate: function(comp) {
                !comp.start || comp._objFlags & IsStartCalled || this.startInvoker.add(comp);
                comp.update && this.updateInvoker.add(comp);
                comp.lateUpdate && this.lateUpdateInvoker.add(comp);
            },
            _deferredSchedule: function() {
                var comps = this.scheduleInNextFrame;
                for (var i = 0, len = comps.length; i < len; i++) {
                    var comp = comps[i];
                    this._scheduleImmediate(comp);
                }
                comps.length = 0;
            },
            startPhase: function() {
                this._updating = true;
                this.scheduleInNextFrame.length > 0 && this._deferredSchedule();
                this.startInvoker.invoke();
            },
            updatePhase: function(dt) {
                this.updateInvoker.invoke(dt);
            },
            lateUpdatePhase: function(dt) {
                this.lateUpdateInvoker.invoke(dt);
                this._updating = false;
            }
        });
        module.exports = ComponentScheduler;
    }), {
        "./platform/CCClass": 173,
        "./platform/CCObject": 179,
        "./platform/js": 193,
        "./utils/misc": 223
    } ],
    72: [ (function(require, module, exports) {
        var AnimationAnimator = require("../../animation/animation-animator");
        var AnimationClip = require("../../animation/animation-clip");
        function equalClips(clip1, clip2) {
            if (clip1 === clip2) {
                return true;
            }
            return clip1 && clip2 && (clip1.name === clip2.name || clip1._uuid === clip2._uuid);
        }
        var Animation = cc.Class({
            name: "cc.Animation",
            extends: require("./CCComponent"),
            mixins: [ cc.EventTarget ],
            editor: false,
            ctor: function() {
                this._animator = null;
                this._nameToState = {};
                this._didInit = false;
                this._currentClip = null;
                this._listeners = [];
            },
            properties: {
                _defaultClip: {
                    default: null,
                    type: AnimationClip
                },
                defaultClip: {
                    type: AnimationClip,
                    get: function() {
                        return this._defaultClip;
                    },
                    set: function(value) {
                        return;
                        var clips;
                        var i, l;
                    },
                    tooltip: "i18n:COMPONENT.animation.default_clip"
                },
                currentClip: {
                    get: function() {
                        return this._currentClip;
                    },
                    set: function(value) {
                        this._currentClip = value;
                    },
                    type: AnimationClip,
                    visible: false
                },
                _clips: {
                    default: [],
                    type: [ AnimationClip ],
                    tooltip: "i18n:COMPONENT.animation.clips",
                    visible: true
                },
                playOnLoad: {
                    default: false,
                    tooltip: "i18n:COMPONENT.animation.play_on_load"
                }
            },
            start: function() {
                if (this.playOnLoad && this._defaultClip) {
                    var state = this.getAnimationState(this._defaultClip.name);
                    this._animator.playState(state);
                }
            },
            onEnable: function() {
                this._animator && this._animator.resume();
            },
            onDisable: function() {
                this._animator && this._animator.pause();
            },
            onDestroy: function() {
                this.stop();
            },
            getClips: function() {
                return this._clips;
            },
            play: function(name, startTime) {
                var state = this.playAdditive(name, startTime);
                this._animator.stopStatesExcept(state);
                return state;
            },
            playAdditive: function(name, startTime) {
                this._init();
                var state = this.getAnimationState(name || this._defaultClip && this._defaultClip.name);
                if (state) {
                    this.enabled = true;
                    var animator = this._animator;
                    if (animator.isPlaying && state.isPlaying) {
                        if (state.isPaused) {
                            animator.resumeState(state);
                        } else {
                            animator.stopState(state);
                            animator.playState(state, startTime);
                        }
                    } else {
                        animator.playState(state, startTime);
                    }
                    this.currentClip = state.clip;
                }
                return state;
            },
            stop: function(name) {
                if (!this._didInit) {
                    return;
                }
                if (name) {
                    var state = this._nameToState[name];
                    state && this._animator.stopState(state);
                } else {
                    this._animator.stop();
                }
            },
            pause: function(name) {
                if (!this._didInit) {
                    return;
                }
                if (name) {
                    var state = this._nameToState[name];
                    state && this._animator.pauseState(state);
                } else {
                    this.enabled = false;
                }
            },
            resume: function(name) {
                if (!this._didInit) {
                    return;
                }
                if (name) {
                    var state = this._nameToState[name];
                    state && this._animator.resumeState(state);
                } else {
                    this.enabled = true;
                }
            },
            setCurrentTime: function(time, name) {
                this._init();
                if (name) {
                    var state = this._nameToState[name];
                    state && this._animator.setStateTime(state, time);
                } else {
                    this._animator.setStateTime(time);
                }
            },
            getAnimationState: function(name) {
                this._init();
                var state = this._nameToState[name];
                state && !state.curveLoaded && this._animator._reloadClip(state);
                return state || null;
            },
            addClip: function(clip, newName) {
                if (!clip) {
                    cc.warnID(3900);
                    return;
                }
                this._init();
                cc.js.array.contains(this._clips, clip) || this._clips.push(clip);
                newName = newName || clip.name;
                var oldState = this._nameToState[newName];
                if (oldState) {
                    if (oldState.clip === clip) {
                        return oldState;
                    }
                    var index = this._clips.indexOf(oldState.clip);
                    index !== -1 && this._clips.splice(index, 1);
                }
                var newState = new cc.AnimationState(clip, newName);
                this._nameToState[newName] = newState;
                return newState;
            },
            removeClip: function(clip, force) {
                if (!clip) {
                    cc.warnID(3901);
                    return;
                }
                this._init();
                var state;
                for (var name in this._nameToState) {
                    state = this._nameToState[name];
                    var stateClip = state.clip;
                    if (stateClip === clip) {
                        break;
                    }
                }
                if (clip === this._defaultClip) {
                    if (!force) {
                        cc.warnID(3902);
                        return;
                    }
                    this._defaultClip = null;
                }
                if (state && state.isPlaying) {
                    if (!force) {
                        cc.warnID(3903);
                        return;
                    }
                    this.stop(state.name);
                }
                this._clips = this._clips.filter((function(item) {
                    return item !== clip;
                }));
                state && delete this._nameToState[state.name];
            },
            sample: function(name) {
                this._init();
                if (name) {
                    var state = this._nameToState[name];
                    state && state.sample();
                } else {
                    this._animator.sample();
                }
            },
            on: function(type, callback, target, useCapture) {
                this._init();
                var listeners = this._listeners;
                for (var i = 0, l = listeners.length; i < l; i++) {
                    var listener = listeners[i];
                    if (listener[0] === type && listener[1] === callback && listener[2] === target && listener[3] === useCapture) {
                        return;
                    }
                }
                this._animator.on(type, callback, target, useCapture);
                listeners.push([ type, callback, target, useCapture ]);
                return callback;
            },
            off: function(type, callback, target, useCapture) {
                this._init();
                var listeners = this._listeners;
                var nameToState = this._nameToState;
                for (var i = listeners.length - 1; i >= 0; i--) {
                    var listener = listeners[i];
                    if (listener[0] === type && listener[1] === callback && listener[2] === target && listener[3] === useCapture) {
                        for (var name in nameToState) {
                            var state = nameToState[name];
                            state.off(type, callback, target, useCapture);
                        }
                        listeners.splice(i, 1);
                    }
                }
            },
            _init: function() {
                if (this._didInit) {
                    return;
                }
                this._didInit = true;
                this._animator = new AnimationAnimator(this.node, this);
                this._createStates();
            },
            _createStates: function() {
                this._nameToState = {};
                var state = null;
                var defaultClipState = false;
                for (var i = 0; i < this._clips.length; ++i) {
                    var clip = this._clips[i];
                    if (clip) {
                        state = new cc.AnimationState(clip);
                        this._nameToState[state.name] = state;
                        equalClips(this._defaultClip, clip) && (defaultClipState = state);
                    }
                }
                if (this._defaultClip && !defaultClipState) {
                    state = new cc.AnimationState(this._defaultClip);
                    this._nameToState[state.name] = state;
                }
            }
        });
        cc.Animation = module.exports = Animation;
    }), {
        "../../animation/animation-animator": 11,
        "../../animation/animation-clip": 12,
        "./CCComponent": 76
    } ],
    73: [ (function(require, module, exports) {
        var AudioSource = cc.Class({
            name: "cc.AudioSource",
            extends: require("./CCComponent"),
            editor: false,
            ctor: function() {
                this.audio = new cc.Audio(this._clip);
            },
            properties: {
                _clip: {
                    default: "",
                    url: cc.AudioClip
                },
                _volume: 1,
                _mute: false,
                _loop: false,
                _pausedFlag: {
                    default: false,
                    serializable: false
                },
                isPlaying: {
                    get: function() {
                        if (!this.audio) {
                            return false;
                        }
                        var state = this.audio.getState();
                        return state === cc.Audio.State.PLAYING;
                    },
                    visible: false
                },
                clip: {
                    get: function() {
                        return this._clip;
                    },
                    set: function(value) {
                        this._clip = value;
                        this.audio.stop();
                        this.audio.src = this._clip;
                        this.audio.preload && this.audio.preload();
                    },
                    url: cc.AudioClip,
                    tooltip: "i18n:COMPONENT.audio.clip",
                    animatable: false
                },
                volume: {
                    get: function() {
                        return this._volume;
                    },
                    set: function(value) {
                        value = cc.clamp01(value);
                        this._volume = value;
                        var audio = this.audio;
                        if (audio && !this._mute) {
                            audio.setVolume(value);
                            audio._loaded || audio.on("load", (function() {
                                audio.setVolume(value);
                            }));
                        }
                        return value;
                    },
                    tooltip: "i18n:COMPONENT.audio.volume"
                },
                mute: {
                    get: function() {
                        return this._mute;
                    },
                    set: function(value) {
                        this._mute = value;
                        this.audio && this.audio.setVolume(value ? 0 : this._volume);
                        return value;
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.audio.mute"
                },
                loop: {
                    get: function() {
                        return this._loop;
                    },
                    set: function(value) {
                        this._loop = value;
                        this.audio && this.audio.setLoop(value);
                        return value;
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.audio.loop"
                },
                playOnLoad: {
                    default: false,
                    tooltip: "i18n:COMPONENT.audio.play_on_load",
                    animatable: false
                },
                preload: {
                    default: false,
                    animatable: false
                }
            },
            _pausedCallback: function() {
                var audio = this.audio;
                if (!audio || audio.paused) {
                    return;
                }
                this.audio.pause();
                this._pausedFlag = true;
            },
            _restoreCallback: function() {
                if (!this.audio) {
                    return;
                }
                this._pausedFlag && this.audio.resume();
                this._pausedFlag = false;
            },
            onEnable: function() {
                this.playOnLoad && this.play();
                if (this.preload) {
                    this.audio.src = this._clip;
                    this.audio.preload();
                }
                cc.game.on(cc.game.EVENT_HIDE, this._pausedCallback, this);
                cc.game.on(cc.game.EVENT_SHOW, this._restoreCallback, this);
            },
            onDisable: function() {
                this.stop();
                cc.game.off(cc.game.EVENT_HIDE, this._pausedCallback, this);
                cc.game.off(cc.game.EVENT_SHOW, this._restoreCallback, this);
            },
            onDestroy: function() {
                this.stop();
                cc.audioEngine.uncache(this._clip);
            },
            play: function() {
                if (!this._clip) {
                    return;
                }
                var volume = this._mute ? 0 : this._volume;
                var audio = this.audio;
                var loop = this._loop;
                if (audio._loaded) {
                    audio.stop();
                    audio.setCurrentTime(0);
                    audio.play();
                    return;
                }
                audio.src = this._clip;
                audio.once("load", (function() {
                    audio.setLoop(loop);
                    audio.setVolume(volume);
                    audio.play();
                }));
                audio.preload();
            },
            stop: function() {
                this.audio && this.audio.stop();
            },
            pause: function() {
                this.audio && this.audio.pause();
            },
            resume: function() {
                this.audio && this.audio.resume();
            },
            rewind: function() {
                this.audio && this.audio.setCurrentTime(0);
            },
            getCurrentTime: function() {
                var time = 0;
                this.audio && (time = this.audio.getCurrentTime());
                return time;
            },
            setCurrentTime: function(time) {
                var audio = this.audio;
                if (!audio) {
                    return time;
                }
                if (!audio._loaded) {
                    audio.once("load", (function() {
                        audio.setCurrentTime(time);
                    }));
                    return time;
                }
                audio.setCurrentTime(time);
                return time;
            },
            getDuration: function() {
                var time = 0;
                this.audio && (time = this.audio.getDuration());
                return time;
            }
        });
        cc.AudioSource = module.exports = AudioSource;
    }), {
        "./CCComponent": 76
    } ],
    74: [ (function(require, module, exports) {
        var Transition = cc.Enum({
            NONE: 0,
            COLOR: 1,
            SPRITE: 2,
            SCALE: 3
        });
        var Button = cc.Class({
            name: "cc.Button",
            extends: require("./CCComponent"),
            ctor: function() {
                this._resetState();
                this._fromColor = null;
                this._toColor = null;
                this._time = 0;
                this._transitionFinished = true;
                this._fromScale = 1;
                this._toScale = 1;
                this._originalScale = 1;
                this._sprite = null;
            },
            _resetState: function() {
                this._pressed = false;
                this._hovered = false;
            },
            editor: false,
            properties: {
                interactable: {
                    default: true,
                    tooltip: "i18n:COMPONENT.button.interactable",
                    notify: function(oldValue) {
                        this._updateState();
                        this.interactable || this._resetState();
                    },
                    animatable: false
                },
                _resizeToTarget: {
                    animatable: false,
                    set: function(value) {
                        value && this._resizeNodeToTargetNode();
                    }
                },
                enableAutoGrayEffect: {
                    default: false,
                    tooltip: "i18n:COMPONENT.button.auto_gray_effect",
                    notify: function() {
                        this._updateDisabledState();
                    }
                },
                transition: {
                    default: Transition.NONE,
                    tooltip: "i18n:COMPONENT.button.transition",
                    type: Transition,
                    animatable: false
                },
                normalColor: {
                    default: cc.color(214, 214, 214),
                    displayName: "Normal",
                    tooltip: "i18n:COMPONENT.button.normal_color",
                    notify: function() {
                        this._updateState();
                    }
                },
                pressedColor: {
                    default: cc.color(211, 211, 211),
                    displayName: "Pressed",
                    tooltip: "i18n:COMPONENT.button.pressed_color"
                },
                hoverColor: {
                    default: cc.Color.WHITE,
                    displayName: "Hover",
                    tooltip: "i18n:COMPONENT.button.hover_color"
                },
                disabledColor: {
                    default: cc.color(124, 124, 124),
                    displayName: "Disabled",
                    tooltip: "i18n:COMPONENT.button.disabled_color",
                    notify: function() {
                        this._updateState();
                    }
                },
                duration: {
                    default: .1,
                    range: [ 0, 10 ],
                    tooltip: "i18n:COMPONENT.button.duration"
                },
                zoomScale: {
                    default: 1.2,
                    tooltip: "i18n:COMPONENT.button.zoom_scale"
                },
                normalSprite: {
                    default: null,
                    type: cc.SpriteFrame,
                    displayName: "Normal",
                    tooltip: "i18n:COMPONENT.button.normal_sprite",
                    notify: function() {
                        this._updateState();
                    }
                },
                pressedSprite: {
                    default: null,
                    type: cc.SpriteFrame,
                    displayName: "Pressed",
                    tooltip: "i18n:COMPONENT.button.pressed_sprite"
                },
                hoverSprite: {
                    default: null,
                    type: cc.SpriteFrame,
                    displayName: "Hover",
                    tooltip: "i18n:COMPONENT.button.hover_sprite"
                },
                disabledSprite: {
                    default: null,
                    type: cc.SpriteFrame,
                    displayName: "Disabled",
                    tooltip: "i18n:COMPONENT.button.disabled_sprite",
                    notify: function() {
                        this._updateState();
                    }
                },
                target: {
                    default: null,
                    type: cc.Node,
                    tooltip: "i18n:COMPONENT.button.target",
                    notify: function() {
                        this._applyTarget();
                    }
                },
                clickEvents: {
                    default: [],
                    type: cc.Component.EventHandler,
                    tooltip: "i18n:COMPONENT.button.click_events"
                }
            },
            statics: {
                Transition: Transition
            },
            __preload: function() {
                this.target || (this.target = this.node);
                this._applyTarget();
                this._updateState();
            },
            onEnable: function() {
                this.normalSprite && this.normalSprite.ensureLoadTexture();
                this.hoverSprite && this.hoverSprite.ensureLoadTexture();
                this.pressedSprite && this.pressedSprite.ensureLoadTexture();
                this.disabledSprite && this.disabledSprite.ensureLoadTexture();
                this._registerEvent();
            },
            update: function(dt) {
                var target = this.target;
                if (this._transitionFinished) {
                    return;
                }
                if (this.transition !== Transition.COLOR && this.transition !== Transition.SCALE) {
                    return;
                }
                this.time += dt;
                var ratio = 1;
                this.duration > 0 && (ratio = this.time / this.duration);
                if (ratio >= 1) {
                    ratio = 1;
                    this._transitionFinished = true;
                }
                this.transition === Transition.COLOR ? target.color = this._fromColor.lerp(this._toColor, ratio) : this.transition === Transition.SCALE && (target.scale = cc.lerp(this._fromScale, this._toScale, ratio));
            },
            _registerEvent: function() {
                this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
                this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this);
                this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
                this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this);
                this.node.on(cc.Node.EventType.MOUSE_ENTER, this._onMouseMoveIn, this);
                this.node.on(cc.Node.EventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
            },
            _getTargetSprite: function(target) {
                var sprite = null;
                target && (sprite = target.getComponent(cc.Sprite));
                return sprite;
            },
            _applyTarget: function() {
                this._sprite = this._getTargetSprite(this.target);
                this.target && (this._originalScale = this.target.scale);
            },
            _onTouchBegan: function(event) {
                if (!this.interactable || !this.enabledInHierarchy) {
                    return;
                }
                this._pressed = true;
                this._updateState();
                event.stopPropagation();
            },
            _onTouchMove: function(event) {
                if (!this.interactable || !this.enabledInHierarchy || !this._pressed) {
                    return;
                }
                var touch = event.touch;
                var hit = this.node._hitTest(touch.getLocation());
                if (this.transition === Transition.SCALE && this.target) {
                    if (hit) {
                        this._fromScale = this._originalScale;
                        this._toScale = this._originalScale * this.zoomScale;
                        this._transitionFinished = false;
                    } else {
                        this.time = 0;
                        this._transitionFinished = true;
                        this.target.scale = this._originalScale;
                    }
                } else {
                    var state;
                    state = hit ? "pressed" : "normal";
                    this._applyTransition(state);
                }
                event.stopPropagation();
            },
            _onTouchEnded: function(event) {
                if (!this.interactable || !this.enabledInHierarchy) {
                    return;
                }
                if (this._pressed) {
                    cc.Component.EventHandler.emitEvents(this.clickEvents, event);
                    this.node.emit("click", this);
                }
                this._pressed = false;
                this._updateState();
                event.stopPropagation();
            },
            _zoomUp: function() {
                this._fromScale = this._originalScale;
                this._toScale = this._originalScale * this.zoomScale;
                this.time = 0;
                this._transitionFinished = false;
            },
            _zoomBack: function() {
                this._fromScale = this.target.scale;
                this._toScale = this._originalScale;
                this.time = 0;
                this._transitionFinished = false;
            },
            _onTouchCancel: function() {
                if (!this.interactable || !this.enabledInHierarchy) {
                    return;
                }
                this._pressed = false;
                this._updateState();
            },
            _onMouseMoveIn: function() {
                if (this._pressed || !this.interactable || !this.enabledInHierarchy) {
                    return;
                }
                if (this.transition === Transition.SPRITE && !this.hoverSprite) {
                    return;
                }
                if (!this._hovered) {
                    this._hovered = true;
                    this._updateState();
                }
            },
            _onMouseMoveOut: function() {
                if (this._hovered) {
                    this._hovered = false;
                    this._updateState();
                }
            },
            _updateState: function() {
                var state = this._getButtonState();
                this._applyTransition(state);
                this._updateDisabledState();
            },
            onDisable: function() {
                this._hovered = false;
                this._pressed = false;
                this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
                this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this);
                this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
                this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this);
                this.node.off(cc.Node.EventType.MOUSE_ENTER, this._onMouseMoveIn, this);
                this.node.off(cc.Node.EventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
            },
            _getButtonState: function() {
                var state;
                state = this.interactable ? this._pressed ? "pressed" : this._hovered ? "hover" : "normal" : "disabled";
                return state;
            },
            _updateColorTransition: function(state) {
                var color = this[state + "Color"];
                var target = this.target;
                this._fromColor = target.color.clone();
                this._toColor = color;
                this.time = 0;
                this._transitionFinished = false;
            },
            _updateSpriteTransition: function(state) {
                var sprite = this[state + "Sprite"];
                this._sprite && sprite && (this._sprite.spriteFrame = sprite);
            },
            _updateScaleTransition: function(state) {
                "pressed" === state ? this._zoomUp() : this._zoomBack();
            },
            _applyTransition: function(state) {
                var transition = this.transition;
                transition === Transition.COLOR ? this._updateColorTransition(state) : transition === Transition.SPRITE ? this._updateSpriteTransition(state) : transition === Transition.SCALE && this._updateScaleTransition(state);
            },
            _resizeNodeToTargetNode: false,
            _updateDisabledState: function() {
                this._sprite && this._sprite._sgNode.setState(0);
                this.enableAutoGrayEffect && this.transition !== Transition.COLOR && (this.transition === Transition.SPRITE && this.disabledSprite || this._sprite && !this.interactable && this._sprite._sgNode.setState(1));
            }
        });
        cc.Button = module.exports = Button;
    }), {
        "./CCComponent": 76
    } ],
    75: [ (function(require, module, exports) {
        var designResolutionWrapper = {
            getContentSize: function() {
                return cc.visibleRect;
            },
            setContentSize: function(size) {},
            _getWidth: function() {
                return this.getContentSize().width;
            },
            _getHeight: function() {
                return this.getContentSize().height;
            }
        };
        var Canvas = cc.Class({
            name: "cc.Canvas",
            extends: require("./CCComponent"),
            editor: false,
            resetInEditor: false,
            statics: {
                instance: null
            },
            properties: {
                _designResolution: cc.size(960, 640),
                designResolution: {
                    get: function() {
                        return cc.size(this._designResolution);
                    },
                    set: function(value) {
                        this._designResolution.width = value.width;
                        this._designResolution.height = value.height;
                        this.applySettings();
                    },
                    tooltip: "i18n:COMPONENT.canvas.design_resolution"
                },
                _fitWidth: false,
                _fitHeight: true,
                fitHeight: {
                    get: function() {
                        return this._fitHeight;
                    },
                    set: function(value) {
                        if (this._fitHeight !== value) {
                            this._fitHeight = value;
                            this.applySettings();
                        }
                    },
                    tooltip: "i18n:COMPONENT.canvas.fit_height"
                },
                fitWidth: {
                    get: function() {
                        return this._fitWidth;
                    },
                    set: function(value) {
                        if (this._fitWidth !== value) {
                            this._fitWidth = value;
                            this.applySettings();
                        }
                    },
                    tooltip: "i18n:COMPONENT.canvas.fit_width"
                }
            },
            ctor: function() {
                this._thisOnResized = this.onResized.bind(this);
            },
            __preload: function() {
                var Flags = cc.Object.Flags;
                this._objFlags |= Flags.IsPositionLocked | Flags.IsAnchorLocked | Flags.IsSizeLocked;
                if (Canvas.instance) {
                    return cc.errorID(6700, this.node.name, Canvas.instance.node.name);
                }
                Canvas.instance = this;
                if (this.node._sizeProvider) {
                    var renderer = this.node.getComponent(cc._RendererUnderSG);
                    renderer ? cc.errorID(6701, cc.js.getClassName(renderer)) : cc.errorID(6702);
                } else {
                    this.node._sizeProvider = designResolutionWrapper;
                }
                cc.director.on(cc.Director.EVENT_BEFORE_VISIT, this.alignWithScreen, this);
                cc.sys.isMobile ? window.addEventListener("resize", this._thisOnResized) : cc.eventManager.addCustomListener("canvas-resize", this._thisOnResized);
                this.applySettings();
                this.onResized();
            },
            onDestroy: function() {
                this.node._sizeProvider === designResolutionWrapper && (this.node._sizeProvider = null);
                cc.director.off(cc.Director.EVENT_BEFORE_VISIT, this.alignWithScreen, this);
                cc.sys.isMobile ? window.removeEventListener("resize", this._thisOnResized) : cc.eventManager.removeCustomListeners("canvas-resize", this._thisOnResized);
                Canvas.instance === this && (Canvas.instance = null);
            },
            alignWithScreen: function() {
                var designSize;
                var canvasSize = cc.visibleRect;
                var clipTopRight = !this.fitHeight && !this.fitWidth;
                var offsetX = 0;
                var offsetY = 0;
                if (clipTopRight) {
                    designSize = cc.view.getDesignResolutionSize();
                    offsetX = .5 * (designSize.width - canvasSize.width);
                    offsetY = .5 * (designSize.height - canvasSize.height);
                }
                this.node.setPosition(.5 * canvasSize.width + offsetX, .5 * canvasSize.height + offsetY);
            },
            onResized: function() {
                this.alignWithScreen();
            },
            applySettings: function() {
                var ResolutionPolicy = cc.ResolutionPolicy;
                var policy;
                policy = this.fitHeight && this.fitWidth ? ResolutionPolicy.SHOW_ALL : this.fitHeight || this.fitWidth ? this.fitWidth ? ResolutionPolicy.FIXED_WIDTH : ResolutionPolicy.FIXED_HEIGHT : ResolutionPolicy.NO_BORDER;
                var designRes = this._designResolution;
                cc.view.setDesignResolutionSize(designRes.width, designRes.height, policy);
            }
        });
        cc.Canvas = module.exports = Canvas;
    }), {
        "./CCComponent": 76
    } ],
    76: [ (function(require, module, exports) {
        var CCObject = require("../platform/CCObject");
        var JS = require("../platform/js");
        var idGenerater = new (require("../platform/id-generater"))("Comp");
        var IsOnEnableCalled = CCObject.Flags.IsOnEnableCalled;
        var IsOnLoadCalled = CCObject.Flags.IsOnLoadCalled;
        var Component = cc.Class({
            name: "cc.Component",
            extends: CCObject,
            ctor: function() {
                this.__instanceId = cc.ClassManager.getNewInstanceId();
                this.__eventTargets = [];
            },
            properties: {
                node: {
                    default: null,
                    visible: false
                },
                name: {
                    get: function() {
                        if (this._name) {
                            return this._name;
                        }
                        var className = cc.js.getClassName(this);
                        var trimLeft = className.lastIndexOf(".");
                        trimLeft >= 0 && (className = className.slice(trimLeft + 1));
                        return this.node.name + "<" + className + ">";
                    },
                    set: function(value) {
                        this._name = value;
                    },
                    visible: false
                },
                _id: {
                    default: "",
                    serializable: false
                },
                uuid: {
                    get: function() {
                        var id = this._id;
                        id || (id = this._id = idGenerater.getNewId());
                        return id;
                    },
                    visible: false
                },
                __scriptAsset: false,
                _enabled: true,
                enabled: {
                    get: function() {
                        return this._enabled;
                    },
                    set: function(value) {
                        if (this._enabled !== value) {
                            this._enabled = value;
                            if (this.node._activeInHierarchy) {
                                var compScheduler = cc.director._compScheduler;
                                value ? compScheduler.enableComp(this) : compScheduler.disableComp(this);
                            }
                        }
                    },
                    visible: false
                },
                enabledInHierarchy: {
                    get: function() {
                        return (this._objFlags & IsOnEnableCalled) > 0;
                    },
                    visible: false
                },
                _isOnLoadCalled: {
                    get: function() {
                        return this._objFlags & IsOnLoadCalled;
                    }
                }
            },
            update: null,
            lateUpdate: null,
            __preload: null,
            onLoad: null,
            start: null,
            onEnable: null,
            onDisable: null,
            onDestroy: null,
            onFocusInEditor: null,
            onLostFocusInEditor: null,
            resetInEditor: null,
            addComponent: function(typeOrClassName) {
                return this.node.addComponent(typeOrClassName);
            },
            getComponent: function(typeOrClassName) {
                return this.node.getComponent(typeOrClassName);
            },
            getComponents: function(typeOrClassName) {
                return this.node.getComponents(typeOrClassName);
            },
            getComponentInChildren: function(typeOrClassName) {
                return this.node.getComponentInChildren(typeOrClassName);
            },
            getComponentsInChildren: function(typeOrClassName) {
                return this.node.getComponentsInChildren(typeOrClassName);
            },
            _getLocalBounds: null,
            onRestore: null,
            destroy: function() {
                var depend;
                this._super() && this._enabled && this.node._activeInHierarchy && cc.director._compScheduler.disableComp(this);
            },
            _onPreDestroy: function() {
                this.unscheduleAllCallbacks();
                var eventTargets = this.__eventTargets;
                for (var i = 0, l = eventTargets.length; i < l; ++i) {
                    var target = eventTargets[i];
                    target && target.targetOff(this);
                }
                eventTargets.length = 0;
                cc.director._nodeActivator.destroyComp(this);
                this.node._removeComponent(this);
            },
            _instantiate: function(cloned) {
                cloned || (cloned = cc.instantiate._clone(this, this));
                cloned.node = null;
                return cloned;
            },
            isRunning: function() {
                return this.enabledInHierarchy;
            },
            schedule: function(callback, interval, repeat, delay) {
                cc.assertID(callback, 1619);
                cc.assertID(interval >= 0, 1620);
                interval = interval || 0;
                repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat;
                delay = delay || 0;
                cc.director.getScheduler().schedule(callback, this, interval, repeat, delay, !this.enabledInHierarchy);
            },
            scheduleOnce: function(callback, delay) {
                this.schedule(callback, 0, 0, delay);
            },
            unschedule: function(callback_fn) {
                if (!callback_fn) {
                    return;
                }
                cc.director.getScheduler().unschedule(callback_fn, this);
            },
            unscheduleAllCallbacks: function() {
                cc.director.getScheduler().unscheduleAllForTarget(this);
            }
        });
        Component._requireComponent = null;
        Component._executionOrder = 0;
        JS.value(Component, "_registerEditorProps", (function(cls, props) {
            var reqComp = props.requireComponent;
            reqComp && (cls._requireComponent = reqComp);
            var order = props.executionOrder;
            order && "number" === typeof order && (cls._executionOrder = order);
            var name;
            var key;
            var val;
            var willExecuteInEditMode;
        }));
        Component.prototype.__scriptUuid = "";
        cc.Component = module.exports = Component;
    }), {
        "../platform/CCObject": 179,
        "../platform/id-generater": 189,
        "../platform/js": 193
    } ],
    77: [ (function(require, module, exports) {
        cc.Component.EventHandler = cc.Class({
            name: "cc.ClickEvent",
            properties: {
                target: {
                    default: null,
                    type: cc.Node
                },
                component: {
                    default: ""
                },
                handler: {
                    default: ""
                },
                customEventData: {
                    default: ""
                }
            },
            statics: {
                emitEvents: function(events) {
                    "use strict";
                    var args, i, l;
                    if (arguments.length > 0) {
                        args = new Array(arguments.length - 1);
                        for (i = 0, l = args.length; i < l; i++) {
                            args[i] = arguments[i + 1];
                        }
                    }
                    for (i = 0, l = events.length; i < l; i++) {
                        var event = events[i];
                        if (!(event instanceof cc.Component.EventHandler)) {
                            continue;
                        }
                        event.emit(args);
                    }
                }
            },
            emit: function(params) {
                var target = this.target;
                if (!cc.isValid(target)) {
                    return;
                }
                var comp = target.getComponent(this.component);
                if (!cc.isValid(comp)) {
                    return;
                }
                var handler = comp[this.handler];
                if ("function" !== typeof handler) {
                    return;
                }
                if (null != this.customEventData && "" !== this.customEventData) {
                    params = params.slice();
                    params.push(this.customEventData);
                }
                handler.apply(comp, params);
            }
        });
    }), {} ],
    78: [ (function(require, module, exports) {
        require("../editbox/CCSGEditBox.js");
        var KeyboardReturnType = _ccsg.EditBox.KeyboardReturnType;
        var InputMode = _ccsg.EditBox.InputMode;
        var InputFlag = _ccsg.EditBox.InputFlag;
        var EditBox = cc.Class({
            name: "cc.EditBox",
            extends: cc._RendererUnderSG,
            editor: false,
            properties: {
                _useOriginalSize: true,
                _string: "",
                string: {
                    tooltip: "i18n:COMPONENT.editbox.string",
                    get: function() {
                        return this._sgNode.string;
                    },
                    set: function(value) {
                        this._sgNode.string = this._string = value;
                    }
                },
                backgroundImage: {
                    tooltip: "i18n:COMPONENT.editbox.backgroundImage",
                    default: null,
                    type: cc.SpriteFrame,
                    notify: function() {
                        var sgNode = this._sgNode;
                        var backgroundSprite = sgNode.getBackgroundSprite();
                        if (this.backgroundImage) {
                            var sprite = this._createBackgroundSprite();
                            sprite.setContentSize(sgNode.getContentSize());
                        } else {
                            backgroundSprite.removeFromParent();
                        }
                    }
                },
                returnType: {
                    default: KeyboardReturnType.DEFAULT,
                    tooltip: "i18n:COMPONENT.editbox.returnType",
                    displayName: "KeyboardReturnType",
                    type: KeyboardReturnType,
                    notify: function() {
                        this._sgNode.returnType = this.returnType;
                    }
                },
                inputFlag: {
                    tooltip: "i18n:COMPONENT.editbox.input_flag",
                    default: InputFlag.DEFAULT,
                    type: InputFlag,
                    notify: function() {
                        this._sgNode.inputFlag = this.inputFlag;
                    }
                },
                inputMode: {
                    tooltip: "i18n:COMPONENT.editbox.input_mode",
                    default: InputMode.ANY,
                    type: InputMode,
                    notify: function() {
                        this._sgNode.inputMode = this.inputMode;
                    }
                },
                fontSize: {
                    tooltip: "i18n:COMPONENT.editbox.font_size",
                    default: 20,
                    notify: function() {
                        this._sgNode.fontSize = this.fontSize;
                    }
                },
                lineHeight: {
                    tooltip: "i18n:COMPONENT.editbox.line_height",
                    default: 40,
                    notify: function() {
                        this._sgNode.setLineHeight(this.lineHeight);
                    }
                },
                fontColor: {
                    tooltip: "i18n:COMPONENT.editbox.font_color",
                    default: cc.Color.WHITE,
                    notify: function() {
                        this._sgNode.fontColor = this.fontColor;
                    }
                },
                placeholder: {
                    tooltip: "i18n:COMPONENT.editbox.placeholder",
                    default: "Enter text here...",
                    notify: function() {
                        this._sgNode.placeholder = this.placeholder;
                    }
                },
                placeholderFontSize: {
                    tooltip: "i18n:COMPONENT.editbox.placeholder_font_size",
                    default: 20,
                    notify: function() {
                        this._sgNode.placeholderFontSize = this.placeholderFontSize;
                    }
                },
                placeholderFontColor: {
                    tooltip: "i18n:COMPONENT.editbox.placeholder_font_color",
                    default: cc.Color.GRAY,
                    notify: function() {
                        this._sgNode.placeholderFontColor = this.placeholderFontColor;
                    }
                },
                maxLength: {
                    tooltip: "i18n:COMPONENT.editbox.max_length",
                    default: 20,
                    notify: function() {
                        this._sgNode.maxLength = this.maxLength;
                    }
                },
                stayOnTop: {
                    tooltip: "i18n:COMPONENT.editbox.stay_on_top",
                    default: false,
                    notify: function() {
                        this._sgNode.stayOnTop(this.stayOnTop);
                        this._sgNode.fontSize = this.fontSize;
                        this._sgNode.fontColor = this.fontColor;
                    }
                },
                _tabIndex: 0,
                tabIndex: {
                    tooltip: "i18n:COMPONENT.editbox.tab_index",
                    get: function() {
                        return this._tabIndex;
                    },
                    set: function(value) {
                        this._tabIndex = value;
                        this._sgNode.setTabIndex(value);
                    }
                },
                editingDidBegan: {
                    default: [],
                    type: cc.Component.EventHandler
                },
                textChanged: {
                    default: [],
                    type: cc.Component.EventHandler
                },
                editingDidEnded: {
                    default: [],
                    type: cc.Component.EventHandler
                },
                editingReturn: {
                    default: [],
                    type: cc.Component.EventHandler
                }
            },
            statics: {
                KeyboardReturnType: KeyboardReturnType,
                InputFlag: InputFlag,
                InputMode: InputMode
            },
            _applyCapInset: function(sprite) {
                var backgroundImage = this.backgroundImage;
                sprite.setInsetTop(backgroundImage.insetTop);
                sprite.setInsetBottom(backgroundImage.insetBottom);
                sprite.setInsetRight(backgroundImage.insetRight);
                sprite.setInsetLeft(backgroundImage.insetLeft);
            },
            _createSgNode: function() {
                return new _ccsg.EditBox(cc.size(160, 40));
            },
            _createBackgroundSprite: function() {
                var sgNode = this._sgNode;
                var bgSprite = new cc.Scale9Sprite();
                bgSprite.setRenderingType(cc.Scale9Sprite.RenderingType.SLICED);
                if (this.backgroundImage) {
                    this.backgroundImage.ensureLoadTexture();
                    bgSprite.setSpriteFrame(this.backgroundImage);
                    this._applyCapInset(bgSprite);
                }
                sgNode.initWithSizeAndBackgroundSprite(cc.size(160, 40), bgSprite);
                return bgSprite;
            },
            _initSgNode: function() {
                var sgNode = this._sgNode;
                sgNode.createDomElementIfNeeded();
                this._createBackgroundSprite();
                sgNode.setContentSize(this.node.getContentSize());
                sgNode.inputMode = this.inputMode;
                sgNode.maxLength = this.maxLength;
                sgNode.string = this._string;
                sgNode.fontSize = this.fontSize;
                sgNode.fontColor = this.fontColor;
                sgNode.placeholder = this.placeholder;
                sgNode.placeholderFontSize = this.placeholderFontSize;
                sgNode.placeholderFontColor = this.placeholderFontColor;
                sgNode.inputFlag = this.inputFlag;
                sgNode.returnType = this.returnType;
                sgNode.setLineHeight(this.lineHeight);
                sgNode.stayOnTop(this.stayOnTop);
                sgNode.setTabIndex(this.tabIndex);
                sgNode.setDelegate(this);
            },
            editBoxEditingDidBegan: function() {
                cc.Component.EventHandler.emitEvents(this.editingDidBegan, this);
                this.node.emit("editing-did-began", this);
            },
            editBoxEditingDidEnded: function() {
                cc.Component.EventHandler.emitEvents(this.editingDidEnded, this);
                this.node.emit("editing-did-ended", this);
            },
            editBoxTextChanged: function(editBox, text) {
                cc.Component.EventHandler.emitEvents(this.textChanged, text, this);
                this.node.emit("text-changed", this);
            },
            editBoxEditingReturn: function() {
                cc.Component.EventHandler.emitEvents(this.editingReturn, this);
                this.node.emit("editing-return", this);
            },
            __preload: function() {
                this._super();
                this._registerEvent();
            },
            _registerEvent: function() {
                this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
                this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
            },
            _onTouchBegan: function(event) {
                this._sgNode && this._sgNode._onTouchBegan(event.touch);
                event.stopPropagation();
            },
            _onTouchEnded: function(event) {
                this._sgNode && this._sgNode._onTouchEnded();
                event.stopPropagation();
            },
            setFocus: function() {
                this._sgNode && this._sgNode.setFocus();
            },
            isFocused: function() {
                var isFocused = false;
                this._sgNode && (isFocused = this._sgNode.isFocused());
                return isFocused;
            }
        });
        cc.EditBox = module.exports = EditBox;
    }), {
        "../editbox/CCSGEditBox.js": 104
    } ],
    79: [ (function(require, module, exports) {
        require("../label/CCSGLabel.js");
        require("../label/CCSGLabelCanvasRenderCmd.js");
        require("../label/CCSGLabelWebGLRenderCmd.js");
        var HorizontalAlign = cc.TextAlignment;
        var VerticalAlign = cc.VerticalTextAlignment;
        var Overflow = _ccsg.Label.Overflow;
        function debounce(func, wait, immediate) {
            var timeout;
            return function() {
                var context = this;
                var later = function() {
                    timeout = null;
                    immediate || func.apply(context, arguments);
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                callNow && func.apply(context, arguments);
            };
        }
        var Label = cc.Class({
            name: "cc.Label",
            extends: cc._RendererUnderSG,
            ctor: function() {},
            editor: false,
            _updateSgNodeString: function() {
                this._sgNode.setString(this.string);
                this._updateNodeSize();
            },
            _updateSgNodeFontSize: function() {
                if (this._sgNode) {
                    this._sgNode.setFontSize(this._fontSize);
                    this._updateNodeSize();
                }
            },
            properties: {
                _useOriginalSize: true,
                string: {
                    default: "Label",
                    multiline: true,
                    tooltip: "i18n:COMPONENT.label.string",
                    notify: function() {
                        this._sgNode && this._updateSgNodeString();
                    }
                },
                horizontalAlign: {
                    default: HorizontalAlign.LEFT,
                    type: HorizontalAlign,
                    tooltip: "i18n:COMPONENT.label.horizontal_align",
                    notify: function() {
                        this._sgNode && this._sgNode.setHorizontalAlign(this.horizontalAlign);
                    },
                    animatable: false
                },
                verticalAlign: {
                    default: VerticalAlign.TOP,
                    type: VerticalAlign,
                    tooltip: "i18n:COMPONENT.label.vertical_align",
                    notify: function() {
                        this._sgNode && this._sgNode.setVerticalAlign(this.verticalAlign);
                    },
                    animatable: false
                },
                _actualFontSize: {
                    default: 40
                },
                actualFontSize: {
                    displayName: "Actual Font Size",
                    animatable: false,
                    readonly: true,
                    get: function() {
                        this._sgNode && (this._actualFontSize = this._sgNode.getFontSize());
                        return this._actualFontSize;
                    }
                },
                _fontSize: 40,
                fontSize: {
                    get: function() {
                        return this._fontSize;
                    },
                    set: function(value) {
                        this._fontSize = value;
                        this._updateSgNodeFontSize();
                    },
                    tooltip: "i18n:COMPONENT.label.font_size"
                },
                fontFamily: {
                    default: "Arial",
                    tooltip: "i18n:COMPONENT.label.font_family",
                    notify: function() {
                        this._sgNode && this._sgNode.setFontFileOrFamily(this.fontFamily);
                    },
                    animatable: false
                },
                _lineHeight: 40,
                lineHeight: {
                    get: function() {
                        this._sgNode && (this._lineHeight = this._sgNode.getLineHeight());
                        return this._lineHeight;
                    },
                    set: function(value) {
                        this._lineHeight = value;
                        if (this._sgNode) {
                            this._sgNode.setLineHeight(value);
                            this._updateNodeSize();
                        }
                    },
                    tooltip: "i18n:COMPONENT.label.line_height"
                },
                overflow: {
                    default: Overflow.NONE,
                    type: Overflow,
                    tooltip: "i18n:COMPONENT.label.overflow",
                    notify: function() {
                        if (this._sgNode) {
                            this._sgNode.setOverflow(this.overflow);
                            this._updateNodeSize();
                        }
                    },
                    animatable: false
                },
                _enableWrapText: true,
                enableWrapText: {
                    get: function() {
                        this._sgNode && (this._enableWrapText = this._sgNode.isWrapTextEnabled());
                        return this._enableWrapText;
                    },
                    set: function(value) {
                        this._enableWrapText = value;
                        this._sgNode && this._sgNode.enableWrapText(value);
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.label.wrap"
                },
                _N$file: null,
                font: {
                    get: function() {
                        return this._N$file;
                    },
                    set: function(value) {
                        value || (this._isSystemFontUsed = true);
                        this._N$file = value;
                        this._bmFontOriginalSize = -1;
                        value && this._isSystemFontUsed && (this._isSystemFontUsed = false);
                        if (this._sgNode) {
                            "string" === typeof value && cc.warnID(4e3);
                            var font = this.font;
                            if (font instanceof cc.BitmapFont) {
                                if (font.spriteFrame) {
                                    this._sgNode.setFontFileOrFamily(font.fntDataStr, font.spriteFrame, font);
                                } else {
                                    cc.warnID(4011, font.name);
                                    this._sgNode.setFontFileOrFamily("");
                                }
                            } else {
                                var isAsset = value instanceof cc.Font;
                                var ttfName = isAsset ? value.rawUrl : "";
                                this._sgNode.setFontFileOrFamily(ttfName);
                            }
                        }
                        value instanceof cc.BitmapFont && (this._bmFontOriginalSize = value.fontSize);
                    },
                    type: cc.Font,
                    tooltip: "i18n:COMPONENT.label.font",
                    animatable: false
                },
                _isSystemFontUsed: true,
                useSystemFont: {
                    get: function() {
                        return this._isSystemFontUsed;
                    },
                    set: function(value) {
                        this._isSystemFontUsed = !!value;
                        if (value) {
                            this.font = null;
                            this._sgNode && this._sgNode.setFontFileOrFamily(this.fontFamily);
                        }
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.label.system_font"
                },
                _bmFontOriginalSize: {
                    displayName: "BMFont Original Size",
                    default: -1,
                    serializable: false,
                    readonly: true,
                    visible: true,
                    animatable: false
                },
                _spacingX: 0,
                spacingX: {
                    get: function() {
                        return this._spacingX;
                    },
                    set: function(value) {
                        this._spacingX = value;
                        if (this._sgNode) {
                            this._sgNode.setSpacingX(this.spacingX);
                            this._updateNodeSize();
                        }
                    }
                }
            },
            statics: {
                HorizontalAlign: HorizontalAlign,
                VerticalAlign: VerticalAlign,
                Overflow: Overflow
            },
            __preload: function() {
                this._super();
                var sgSizeInitialized = this._sgNode._isUseSystemFont;
                sgSizeInitialized && this._updateNodeSize();
                this._sgNode.on("load", this._updateNodeSize, this);
            },
            _createSgNode: function() {
                return null;
            },
            _initSgNode: function() {
                var font = this.font;
                "string" === typeof font && cc.warnID(4e3);
                var sgNode;
                if (font instanceof cc.BitmapFont) {
                    if (font.spriteFrame) {
                        sgNode = this._sgNode = new _ccsg.Label(this.string, font.fntDataStr, font.spriteFrame, font);
                    } else {
                        cc.warnID(4011, font.name);
                        sgNode = this._sgNode = new _ccsg.Label(this.string);
                    }
                } else {
                    var isAsset = font instanceof cc.Font;
                    var ttfName = isAsset ? font.rawUrl : "";
                    sgNode = this._sgNode = new _ccsg.Label(this.string, ttfName);
                }
                font instanceof cc.BitmapFont && (this._bmFontOriginalSize = font.fontSize);
                sgNode.setVisible(false);
                sgNode.setHorizontalAlign(this.horizontalAlign);
                sgNode.setVerticalAlign(this.verticalAlign);
                sgNode.setFontSize(this._fontSize);
                this.useSystemFont && sgNode.setFontFileOrFamily(this.fontFamily);
                sgNode.setOverflow(this.overflow);
                sgNode.enableWrapText(this._enableWrapText);
                sgNode.setLineHeight(this._lineHeight);
                sgNode.setString(this.string);
                font instanceof cc.BitmapFont && sgNode.setSpacingX(this.spacingX);
                sgNode.setContentSize(this.node.getContentSize());
                sgNode.setColor(this.node.color);
            },
            _updateNodeSize: function() {
                var initialized = this._sgNode && this._sgNode.parent;
                initialized && (this.overflow !== Overflow.NONE && this.overflow !== Overflow.RESIZE_HEIGHT || this.node.setContentSize(this._sgNode.getContentSize()));
            }
        });
        cc.Label = module.exports = Label;
    }), {
        "../label/CCSGLabel.js": 126,
        "../label/CCSGLabelCanvasRenderCmd.js": 127,
        "../label/CCSGLabelWebGLRenderCmd.js": 128
    } ],
    80: [ (function(require, module, exports) {
        var LabelOutline = cc.Class({
            name: "cc.LabelOutline",
            extends: require("./CCComponent"),
            editor: false,
            ctor: function() {
                this._labelSGNode = null;
            },
            properties: {
                _color: cc.color(255, 255, 255, 255),
                _width: 1,
                color: {
                    get: function() {
                        return this._color;
                    },
                    set: function(value) {
                        this._color = cc.color(value);
                        this._labelSGNode && this._labelSGNode.setOutlineColor(cc.color(this._color));
                    }
                },
                width: {
                    get: function() {
                        return this._width;
                    },
                    set: function(value) {
                        this._width = value;
                        if (this._labelSGNode) {
                            this._labelSGNode.setOutlineWidth(value);
                            this._labelSGNode.setMargin(value);
                        }
                    }
                }
            },
            onEnable: function() {
                var label = this.node.getComponent("cc.Label");
                var sgNode = this._labelSGNode = label && label._sgNode;
                if (this._labelSGNode) {
                    sgNode.setOutlined(true);
                    sgNode.setOutlineColor(cc.color(this._color));
                    sgNode.setOutlineWidth(this._width);
                    sgNode.setMargin(this._width);
                }
            },
            onDisable: function() {
                if (this._labelSGNode) {
                    this._labelSGNode.setOutlined(false);
                    this._labelSGNode.setMargin(0);
                }
                this._labelSGNode = null;
            }
        });
        cc.LabelOutline = module.exports = LabelOutline;
    }), {
        "./CCComponent": 76
    } ],
    81: [ (function(require, module, exports) {
        var Type = cc.Enum({
            NONE: 0,
            HORIZONTAL: 1,
            VERTICAL: 2,
            GRID: 3
        });
        var ResizeMode = cc.Enum({
            NONE: 0,
            CONTAINER: 1,
            CHILDREN: 2
        });
        var AxisDirection = cc.Enum({
            HORIZONTAL: 0,
            VERTICAL: 1
        });
        var VerticalDirection = cc.Enum({
            BOTTOM_TO_TOP: 0,
            TOP_TO_BOTTOM: 1
        });
        var HorizontalDirection = cc.Enum({
            LEFT_TO_RIGHT: 0,
            RIGHT_TO_LEFT: 1
        });
        var Layout = cc.Class({
            name: "cc.Layout",
            extends: require("./CCComponent"),
            editor: false,
            properties: {
                _layoutSize: cc.size(300, 200),
                _layoutDirty: {
                    default: true,
                    serializable: false
                },
                _resize: ResizeMode.NONE,
                _N$layoutType: Type.NONE,
                type: {
                    type: Type,
                    get: function() {
                        return this._N$layoutType;
                    },
                    set: function(value) {
                        this._N$layoutType = value;
                        var reLayouted;
                        this._doLayoutDirty();
                    },
                    tooltip: "i18n:COMPONENT.layout.layout_type",
                    animatable: false
                },
                resizeMode: {
                    type: ResizeMode,
                    tooltip: "i18n:COMPONENT.layout.resize_mode",
                    animatable: false,
                    get: function() {
                        return this._resize;
                    },
                    set: function(value) {
                        if (this.type === Type.NONE && value === ResizeMode.CHILDREN) {
                            return;
                        }
                        this._resize = value;
                        var reLayouted;
                        this._doLayoutDirty();
                    }
                },
                cellSize: {
                    default: cc.size(40, 40),
                    tooltip: "i18n:COMPONENT.layout.cell_size",
                    type: cc.Size,
                    notify: function() {
                        this._doLayoutDirty();
                    }
                },
                startAxis: {
                    default: AxisDirection.HORIZONTAL,
                    tooltip: "i18n:COMPONENT.layout.start_axis",
                    type: AxisDirection,
                    notify: function() {
                        var reLayouted;
                        this._doLayoutDirty();
                    },
                    animatable: false
                },
                _N$padding: {
                    default: 0
                },
                paddingLeft: {
                    default: 0,
                    tooltip: "i18n:COMPONENT.layout.padding_left",
                    notify: function() {
                        this._doLayoutDirty();
                    }
                },
                paddingRight: {
                    default: 0,
                    tooltip: "i18n:COMPONENT.layout.padding_right",
                    notify: function() {
                        this._doLayoutDirty();
                    }
                },
                paddingTop: {
                    default: 0,
                    tooltip: "i18n:COMPONENT.layout.padding_top",
                    notify: function() {
                        this._doLayoutDirty();
                    }
                },
                paddingBottom: {
                    default: 0,
                    tooltip: "i18n:COMPONENT.layout.padding_bottom",
                    notify: function() {
                        this._doLayoutDirty();
                    }
                },
                spacingX: {
                    default: 0,
                    notify: function() {
                        this._doLayoutDirty();
                    },
                    tooltip: "i18n:COMPONENT.layout.space_x"
                },
                spacingY: {
                    default: 0,
                    notify: function() {
                        this._doLayoutDirty();
                    },
                    tooltip: "i18n:COMPONENT.layout.space_y"
                },
                verticalDirection: {
                    default: VerticalDirection.TOP_TO_BOTTOM,
                    type: VerticalDirection,
                    notify: function() {
                        this._doLayoutDirty();
                    },
                    tooltip: "i18n:COMPONENT.layout.vertical_direction",
                    animatable: false
                },
                horizontalDirection: {
                    default: HorizontalDirection.LEFT_TO_RIGHT,
                    type: HorizontalDirection,
                    notify: function() {
                        this._doLayoutDirty();
                    },
                    tooltip: "i18n:COMPONENT.layout.horizontal_direction",
                    animatable: false
                }
            },
            statics: {
                Type: Type,
                VerticalDirection: VerticalDirection,
                HorizontalDirection: HorizontalDirection,
                ResizeMode: ResizeMode,
                AxisDirection: AxisDirection
            },
            _migratePaddingData: function() {
                this.paddingLeft = this._N$padding;
                this.paddingRight = this._N$padding;
                this.paddingTop = this._N$padding;
                this.paddingBottom = this._N$padding;
                this._N$padding = 0;
            },
            __preload: function() {
                cc.sizeEqualToSize(this.node.getContentSize(), cc.size(0, 0)) && this.node.setContentSize(this._layoutSize);
                0 !== this._N$padding && this._migratePaddingData();
                this.node.on("size-changed", this._resized, this);
                this.node.on("anchor-changed", this._doLayoutDirty, this);
                this.node.on("child-added", this._childAdded, this);
                this.node.on("child-removed", this._childRemoved, this);
                this.node.on("child-reorder", this._doLayoutDirty, this);
                this._updateChildrenEventListener();
            },
            _doLayoutDirty: function() {
                this._layoutDirty = true;
            },
            _updateChildrenEventListener: function() {
                var children = this.node.children;
                children.forEach(function(child) {
                    child.on("size-changed", this._doLayoutDirty, this);
                    child.on("position-changed", this._doLayoutDirty, this);
                    child.on("anchor-changed", this._doLayoutDirty, this);
                    child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
                }.bind(this));
            },
            _childAdded: function(event) {
                var child = event.detail;
                child.on("size-changed", this._doLayoutDirty, this);
                child.on("position-changed", this._doLayoutDirty, this);
                child.on("anchor-changed", this._doLayoutDirty, this);
                child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
                this._doLayoutDirty();
            },
            _childRemoved: function(event) {
                var child = event.detail;
                child.off("size-changed", this._doLayoutDirty, this);
                child.off("position-changed", this._doLayoutDirty, this);
                child.off("anchor-changed", this._doLayoutDirty, this);
                child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
                this._doLayoutDirty();
            },
            _resized: function() {
                this._layoutSize = this.node.getContentSize();
                this._doLayoutDirty();
            },
            _doLayoutHorizontally: function(baseWidth, rowBreak, fnPositionY, applyChildren) {
                var layoutAnchor = this.node.getAnchorPoint();
                var children = this.node.children;
                var sign = 1;
                var paddingX = this.paddingLeft;
                var leftBoundaryOfLayout = -layoutAnchor.x * baseWidth;
                if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                    sign = -1;
                    leftBoundaryOfLayout = (1 - layoutAnchor.x) * baseWidth;
                    paddingX = this.paddingRight;
                }
                var nextX = leftBoundaryOfLayout + sign * paddingX - sign * this.spacingX;
                var rowMaxHeight = 0;
                var tempMaxHeight = 0;
                var secondMaxHeight = 0;
                var row = 0;
                var containerResizeBoundary = 0;
                var maxHeightChildAnchorY = 0;
                var newChildWidth = this.cellSize.width;
                this.type !== Type.GRID && this.resizeMode === ResizeMode.CHILDREN && (newChildWidth = (baseWidth - (this.paddingLeft + this.paddingRight) - (children.length - 1) * this.spacingX) / children.length);
                children.forEach(function(child) {
                    if (!child.activeInHierarchy) {
                        return;
                    }
                    if (this._resize === ResizeMode.CHILDREN) {
                        child.width = newChildWidth;
                        this.type === Type.GRID && (child.height = this.cellSize.height);
                    }
                    var anchorX = child.anchorX;
                    secondMaxHeight > tempMaxHeight && (tempMaxHeight = secondMaxHeight);
                    if (child.height >= tempMaxHeight) {
                        secondMaxHeight = tempMaxHeight;
                        tempMaxHeight = child.height;
                        maxHeightChildAnchorY = child.getAnchorPoint().y;
                    }
                    this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (anchorX = 1 - child.anchorX);
                    nextX = nextX + sign * anchorX * child.width + sign * this.spacingX;
                    var rightBoundaryOfChild = sign * (1 - anchorX) * child.width;
                    if (rowBreak) {
                        var rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this.paddingRight : this.paddingLeft);
                        var leftToRightRowBreak = this.horizontalDirection === HorizontalDirection.LEFT_TO_RIGHT && rowBreakBoundary > (1 - layoutAnchor.x) * baseWidth;
                        var rightToLeftRowBreak = this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && rowBreakBoundary < -layoutAnchor.x * baseWidth;
                        if (leftToRightRowBreak || rightToLeftRowBreak) {
                            if (child.height >= tempMaxHeight) {
                                0 === secondMaxHeight && (secondMaxHeight = tempMaxHeight);
                                rowMaxHeight += secondMaxHeight;
                                secondMaxHeight = tempMaxHeight;
                            } else {
                                rowMaxHeight += tempMaxHeight;
                                secondMaxHeight = child.height;
                                tempMaxHeight = 0;
                            }
                            nextX = leftBoundaryOfLayout + sign * (paddingX + anchorX * child.width);
                            row++;
                        }
                    }
                    var finalPositionY = fnPositionY(child, rowMaxHeight, row);
                    baseWidth >= child.width + this.paddingLeft + this.paddingRight && applyChildren && child.setPosition(cc.p(nextX, finalPositionY));
                    var signX = 1;
                    var tempFinalPositionY;
                    var topMarign = 0 === tempMaxHeight ? child.height : tempMaxHeight;
                    if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                        containerResizeBoundary = containerResizeBoundary || this.node._contentSize.height;
                        signX = -1;
                        tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this.paddingBottom);
                        tempFinalPositionY < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY);
                    } else {
                        containerResizeBoundary = containerResizeBoundary || -this.node._contentSize.height;
                        tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this.paddingTop);
                        tempFinalPositionY > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY);
                    }
                    nextX += rightBoundaryOfChild;
                }.bind(this));
                return containerResizeBoundary;
            },
            _getVerticalBaseHeight: function(children) {
                var newHeight = 0;
                var activeChildCount = 0;
                if (this.resizeMode === ResizeMode.CONTAINER) {
                    children.forEach((function(child) {
                        if (!child.activeInHierarchy) {
                            return;
                        }
                        activeChildCount++;
                        newHeight += child.height;
                    }));
                    newHeight += (activeChildCount - 1) * this.spacingY + this.paddingBottom + this.paddingTop;
                } else {
                    newHeight = this.node.getContentSize().height;
                }
                return newHeight;
            },
            _doLayoutVertically: function(baseHeight, columnBreak, fnPositionX, applyChildren) {
                var layoutAnchor = this.node.getAnchorPoint();
                var children = this.node.children;
                var sign = 1;
                var paddingY = this.paddingBottom;
                var bottomBoundaryOfLayout = -layoutAnchor.y * baseHeight;
                if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                    sign = -1;
                    bottomBoundaryOfLayout = (1 - layoutAnchor.y) * baseHeight;
                    paddingY = this.paddingTop;
                }
                var nextY = bottomBoundaryOfLayout + sign * paddingY - sign * this.spacingY;
                var columnMaxWidth = 0;
                var tempMaxWidth = 0;
                var secondMaxWidth = 0;
                var column = 0;
                var containerResizeBoundary = 0;
                var maxWidthChildAnchorX = 0;
                var newChildHeight = this.cellSize.height;
                this.type !== Type.GRID && this.resizeMode === ResizeMode.CHILDREN && (newChildHeight = (baseHeight - (this.paddingTop + this.paddingBottom) - (children.length - 1) * this.spacingY) / children.length);
                children.forEach(function(child) {
                    if (!child.activeInHierarchy) {
                        return;
                    }
                    if (this.resizeMode === ResizeMode.CHILDREN) {
                        child.height = newChildHeight;
                        this.type === Type.GRID && (child.width = this.cellSize.width);
                    }
                    var anchorY = child.anchorY;
                    secondMaxWidth > tempMaxWidth && (tempMaxWidth = secondMaxWidth);
                    if (child.width >= tempMaxWidth) {
                        secondMaxWidth = tempMaxWidth;
                        tempMaxWidth = child.width;
                        maxWidthChildAnchorX = child.getAnchorPoint().x;
                    }
                    this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (anchorY = 1 - child.anchorY);
                    nextY = nextY + sign * anchorY * child.height + sign * this.spacingY;
                    var topBoundaryOfChild = sign * (1 - anchorY) * child.height;
                    if (columnBreak) {
                        var columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this.paddingTop : this.paddingBottom);
                        var bottomToTopColumnBreak = this.verticalDirection === VerticalDirection.BOTTOM_TO_TOP && columnBreakBoundary > (1 - layoutAnchor.y) * baseHeight;
                        var topToBottomColumnBreak = this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM && columnBreakBoundary < -layoutAnchor.y * baseHeight;
                        if (bottomToTopColumnBreak || topToBottomColumnBreak) {
                            if (child.width >= tempMaxWidth) {
                                0 === secondMaxWidth && (secondMaxWidth = tempMaxWidth);
                                columnMaxWidth += secondMaxWidth;
                                secondMaxWidth = tempMaxWidth;
                            } else {
                                columnMaxWidth += tempMaxWidth;
                                secondMaxWidth = child.width;
                                tempMaxWidth = 0;
                            }
                            nextY = bottomBoundaryOfLayout + sign * (paddingY + anchorY * child.height);
                            column++;
                        }
                    }
                    var finalPositionX = fnPositionX(child, columnMaxWidth, column);
                    baseHeight >= child.height + (this.paddingTop + this.paddingBottom) && applyChildren && child.setPosition(cc.p(finalPositionX, nextY));
                    var signX = 1;
                    var tempFinalPositionX;
                    var rightMarign = 0 === tempMaxWidth ? child.width : tempMaxWidth;
                    if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                        signX = -1;
                        containerResizeBoundary = containerResizeBoundary || this.node._contentSize.width;
                        tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this.paddingLeft);
                        tempFinalPositionX < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX);
                    } else {
                        containerResizeBoundary = containerResizeBoundary || -this.node._contentSize.width;
                        tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this.paddingRight);
                        tempFinalPositionX > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX);
                    }
                    nextY += topBoundaryOfChild;
                }.bind(this));
                return containerResizeBoundary;
            },
            _doLayoutBasic: function() {
                var children = this.node.children;
                var allChildrenBoundingBox = null;
                children.forEach((function(child) {
                    if (!child.activeInHierarchy) {
                        return;
                    }
                    allChildrenBoundingBox = allChildrenBoundingBox ? cc.rectUnion(allChildrenBoundingBox, child.getBoundingBoxToWorld()) : child.getBoundingBoxToWorld();
                }));
                if (allChildrenBoundingBox) {
                    var leftBottomInParentSpace = this.node.parent.convertToNodeSpaceAR(cc.p(allChildrenBoundingBox.x, allChildrenBoundingBox.y));
                    leftBottomInParentSpace = cc.pAdd(leftBottomInParentSpace, cc.p(-this.paddingLeft, -this.paddingBottom));
                    var rightTopInParentSpace = this.node.parent.convertToNodeSpaceAR(cc.p(allChildrenBoundingBox.x + allChildrenBoundingBox.width, allChildrenBoundingBox.y + allChildrenBoundingBox.height));
                    rightTopInParentSpace = cc.pAdd(rightTopInParentSpace, cc.p(this.paddingRight, this.paddingTop));
                    var newSize = cc.size(parseFloat((rightTopInParentSpace.x - leftBottomInParentSpace.x).toFixed(2)), parseFloat((rightTopInParentSpace.y - leftBottomInParentSpace.y).toFixed(2)));
                    var layoutPosition = this.node.getPosition();
                    var newAnchorX = (layoutPosition.x - leftBottomInParentSpace.x) / newSize.width;
                    var newAnchorY = (layoutPosition.y - leftBottomInParentSpace.y) / newSize.height;
                    var newAnchor = cc.p(parseFloat(newAnchorX.toFixed(2)), parseFloat(newAnchorY.toFixed(2)));
                    this.node.setAnchorPoint(newAnchor);
                    this.node.setContentSize(newSize);
                }
            },
            _doLayoutGridAxisHorizontal: function(layoutAnchor, layoutSize) {
                var baseWidth = layoutSize.width;
                var sign = 1;
                var bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height;
                var paddingY = this.paddingBottom;
                if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                    sign = -1;
                    bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height;
                    paddingY = this.paddingTop;
                }
                var fnPositionY = function(child, topOffset, row) {
                    return bottomBoundaryOfLayout + sign * (topOffset + child.anchorY * child.height + paddingY + row * this.spacingY);
                }.bind(this);
                var newHeight = 0;
                if (this.resizeMode === ResizeMode.CONTAINER) {
                    var boundary = this._doLayoutHorizontally(baseWidth, true, fnPositionY, false);
                    newHeight = bottomBoundaryOfLayout - boundary;
                    newHeight < 0 && (newHeight *= -1);
                    bottomBoundaryOfLayout = -layoutAnchor.y * newHeight;
                    if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                        sign = -1;
                        bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight;
                    }
                }
                this._doLayoutHorizontally(baseWidth, true, fnPositionY, true);
                this.resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(baseWidth, newHeight);
            },
            _doLayoutGridAxisVertical: function(layoutAnchor, layoutSize) {
                var baseHeight = layoutSize.height;
                var sign = 1;
                var leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width;
                var paddingX = this.paddingLeft;
                if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                    sign = -1;
                    leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width;
                    paddingX = this.paddingRight;
                }
                var fnPositionX = function(child, leftOffset, column) {
                    return leftBoundaryOfLayout + sign * (leftOffset + child.anchorX * child.width + paddingX + column * this.spacingX);
                }.bind(this);
                var newWidth = 0;
                if (this.resizeMode === ResizeMode.CONTAINER) {
                    var boundary = this._doLayoutVertically(baseHeight, true, fnPositionX, false);
                    newWidth = leftBoundaryOfLayout - boundary;
                    newWidth < 0 && (newWidth *= -1);
                    leftBoundaryOfLayout = -layoutAnchor.x * newWidth;
                    if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                        sign = -1;
                        leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth;
                    }
                }
                this._doLayoutVertically(baseHeight, true, fnPositionX, true);
                this.resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(newWidth, baseHeight);
            },
            _doLayoutGrid: function() {
                var layoutAnchor = this.node.getAnchorPoint();
                var layoutSize = this.node.getContentSize();
                this.startAxis === AxisDirection.HORIZONTAL ? this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) : this.startAxis === AxisDirection.VERTICAL && this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
            },
            _getHorizontalBaseWidth: function(children) {
                var newWidth = 0;
                var activeChildCount = 0;
                if (this.resizeMode === ResizeMode.CONTAINER) {
                    children.forEach((function(child) {
                        if (!child.activeInHierarchy) {
                            return;
                        }
                        activeChildCount++;
                        newWidth += child.width;
                    }));
                    newWidth += (activeChildCount - 1) * this.spacingX + this.paddingLeft + this.paddingRight;
                } else {
                    newWidth = this.node.getContentSize().width;
                }
                return newWidth;
            },
            _doLayout: function() {
                if (this.type === Type.HORIZONTAL) {
                    var newWidth = this._getHorizontalBaseWidth(this.node.children);
                    var fnPositionY = function(child) {
                        return child.y;
                    };
                    this._doLayoutHorizontally(newWidth, false, fnPositionY, true);
                    this.node.width = newWidth;
                } else {
                    if (this.type === Type.VERTICAL) {
                        var newHeight = this._getVerticalBaseHeight(this.node.children);
                        var fnPositionX = function(child) {
                            return child.x;
                        };
                        this._doLayoutVertically(newHeight, false, fnPositionX, true);
                        this.node.height = newHeight;
                    } else {
                        this.type === Type.NONE ? this.resizeMode === ResizeMode.CONTAINER && this._doLayoutBasic() : this.type === Type.GRID && this._doLayoutGrid();
                    }
                }
            },
            onEnable: function() {
                cc.director.on(cc.Director.EVENT_BEFORE_VISIT, this._updateLayout, this);
            },
            onDisable: function() {
                cc.director.off(cc.Director.EVENT_BEFORE_VISIT, this._updateLayout, this);
            },
            _updateLayout: function() {
                if (this._layoutDirty && this.node.children.length > 0) {
                    this._doLayout();
                    this._layoutDirty = false;
                }
            }
        });
        Object.defineProperty(Layout.prototype, "padding", {
            get: function() {
                cc.warnID(4100);
                return this.paddingLeft;
            },
            set: function(value) {
                this._N$padding = value;
                this._migratePaddingData();
                this._doLayoutDirty();
            }
        });
        cc.Layout = module.exports = Layout;
    }), {
        "./CCComponent": 76
    } ],
    82: [ (function(require, module, exports) {
        require("../../clipping-nodes/CCClippingNode.js");
        require("../../clipping-nodes/CCClippingNodeCanvasRenderCmd.js");
        require("../../clipping-nodes/CCClippingNodeWebGLRenderCmd.js");
        var Base = cc._RendererInSG;
        var MaskType = cc.Enum({
            RECT: 0,
            ELLIPSE: 1,
            IMAGE_STENCIL: 2
        });
        var Mask = cc.Class({
            name: "cc.Mask",
            extends: Base,
            editor: false,
            properties: {
                _clippingStencil: {
                    default: null,
                    serializable: false
                },
                _type: MaskType.RECT,
                type: {
                    get: function() {
                        return this._type;
                    },
                    set: function(value) {
                        this._type = value;
                        this._refreshStencil();
                    },
                    type: MaskType,
                    tooltip: "i18n:COMPONENT.mask.type"
                },
                spriteFrame: {
                    default: null,
                    type: cc.SpriteFrame,
                    tooltip: "i18n:COMPONENT.mask.spriteFrame",
                    notify: function() {
                        this._refreshStencil();
                    }
                },
                alphaThreshold: {
                    default: 1,
                    type: cc.Float,
                    range: [ 0, 1, .1 ],
                    slide: true,
                    tooltip: "i18n:COMPONENT.mask.alphaThreshold",
                    notify: function() {
                        if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                            cc.warnID(4201);
                            return;
                        }
                        this._sgNode.setAlphaThreshold(this.alphaThreshold);
                    }
                },
                inverted: {
                    default: false,
                    type: cc.Boolean,
                    tooltip: "i18n:COMPONENT.mask.inverted",
                    notify: function() {
                        if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                            cc.warnID(4202);
                            return;
                        }
                        this._sgNode.setInverted(this.inverted);
                    }
                },
                _segements: 64,
                segements: {
                    get: function() {
                        return this._segements;
                    },
                    set: function(value) {
                        this._segements = value < 3 ? 3 : value;
                        this._refreshStencil();
                    },
                    type: cc.Integer,
                    tooltip: "i18n:COMPONENT.mask.segements"
                },
                _resizeToTarget: {
                    animatable: false,
                    set: function(value) {
                        value && this._resizeNodeToTargetNode();
                    }
                }
            },
            statics: {
                Type: MaskType
            },
            _resizeNodeToTargetNode: false,
            _createSgNode: function() {
                return new cc.ClippingNode();
            },
            _initSgNode: function() {},
            _hitTest: function(point) {
                var size = this.node.getContentSize(), w = size.width, h = size.height, trans = this.node.getNodeToWorldTransform();
                if (this.type === MaskType.RECT || this.type === MaskType.IMAGE_STENCIL) {
                    var rect = cc.rect(0, 0, w, h);
                    cc._rectApplyAffineTransformIn(rect, trans);
                    var left = point.x - rect.x, right = rect.x + rect.width - point.x, bottom = point.y - rect.y, top = rect.y + rect.height - point.y;
                    return left >= 0 && right >= 0 && top >= 0 && bottom >= 0;
                }
                if (this.type === MaskType.ELLIPSE) {
                    var a = w / 2, b = h / 2;
                    var cx = trans.a * a + trans.c * b + trans.tx;
                    var cy = trans.b * a + trans.d * b + trans.ty;
                    var px = point.x - cx, py = point.y - cy;
                    return px * px / (a * a) + py * py / (b * b) < 1;
                }
            },
            __preload: function() {
                this._refreshStencil();
            },
            onEnable: function() {
                this._super();
                this.node.on("size-changed", this._refreshStencil, this);
                this.node.on("anchor-changed", this._refreshStencil, this);
            },
            onDisable: function() {
                this._super();
                this.node.off("size-changed", this._refreshStencil, this);
                this.node.off("anchor-changed", this._refreshStencil, this);
            },
            _calculateCircle: function(center, radius, segements) {
                var polies = [];
                var anglePerStep = 2 * Math.PI / segements;
                for (var step = 0; step < segements; ++step) {
                    polies.push(cc.v2(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y));
                }
                return polies;
            },
            _refreshStencil: function() {
                if (this.type === MaskType.IMAGE_STENCIL && cc._renderType !== cc.game.RENDER_TYPE_WEBGL && true) {
                    cc.warnID(4200);
                    return;
                }
                var contentSize = this.node.getContentSize();
                var anchorPoint = this.node.getAnchorPoint();
                var stencil = this._clippingStencil;
                if (this._type === MaskType.IMAGE_STENCIL) {
                    var isSgSprite = stencil instanceof cc.Scale9Sprite;
                    if (!isSgSprite || stencil._spriteFrame !== this.spriteFrame) {
                        stencil = new cc.Scale9Sprite();
                        stencil.setSpriteFrame(this.spriteFrame);
                        this._sgNode.setStencil(stencil);
                    }
                    stencil.setContentSize(contentSize);
                    stencil.setAnchorPoint(anchorPoint);
                    this._sgNode.setAlphaThreshold(this.alphaThreshold);
                } else {
                    var isDrawNode = stencil instanceof cc.DrawNode;
                    if (!isDrawNode) {
                        stencil = new cc.DrawNode();
                        this._sgNode.setStencil(stencil);
                    }
                    var width = contentSize.width;
                    var height = contentSize.height;
                    var x = -width * anchorPoint.x;
                    var y = -height * anchorPoint.y;
                    var color = cc.color(255, 255, 255, 0);
                    stencil.clear();
                    if (this._type === MaskType.RECT) {
                        var rectangle = [ cc.v2(x, y), cc.v2(x + width, y), cc.v2(x + width, y + height), cc.v2(x, y + height) ];
                        stencil.drawPoly(rectangle, color, 0, color);
                    } else {
                        if (this._type === MaskType.ELLIPSE) {
                            var center = cc.v2(x + width / 2, y + height / 2);
                            var radius = {
                                x: width / 2,
                                y: height / 2
                            };
                            stencil.drawPoly(this._calculateCircle(center, radius, this._segements), color, 0, color);
                        }
                    }
                }
                this._sgNode.setInverted(this.inverted);
                this._clippingStencil = stencil;
                cc.renderer.childrenOrderDirty = true;
            }
        });
        cc.Mask = module.exports = Mask;
    }), {
        "../../clipping-nodes/CCClippingNode.js": 26,
        "../../clipping-nodes/CCClippingNodeCanvasRenderCmd.js": 27,
        "../../clipping-nodes/CCClippingNodeWebGLRenderCmd.js": 28
    } ],
    83: [ (function(require, module, exports) {
        var SizeMode = cc.Enum({
            Unified: 0,
            Free: 1
        });
        var Direction = cc.Enum({
            Horizontal: 0,
            Vertical: 1
        });
        var EventType = cc.Enum({
            PAGE_TURNING: 0
        });
        var PageView = cc.Class({
            name: "cc.PageView",
            extends: cc.ScrollView,
            editor: false,
            ctor: function() {
                this._curPageIdx = 0;
                this._lastPageIdx = 0;
                this._pages = [];
                this._scrollCenterOffsetX = [];
                this._scrollCenterOffsetY = [];
            },
            properties: {
                sizeMode: {
                    default: SizeMode.Unified,
                    type: SizeMode,
                    tooltip: "i18n:COMPONENT.pageview.sizeMode",
                    notify: function() {
                        this._syncSizeMode();
                    }
                },
                direction: {
                    default: Direction.Horizontal,
                    type: Direction,
                    tooltip: "i18n:COMPONENT.pageview.direction",
                    notify: function() {
                        this._syncScrollDirection();
                    }
                },
                scrollThreshold: {
                    default: .5,
                    type: cc.Float,
                    slide: true,
                    range: [ 0, 1, .01 ],
                    tooltip: "i18n:COMPONENT.pageview.scrollThreshold"
                },
                autoPageTurningThreshold: {
                    default: 100,
                    type: cc.Float,
                    tooltip: "i18n:COMPONENT.pageview.autoPageTurningThreshold"
                },
                pageTurningEventTiming: {
                    default: .1,
                    type: cc.Float,
                    range: [ 0, 1, .01 ],
                    tooltip: "i18n:COMPONENT.pageview.pageTurningEventTiming"
                },
                indicator: {
                    default: null,
                    type: cc.PageViewIndicator,
                    tooltip: "i18n:COMPONENT.pageview.indicator",
                    notify: function() {
                        this.indicator && this.indicator.setPageView(this);
                    }
                },
                pageEvents: {
                    default: [],
                    type: cc.Component.EventHandler,
                    tooltip: "i18n:COMPONENT.pageview.pageEvents"
                }
            },
            statics: {
                SizeMode: SizeMode,
                Direction: Direction,
                EventType: EventType
            },
            __preload: function() {
                this.node.on("size-changed", this._updateAllPagesSize, this);
            },
            onEnable: function() {
                this._super();
                this.node.on("scroll-ended-with-threshold", this._dispatchPageTurningEvent, this);
            },
            onDisable: function() {
                this._super();
                this.node.off("scroll-ended-with-threshold", this._dispatchPageTurningEvent, this);
            },
            onLoad: function() {
                this._initPages();
                this.indicator && this.indicator.setPageView(this);
            },
            onDestroy: function() {
                this.node.off("size-changed", this._updateAllPagesSize, this);
            },
            getCurrentPageIndex: function() {
                return this._curPageIdx;
            },
            setCurrentPageIndex: function(index) {
                this.scrollToPage(index, true);
            },
            getPages: function() {
                return this._pages;
            },
            addPage: function(page) {
                if (!page || this._pages.indexOf(page) !== -1 || !this.content) {
                    return;
                }
                this.content.addChild(page);
                this._pages.push(page);
                this._updatePageView();
            },
            insertPage: function(page, index) {
                if (index < 0 || !page || this._pages.indexOf(page) !== -1 || !this.content) {
                    return;
                }
                var pageCount = this._pages.length;
                if (index >= pageCount) {
                    this.addPage(page);
                } else {
                    this._pages.splice(index, 0, page);
                    this.content.addChild(page);
                    this._updatePageView();
                }
            },
            removePage: function(page) {
                if (!page || !this.content) {
                    return;
                }
                var index = this._pages.indexOf(page);
                if (index === -1) {
                    cc.warnID(4300, page.name);
                    return;
                }
                this.removePageAtIndex(index);
            },
            removePageAtIndex: function(index) {
                var pageList = this._pages;
                if (index < 0 || index >= pageList.length) {
                    return;
                }
                var page = pageList[index];
                if (!page) {
                    return;
                }
                this.content.removeChild(page);
                pageList.splice(index, 1);
                this._updatePageView();
            },
            removeAllPages: function() {
                if (!this.content) {
                    return;
                }
                var locPages = this._pages;
                for (var i = 0, len = locPages.length; i < len; i++) {
                    this.content.removeChild(locPages[i]);
                }
                this._pages.length = 0;
                this._updatePageView();
            },
            scrollToPage: function(idx, timeInSecond) {
                if (idx < 0 || idx > this._pages.length) {
                    return;
                }
                timeInSecond = void 0 !== timeInSecond ? timeInSecond : .3;
                this._curPageIdx = idx;
                this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, true);
                this.indicator && this.indicator._changedState();
            },
            getScrollEndedEventTiming: function() {
                return this.pageTurningEventTiming;
            },
            _syncScrollDirection: function() {
                this.horizontal = this.direction === Direction.Horizontal;
                this.vertical = this.direction === Direction.Vertical;
            },
            _syncSizeMode: function() {
                if (!this.content) {
                    return;
                }
                var layout = this.content.getComponent(cc.Layout);
                if (layout) {
                    if (0 === this._pages.length) {
                        layout.padding = 0;
                    } else {
                        var lastPage = this._pages[this._pages.length - 1];
                        if (this.sizeMode === SizeMode.Free) {
                            if (this.direction === Direction.Horizontal) {
                                layout.paddingLeft = (this.node.width - this._pages[0].width) / 2;
                                layout.paddingRight = (this.node.width - lastPage.width) / 2;
                            } else {
                                if (this.direction === Direction.Vertical) {
                                    layout.paddingTop = (this.node.height - this._pages[0].height) / 2;
                                    layout.paddingBottom = (this.node.height - lastPage.height) / 2;
                                }
                            }
                        }
                    }
                    layout._updateLayout();
                }
            },
            _updatePageView: function() {
                var pageCount = this._pages.length;
                var layout = this.content.getComponent(cc.Layout);
                layout && layout.enabled && layout._updateLayout();
                if (this._curPageIdx >= pageCount) {
                    this._curPageIdx = 0 === pageCount ? 0 : pageCount - 1;
                    this._lastPageIdx = this._curPageIdx;
                }
                for (var i = 0; i < pageCount; ++i) {
                    this._pages[i].setSiblingIndex(i);
                    this.direction === Direction.Horizontal ? this._scrollCenterOffsetX[i] = Math.abs(this.content.x + this._pages[i].x) : this._scrollCenterOffsetY[i] = Math.abs(this.content.y + this._pages[i].y);
                }
                this.indicator && this.indicator._refresh();
            },
            _updateAllPagesSize: function() {
                if (this.sizeMode !== SizeMode.Unified) {
                    return;
                }
                var locPages = this._pages;
                var selfSize = this.node.getContentSize();
                for (var i = 0, len = locPages.length; i < len; i++) {
                    locPages[i].setContentSize(selfSize);
                }
            },
            _initPages: function() {
                if (!this.content) {
                    return;
                }
                var children = this.content.children;
                for (var i = 0; i < children.length; ++i) {
                    var page = children[i];
                    if (this._pages.indexOf(page) >= 0) {
                        continue;
                    }
                    this._pages.push(page);
                }
                this._syncScrollDirection();
                this._syncSizeMode();
                this._updatePageView();
            },
            _dispatchPageTurningEvent: function() {
                if (this._lastPageIdx === this._curPageIdx) {
                    return;
                }
                this._lastPageIdx = this._curPageIdx;
                cc.Component.EventHandler.emitEvents(this.pageEvents, this, EventType.PAGE_TURNING);
                this.node.emit("page-turning", this);
            },
            _isScrollable: function(offset, index, nextIndex) {
                if (this.sizeMode === SizeMode.Free) {
                    var curPageCenter, nextPageCenter;
                    if (this.direction === Direction.Horizontal) {
                        curPageCenter = this._scrollCenterOffsetX[index];
                        nextPageCenter = this._scrollCenterOffsetX[nextIndex];
                        return Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
                    }
                    if (this.direction === Direction.Vertical) {
                        curPageCenter = this._scrollCenterOffsetY[index];
                        nextPageCenter = this._scrollCenterOffsetY[nextIndex];
                        return Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
                    }
                } else {
                    if (this.direction === Direction.Horizontal) {
                        return Math.abs(offset.x) >= this.node.width * this.scrollThreshold;
                    }
                    if (this.direction === Direction.Vertical) {
                        return Math.abs(offset.y) >= this.node.height * this.scrollThreshold;
                    }
                }
            },
            _isQuicklyScrollable: function(touchMoveVelocity) {
                if (this.direction === Direction.Horizontal) {
                    if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) {
                        return true;
                    }
                } else {
                    if (this.direction === Direction.Vertical && Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) {
                        return true;
                    }
                }
                return false;
            },
            _moveOffsetValue: function(idx) {
                var offset = cc.p(0, 0);
                this.sizeMode === SizeMode.Free ? this.direction === Direction.Horizontal ? offset.x = this._scrollCenterOffsetX[idx] : this.direction === Direction.Vertical && (offset.y = this._scrollCenterOffsetY[idx]) : this.direction === Direction.Horizontal ? offset.x = idx * this.node.width : this.direction === Direction.Vertical && (offset.y = idx * this.node.height);
                return offset;
            },
            _getDragDirection: function(moveOffset) {
                if (this.direction === Direction.Horizontal) {
                    if (0 === moveOffset.x) {
                        return 0;
                    }
                    return moveOffset.x > 0 ? 1 : -1;
                }
                if (this.direction === Direction.Vertical) {
                    if (0 === moveOffset.y) {
                        return 0;
                    }
                    return moveOffset.y < 0 ? 1 : -1;
                }
            },
            _handleReleaseLogic: function(touch) {
                var bounceBackStarted = this._startBounceBackIfNeeded();
                var moveOffset = cc.pSub(this._touchBeganPosition, this._touchEndPosition);
                if (bounceBackStarted) {
                    var dragDirection = this._getDragDirection(moveOffset);
                    if (0 === dragDirection) {
                        return;
                    }
                    dragDirection > 0 ? this._curPageIdx = this._pages.length - 1 : this._curPageIdx = 0;
                    this.indicator && this.indicator._changedState();
                } else {
                    var index = this._curPageIdx, nextIndex = index + this._getDragDirection(moveOffset);
                    if (nextIndex < this._pages.length) {
                        if (this._isScrollable(moveOffset, index, nextIndex)) {
                            this.scrollToPage(nextIndex);
                            return;
                        }
                        var touchMoveVelocity = this._calculateTouchMoveVelocity();
                        if (this._isQuicklyScrollable(touchMoveVelocity)) {
                            this.scrollToPage(nextIndex);
                            return;
                        }
                    }
                    this.scrollToPage(index);
                }
            },
            _onTouchBegan: function(event, captureListeners) {
                this._touchBeganPosition = event.touch.getLocation();
                this._super(event, captureListeners);
            },
            _onTouchMoved: function(event, captureListeners) {
                this._super(event, captureListeners);
            },
            _onTouchEnded: function(event, captureListeners) {
                this._touchEndPosition = event.touch.getLocation();
                this._super(event, captureListeners);
            },
            _onTouchCancelled: function(event, captureListeners) {
                this._touchEndPosition = event.touch.getLocation();
                this._super(event, captureListeners);
            },
            _onMouseWheel: function() {}
        });
        cc.PageView = module.exports = PageView;
    }), {} ],
    84: [ (function(require, module, exports) {
        var Direction = cc.Enum({
            HORIZONTAL: 0,
            VERTICAL: 1
        });
        var PageViewIndicator = cc.Class({
            name: "cc.PageViewIndicator",
            extends: require("./CCComponent"),
            editor: false,
            properties: {
                _layout: null,
                _pageView: null,
                _indicators: [],
                spriteFrame: {
                    default: null,
                    type: cc.SpriteFrame,
                    tooltip: "i18n:COMPONENT.pageview_indicator.spriteFrame"
                },
                direction: {
                    default: Direction.HORIZONTAL,
                    type: Direction,
                    tooltip: "i18n:COMPONENT.pageview_indicator.direction"
                },
                cellSize: {
                    default: cc.size(20, 20),
                    tooltip: "i18n:COMPONENT.pageview_indicator.cell_size"
                },
                spacing: {
                    default: 0,
                    tooltip: "i18n:COMPONENT.pageview_indicator.spacing"
                }
            },
            statics: {
                Direction: Direction
            },
            onLoad: function() {
                this._updateLayout();
            },
            setPageView: function(target) {
                this._pageView = target;
                this._refresh();
            },
            _updateLayout: function() {
                this._layout = this.getComponent(cc.Layout);
                this._layout || (this._layout = this.addComponent(cc.Layout));
                if (this.direction === Direction.HORIZONTAL) {
                    this._layout.type = cc.Layout.Type.HORIZONTAL;
                    this._layout.spacingX = this.spacing;
                } else {
                    if (this.direction === Direction.VERTICAL) {
                        this._layout.type = cc.Layout.Type.VERTICAL;
                        this._layout.spacingY = this.spacing;
                    }
                }
                this._layout.resizeMode = cc.Layout.ResizeMode.CONTAINER;
            },
            _createIndicator: function() {
                var node = new cc.Node();
                var sprite = node.addComponent(cc.Sprite);
                sprite.spriteFrame = this.spriteFrame;
                node.parent = this.node;
                node.width = this.cellSize.width;
                node.height = this.cellSize.height;
                return node;
            },
            _changedState: function() {
                var indicators = this._indicators;
                if (0 === indicators.length) {
                    return;
                }
                var idx = this._pageView._curPageIdx;
                if (idx >= indicators.length) {
                    return;
                }
                for (var i = 0; i < indicators.length; ++i) {
                    var node = indicators[i];
                    node.opacity = 127.5;
                }
                indicators[idx].opacity = 255;
            },
            _refresh: function() {
                if (!this._pageView) {
                    return;
                }
                var indicators = this._indicators;
                var pages = this._pageView.getPages();
                if (pages.length === indicators.length) {
                    return;
                }
                var i = 0;
                if (pages.length > indicators.length) {
                    for (i = 0; i < pages.length; ++i) {
                        indicators[i] || (indicators[i] = this._createIndicator());
                    }
                } else {
                    var count = indicators.length - pages.length;
                    for (i = count; i > 0; --i) {
                        var node = indicators[i - 1];
                        this.node.removeChild(node);
                        indicators.splice(i - 1, 1);
                    }
                }
                this._layout && this._layout.enabledInHierarchy && this._layout._updateLayout();
                this._changedState();
            }
        });
        cc.PageViewIndicator = module.exports = PageViewIndicator;
    }), {
        "./CCComponent": 76
    } ],
    85: [ (function(require, module, exports) {
        var Mode = cc.Enum({
            HORIZONTAL: 0,
            VERTICAL: 1,
            FILLED: 2
        });
        var ProgressBar = cc.Class({
            name: "cc.ProgressBar",
            extends: require("./CCComponent"),
            editor: false,
            _initBarSprite: function() {
                if (this.barSprite) {
                    var entity = this.barSprite.node;
                    if (!entity) {
                        return;
                    }
                    var nodeSize = this.node.getContentSize();
                    var nodeAnchor = this.node.getAnchorPoint();
                    var entitySize = entity.getContentSize();
                    entity.parent === this.node && this.node.setContentSize(entitySize);
                    this.barSprite.fillType === cc.Sprite.FillType.RADIAL && (this.mode = Mode.FILLED);
                    var barSpriteSize = entity.getContentSize();
                    this.mode === Mode.HORIZONTAL ? this.totalLength = barSpriteSize.width : this.mode === Mode.VERTICAL ? this.totalLength = barSpriteSize.height : this.totalLength = this.barSprite.fillRange;
                    if (entity.parent === this.node) {
                        var x = -nodeSize.width * nodeAnchor.x;
                        var y = 0;
                        entity.setPosition(cc.p(x, y));
                    }
                }
            },
            _updateBarStatus: function() {
                if (this.barSprite) {
                    var entity = this.barSprite.node;
                    if (!entity) {
                        return;
                    }
                    var entityAnchorPoint = entity.getAnchorPoint();
                    var entitySize = entity.getContentSize();
                    var entityPosition = entity.getPosition();
                    var anchorPoint = cc.p(0, .5);
                    var progress = cc.clamp01(this.progress);
                    var actualLenth = this.totalLength * progress;
                    var finalContentSize;
                    var totalWidth;
                    var totalHeight;
                    switch (this.mode) {
                      case Mode.HORIZONTAL:
                        this.reverse && (anchorPoint = cc.p(1, .5));
                        finalContentSize = cc.size(actualLenth, entitySize.height);
                        totalWidth = this.totalLength;
                        totalHeight = entitySize.height;
                        break;

                      case Mode.VERTICAL:
                        anchorPoint = this.reverse ? cc.p(.5, 1) : cc.p(.5, 0);
                        finalContentSize = cc.size(entitySize.width, actualLenth);
                        totalWidth = entitySize.width;
                        totalHeight = this.totalLength;
                    }
                    if (this.mode === Mode.FILLED) {
                        if (this.barSprite.type !== cc.Sprite.Type.FILLED) {
                            cc.warn("ProgressBar FILLED mode only works when barSprite's Type is FILLED!");
                        } else {
                            this.reverse && (actualLenth *= -1);
                            this.barSprite.fillRange = actualLenth;
                        }
                    } else {
                        if (this.barSprite.type !== cc.Sprite.Type.FILLED) {
                            var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x;
                            var anchorOffsetY = anchorPoint.y - entityAnchorPoint.y;
                            var finalPosition = cc.p(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY);
                            entity.setPosition(cc.pAdd(entityPosition, finalPosition));
                            entity.setAnchorPoint(anchorPoint);
                            entity.setContentSize(finalContentSize);
                        } else {
                            cc.warn("ProgressBar non-FILLED mode only works when barSprite's Type is non-FILLED!");
                        }
                    }
                }
            },
            properties: {
                barSprite: {
                    default: null,
                    type: cc.Sprite,
                    tooltip: "i18n:COMPONENT.progress.bar_sprite",
                    notify: function() {
                        this._initBarSprite();
                    },
                    animatable: false
                },
                mode: {
                    default: Mode.HORIZONTAL,
                    type: Mode,
                    tooltip: "i18n:COMPONENT.progress.mode",
                    notify: function() {
                        if (this.barSprite) {
                            var entity = this.barSprite.node;
                            if (!entity) {
                                return;
                            }
                            var entitySize = entity.getContentSize();
                            this.mode === Mode.HORIZONTAL ? this.totalLength = entitySize.width : this.mode === Mode.VERTICAL ? this.totalLength = entitySize.height : this.mode === Mode.FILLED && (this.totalLength = this.barSprite.fillRange);
                        }
                    },
                    animatable: false
                },
                _N$totalLength: 1,
                totalLength: {
                    range: [ 0, Number.MAX_VALUE ],
                    tooltip: "i18n:COMPONENT.progress.total_length",
                    get: function() {
                        return this._N$totalLength;
                    },
                    set: function(value) {
                        this.mode === Mode.FILLED && (value = cc.clamp01(value));
                        this._N$totalLength = value;
                        this._updateBarStatus();
                    }
                },
                progress: {
                    default: 1,
                    type: "Float",
                    range: [ 0, 1, .1 ],
                    slide: true,
                    tooltip: "i18n:COMPONENT.progress.progress",
                    notify: function() {
                        this._updateBarStatus();
                    }
                },
                reverse: {
                    default: false,
                    tooltip: "i18n:COMPONENT.progress.reverse",
                    notify: function() {
                        this.barSprite && (this.barSprite.fillStart = 1 - this.barSprite.fillStart);
                        this._updateBarStatus();
                    },
                    animatable: false
                }
            },
            statics: {
                Mode: Mode
            }
        });
        cc.ProgressBar = module.exports = ProgressBar;
    }), {
        "./CCComponent": 76
    } ],
    86: [ (function(require, module, exports) {
        var RendererInSG = cc.Class({
            extends: require("./CCSGComponent"),
            name: "cc._RendererInSG",
            ctor: function() {
                var sgNode = this._sgNode = this._createSgNode();
                sgNode.setVisible(false);
                this._plainNode = new _ccsg.Node();
            },
            __preload: function() {
                this._initSgNode();
                var sgSize;
            },
            onEnable: function() {
                this._replaceSgNode(this._sgNode);
            },
            onDisable: function() {
                this._replaceSgNode(this._plainNode);
            },
            onDestroy: function() {
                this._removeSgNode();
                var releasedByNode;
            },
            _replaceSgNode: function(sgNode) {
                var node = this.node;
                var replaced = node._sgNode;
                replaced._entity = null;
                var children = replaced.getChildren().slice();
                replaced.removeAllChildren(false);
                sgNode.getChildrenCount() > 0 && sgNode.removeAllChildren(false);
                for (var i = 0, len = children.length; i < len; ++i) {
                    sgNode.addChild(children[i]);
                }
                var parentNode = replaced.getParent();
                if (parentNode) {
                    parentNode.removeChild(replaced, false);
                    parentNode.addChild(sgNode);
                    sgNode._arrivalOrder = replaced._arrivalOrder;
                    cc.renderer.childrenOrderDirty = parentNode._reorderChildDirty = true;
                }
                node._sgNode = sgNode;
                node._sgNode._entity = node;
                node._updateSgNode();
            }
        });
        cc._RendererInSG = module.exports = RendererInSG;
    }), {
        "./CCSGComponent": 89
    } ],
    87: [ (function(require, module, exports) {
        var RendererUnderSG = cc.Class({
            extends: require("./CCSGComponent"),
            name: "cc._RendererUnderSG",
            ctor: function() {
                var sgNode = this._sgNode = this._createSgNode();
                sgNode && sgNode.setVisible(false);
            },
            __preload: function() {
                this._initSgNode();
                this._registSizeProvider();
                this._appendSgNode(this._sgNode);
            },
            onEnable: function() {
                this._sgNode && this._sgNode.setVisible(true);
            },
            onDisable: function() {
                this._sgNode && this._sgNode.setVisible(false);
            },
            onDestroy: function() {
                this.node._sizeProvider === this._sgNode && (this.node._sizeProvider = null);
                this._removeSgNode();
            },
            _appendSgNode: function(sgNode) {
                if (!sgNode) {
                    return;
                }
                var node = this.node;
                sgNode.setColor(node._color);
                node._cascadeOpacityEnabled || sgNode.setOpacity(node._opacity);
                sgNode.setAnchorPoint(node._anchorPoint);
                sgNode.setIgnoreAnchorPointForPosition(node.__ignoreAnchor);
                sgNode.setOpacityModifyRGB(node._opacityModifyRGB);
                sgNode.setLocalZOrder(-1);
                var sgParent = node._sgNode;
                sgParent.addChild(sgNode);
            }
        });
        cc._RendererUnderSG = module.exports = RendererUnderSG;
    }), {
        "./CCSGComponent": 89
    } ],
    88: [ (function(require, module, exports) {
        require("../label/CCHtmlTextParser.js");
        require("../label/CCTextUtils.js");
        var HorizontalAlign = cc.TextAlignment;
        var VerticalAlign = cc.VerticalTextAlignment;
        function debounce(func, wait, immediate) {
            var timeout;
            return function() {
                var context = this;
                var later = function() {
                    timeout = null;
                    immediate || func.apply(context, arguments);
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                callNow && func.apply(context, arguments);
            };
        }
        var RichText = cc.Class({
            name: "cc.RichText",
            extends: cc._RendererUnderSG,
            ctor: function() {
                this._textArray = null;
                this._labelSegments = [];
                this._labelSegmentsCache = [];
                this._linesWidth = [];
                this._resetState();
                this._updateRichTextStatus = this._updateRichText;
            },
            editor: false,
            properties: {
                string: {
                    default: "<color=#00ff00>Rich</c><color=#0fffff>Text</color>",
                    multiline: true,
                    tooltip: "i18n:COMPONENT.richtext.string",
                    notify: function() {
                        this._updateRichTextStatus();
                    }
                },
                horizontalAlign: {
                    default: HorizontalAlign.LEFT,
                    type: HorizontalAlign,
                    tooltip: "i18n:COMPONENT.richtext.horizontal_align",
                    animatable: false,
                    notify: function(oldValue) {
                        if (this.horizontalAlign === oldValue) {
                            return;
                        }
                        this._layoutDirty = true;
                        this._updateRichTextStatus();
                    }
                },
                fontSize: {
                    default: 40,
                    tooltip: "i18n:COMPONENT.richtext.font_size",
                    notify: function(oldValue) {
                        if (this.fontSize === oldValue) {
                            return;
                        }
                        this._layoutDirty = true;
                        this._updateRichTextStatus();
                    }
                },
                font: {
                    default: null,
                    type: cc.TTFFont,
                    tooltip: "i18n:COMPONENT.richtext.font",
                    notify: function(oldValue) {
                        if (this.font === oldValue) {
                            return;
                        }
                        this._layoutDirty = true;
                        this.font && this._onTTFLoaded();
                        this._updateRichTextStatus();
                    }
                },
                maxWidth: {
                    default: 0,
                    tooltip: "i18n:COMPONENT.richtext.max_width",
                    notify: function(oldValue) {
                        if (this.maxWidth === oldValue) {
                            return;
                        }
                        this._layoutDirty = true;
                        this._updateRichTextStatus();
                    }
                },
                lineHeight: {
                    default: 40,
                    tooltip: "i18n:COMPONENT.richtext.line_height",
                    notify: function(oldValue) {
                        if (this.lineHeight === oldValue) {
                            return;
                        }
                        this._layoutDirty = true;
                        this._updateRichTextStatus();
                    }
                },
                imageAtlas: {
                    default: null,
                    type: cc.SpriteAtlas,
                    tooltip: "i18n:COMPONENT.richtext.image_atlas",
                    notify: function(oldValue) {
                        if (this.imageAtlas === oldValue) {
                            return;
                        }
                        this._layoutDirty = true;
                        this._updateRichTextStatus();
                    }
                }
            },
            statics: {
                HorizontalAlign: HorizontalAlign,
                VerticalAlign: VerticalAlign
            },
            __preload: function() {
                this._super();
                this._registerEvents();
            },
            _createSgNode: function() {
                var sgNode = new _ccsg.Node();
                sgNode.setCascadeOpacityEnabled(true);
                var self = this;
                sgNode.setColor = function() {
                    self._updateLabelSegmentTextAttributes();
                };
                sgNode._setContentSize = sgNode.setContentSize;
                sgNode.setContentSize = function() {};
                return sgNode;
            },
            _updateLabelSegmentTextAttributes: function() {
                this._labelSegments.forEach(function(item) {
                    this._applyTextAttribute(item);
                }.bind(this));
            },
            _initSgNode: function() {
                this._updateRichText();
                this._onTTFLoaded();
            },
            _createFontLabel: function(string) {
                return new _ccsg.Label(string, this._getFontRawUrl());
            },
            _getFontRawUrl: function() {
                var isAsset = this.font instanceof cc.TTFFont;
                var fntRawUrl = isAsset ? this.font.rawUrl : "";
                return fntRawUrl;
            },
            _onTTFLoaded: function() {
                var rawUrl = this._getFontRawUrl();
                if (!rawUrl) {
                    return;
                }
                var self = this;
                var callback = function() {
                    self._layoutDirty = true;
                    self._updateRichText();
                };
                cc.CustomFontLoader.loadTTF(rawUrl, callback);
            },
            _measureText: function(styleIndex, string) {
                var self = this;
                var func = function(string) {
                    var label;
                    if (0 === self._labelSegmentsCache.length) {
                        label = self._createFontLabel(string);
                        self._labelSegmentsCache.push(label);
                    } else {
                        label = self._labelSegmentsCache[0];
                        label.setString(string);
                    }
                    label._styleIndex = styleIndex;
                    self._applyTextAttribute(label);
                    var labelSize = label.getContentSize();
                    return labelSize.width;
                };
                return string ? func(string) : func;
            },
            _onTouchEnded: function(event) {
                if (!this.enabledInHierarchy) {
                    return;
                }
                var components = this.node.getComponents(cc.Component);
                for (var i = 0; i < this._labelSegments.length; ++i) {
                    var labelSegment = this._labelSegments[i];
                    var clickHandler = labelSegment._clickHandler;
                    clickHandler && this._containsTouchLocation(labelSegment, event.touch.getLocation()) && components.forEach((function(component) {
                        component.enabledInHierarchy && component[clickHandler] && component[clickHandler](event);
                    }));
                }
            },
            _containsTouchLocation: function(label, point) {
                var myRect = label.getBoundingBoxToWorld();
                return cc.rectContainsPoint(myRect, point);
            },
            _registerEvents: function() {
                this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
            },
            _resetState: function() {
                var sgNode = this._sgNode;
                sgNode && sgNode.removeAllChildren();
                this._labelSegments.length = 0;
                this._labelSegmentsCache.length = 0;
                this._linesWidth.length = 0;
                this._lineOffsetX = 0;
                this._lineCount = 1;
                this._labelWidth = 0;
                this._labelHeight = 0;
                this._layoutDirty = true;
            },
            _addLabelSegment: function(stringToken, styleIndex) {
                var labelSegment;
                if (0 === this._labelSegmentsCache.length) {
                    labelSegment = this._createFontLabel(stringToken);
                } else {
                    labelSegment = this._labelSegmentsCache.pop();
                    labelSegment.setString(stringToken);
                }
                labelSegment._styleIndex = styleIndex;
                labelSegment._lineCount = this._lineCount;
                this._applyTextAttribute(labelSegment);
                labelSegment.setAnchorPoint(0, 0);
                this._sgNode.addChild(labelSegment);
                this._labelSegments.push(labelSegment);
                var size;
                return labelSegment;
            },
            _updateRichTextWithMaxWidth: function(labelString, labelWidth, styleIndex) {
                var fragmentWidth = labelWidth;
                var labelSegment;
                if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this.maxWidth) {
                    var checkStartIndex = 0;
                    while (this._lineOffsetX <= this.maxWidth) {
                        var checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length);
                        var checkString = labelString.substr(checkStartIndex, checkEndIndex);
                        var checkStringWidth = this._measureText(styleIndex, checkString);
                        if (!(this._lineOffsetX + checkStringWidth <= this.maxWidth)) {
                            if (checkStartIndex > 0) {
                                var remainingString = labelString.substr(0, checkStartIndex);
                                this._addLabelSegment(remainingString, styleIndex);
                                labelString = labelString.substr(checkStartIndex, labelString.length);
                                fragmentWidth = this._measureText(styleIndex, labelString);
                            }
                            this._updateLineInfo();
                            break;
                        }
                        this._lineOffsetX += checkStringWidth;
                        checkStartIndex += checkEndIndex;
                    }
                }
                if (fragmentWidth > this.maxWidth) {
                    var fragments = cc.TextUtils.fragmentText(labelString, fragmentWidth, this.maxWidth, this._measureText(styleIndex));
                    for (var k = 0; k < fragments.length; ++k) {
                        var splitString = fragments[k];
                        labelSegment = this._addLabelSegment(splitString, styleIndex);
                        var labelSize = labelSegment.getContentSize();
                        this._lineOffsetX += labelSize.width;
                        fragments.length > 1 && k < fragments.length - 1 && this._updateLineInfo();
                    }
                } else {
                    this._lineOffsetX += fragmentWidth;
                    this._addLabelSegment(labelString, styleIndex);
                }
            },
            _isLastComponentCR: function(stringToken) {
                return stringToken.length - 1 === stringToken.lastIndexOf("\n");
            },
            _updateLineInfo: function() {
                this._linesWidth.push(this._lineOffsetX);
                this._lineOffsetX = 0;
                this._lineCount++;
            },
            _needsUpdateTextLayout: function(newTextArray) {
                if (this._layoutDirty || !this._textArray || !newTextArray) {
                    return true;
                }
                if (this._textArray.length !== newTextArray.length) {
                    return true;
                }
                for (var i = 0; i < this._textArray.length; ++i) {
                    var oldItem = this._textArray[i];
                    var newItem = newTextArray[i];
                    if (oldItem.text != newItem.text) {
                        return true;
                    }
                    if (oldItem.style) {
                        if (newItem.style) {
                            if (oldItem.style.size !== newItem.style.size || oldItem.style.italic !== newItem.style.italic || oldItem.style.isImage !== newItem.style.isImage) {
                                return true;
                            }
                            if (oldItem.style.isImage === newItem.style.isImage && oldItem.style.src !== newItem.style.src) {
                                return true;
                            }
                        } else {
                            if (oldItem.style.size || oldItem.style.italic || oldItem.style.isImage) {
                                return true;
                            }
                        }
                    } else {
                        if (newItem.style && (newItem.style.size || newItem.style.italic || newItem.style.isImage)) {
                            return true;
                        }
                    }
                }
                return false;
            },
            _onSpriteFrameLoaded: function(event, spriteFrame) {
                var newSpriteFrame;
                newSpriteFrame = spriteFrame ? spriteFrame : event.target;
                var sprite = newSpriteFrame.__sprite;
                sprite.setSpriteFrame(newSpriteFrame);
            },
            _applySpriteFrame: function(spriteFrame) {
                if (spriteFrame) {
                    if (spriteFrame.textureLoaded()) {
                        this._onSpriteFrameLoaded(null, spriteFrame);
                    } else {
                        spriteFrame.once("load", this._onSpriteFrameLoaded, this);
                        spriteFrame.ensureLoadTexture();
                    }
                }
            },
            _addRichTextImageElement: function(richTextElement) {
                var spriteFrameName = richTextElement.style.src;
                var spriteFrame = this.imageAtlas.getSpriteFrame(spriteFrameName);
                if (spriteFrame) {
                    var sprite = new cc.Scale9Sprite();
                    sprite.setAnchorPoint(0, 0);
                    spriteFrame.__sprite = sprite;
                    this._sgNode.addChild(sprite);
                    this._labelSegments.push(sprite);
                    var spriteRect = spriteFrame.getRect();
                    var scaleFactor = 1;
                    spriteRect.height > this.lineHeight && (scaleFactor = this.lineHeight / spriteRect.height);
                    if (this.maxWidth > 0) {
                        this._lineOffsetX + spriteRect.width * scaleFactor > this.maxWidth && this._updateLineInfo();
                        this._lineOffsetX += spriteRect.width * scaleFactor;
                    } else {
                        this._lineOffsetX += spriteRect.width * scaleFactor;
                        this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX);
                    }
                    this._applySpriteFrame(spriteFrame);
                    sprite.setContentSize(spriteRect.width * scaleFactor, spriteRect.height * scaleFactor);
                    sprite._lineCount = this._lineCount;
                    richTextElement.style.event && richTextElement.style.event.click && (sprite._clickHandler = richTextElement.style.event.click);
                } else {
                    cc.warnID(4400);
                }
            },
            _updateRichText: function() {
                if (!this.enabled) {
                    return;
                }
                var newTextArray = cc.htmlTextParser.parse(this.string);
                if (!this._needsUpdateTextLayout(newTextArray)) {
                    this._textArray = newTextArray;
                    this._updateLabelSegmentTextAttributes();
                    return;
                }
                this._textArray = newTextArray;
                var sgNode = this._sgNode;
                this._resetState();
                var lastEmptyLine = false;
                var label;
                var labelSize;
                for (var i = 0; i < this._textArray.length; ++i) {
                    var richTextElement = this._textArray[i];
                    var text = richTextElement.text;
                    if ("" === text) {
                        if (richTextElement.style && richTextElement.style.newline) {
                            this._updateLineInfo();
                            continue;
                        }
                        if (richTextElement.style && richTextElement.style.isImage && this.imageAtlas) {
                            this._addRichTextImageElement(richTextElement);
                            continue;
                        }
                    }
                    var multilineTexts = text.split("\n");
                    for (var j = 0; j < multilineTexts.length; ++j) {
                        var labelString = multilineTexts[j];
                        if ("" === labelString) {
                            if (this._isLastComponentCR(text) && j == multilineTexts.length - 1) {
                                continue;
                            }
                            this._updateLineInfo();
                            lastEmptyLine = true;
                            continue;
                        }
                        lastEmptyLine = false;
                        if (this.maxWidth > 0) {
                            var labelWidth = this._measureText(i, labelString);
                            this._updateRichTextWithMaxWidth(labelString, labelWidth, i);
                            multilineTexts.length > 1 && j < multilineTexts.length - 1 && this._updateLineInfo();
                        } else {
                            label = this._addLabelSegment(labelString, i);
                            labelSize = label.getContentSize();
                            this._lineOffsetX += labelSize.width;
                            this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX);
                            multilineTexts.length > 1 && j < multilineTexts.length - 1 && this._updateLineInfo();
                        }
                    }
                }
                lastEmptyLine || this._linesWidth.push(this._lineOffsetX);
                this.maxWidth > 0 && (this._labelWidth = this.maxWidth);
                this._labelHeight = this._lineCount * this.lineHeight;
                sgNode._setContentSize(this._labelWidth, this._labelHeight);
                this.node.emit("size-changed");
                this._updateRichTextPosition();
                this._layoutDirty = false;
            },
            _getFirstWordLen: function(text, startIndex, textLen) {
                var character = text.charAt(startIndex);
                if (cc.TextUtils.isUnicodeCJK(character) || cc.TextUtils.isUnicodeSpace(character)) {
                    return 1;
                }
                var len = 1;
                for (var index = startIndex + 1; index < textLen; ++index) {
                    character = text.charAt(index);
                    if (cc.TextUtils.isUnicodeSpace(character) || cc.TextUtils.isUnicodeCJK(character)) {
                        break;
                    }
                    len++;
                }
                return len;
            },
            _updateRichTextPosition: function() {
                var nextTokenX = 0;
                var nextLineIndex = 1;
                var totalLineCount = this._lineCount;
                for (var i = 0; i < this._labelSegments.length; ++i) {
                    var label = this._labelSegments[i];
                    var lineCount = label._lineCount;
                    if (lineCount > nextLineIndex) {
                        nextTokenX = 0;
                        nextLineIndex = lineCount;
                    }
                    var lineOffsetX = 0;
                    switch (this.horizontalAlign) {
                      case cc.TextAlignment.LEFT:
                        lineOffsetX = 0;
                        break;

                      case cc.TextAlignment.CENTER:
                        lineOffsetX = (this._labelWidth - this._linesWidth[lineCount - 1]) / 2;
                        break;

                      case cc.TextAlignment.RIGHT:
                        lineOffsetX = this._labelWidth - this._linesWidth[lineCount - 1];
                    }
                    label.setPositionX(nextTokenX + lineOffsetX);
                    var labelSize = label.getContentSize();
                    var positionY = (totalLineCount - lineCount) * this.lineHeight;
                    label instanceof cc.Scale9Sprite && (positionY += (this.lineHeight - label.getContentSize().height) / 2);
                    label.setPositionY(positionY);
                    lineCount === nextLineIndex && (nextTokenX += labelSize.width);
                }
            },
            _convertLiteralColorValue: function(color) {
                var colorValue = color.toUpperCase();
                return cc.Color[colorValue] ? cc.Color[colorValue] : cc.hexToColor(color);
            },
            _applyTextAttribute: function(label) {
                if (label instanceof cc.Scale9Sprite) {
                    return;
                }
                var index = label._styleIndex;
                label.setLineHeight(this.lineHeight);
                label.setVerticalAlign(VerticalAlign.CENTER);
                var textStyle = null;
                this._textArray[index] && (textStyle = this._textArray[index].style);
                textStyle && textStyle.color ? label.setColor(this._convertLiteralColorValue(textStyle.color)) : label.setColor(this.node.color);
                textStyle && textStyle.bold ? label.enableBold(true) : label.enableBold(false);
                textStyle && textStyle.italic ? label.enableItalics(true) : label.enableItalics(false);
                textStyle && textStyle.underline ? label.enableUnderline(true) : label.enableUnderline(false);
                if (textStyle && textStyle.outline) {
                    label.setOutlined(true);
                    label.setOutlineColor(this._convertLiteralColorValue(textStyle.outline.color));
                    label.setOutlineWidth(textStyle.outline.width);
                    label.setMargin(textStyle.outline.width);
                } else {
                    label.setOutlined(false);
                    label.setMargin(0);
                }
                textStyle && textStyle.size ? label.setFontSize(textStyle.size) : label.setFontSize(this.fontSize);
                textStyle && textStyle.event && textStyle.event.click && (label._clickHandler = textStyle.event.click);
            }
        });
        cc.RichText = module.exports = RichText;
    }), {
        "../label/CCHtmlTextParser.js": 125,
        "../label/CCTextUtils.js": 129
    } ],
    89: [ (function(require, module, exports) {
        var SceneGraphHelper = require("../utils/scene-graph-helper");
        var SGComponent = cc.Class({
            extends: require("./CCComponent"),
            name: "cc._SGComponent",
            editor: false,
            properties: {
                _sgNode: {
                    default: null,
                    serializable: false
                }
            },
            _createSgNode: null,
            _initSgNode: null,
            _removeSgNode: SceneGraphHelper.removeSgNode,
            _registSizeProvider: function() {
                if (this.node._sizeProvider) {
                    var name = cc.js.getClassName(this);
                    this.node.getComponent(cc.Canvas) ? cc.errorID(3627, name) : cc.errorID(3628, name);
                } else {
                    this.node._sizeProvider = this._sgNode;
                }
            }
        });
        cc._SGComponent = module.exports = SGComponent;
    }), {
        "../utils/scene-graph-helper": 226,
        "./CCComponent": 76
    } ],
    90: [ (function(require, module, exports) {
        var GETTINGSHORTERFACTOR = 20;
        var Direction = cc.Enum({
            HORIZONTAL: 0,
            VERTICAL: 1
        });
        var Scrollbar = cc.Class({
            name: "cc.Scrollbar",
            extends: require("./CCComponent"),
            editor: false,
            properties: {
                _scrollView: null,
                _touching: false,
                _autoHideRemainingTime: {
                    default: 0,
                    serializable: false
                },
                _opacity: 255,
                handle: {
                    default: null,
                    type: cc.Sprite,
                    tooltip: "i18n:COMPONENT.scrollbar.handle",
                    notify: function() {
                        this._onScroll(cc.p(0, 0));
                    },
                    animatable: false
                },
                direction: {
                    default: Direction.HORIZONTAL,
                    type: Direction,
                    tooltip: "i18n:COMPONENT.scrollbar.direction",
                    notify: function() {
                        this._onScroll(cc.p(0, 0));
                    },
                    animatable: false
                },
                enableAutoHide: {
                    default: true,
                    animatable: false,
                    tooltip: "i18n:COMPONENT.scrollbar.auto_hide"
                },
                autoHideTime: {
                    default: 1,
                    animatable: false,
                    tooltip: "i18n:COMPONENT.scrollbar.auto_hide_time"
                }
            },
            statics: {
                Direction: Direction
            },
            setTargetScrollView: function(scrollView) {
                this._scrollView = scrollView;
            },
            _convertToScrollViewSpace: function(content) {
                var worldSpacePos = content.convertToWorldSpace(cc.p(0, 0));
                var scrollViewSpacePos = this._scrollView.node.convertToNodeSpace(worldSpacePos);
                return scrollViewSpacePos;
            },
            _setOpacity: function(opacity) {
                this.handle && this.node.setOpacity(opacity);
            },
            _onScroll: function(outOfBoundary) {
                if (this._scrollView) {
                    var content = this._scrollView.content;
                    if (content) {
                        var contentSize = content.getContentSize();
                        var scrollViewSize = this._scrollView.node.getContentSize();
                        var handleNodeSize = this.node.getContentSize();
                        if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                            return;
                        }
                        if (this.enableAutoHide) {
                            this._autoHideRemainingTime = this.autoHideTime;
                            this._setOpacity(this._opacity);
                        }
                        var contentMeasure = 0;
                        var scrollViewMeasure = 0;
                        var outOfBoundaryValue = 0;
                        var contentPosition = 0;
                        var handleNodeMeasure = 0;
                        if (this.direction === Direction.HORIZONTAL) {
                            contentMeasure = contentSize.width;
                            scrollViewMeasure = scrollViewSize.width;
                            handleNodeMeasure = handleNodeSize.width;
                            outOfBoundaryValue = outOfBoundary.x;
                            contentPosition = -this._convertToScrollViewSpace(content).x;
                        } else {
                            if (this.direction === Direction.VERTICAL) {
                                contentMeasure = contentSize.height;
                                scrollViewMeasure = scrollViewSize.height;
                                handleNodeMeasure = handleNodeSize.height;
                                outOfBoundaryValue = outOfBoundary.y;
                                contentPosition = -this._convertToScrollViewSpace(content).y;
                            }
                        }
                        var length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue);
                        var position = this._calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);
                        this._updateLength(length);
                        this._updateHanlderPosition(position);
                    }
                }
            },
            _updateHanlderPosition: function(position) {
                if (this.handle) {
                    var oldPosition = this._fixupHandlerPosition();
                    this.handle.node.setPosition(cc.pAdd(position, oldPosition));
                }
            },
            _fixupHandlerPosition: function() {
                var barSize = this.node.getContentSize();
                var barAnchor = this.node.getAnchorPoint();
                var handleSize = this.handle.node.getContentSize();
                var handleParent = this.handle.node.parent;
                var leftBottomWorldPosition = this.node.convertToWorldSpaceAR(cc.p(-barSize.width * barAnchor.x, -barSize.height * barAnchor.y));
                var fixupPosition = handleParent.convertToNodeSpaceAR(leftBottomWorldPosition);
                this.direction === Direction.HORIZONTAL ? fixupPosition = cc.pAdd(fixupPosition, cc.p(0, (barSize.height - handleSize.height) / 2)) : this.direction === Direction.VERTICAL && (fixupPosition = cc.pAdd(fixupPosition, cc.p((barSize.width - handleSize.width) / 2, 0)));
                this.handle.node.setPosition(fixupPosition);
                return fixupPosition;
            },
            _onTouchBegan: function() {
                if (!this.enableAutoHide) {
                    return;
                }
                this._touching = true;
            },
            _conditionalDisableScrollBar: function(contentSize, scrollViewSize) {
                if (contentSize.width <= scrollViewSize.width && this.direction === Direction.HORIZONTAL) {
                    return true;
                }
                if (contentSize.height <= scrollViewSize.height && this.direction === Direction.VERTICAL) {
                    return true;
                }
                return false;
            },
            _onTouchEnded: function() {
                if (!this.enableAutoHide) {
                    return;
                }
                this._touching = false;
                if (this.autoHideTime <= 0) {
                    return;
                }
                if (this._scrollView) {
                    var content = this._scrollView.content;
                    if (content) {
                        var contentSize = content.getContentSize();
                        var scrollViewSize = this._scrollView.node.getContentSize();
                        if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                            return;
                        }
                    }
                }
                this._autoHideRemainingTime = this.autoHideTime;
            },
            _calculateLength: function(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
                var denominatorValue = contentMeasure;
                outOfBoundary && (denominatorValue += (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary) * GETTINGSHORTERFACTOR);
                var lengthRation = scrollViewMeasure / denominatorValue;
                return handleNodeMeasure * lengthRation;
            },
            _calculatePosition: function(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
                var denominatorValue = contentMeasure - scrollViewMeasure;
                outOfBoundary && (denominatorValue += Math.abs(outOfBoundary));
                var positionRatio = 0;
                if (denominatorValue) {
                    positionRatio = contentPosition / denominatorValue;
                    positionRatio = cc.clamp01(positionRatio);
                }
                var position = (handleNodeMeasure - actualLenth) * positionRatio;
                return this.direction === Direction.VERTICAL ? cc.p(0, position) : cc.p(position, 0);
            },
            _updateLength: function(length) {
                if (this.handle) {
                    var handleNode = this.handle.node;
                    var handleNodeSize = handleNode.getContentSize();
                    handleNode.setAnchorPoint(cc.p(0, 0));
                    this.direction === Direction.HORIZONTAL ? handleNode.setContentSize(length, handleNodeSize.height) : handleNode.setContentSize(handleNodeSize.width, length);
                }
            },
            _processAutoHide: function(deltaTime) {
                if (!this.enableAutoHide || this._autoHideRemainingTime <= 0) {
                    return;
                }
                if (this._touching) {
                    return;
                }
                this._autoHideRemainingTime -= deltaTime;
                if (this._autoHideRemainingTime <= this.autoHideTime) {
                    this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
                    var opacity = this._opacity * (this._autoHideRemainingTime / this.autoHideTime);
                    this._setOpacity(opacity);
                }
            },
            start: function() {
                this.enableAutoHide && this._setOpacity(0);
            },
            hide: function() {
                this._autoHideRemainingTime = 0;
                this._setOpacity(0);
            },
            show: function() {
                this._autoHideRemainingTime = this.autoHideTime;
                this._setOpacity(this._opacity);
            },
            update: function(dt) {
                this._processAutoHide(dt);
            }
        });
        cc.Scrollbar = module.exports = Scrollbar;
    }), {
        "./CCComponent": 76
    } ],
    91: [ (function(require, module, exports) {
        var NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED = 5;
        var OUT_OF_BOUNDARY_BREAKING_FACTOR = .05;
        var EPSILON = 1e-4;
        var MOVEMENT_FACTOR = .7;
        var quintEaseOut = function(time) {
            time -= 1;
            return time * time * time * time * time + 1;
        };
        var getTimeInMilliseconds = function() {
            var currentTime = new Date();
            return currentTime.getMilliseconds();
        };
        var EventType = cc.Enum({
            SCROLL_TO_TOP: 0,
            SCROLL_TO_BOTTOM: 1,
            SCROLL_TO_LEFT: 2,
            SCROLL_TO_RIGHT: 3,
            SCROLLING: 4,
            BOUNCE_TOP: 5,
            BOUNCE_BOTTOM: 6,
            BOUNCE_LEFT: 7,
            BOUNCE_RIGHT: 8,
            AUTOSCROLL_ENDED: 9,
            TOUCH_UP: 10,
            AUTOSCROLL_ENDED_WITH_THRESHOLD: 11
        });
        var eventMap = {
            "scroll-to-top": EventType.SCROLL_TO_TOP,
            "scroll-to-bottom": EventType.SCROLL_TO_BOTTOM,
            "scroll-to-left": EventType.SCROLL_TO_LEFT,
            "scroll-to-right": EventType.SCROLL_TO_RIGHT,
            scrolling: EventType.SCROLLING,
            "bounce-bottom": EventType.BOUNCE_BOTTOM,
            "bounce-left": EventType.BOUNCE_LEFT,
            "bounce-right": EventType.BOUNCE_RIGHT,
            "bounce-top": EventType.BOUNCE_TOP,
            "scroll-ended": EventType.AUTOSCROLL_ENDED,
            "touch-up": EventType.TOUCH_UP,
            "scroll-ended-with-threshold": EventType.AUTOSCROLL_ENDED_WITH_THRESHOLD
        };
        var ScrollView = cc.Class({
            name: "cc.ScrollView",
            extends: require("./CCViewGroup"),
            editor: false,
            ctor: function() {
                this._topBoundary = 0;
                this._bottomBoundary = 0;
                this._leftBoundary = 0;
                this._rightBoundary = 0;
                this._touchMoveDisplacements = [];
                this._touchMoveTimeDeltas = [];
                this._touchMovePreviousTimestamp = 0;
                this._touchMoved = false;
                this._autoScrolling = false;
                this._autoScrollAttenuate = false;
                this._autoScrollStartPosition = cc.p(0, 0);
                this._autoScrollTargetDelta = cc.p(0, 0);
                this._autoScrollTotalTime = 0;
                this._autoScrollAccumulatedTime = 0;
                this._autoScrollCurrentlyOutOfBoundary = false;
                this._autoScrollBraking = false;
                this._autoScrollBrakingStartPosition = cc.p(0, 0);
                this._outOfBoundaryAmount = cc.p(0, 0);
                this._outOfBoundaryAmountDirty = true;
                this._stopMouseWheel = false;
                this._mouseWheelEventElapsedTime = 0;
                this._isScrollEndedWithThresholdEventFired = false;
                this._scrollEventEmitMask = 0;
                this._isBouncing = false;
            },
            properties: {
                content: {
                    default: void 0,
                    type: cc.Node,
                    tooltip: "i18n:COMPONENT.scrollview.content"
                },
                horizontal: {
                    default: true,
                    animatable: false,
                    tooltip: "i18n:COMPONENT.scrollview.horizontal"
                },
                vertical: {
                    default: true,
                    animatable: false,
                    tooltip: "i18n:COMPONENT.scrollview.vertical"
                },
                inertia: {
                    default: true,
                    tooltip: "i18n:COMPONENT.scrollview.inertia"
                },
                brake: {
                    default: .5,
                    type: "Float",
                    range: [ 0, 1, .1 ],
                    tooltip: "i18n:COMPONENT.scrollview.brake"
                },
                elastic: {
                    default: true,
                    animatable: false,
                    tooltip: "i18n:COMPONENT.scrollview.elastic"
                },
                bounceDuration: {
                    default: 1,
                    range: [ 0, 10 ],
                    tooltip: "i18n:COMPONENT.scrollview.bounceDuration"
                },
                horizontalScrollBar: {
                    default: void 0,
                    type: cc.Scrollbar,
                    tooltip: "i18n:COMPONENT.scrollview.horizontal_bar",
                    notify: function() {
                        if (this.horizontalScrollBar) {
                            this.horizontalScrollBar.setTargetScrollView(this);
                            this._updateScrollBar(0);
                        }
                    },
                    animatable: false
                },
                verticalScrollBar: {
                    default: void 0,
                    type: cc.Scrollbar,
                    tooltip: "i18n:COMPONENT.scrollview.vertical_bar",
                    notify: function() {
                        if (this.verticalScrollBar) {
                            this.verticalScrollBar.setTargetScrollView(this);
                            this._updateScrollBar(0);
                        }
                    },
                    animatable: false
                },
                scrollEvents: {
                    default: [],
                    type: cc.Component.EventHandler,
                    tooltip: "i18n:COMPONENT.scrollview.scrollEvents"
                },
                cancelInnerEvents: {
                    default: true,
                    animatable: false,
                    tooltip: "i18n:COMPONENT.scrollview.cancelInnerEvents"
                }
            },
            statics: {
                EventType: EventType
            },
            scrollToBottom: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(0, 0),
                    applyToHorizontal: false,
                    applyToVertical: true
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta, true);
            },
            scrollToTop: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(0, 1),
                    applyToHorizontal: false,
                    applyToVertical: true
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
            },
            scrollToLeft: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(0, 0),
                    applyToHorizontal: true,
                    applyToVertical: false
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
            },
            scrollToRight: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(1, 0),
                    applyToHorizontal: true,
                    applyToVertical: false
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
            },
            scrollToTopLeft: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(0, 1),
                    applyToHorizontal: true,
                    applyToVertical: true
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
            },
            scrollToTopRight: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(1, 1),
                    applyToHorizontal: true,
                    applyToVertical: true
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
            },
            scrollToBottomLeft: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(0, 0),
                    applyToHorizontal: true,
                    applyToVertical: true
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
            },
            scrollToBottomRight: function(timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(1, 0),
                    applyToHorizontal: true,
                    applyToVertical: true
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
            },
            scrollToOffset: function(offset, timeInSecond, attenuated) {
                var maxScrollOffset = this.getMaxScrollOffset();
                var anchor = cc.p(0, 0);
                0 === maxScrollOffset.x ? anchor.x = 0 : anchor.x = offset.x / maxScrollOffset.x;
                0 === maxScrollOffset.y ? anchor.y = 1 : anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y;
                this.scrollTo(anchor, timeInSecond, attenuated);
            },
            getScrollOffset: function() {
                var topDelta = this._getContentTopBoundary() - this._topBoundary;
                var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
                return cc.p(leftDeta, topDelta);
            },
            getMaxScrollOffset: function() {
                var scrollSize = this.node.getContentSize();
                var contentSize = this.content.getContentSize();
                var horizontalMaximizeOffset = contentSize.width - scrollSize.width;
                var verticalMaximizeOffset = contentSize.height - scrollSize.height;
                horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0;
                verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0;
                return cc.p(horizontalMaximizeOffset, verticalMaximizeOffset);
            },
            scrollToPercentHorizontal: function(percent, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(percent, 0),
                    applyToHorizontal: true,
                    applyToVertical: false
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
            },
            scrollTo: function(anchor, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: anchor,
                    applyToHorizontal: true,
                    applyToVertical: true
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
            },
            scrollToPercentVertical: function(percent, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                    anchor: cc.p(0, percent),
                    applyToHorizontal: false,
                    applyToVertical: true
                });
                timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
            },
            stopAutoScroll: function() {
                this._autoScrolling = false;
                this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
            },
            setContentPosition: function(position) {
                if (cc.pFuzzyEqual(position, this.getContentPosition(), EPSILON)) {
                    return;
                }
                this.content.setPosition(position);
                this._outOfBoundaryAmountDirty = true;
            },
            getContentPosition: function() {
                return this.content.getPosition();
            },
            _registerEvent: function() {
                this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this, true);
                this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this, true);
                this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this, true);
                this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
                this.node.on(cc.Node.EventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
            },
            _unregisterEvent: function() {
                this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this, true);
                this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this, true);
                this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this, true);
                this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
                this.node.off(cc.Node.EventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
            },
            _onMouseWheel: function(event, captureListeners) {
                if (!this.enabledInHierarchy) {
                    return;
                }
                if (this._hasNestedViewGroup(event, captureListeners)) {
                    return;
                }
                var deltaMove = cc.p(0, 0);
                var wheelPrecision = -.1;
                this.vertical ? deltaMove = cc.p(0, event.getScrollY() * wheelPrecision) : this.horizontal && (deltaMove = cc.p(event.getScrollY() * wheelPrecision, 0));
                this._mouseWheelEventElapsedTime = 0;
                this._processDeltaMove(deltaMove);
                if (!this._stopMouseWheel) {
                    this._handlePressLogic();
                    this.schedule(this._checkMouseWheel, 1 / 60);
                    this._stopMouseWheel = true;
                }
                this._stopPropagationIfTargetIsMe(event);
            },
            _checkMouseWheel: function(dt) {
                var currentOutOfBoundary = this._getHowMuchOutOfBoundary();
                var maxElapsedTime = .1;
                if (!cc.pFuzzyEqual(currentOutOfBoundary, cc.p(0, 0), EPSILON)) {
                    this._processInertiaScroll();
                    this.unschedule(this._checkMouseWheel);
                    this._stopMouseWheel = false;
                    return;
                }
                this._mouseWheelEventElapsedTime += dt;
                if (this._mouseWheelEventElapsedTime > maxElapsedTime) {
                    this._onScrollBarTouchEnded();
                    this.unschedule(this._checkMouseWheel);
                    this._stopMouseWheel = false;
                }
            },
            _calculateMovePercentDelta: function(options) {
                var anchor = options.anchor;
                var applyToHorizontal = options.applyToHorizontal;
                var applyToVertical = options.applyToVertical;
                this._calculateBoundary();
                anchor = cc.pClamp(anchor, cc.p(0, 0), cc.p(1, 1));
                var scrollSize = this.node.getContentSize();
                var contentSize = this.content.getContentSize();
                var bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
                bottomDeta = -bottomDeta;
                var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
                leftDeta = -leftDeta;
                var moveDelta = cc.p(0, 0);
                var totalScrollDelta = 0;
                if (applyToHorizontal) {
                    totalScrollDelta = contentSize.width - scrollSize.width;
                    moveDelta.x = leftDeta - totalScrollDelta * anchor.x;
                }
                if (applyToVertical) {
                    totalScrollDelta = contentSize.height - scrollSize.height;
                    moveDelta.y = bottomDeta - totalScrollDelta * anchor.y;
                }
                return moveDelta;
            },
            _moveContentToTopLeft: function(scrollViewSize) {
                var contentSize = this.content.getContentSize();
                var bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
                bottomDeta = -bottomDeta;
                var moveDelta = cc.p(0, 0);
                var totalScrollDelta = 0;
                var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
                leftDeta = -leftDeta;
                if (contentSize.height < scrollViewSize.height) {
                    totalScrollDelta = contentSize.height - scrollViewSize.height;
                    moveDelta.y = bottomDeta - totalScrollDelta;
                    this.verticalScrollBar && this.verticalScrollBar.hide();
                } else {
                    this.verticalScrollBar && this.verticalScrollBar.show();
                }
                if (contentSize.width < scrollViewSize.width) {
                    totalScrollDelta = contentSize.width - scrollViewSize.width;
                    moveDelta.x = leftDeta;
                    this.horizontalScrollBar && this.horizontalScrollBar.hide();
                } else {
                    this.horizontalScrollBar && this.horizontalScrollBar.show();
                }
                this._moveContent(moveDelta);
                this._adjustContentOutOfBoundary();
            },
            _calculateBoundary: function() {
                if (this.content) {
                    var layout = this.content.getComponent(cc.Layout);
                    layout && layout.enabledInHierarchy && layout._updateLayout();
                    var scrollViewSize = this.node.getContentSize();
                    var leftBottomPosition = this._convertToContentParentSpace(cc.p(0, 0));
                    this._leftBoundary = leftBottomPosition.x;
                    this._bottomBoundary = leftBottomPosition.y;
                    var topRightPosition = this._convertToContentParentSpace(cc.p(scrollViewSize.width, scrollViewSize.height));
                    this._rightBoundary = topRightPosition.x;
                    this._topBoundary = topRightPosition.y;
                    this._moveContentToTopLeft(scrollViewSize);
                }
            },
            _convertToContentParentSpace: function(position) {
                var scrollViewPositionInWorldSpace = this.node.convertToWorldSpace(position);
                var contentParent = this.content.parent;
                return contentParent.convertToNodeSpaceAR(scrollViewPositionInWorldSpace);
            },
            _hasNestedViewGroup: function(event, captureListeners) {
                if (event.eventPhase !== cc.Event.CAPTURING_PHASE) {
                    return;
                }
                if (captureListeners) {
                    for (var i = 0; i < captureListeners.length; ++i) {
                        var item = captureListeners[i];
                        if (this.node === item) {
                            if (event.target.getComponent(cc.ViewGroup)) {
                                return true;
                            }
                            return false;
                        }
                        if (item.getComponent(cc.ViewGroup)) {
                            return true;
                        }
                    }
                }
                return false;
            },
            _stopPropagationIfTargetIsMe: function(event) {
                event.eventPhase === cc.Event.AT_TARGET && event.target === this.node && event.stopPropagation();
            },
            _onTouchBegan: function(event, captureListeners) {
                if (!this.enabledInHierarchy) {
                    return;
                }
                if (this._hasNestedViewGroup(event, captureListeners)) {
                    return;
                }
                var touch = event.touch;
                this.content && this._handlePressLogic(touch);
                this._touchMoved = false;
                this._stopPropagationIfTargetIsMe(event);
            },
            _onTouchMoved: function(event, captureListeners) {
                if (!this.enabledInHierarchy) {
                    return;
                }
                if (this._hasNestedViewGroup(event, captureListeners)) {
                    return;
                }
                var touch = event.touch;
                this.content && this._handleMoveLogic(touch);
                if (!this.cancelInnerEvents) {
                    return;
                }
                var deltaMove = cc.pSub(touch.getLocation(), touch.getStartLocation());
                if (cc.pLength(deltaMove) > 7 && !this._touchMoved && event.target !== this.node) {
                    var cancelEvent = new cc.Event.EventTouch(event.getTouches(), event.bubbles);
                    cancelEvent.type = cc.Node.EventType.TOUCH_CANCEL;
                    cancelEvent.touch = event.touch;
                    cancelEvent.simulate = true;
                    event.target.dispatchEvent(cancelEvent);
                    this._touchMoved = true;
                }
                this._stopPropagationIfTargetIsMe(event);
            },
            _onTouchEnded: function(event, captureListeners) {
                if (!this.enabledInHierarchy) {
                    return;
                }
                if (this._hasNestedViewGroup(event, captureListeners)) {
                    return;
                }
                this._dispatchEvent("touch-up");
                var touch = event.touch;
                this.content && this._handleReleaseLogic(touch);
                this._touchMoved ? event.stopPropagation() : this._stopPropagationIfTargetIsMe(event);
            },
            _onTouchCancelled: function(event, captureListeners) {
                if (!this.enabledInHierarchy) {
                    return;
                }
                if (this._hasNestedViewGroup(event, captureListeners)) {
                    return;
                }
                if (!event.simulate) {
                    var touch = event.touch;
                    this.content && this._handleReleaseLogic(touch);
                }
                this._stopPropagationIfTargetIsMe(event);
            },
            _processDeltaMove: function(deltaMove) {
                this._scrollChildren(deltaMove);
                this._gatherTouchMove(deltaMove);
            },
            _handleMoveLogic: function(touch) {
                var deltaMove = touch.getDelta();
                this._processDeltaMove(deltaMove);
            },
            _scrollChildren: function(deltaMove) {
                deltaMove = this._clampDelta(deltaMove);
                var realMove = deltaMove;
                var outOfBoundary;
                if (this.elastic) {
                    outOfBoundary = this._getHowMuchOutOfBoundary();
                    realMove.x *= 0 === outOfBoundary.x ? 1 : .5;
                    realMove.y *= 0 === outOfBoundary.y ? 1 : .5;
                }
                if (!this.elastic) {
                    outOfBoundary = this._getHowMuchOutOfBoundary(realMove);
                    realMove = cc.pAdd(realMove, outOfBoundary);
                }
                var scrollEventType = -1;
                if (realMove.y > 0) {
                    var icBottomPos = this.content.y - this.content.anchorY * this.content.height;
                    icBottomPos + realMove.y > this._bottomBoundary && (scrollEventType = "scroll-to-bottom");
                } else {
                    if (realMove.y < 0) {
                        var icTopPos = this.content.y - this.content.anchorY * this.content.height + this.content.height;
                        icTopPos + realMove.y <= this._topBoundary && (scrollEventType = "scroll-to-top");
                    } else {
                        if (realMove.x < 0) {
                            var icRightPos = this.content.x - this.content.anchorX * this.content.width + this.content.width;
                            icRightPos + realMove.x <= this._rightBoundary && (scrollEventType = "scroll-to-right");
                        } else {
                            if (realMove.x > 0) {
                                var icLeftPos = this.content.x - this.content.anchorX * this.content.width;
                                icLeftPos + realMove.x >= this._leftBoundary && (scrollEventType = "scroll-to-left");
                            }
                        }
                    }
                }
                this._moveContent(realMove, false);
                0 === realMove.x && 0 === realMove.y || this._dispatchEvent("scrolling");
                scrollEventType !== -1 && this._dispatchEvent(scrollEventType);
            },
            _handlePressLogic: function() {
                this._autoScrolling && this._dispatchEvent("scroll-ended");
                this._autoScrolling = false;
                this._isBouncing = false;
                this._touchMovePreviousTimestamp = getTimeInMilliseconds();
                this._touchMoveDisplacements.length = 0;
                this._touchMoveTimeDeltas.length = 0;
                this._onScrollBarTouchBegan();
            },
            _clampDelta: function(delta) {
                var contentSize = this.content.getContentSize();
                var scrollViewSize = this.node.getContentSize();
                contentSize.width < scrollViewSize.width && (delta.x = 0);
                contentSize.height < scrollViewSize.height && (delta.y = 0);
                return delta;
            },
            _gatherTouchMove: function(delta) {
                delta = this._clampDelta(delta);
                while (this._touchMoveDisplacements.length >= NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED) {
                    this._touchMoveDisplacements.shift();
                    this._touchMoveTimeDeltas.shift();
                }
                this._touchMoveDisplacements.push(delta);
                var timeStamp = getTimeInMilliseconds();
                this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1e3);
                this._touchMovePreviousTimestamp = timeStamp;
            },
            _startBounceBackIfNeeded: function() {
                if (!this.elastic) {
                    return false;
                }
                var bounceBackAmount = this._getHowMuchOutOfBoundary();
                bounceBackAmount = this._clampDelta(bounceBackAmount);
                if (cc.pFuzzyEqual(bounceBackAmount, cc.p(0, 0), EPSILON)) {
                    return false;
                }
                var bounceBackTime = Math.max(this.bounceDuration, 0);
                this._startAutoScroll(bounceBackAmount, bounceBackTime, true);
                if (!this._isBouncing) {
                    bounceBackAmount.y > 0 && this._dispatchEvent("bounce-top");
                    bounceBackAmount.y < 0 && this._dispatchEvent("bounce-bottom");
                    bounceBackAmount.x > 0 && this._dispatchEvent("bounce-right");
                    bounceBackAmount.x < 0 && this._dispatchEvent("bounce-left");
                    this._isBouncing = true;
                }
                return true;
            },
            _processInertiaScroll: function() {
                var bounceBackStarted = this._startBounceBackIfNeeded();
                if (!bounceBackStarted && this.inertia) {
                    var touchMoveVelocity = this._calculateTouchMoveVelocity();
                    !cc.pFuzzyEqual(touchMoveVelocity, cc.p(0, 0), EPSILON) && this.brake < 1 && this._startInertiaScroll(touchMoveVelocity);
                }
                this._onScrollBarTouchEnded();
            },
            _handleReleaseLogic: function(touch) {
                var delta = touch.getDelta();
                this._gatherTouchMove(delta);
                this._processInertiaScroll();
            },
            _isOutOfBoundary: function() {
                var outOfBoundary = this._getHowMuchOutOfBoundary();
                return !cc.pFuzzyEqual(outOfBoundary, cc.p(0, 0), EPSILON);
            },
            _isNecessaryAutoScrollBrake: function() {
                if (this._autoScrollBraking) {
                    return true;
                }
                if (this._isOutOfBoundary()) {
                    if (!this._autoScrollCurrentlyOutOfBoundary) {
                        this._autoScrollCurrentlyOutOfBoundary = true;
                        this._autoScrollBraking = true;
                        this._autoScrollBrakingStartPosition = this.getContentPosition();
                        return true;
                    }
                } else {
                    this._autoScrollCurrentlyOutOfBoundary = false;
                }
                return false;
            },
            getScrollEndedEventTiming: function() {
                return EPSILON;
            },
            _processAutoScrolling: function(dt) {
                var isAutoScrollBrake = this._isNecessaryAutoScrollBrake();
                var brakingFactor = isAutoScrollBrake ? OUT_OF_BOUNDARY_BREAKING_FACTOR : 1;
                this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
                var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
                this._autoScrollAttenuate && (percentage = quintEaseOut(percentage));
                var newPosition = cc.pAdd(this._autoScrollStartPosition, cc.pMult(this._autoScrollTargetDelta, percentage));
                var reachedEnd = Math.abs(percentage - 1) <= EPSILON;
                var fireEvent = Math.abs(percentage - 1) <= this.getScrollEndedEventTiming();
                if (fireEvent && !this._isScrollEndedWithThresholdEventFired) {
                    this._dispatchEvent("scroll-ended-with-threshold");
                    this._isScrollEndedWithThresholdEventFired = true;
                }
                if (this.elastic) {
                    var brakeOffsetPosition = cc.pSub(newPosition, this._autoScrollBrakingStartPosition);
                    isAutoScrollBrake && (brakeOffsetPosition = cc.pMult(brakeOffsetPosition, brakingFactor));
                    newPosition = cc.pAdd(this._autoScrollBrakingStartPosition, brakeOffsetPosition);
                } else {
                    var moveDelta = cc.pSub(newPosition, this.getContentPosition());
                    var outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);
                    if (!cc.pFuzzyEqual(outOfBoundary, cc.p(0, 0), EPSILON)) {
                        newPosition = cc.pAdd(newPosition, outOfBoundary);
                        reachedEnd = true;
                    }
                }
                reachedEnd && (this._autoScrolling = false);
                var contentPos = cc.pSub(newPosition, this.getContentPosition());
                this._moveContent(contentPos, reachedEnd);
                this._dispatchEvent("scrolling");
                if (!this._autoScrolling) {
                    this._isBouncing = false;
                    this._dispatchEvent("scroll-ended");
                }
            },
            _startInertiaScroll: function(touchMoveVelocity) {
                var inertiaTotalMovement = cc.pMult(touchMoveVelocity, MOVEMENT_FACTOR);
                this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
            },
            _calculateAttenuatedFactor: function(distance) {
                if (this.brake <= 0) {
                    return 1 - this.brake;
                }
                var attenuatedFactor = (1 - this.brake) * (1 / (1 + 14e-6 * distance + distance * distance * 8e-9));
                return attenuatedFactor;
            },
            _startAttenuatingAutoScroll: function(deltaMove, initialVelocity) {
                var time = this._calculateAutoScrollTimeByInitalSpeed(cc.pLength(initialVelocity));
                var targetDelta = cc.pNormalize(deltaMove);
                var contentSize = this.content.getContentSize();
                var scrollviewSize = this.node.getContentSize();
                var totalMoveWidth = contentSize.width - scrollviewSize.width;
                var totalMoveHeight = contentSize.height - scrollviewSize.height;
                var attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth);
                var attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);
                targetDelta = cc.p(targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX, targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake));
                var originalMoveLength = cc.pLength(deltaMove);
                var factor = cc.pLength(targetDelta) / originalMoveLength;
                targetDelta = cc.pAdd(targetDelta, deltaMove);
                if (this.brake > 0 && factor > 7) {
                    factor = Math.sqrt(factor);
                    targetDelta = cc.pAdd(cc.pMult(deltaMove, factor), deltaMove);
                }
                if (this.brake > 0 && factor > 3) {
                    factor = 3;
                    time *= factor;
                }
                0 === this.brake && factor > 1 && (time *= factor);
                this._startAutoScroll(targetDelta, time, true);
            },
            _calculateAutoScrollTimeByInitalSpeed: function(initalSpeed) {
                var time = Math.sqrt(Math.sqrt(initalSpeed / 5));
                return time;
            },
            _startAutoScroll: function(deltaMove, timeInSecond, attenuated) {
                var adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);
                this._autoScrolling = true;
                this._autoScrollTargetDelta = adjustedDeltaMove;
                this._autoScrollAttenuate = attenuated;
                this._autoScrollStartPosition = this.getContentPosition();
                this._autoScrollTotalTime = timeInSecond;
                this._autoScrollAccumulatedTime = 0;
                this._autoScrollBraking = false;
                this._isScrollEndedWithThresholdEventFired = false;
                this._autoScrollBrakingStartPosition = cc.p(0, 0);
                var currentOutOfBoundary = this._getHowMuchOutOfBoundary();
                if (!cc.pFuzzyEqual(currentOutOfBoundary, cc.p(0, 0), EPSILON)) {
                    this._autoScrollCurrentlyOutOfBoundary = true;
                    var afterOutOfBoundary = this._getHowMuchOutOfBoundary(adjustedDeltaMove);
                    (currentOutOfBoundary.x * afterOutOfBoundary.x > 0 || currentOutOfBoundary.y * afterOutOfBoundary.y > 0) && (this._autoScrollBraking = true);
                }
            },
            _calculateTouchMoveVelocity: function() {
                var totalTime = 0;
                totalTime = this._touchMoveTimeDeltas.reduce((function(a, b) {
                    return a + b;
                }), totalTime);
                if (totalTime <= 0 || totalTime >= .5) {
                    return cc.p(0, 0);
                }
                var totalMovement = cc.p(0, 0);
                totalMovement = this._touchMoveDisplacements.reduce((function(a, b) {
                    return cc.pAdd(a, b);
                }), totalMovement);
                return cc.p(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime);
            },
            _flattenVectorByDirection: function(vector) {
                var result = vector;
                result.x = this.horizontal ? result.x : 0;
                result.y = this.vertical ? result.y : 0;
                return result;
            },
            _moveContent: function(deltaMove, canStartBounceBack) {
                var adjustedMove = this._flattenVectorByDirection(deltaMove);
                var newPosition = cc.pAdd(this.getContentPosition(), adjustedMove);
                this.setContentPosition(newPosition);
                var outOfBoundary = this._getHowMuchOutOfBoundary();
                this._updateScrollBar(outOfBoundary);
                this.elastic && canStartBounceBack && this._startBounceBackIfNeeded();
            },
            _getContentLeftBoundary: function() {
                var contentPos = this.getContentPosition();
                var leftBoundary = contentPos.x - this.content.getAnchorPoint().x * this.content.getContentSize().width;
                return leftBoundary;
            },
            _getContentRightBoundary: function() {
                var contentSize = this.content.getContentSize();
                return this._getContentLeftBoundary() + contentSize.width;
            },
            _getContentTopBoundary: function() {
                var contentSize = this.content.getContentSize();
                return this._getContentBottomBoundary() + contentSize.height;
            },
            _getContentBottomBoundary: function() {
                var contentPos = this.getContentPosition();
                var bottomBoundary = contentPos.y - this.content.getAnchorPoint().y * this.content.getContentSize().height;
                return bottomBoundary;
            },
            _getHowMuchOutOfBoundary: function(addition) {
                addition = addition || cc.p(0, 0);
                if (cc.pFuzzyEqual(addition, cc.p(0, 0), EPSILON) && !this._outOfBoundaryAmountDirty) {
                    return this._outOfBoundaryAmount;
                }
                var outOfBoundaryAmount = cc.p(0, 0);
                this._getContentLeftBoundary() + addition.x > this._leftBoundary ? outOfBoundaryAmount.x = this._leftBoundary - (this._getContentLeftBoundary() + addition.x) : this._getContentRightBoundary() + addition.x < this._rightBoundary && (outOfBoundaryAmount.x = this._rightBoundary - (this._getContentRightBoundary() + addition.x));
                this._getContentTopBoundary() + addition.y < this._topBoundary ? outOfBoundaryAmount.y = this._topBoundary - (this._getContentTopBoundary() + addition.y) : this._getContentBottomBoundary() + addition.y > this._bottomBoundary && (outOfBoundaryAmount.y = this._bottomBoundary - (this._getContentBottomBoundary() + addition.y));
                if (cc.pFuzzyEqual(addition, cc.p(0, 0), EPSILON)) {
                    this._outOfBoundaryAmount = outOfBoundaryAmount;
                    this._outOfBoundaryAmountDirty = false;
                }
                outOfBoundaryAmount = this._clampDelta(outOfBoundaryAmount);
                return outOfBoundaryAmount;
            },
            _updateScrollBar: function(outOfBoundary) {
                this.horizontalScrollBar && this.horizontalScrollBar._onScroll(outOfBoundary);
                this.verticalScrollBar && this.verticalScrollBar._onScroll(outOfBoundary);
            },
            _onScrollBarTouchBegan: function() {
                this.horizontalScrollBar && this.horizontalScrollBar._onTouchBegan();
                this.verticalScrollBar && this.verticalScrollBar._onTouchBegan();
            },
            _onScrollBarTouchEnded: function() {
                this.horizontalScrollBar && this.horizontalScrollBar._onTouchEnded();
                this.verticalScrollBar && this.verticalScrollBar._onTouchEnded();
            },
            _dispatchEvent: function(event) {
                if ("scroll-ended" === event) {
                    this._scrollEventEmitMask = 0;
                } else {
                    if ("scroll-to-top" === event || "scroll-to-bottom" === event || "scroll-to-left" === event || "scroll-to-right" === event) {
                        var flag = 1 << eventMap[event];
                        if (this._scrollEventEmitMask & flag) {
                            return;
                        }
                        this._scrollEventEmitMask |= flag;
                    }
                }
                cc.Component.EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]);
                this.node.emit(event, this);
            },
            _adjustContentOutOfBoundary: function() {
                this._outOfBoundaryAmountDirty = true;
                if (this._isOutOfBoundary()) {
                    var outOfBoundary = this._getHowMuchOutOfBoundary(cc.p(0, 0));
                    var newPosition = cc.pAdd(this.getContentPosition(), outOfBoundary);
                    if (this.content) {
                        this.content.setPosition(newPosition);
                        this._updateScrollBar(0);
                    }
                }
            },
            start: function() {
                this._calculateBoundary();
                this.content && cc.director.once(cc.Director.EVENT_AFTER_VISIT, this._adjustContentOutOfBoundary, this);
            },
            _hideScrollbar: function() {
                this.horizontalScrollBar && this.horizontalScrollBar.hide();
                this.verticalScrollBar && this.verticalScrollBar.hide();
            },
            _showScrollbar: function() {
                this.horizontalScrollBar && this.horizontalScrollBar.show();
                this.verticalScrollBar && this.verticalScrollBar.show();
            },
            onDisable: function() {
                this._unregisterEvent();
                this.node.off("size-changed", this._calculateBoundary, this);
                this.content && this.content.off("size-changed", this._calculateBoundary, this);
                this._hideScrollbar();
                this.stopAutoScroll();
            },
            onEnable: function() {
                this._registerEvent();
                this.node.on("size-changed", this._calculateBoundary, this);
                this.content && this.content.on("size-changed", this._calculateBoundary, this);
                this._showScrollbar();
            },
            update: function(dt) {
                this._autoScrolling && this._processAutoScrolling(dt);
            }
        });
        cc.ScrollView = module.exports = ScrollView;
    }), {
        "./CCViewGroup": 99
    } ],
    92: [ (function(require, module, exports) {
        var Direction = cc.Enum({
            Horizontal: 0,
            Vertical: 1
        });
        var Slider = cc.Class({
            name: "cc.Slider",
            extends: require("./CCComponent"),
            editor: false,
            ctor: function() {
                this._dragging = false;
            },
            properties: {
                handle: {
                    default: null,
                    type: cc.Button,
                    tooltip: "i18n:COMPONENT.slider.handle",
                    notify: function() {}
                },
                direction: {
                    default: Direction.Horizontal,
                    type: Direction,
                    tooltip: "i18n:COMPONENT.slider.direction"
                },
                progress: {
                    default: .5,
                    type: cc.Float,
                    range: [ 0, 1, .1 ],
                    slide: true,
                    tooltip: "i18n:COMPONENT.slider.progress",
                    notify: function() {
                        this._updateHandlePosition();
                    }
                },
                slideEvents: {
                    default: [],
                    type: cc.Component.EventHandler,
                    tooltip: "i18n:COMPONENT.slider.slideEvents"
                }
            },
            statics: {
                Direction: Direction
            },
            __preload: function() {
                this._updateHandlePosition();
            },
            onEnable: function() {
                this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
                this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
                this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
                this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this);
                if (this.handle && this.handle.isValid) {
                    this.handle.node.on(cc.Node.EventType.TOUCH_START, this._onHandleDragStart, this);
                    this.handle.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
                    this.handle.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
                }
            },
            onDisable: function() {
                this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
                this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
                this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
                this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this);
                if (this.handle && this.handle.isValid) {
                    this.handle.node.off(cc.Node.EventType.TOUCH_START, this._onHandleDragStart, this);
                    this.handle.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
                    this.handle.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
                }
            },
            _onHandleDragStart: function(event) {
                this._dragging = true;
                event.stopPropagation();
            },
            _onTouchBegan: function(event) {
                if (!this.handle) {
                    return;
                }
                this._dragging = true;
                this._handleSliderLogic(event.touch);
                event.stopPropagation();
            },
            _onTouchMoved: function(event) {
                if (!this._dragging) {
                    return;
                }
                this._handleSliderLogic(event.touch);
                event.stopPropagation();
            },
            _onTouchEnded: function(event) {
                this._dragging = false;
                event.stopPropagation();
            },
            _onTouchCancelled: function(event) {
                this._dragging = false;
                event.stopPropagation();
            },
            _handleSliderLogic: function(touch) {
                this._updateProgress(touch);
                this._emitSlideEvent();
            },
            _emitSlideEvent: function() {
                cc.Component.EventHandler.emitEvents(this.slideEvents, this);
                this.node.emit("slide", this);
            },
            _updateProgress: function(touch) {
                if (!this.handle) {
                    return;
                }
                var maxRange = null, progress = 0, newPos = this.node.convertTouchToNodeSpaceAR(touch);
                if (this.direction === Direction.Horizontal) {
                    maxRange = this.node.width / 2 - this.handle.node.width * this.handle.node.anchorX;
                    progress = cc.clamp01((newPos.x + maxRange) / (2 * maxRange), 0, 1);
                } else {
                    if (this.direction === Direction.Vertical) {
                        maxRange = this.node.height / 2 - this.handle.node.height * this.handle.node.anchorY;
                        progress = cc.clamp01((newPos.y + maxRange) / (2 * maxRange), 0, 1);
                    }
                }
                this.progress = progress;
            },
            _updateHandlePosition: function() {
                if (!this.handle) {
                    return;
                }
                var handlelocalPos;
                handlelocalPos = this.direction === Direction.Horizontal ? cc.p(-this.node.width * this.node.anchorX + this.progress * this.node.width, 0) : cc.p(0, -this.node.height * this.node.anchorY + this.progress * this.node.height);
                var worldSpacePos = this.node.convertToWorldSpaceAR(handlelocalPos);
                this.handle.node.position = this.handle.node.parent.convertToNodeSpaceAR(worldSpacePos);
            }
        });
        cc.Slider = module.exports = Slider;
    }), {
        "./CCComponent": 76
    } ],
    93: [ (function(require, module, exports) {
        var Base = require("./CCRendererUnderSG");
        var SpriteType = cc.Scale9Sprite.RenderingType;
        var FillType = cc.Scale9Sprite.FillType;
        var BlendFactor = cc.BlendFunc.BlendFactor;
        var SizeMode = cc.Enum({
            CUSTOM: 0,
            TRIMMED: 1,
            RAW: 2
        });
        var Sprite = cc.Class({
            name: "cc.Sprite",
            extends: Base,
            editor: false,
            ctor: function() {
                this._blendFunc = new cc.BlendFunc(this._srcBlendFactor, this._dstBlendFactor);
            },
            properties: {
                _spriteFrame: {
                    default: null,
                    type: cc.SpriteFrame
                },
                _type: SpriteType.SIMPLE,
                _sizeMode: SizeMode.TRIMMED,
                _fillType: 0,
                _fillCenter: cc.v2(0, 0),
                _fillStart: 0,
                _fillRange: 0,
                _isTrimmedMode: true,
                _srcBlendFactor: BlendFactor.SRC_ALPHA,
                _dstBlendFactor: BlendFactor.ONE_MINUS_SRC_ALPHA,
                _atlas: {
                    default: null,
                    type: cc.SpriteAtlas,
                    tooltip: "i18n:COMPONENT.sprite.atlas",
                    editorOnly: true,
                    visible: true,
                    animatable: false
                },
                spriteFrame: {
                    get: function() {
                        return this._spriteFrame;
                    },
                    set: function(value, force) {
                        var lastSprite = this._spriteFrame;
                        if (lastSprite === value) {
                            return;
                        }
                        this._spriteFrame = value;
                        this._applySpriteFrame(lastSprite);
                    },
                    type: cc.SpriteFrame
                },
                type: {
                    get: function() {
                        return this._type;
                    },
                    set: function(value) {
                        this._type = value;
                        this._sgNode.setRenderingType(value);
                    },
                    type: SpriteType,
                    animatable: false,
                    tooltip: "i18n:COMPONENT.sprite.type"
                },
                fillType: {
                    get: function() {
                        return this._fillType;
                    },
                    set: function(value) {
                        this._fillType = value;
                        this._sgNode && this._sgNode.setFillType(value);
                    },
                    type: FillType,
                    tooltip: "i18n:COMPONENT.sprite.fill_type"
                },
                fillCenter: {
                    get: function() {
                        return this._fillCenter;
                    },
                    set: function(value) {
                        this._fillCenter = cc.v2(value);
                        this._sgNode && this._sgNode.setFillCenter(this._fillCenter);
                    },
                    tooltip: "i18n:COMPONENT.sprite.fill_center"
                },
                fillStart: {
                    get: function() {
                        return this._fillStart;
                    },
                    set: function(value) {
                        this._fillStart = cc.clampf(value, -1, 1);
                        this._sgNode && this._sgNode.setFillStart(value);
                    },
                    tooltip: "i18n:COMPONENT.sprite.fill_start"
                },
                fillRange: {
                    get: function() {
                        return this._fillRange;
                    },
                    set: function(value) {
                        this._fillRange = cc.clampf(value, -1, 1);
                        this._sgNode && this._sgNode.setFillRange(value);
                    },
                    tooltip: "i18n:COMPONENT.sprite.fill_range"
                },
                trim: {
                    get: function() {
                        return this._isTrimmedMode;
                    },
                    set: function(value) {
                        if (this._isTrimmedMode !== value) {
                            this._isTrimmedMode = value;
                            this._sgNode.enableTrimmedContentSize(value);
                        }
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.sprite.trim"
                },
                srcBlendFactor: {
                    get: function() {
                        return this._srcBlendFactor;
                    },
                    set: function(value) {
                        this._srcBlendFactor = value;
                        this._blendFunc.src = value;
                        this._sgNode.setBlendFunc(this._blendFunc);
                    },
                    animatable: false,
                    type: BlendFactor,
                    tooltip: "i18n:COMPONENT.sprite.src_blend_factor"
                },
                dstBlendFactor: {
                    get: function() {
                        return this._dstBlendFactor;
                    },
                    set: function(value) {
                        this._dstBlendFactor = value;
                        this._blendFunc.dst = value;
                        this._sgNode.setBlendFunc(this._blendFunc);
                    },
                    animatable: false,
                    type: BlendFactor,
                    tooltip: "i18n:COMPONENT.sprite.dst_blend_factor"
                },
                sizeMode: {
                    get: function() {
                        return this._sizeMode;
                    },
                    set: function(value) {
                        this._sizeMode = value;
                        value !== SizeMode.CUSTOM && this._applySpriteSize();
                    },
                    animatable: false,
                    type: SizeMode,
                    tooltip: "i18n:COMPONENT.sprite.size_mode"
                }
            },
            statics: {
                FillType: FillType,
                Type: SpriteType,
                SizeMode: SizeMode
            },
            setVisible: function(visible) {
                this.enabled = visible;
            },
            setInsetLeft: function(insetLeft) {
                this._sgNode.setInsetLeft(insetLeft);
            },
            getInsetLeft: function() {
                return this._sgNode.getInsetLeft();
            },
            setInsetTop: function(insetTop) {
                this._sgNode.setInsetTop(insetTop);
            },
            getInsetTop: function() {
                return this._sgNode.getInsetTop();
            },
            setInsetRight: function(insetRight) {
                this._sgNode.setInsetRight(insetRight);
            },
            getInsetRight: function() {
                return this._sgNode.getInsetRight();
            },
            setInsetBottom: function(insetBottom) {
                this._sgNode.setInsetBottom(insetBottom);
            },
            getInsetBottom: function() {
                return this._sgNode.getInsetBottom();
            },
            onEnable: function() {
                this._sgNode && this._spriteFrame && this._spriteFrame.textureLoaded() && this._sgNode.setVisible(true);
            },
            _applyAtlas: false,
            _applySpriteFrameInsets: function() {
                var spriteFrame = this._spriteFrame;
                var sgNode = this._sgNode;
                sgNode.setInsetTop(spriteFrame.insetTop);
                sgNode.setInsetBottom(spriteFrame.insetBottom);
                sgNode.setInsetRight(spriteFrame.insetRight);
                sgNode.setInsetLeft(spriteFrame.insetLeft);
            },
            _applySpriteSize: function() {
                if (SizeMode.CUSTOM !== this._sizeMode && this._spriteFrame) {
                    if (SizeMode.RAW === this._sizeMode) {
                        var size = this._spriteFrame.getOriginalSize();
                        this.node.setContentSize(size);
                    } else {
                        if (SizeMode.TRIMMED === this._sizeMode) {
                            var rect = this._spriteFrame.getRect();
                            this.node.setContentSize(cc.size(rect.width, rect.height));
                        } else {
                            this.node.setContentSize(this.node.getContentSize(true));
                        }
                    }
                } else {
                    this.node.setContentSize(this.node.getContentSize(true));
                }
            },
            _onTextureLoaded: function(event) {
                var self = this;
                if (!self.isValid) {
                    return;
                }
                var sgNode = self._sgNode;
                sgNode.setSpriteFrame(self._spriteFrame);
                self._applySpriteSize();
                self.enabledInHierarchy && !sgNode.isVisible() && sgNode.setVisible(true);
            },
            _applySpriteFrame: function(oldFrame, keepInsets) {
                var sgNode = this._sgNode;
                oldFrame && oldFrame.off && oldFrame.off("load", this._onTextureLoaded, this);
                var spriteFrame = this._spriteFrame;
                if (spriteFrame) {
                    keepInsets || this._applySpriteFrameInsets();
                    if (spriteFrame.textureLoaded()) {
                        this._onTextureLoaded(null);
                    } else {
                        spriteFrame.once("load", this._onTextureLoaded, this);
                        spriteFrame.ensureLoadTexture();
                    }
                } else {
                    sgNode.setVisible(false);
                }
            },
            _createSgNode: function() {
                return new cc.Scale9Sprite();
            },
            _initSgNode: function() {
                var sgNode = this._sgNode;
                var insetsChangedViaAPI = 0 !== sgNode.getInsetLeft() || 0 !== sgNode.getInsetRight() || 0 !== sgNode.getInsetTop() || 0 !== sgNode.getInsetBottom();
                this._applySpriteFrame(null, insetsChangedViaAPI);
                sgNode.setContentSize(this.node.getContentSize(true));
                this._applySpriteSize();
                sgNode.setRenderingType(this._type);
                sgNode.setFillType(this._fillType);
                sgNode.setFillCenter(this._fillCenter);
                sgNode.setFillStart(this._fillStart);
                sgNode.setFillRange(this._fillRange);
                sgNode.enableTrimmedContentSize(this._isTrimmedMode);
                this._blendFunc.src = this._srcBlendFactor;
                this._blendFunc.dst = this._dstBlendFactor;
                sgNode.setBlendFunc(this._blendFunc);
            },
            _resized: false
        });
        var misc = require("../utils/misc");
        var SameNameGetSets = [ "insetLeft", "insetTop", "insetRight", "insetBottom" ];
        var DiffNameGetSets = {
            type: [ null, "setRenderingType" ]
        };
        misc.propertyDefine(Sprite, SameNameGetSets, DiffNameGetSets);
        cc.Sprite = module.exports = Sprite;
    }), {
        "../utils/misc": 223,
        "./CCRendererUnderSG": 87
    } ],
    94: [ (function(require, module, exports) {
        var SpriteDistortion = cc.Class({
            name: "cc.SpriteDistortion",
            extends: require("./CCComponent"),
            editor: false,
            ctor: function() {
                this._spriteSGNode = null;
            },
            properties: {
                _distortionOffset: cc.v2(0, 0),
                offset: {
                    get: function() {
                        return this._distortionOffset;
                    },
                    set: function(value) {
                        this._distortionOffset.x = value.x;
                        this._distortionOffset.y = value.y;
                        this._spriteSGNode && this._spriteSGNode.setDistortionOffset(this._distortionOffset);
                    }
                },
                _distortionTiling: cc.v2(1, 1),
                tiling: {
                    get: function() {
                        return this._distortionTiling;
                    },
                    set: function(value) {
                        this._distortionTiling.x = value.x;
                        this._distortionTiling.y = value.y;
                        this._spriteSGNode && this._spriteSGNode.setDistortionTiling(this._distortionTiling);
                    }
                }
            },
            onEnable: function() {
                var sprite = this.node.getComponent("cc.Sprite");
                var sgNode = this._spriteSGNode = sprite && sprite._sgNode;
                if (this._spriteSGNode) {
                    sgNode.setState(cc.Scale9Sprite.state.DISTORTION);
                    sgNode.setDistortionOffset(this._distortionOffset);
                    sgNode.setDistortionTiling(this._distortionTiling);
                }
            },
            onDisable: function() {
                this._spriteSGNode && this._spriteSGNode.setState(cc.Scale9Sprite.state.NORMAL);
                this._spriteSGNode = null;
            }
        });
        cc.SpriteDistortion = module.exports = SpriteDistortion;
    }), {
        "./CCComponent": 76
    } ],
    95: [ (function(require, module, exports) {
        var ComponentType = cc.Enum({
            NONE: 0,
            CHECKBOX: 1,
            TEXT_ATLAS: 2,
            SLIDER_BAR: 3,
            LIST_VIEW: 4,
            PAGE_VIEW: 5
        });
        var ListDirection = cc.Enum({
            VERTICAL: 0,
            HORIZONTAL: 1
        });
        var VerticalAlign = cc.Enum({
            TOP: 0,
            CENTER: 1,
            BOTTOM: 2
        });
        var HorizontalAlign = cc.Enum({
            LEFT: 0,
            CENTER: 1,
            RIGHT: 2
        });
        var StudioComponent = cc.Class({
            name: "cc.StudioComponent",
            extends: cc.Component,
            editor: false,
            properties: false,
            statics: {
                ComponentType: ComponentType,
                ListDirection: ListDirection,
                VerticalAlign: VerticalAlign,
                HorizontalAlign: HorizontalAlign
            }
        });
        cc.StudioComponent = module.exports = StudioComponent;
    }), {} ],
    96: [ (function(require, module, exports) {
        var Toggle = cc.Class({
            name: "cc.Toggle",
            extends: require("./CCButton.js"),
            editor: false,
            properties: {
                isChecked: {
                    default: true,
                    tooltip: "i18n:COMPONENT.toggle.isChecked",
                    notify: function() {
                        this._updateCheckMark();
                    }
                },
                toggleGroup: {
                    default: null,
                    tooltip: "i18n:COMPONENT.toggle.toggleGroup",
                    type: cc.ToggleGroup
                },
                checkMark: {
                    default: null,
                    type: cc.Sprite,
                    tooltip: "i18n:COMPONENT.toggle.checkMark"
                },
                checkEvents: {
                    default: [],
                    type: cc.Component.EventHandler
                },
                _resizeToTarget: {
                    animatable: false,
                    set: function(value) {
                        value && this._resizeNodeToTargetNode();
                    }
                }
            },
            __preload: function() {
                this._super();
            },
            onEnable: function() {
                this._super();
                this._registerToggleEvent();
                this.toggleGroup && this.toggleGroup.enabled && this.toggleGroup.addToggle(this);
            },
            onDisable: function() {
                this._super();
                this._unregisterToggleEvent();
                this.toggleGroup && this.toggleGroup.enabled && this.toggleGroup.removeToggle(this);
            },
            _updateCheckMark: function() {
                this.checkMark && (this.checkMark.node.active = !!this.isChecked);
            },
            _updateDisabledState: function() {
                this._super();
                this.checkMark && this.checkMark._sgNode.setState(0);
                this.enableAutoGrayEffect && this.checkMark && !this.interactable && this.checkMark._sgNode.setState(1);
            },
            _registerToggleEvent: function() {
                this.node.on("click", this.toggle, this);
            },
            _unregisterToggleEvent: function() {
                this.node.off("click", this.toggle, this);
            },
            toggle: function(event) {
                if (this.toggleGroup && this.toggleGroup.enabled && this.isChecked && !this.toggleGroup.allowSwitchOff) {
                    return;
                }
                this.isChecked = !this.isChecked;
                this._updateCheckMark();
                this.toggleGroup && this.toggleGroup.enabled && this.toggleGroup.updateToggles(this);
                this._emitToggleEvents(event);
            },
            _emitToggleEvents: function() {
                this.node.emit("toggle", this);
                this.checkEvents && cc.Component.EventHandler.emitEvents(this.checkEvents, this);
            },
            check: function() {
                if (this.toggleGroup && this.toggleGroup.enabled && this.isChecked && !this.toggleGroup.allowSwitchOff) {
                    return;
                }
                this.isChecked = true;
                this.toggleGroup && this.toggleGroup.enabled && this.toggleGroup.updateToggles(this);
                this._emitToggleEvents();
            },
            uncheck: function() {
                if (this.toggleGroup && this.toggleGroup.enabled && this.isChecked && !this.toggleGroup.allowSwitchOff) {
                    return;
                }
                this.isChecked = false;
                this._emitToggleEvents();
            }
        });
        cc.Toggle = module.exports = Toggle;
    }), {
        "./CCButton.js": 74
    } ],
    97: [ (function(require, module, exports) {
        var ToggleGroup = cc.Class({
            name: "cc.ToggleGroup",
            extends: cc.Component,
            ctor: function() {
                this._toggleItems = [];
            },
            editor: false,
            properties: {
                allowSwitchOff: {
                    tooltip: "i18n:COMPONENT.toggle_group.allowSwitchOff",
                    default: false
                },
                toggleItems: {
                    get: function() {
                        return this._toggleItems;
                    }
                }
            },
            updateToggles: function(toggle) {
                if (!this.enabledInHierarchy) {
                    return;
                }
                this._toggleItems.forEach((function(item) {
                    toggle.isChecked && item !== toggle && item.isChecked && item.enabled && (item.isChecked = false);
                }));
            },
            addToggle: function(toggle) {
                var index = this._toggleItems.indexOf(toggle);
                index === -1 && this._toggleItems.push(toggle);
                this._allowOnlyOneToggleChecked();
            },
            removeToggle: function(toggle) {
                var index = this._toggleItems.indexOf(toggle);
                index > -1 && this._toggleItems.splice(index, 1);
                this._makeAtLeastOneToggleChecked();
            },
            _allowOnlyOneToggleChecked: function() {
                var isChecked = false;
                this._toggleItems.forEach((function(item) {
                    isChecked && item.enabled && (item.isChecked = false);
                    item.isChecked && item.enabled && (isChecked = true);
                }));
                return isChecked;
            },
            _makeAtLeastOneToggleChecked: function() {
                var isChecked = this._allowOnlyOneToggleChecked();
                isChecked || this.allowSwitchOff || this._toggleItems.length > 0 && (this._toggleItems[0].isChecked = true);
            },
            start: function() {
                this._makeAtLeastOneToggleChecked();
            }
        });
        cc.ToggleGroup = module.exports = ToggleGroup;
    }), {} ],
    98: [ (function(require, module, exports) {
        require("../videoplayer/CCSGVideoPlayer.js");
        var EventType = _ccsg.VideoPlayer.EventType;
        var ResourceType = cc.Enum({
            REMOTE: 0,
            LOCAL: 1
        });
        var VideoPlayer = cc.Class({
            name: "cc.VideoPlayer",
            extends: cc._RendererUnderSG,
            editor: false,
            properties: {
                _resourceType: ResourceType.REMOTE,
                resourceType: {
                    tooltip: "i18n:COMPONENT.videoplayer.resourceType",
                    type: ResourceType,
                    set: function(value) {
                        this._resourceType = value;
                        this._updateVideoSource();
                    },
                    get: function() {
                        return this._resourceType;
                    }
                },
                _remoteURL: "",
                remoteURL: {
                    tooltip: "i18n:COMPONENT.videoplayer.url",
                    type: cc.String,
                    set: function(url) {
                        this._remoteURL = url;
                        this._updateVideoSource();
                    },
                    get: function() {
                        return this._remoteURL;
                    }
                },
                _clip: {
                    default: null,
                    url: cc.RawAsset
                },
                clip: {
                    tooltip: "i18n:COMPONENT.videoplayer.video",
                    get: function() {
                        return this._clip;
                    },
                    set: function(value) {
                        "string" !== typeof value && (value = "");
                        this._clip = value;
                        this._updateVideoSource();
                    },
                    url: cc.RawAsset
                },
                currentTime: {
                    tooltip: "i18n:COMPONENT.videoplayer.currentTime",
                    type: cc.Float,
                    set: function(time) {
                        this._sgNode && this._sgNode.seekTo(time);
                    },
                    get: function() {
                        if (this._sgNode) {
                            return this._sgNode.currentTime();
                        }
                        return -1;
                    }
                },
                keepAspectRatio: {
                    tooltip: "i18n:COMPONENT.videoplayer.keepAspectRatio",
                    default: true,
                    type: cc.Boolean,
                    notify: function() {
                        this._sgNode.setKeepAspectRatioEnabled(this.keepAspectRatio);
                    }
                },
                isFullscreen: {
                    tooltip: "i18n:COMPONENT.videoplayer.isFullscreen",
                    default: false,
                    type: cc.Boolean,
                    notify: function() {
                        this._sgNode.setFullScreenEnabled(this.isFullscreen);
                    }
                },
                videoPlayerEvent: {
                    default: [],
                    type: cc.Component.EventHandler
                }
            },
            statics: {
                EventType: EventType,
                ResourceType: ResourceType
            },
            onLoad: function() {},
            _createSgNode: function() {
                return new _ccsg.VideoPlayer();
            },
            _updateVideoSource: function() {
                var sgNode = this._sgNode;
                this.resourceType === ResourceType.REMOTE ? sgNode.setURL(this.remoteURL) : sgNode.setURL(this._clip || "");
            },
            _initSgNode: function() {
                var sgNode = this._sgNode;
                if (sgNode) {
                    sgNode.createDomElementIfNeeded();
                    this._updateVideoSource();
                    sgNode.seekTo(this.currentTime);
                    sgNode.setKeepAspectRatioEnabled(this.keepAspectRatio);
                    sgNode.setFullScreenEnabled(this.isFullscreen);
                    sgNode.setContentSize(this.node.getContentSize());
                    this.pause();
                    sgNode.setEventListener(EventType.PLAYING, this.onPlaying.bind(this));
                    sgNode.setEventListener(EventType.PAUSED, this.onPasued.bind(this));
                    sgNode.setEventListener(EventType.STOPPED, this.onStopped.bind(this));
                    sgNode.setEventListener(EventType.COMPLETED, this.onCompleted.bind(this));
                    sgNode.setEventListener(EventType.META_LOADED, this.onMetaLoaded.bind(this));
                    sgNode.setEventListener(EventType.CLICKED, this.onClicked.bind(this));
                    sgNode.setEventListener(EventType.READY_TO_PLAY, this.onReadyToPlay.bind(this));
                }
            },
            onReadyToPlay: function() {
                cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.READY_TO_PLAY);
                this.node.emit("ready-to-play", this);
            },
            onMetaLoaded: function() {
                cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.META_LOADED);
                this.node.emit("meta-loaded", this);
            },
            onClicked: function() {
                cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.CLICKED);
                this.node.emit("clicked", this);
            },
            onPlaying: function() {
                cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.PLAYING);
                this.node.emit("playing", this);
            },
            onPasued: function() {
                cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.PAUSED);
                this.node.emit("paused", this);
            },
            onStopped: function() {
                cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.STOPPED);
                this.node.emit("stopped", this);
            },
            onCompleted: function() {
                cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.COMPLETED);
                this.node.emit("completed", this);
            },
            play: function() {
                this._sgNode && this._sgNode.play();
            },
            resume: function() {
                this._sgNode && this._sgNode.resume();
            },
            pause: function() {
                this._sgNode && this._sgNode.pause();
            },
            stop: function() {
                this._sgNode && this._sgNode.stop();
            },
            getDuration: function() {
                if (this._sgNode) {
                    return this._sgNode.duration();
                }
                return -1;
            },
            isPlaying: function() {
                if (this._sgNode) {
                    return this._sgNode.isPlaying();
                }
                return false;
            }
        });
        cc.VideoPlayer = module.exports = VideoPlayer;
    }), {
        "../videoplayer/CCSGVideoPlayer.js": 237
    } ],
    99: [ (function(require, module, exports) {
        var ViewGroup = cc.Class({
            name: "cc.ViewGroup",
            extends: require("./CCComponent")
        });
        cc.ViewGroup = module.exports = ViewGroup;
    }), {
        "./CCComponent": 76
    } ],
    100: [ (function(require, module, exports) {
        require("../webview/CCSGWebView.js");
        var EventType = _ccsg.WebView.EventType;
        var WebView = cc.Class({
            name: "cc.WebView",
            extends: cc._RendererUnderSG,
            editor: false,
            properties: {
                _useOriginalSize: true,
                _url: "",
                url: {
                    type: String,
                    tooltip: "i18n:COMPONENT.webview.url",
                    get: function() {
                        return this._url;
                    },
                    set: function(url) {
                        this._url = url;
                        var sgNode = this._sgNode;
                        sgNode && sgNode.loadURL(url);
                    }
                },
                webviewEvents: {
                    default: [],
                    type: cc.Component.EventHandler
                }
            },
            statics: {
                EventType: EventType
            },
            onLoad: false,
            _createSgNode: function() {
                return new _ccsg.WebView();
            },
            _initSgNode: function() {
                var sgNode = this._sgNode;
                if (!sgNode) {
                    return;
                }
                sgNode.createDomElementIfNeeded();
                sgNode.setEventListener(EventType.LOADED, this._onWebViewLoaded.bind(this));
                sgNode.setEventListener(EventType.LOADING, this._onWebViewLoading.bind(this));
                sgNode.setEventListener(EventType.ERROR, this._onWebViewLoadError.bind(this));
                sgNode.loadURL(this._url);
                sgNode.setContentSize(this.node.getContentSize());
            },
            _onWebViewLoaded: function() {
                cc.Component.EventHandler.emitEvents(this.webviewEvents, this, EventType.LOADED);
                this.node.emit("loaded", this);
            },
            _onWebViewLoading: function() {
                cc.Component.EventHandler.emitEvents(this.webviewEvents, this, EventType.LOADING);
                this.node.emit("loading", this);
                return true;
            },
            _onWebViewLoadError: function() {
                cc.Component.EventHandler.emitEvents(this.webviewEvents, this, EventType.ERROR);
                this.node.emit("error", this);
            }
        });
        cc.WebView = module.exports = WebView;
    }), {
        "../webview/CCSGWebView.js": 238
    } ],
    101: [ (function(require, module, exports) {
        var WidgetManager = require("../base-ui/CCWidgetManager");
        var AlignFlags = WidgetManager._AlignFlags;
        var TOP = AlignFlags.TOP;
        var MID = AlignFlags.MID;
        var BOT = AlignFlags.BOT;
        var LEFT = AlignFlags.LEFT;
        var CENTER = AlignFlags.CENTER;
        var RIGHT = AlignFlags.RIGHT;
        var TOP_BOT = TOP | BOT;
        var LEFT_RIGHT = LEFT | RIGHT;
        var Widget = cc.Class({
            name: "cc.Widget",
            extends: require("./CCComponent"),
            editor: false,
            properties: {
                target: {
                    get: function() {
                        return this._target;
                    },
                    set: function(value) {
                        this._target = value;
                    },
                    type: cc.Node,
                    tooltip: "i18n:COMPONENT.widget.target"
                },
                isAlignTop: {
                    get: function() {
                        return (this._alignFlags & TOP) > 0;
                    },
                    set: function(value) {
                        this._setAlign(TOP, value);
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.widget.align_top"
                },
                isAlignVerticalCenter: {
                    get: function() {
                        return (this._alignFlags & MID) > 0;
                    },
                    set: function(value) {
                        if (value) {
                            this.isAlignTop = false;
                            this.isAlignBottom = false;
                            this._alignFlags |= MID;
                        } else {
                            this._alignFlags &= ~MID;
                        }
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.widget.align_v_center"
                },
                isAlignBottom: {
                    get: function() {
                        return (this._alignFlags & BOT) > 0;
                    },
                    set: function(value) {
                        this._setAlign(BOT, value);
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.widget.align_bottom"
                },
                isAlignLeft: {
                    get: function() {
                        return (this._alignFlags & LEFT) > 0;
                    },
                    set: function(value) {
                        this._setAlign(LEFT, value);
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.widget.align_left"
                },
                isAlignHorizontalCenter: {
                    get: function() {
                        return (this._alignFlags & CENTER) > 0;
                    },
                    set: function(value) {
                        if (value) {
                            this.isAlignLeft = false;
                            this.isAlignRight = false;
                            this._alignFlags |= CENTER;
                        } else {
                            this._alignFlags &= ~CENTER;
                        }
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.widget.align_h_center"
                },
                isAlignRight: {
                    get: function() {
                        return (this._alignFlags & RIGHT) > 0;
                    },
                    set: function(value) {
                        this._setAlign(RIGHT, value);
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.widget.align_right"
                },
                isStretchWidth: {
                    get: function() {
                        return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
                    },
                    visible: false
                },
                isStretchHeight: {
                    get: function() {
                        return (this._alignFlags & TOP_BOT) === TOP_BOT;
                    },
                    visible: false
                },
                top: {
                    get: function() {
                        return this._top;
                    },
                    set: function(value) {
                        this._top = value;
                    },
                    tooltip: "i18n:COMPONENT.widget.top"
                },
                bottom: {
                    get: function() {
                        return this._bottom;
                    },
                    set: function(value) {
                        this._bottom = value;
                    },
                    tooltip: "i18n:COMPONENT.widget.bottom"
                },
                left: {
                    get: function() {
                        return this._left;
                    },
                    set: function(value) {
                        this._left = value;
                    },
                    tooltip: "i18n:COMPONENT.widget.left"
                },
                right: {
                    get: function() {
                        return this._right;
                    },
                    set: function(value) {
                        this._right = value;
                    },
                    tooltip: "i18n:COMPONENT.widget.right"
                },
                horizontalCenter: {
                    get: function() {
                        return this._horizontalCenter;
                    },
                    set: function(value) {
                        this._horizontalCenter = value;
                    },
                    tooltip: "i18n:COMPONENT.widget.horizontal_center"
                },
                verticalCenter: {
                    get: function() {
                        return this._verticalCenter;
                    },
                    set: function(value) {
                        this._verticalCenter = value;
                    },
                    tooltip: "i18n:COMPONENT.widget.vertical_center"
                },
                isAbsoluteHorizontalCenter: {
                    get: function() {
                        return this._isAbsHorizontalCenter;
                    },
                    set: function(value) {
                        this._isAbsHorizontalCenter = value;
                    },
                    animatable: false
                },
                isAbsoluteVerticalCenter: {
                    get: function() {
                        return this._isAbsVerticalCenter;
                    },
                    set: function(value) {
                        this._isAbsVerticalCenter = value;
                    },
                    animatable: false
                },
                isAbsoluteTop: {
                    get: function() {
                        return this._isAbsTop;
                    },
                    set: function(value) {
                        this._isAbsTop = value;
                    },
                    animatable: false
                },
                isAbsoluteBottom: {
                    get: function() {
                        return this._isAbsBottom;
                    },
                    set: function(value) {
                        this._isAbsBottom = value;
                    },
                    animatable: false
                },
                isAbsoluteLeft: {
                    get: function() {
                        return this._isAbsLeft;
                    },
                    set: function(value) {
                        this._isAbsLeft = value;
                    },
                    animatable: false
                },
                isAbsoluteRight: {
                    get: function() {
                        return this._isAbsRight;
                    },
                    set: function(value) {
                        this._isAbsRight = value;
                    },
                    animatable: false
                },
                isAlignOnce: {
                    default: true,
                    tooltip: "i18n:COMPONENT.widget.align_once",
                    displayName: "AlignOnce"
                },
                _target: null,
                _alignFlags: 0,
                _left: 0,
                _right: 0,
                _top: 0,
                _bottom: 0,
                _verticalCenter: 0,
                _horizontalCenter: 0,
                _isAbsLeft: true,
                _isAbsRight: true,
                _isAbsTop: true,
                _isAbsBottom: true,
                _isAbsHorizontalCenter: true,
                _isAbsVerticalCenter: true,
                _originalWidth: 0,
                _originalHeight: 0
            },
            onEnable: function() {
                WidgetManager.add(this);
            },
            onDisable: function() {
                WidgetManager.remove(this);
            },
            _setAlign: function(flag, isAlign) {
                var current = (this._alignFlags & flag) > 0;
                if (isAlign == current) {
                    return;
                }
                var isHorizontal = (flag & LEFT_RIGHT) > 0;
                if (isAlign) {
                    this._alignFlags |= flag;
                    if (isHorizontal) {
                        this.isAlignHorizontalCenter = false;
                        this.isStretchWidth && (this._originalWidth = this.node.width);
                    } else {
                        this.isAlignVerticalCenter = false;
                        this.isStretchHeight && (this._originalHeight = this.node.height);
                    }
                } else {
                    isHorizontal ? this.isStretchWidth && (this.node.width = this._originalWidth) : this.isStretchHeight && (this.node.height = this._originalHeight);
                    this._alignFlags &= ~flag;
                }
            },
            updateAlignment: function() {
                WidgetManager.updateAlignment(this.node);
            }
        });
        cc.Widget = module.exports = Widget;
    }), {
        "../base-ui/CCWidgetManager": 60,
        "./CCComponent": 76
    } ],
    102: [ (function(require, module, exports) {
        require("./CCComponent");
        require("./CCRendererInSG");
        require("./CCRendererUnderSG");
        require("./CCComponentEventHandler");
        require("./missing-script");
        module.exports = [ require("./CCSprite"), require("./CCWidget"), require("./CCCanvas"), require("./CCAudioSource"), require("./CCAnimation"), require("./CCButton"), require("./CCLabel"), require("./CCProgressBar"), require("./CCMask"), require("./CCScrollBar"), require("./CCScrollView"), require("./CCPageViewIndicator"), require("./CCPageView"), require("./CCSlider"), require("./CCLayout"), require("./CCEditBox"), require("./CCVideoPlayer"), require("./CCWebView"), require("./CCSpriteDistortion"), require("./CCLabelOutline"), require("./CCRichText"), require("./CCToggleGroup"), require("./CCToggle") ];
    }), {
        "./CCAnimation": 72,
        "./CCAudioSource": 73,
        "./CCButton": 74,
        "./CCCanvas": 75,
        "./CCComponent": 76,
        "./CCComponentEventHandler": 77,
        "./CCEditBox": 78,
        "./CCLabel": 79,
        "./CCLabelOutline": 80,
        "./CCLayout": 81,
        "./CCMask": 82,
        "./CCPageView": 83,
        "./CCPageViewIndicator": 84,
        "./CCProgressBar": 85,
        "./CCRendererInSG": 86,
        "./CCRendererUnderSG": 87,
        "./CCRichText": 88,
        "./CCScrollBar": 90,
        "./CCScrollView": 91,
        "./CCSlider": 92,
        "./CCSprite": 93,
        "./CCSpriteDistortion": 94,
        "./CCToggle": 96,
        "./CCToggleGroup": 97,
        "./CCVideoPlayer": 98,
        "./CCWebView": 100,
        "./CCWidget": 101,
        "./missing-script": 103
    } ],
    103: [ (function(require, module, exports) {
        var JS = cc.js;
        var isBuiltinClassId = require("../utils/misc").isBuiltinClassId;
        var MissingClass = cc.Class({
            name: "cc.MissingClass",
            properties: {
                _$erialized: {
                    default: null,
                    visible: false,
                    editorOnly: true
                }
            }
        });
        var MissingScript = cc.Class({
            name: "cc.MissingScript",
            extends: cc.Component,
            editor: {
                inspector: "packages://inspector/inspectors/comps/missing-script.js"
            },
            properties: {
                compiled: {
                    default: false,
                    serializable: false
                },
                _$erialized: {
                    default: null,
                    visible: false,
                    editorOnly: true
                }
            },
            ctor: false,
            statics: {
                safeFindClass: function(id, data) {
                    var cls = JS._getClassById(id);
                    if (cls) {
                        return cls;
                    }
                    if (id) {
                        cc.deserialize.reportMissingClass(id);
                        return MissingScript.getMissingWrapper(id, data);
                    }
                    return null;
                },
                getMissingWrapper: function(id, data) {
                    return data.node && (/^[0-9a-zA-Z+\/]{23}$/.test(id) || isBuiltinClassId(id)) ? MissingScript : MissingClass;
                }
            },
            onLoad: function() {
                cc.warnID(4600, this.node.name);
            }
        });
        cc._MissingScript = module.exports = MissingScript;
    }), {
        "../utils/misc": 223
    } ],
    104: [ (function(require, module, exports) {
        var SCROLLY = 40;
        var TIMER_NAME = 400;
        var LEFT_PADDING = 2;
        var Utils = require("../platform/utils");
        function adjustEditBoxPosition(editBox) {
            var worldPos = editBox.convertToWorldSpace(cc.p(0, 0));
            var windowHeight = cc.visibleRect.height;
            var windowWidth = cc.visibleRect.width;
            var factor = .5;
            windowWidth > windowHeight && (factor = .7);
            setTimeout((function() {
                if (window.scrollY < SCROLLY && worldPos.y < windowHeight * factor) {
                    var scrollOffset = windowHeight * factor - worldPos.y - window.scrollY;
                    scrollOffset < 35 && (scrollOffset = 35);
                    scrollOffset > 320 && (scrollOffset = 320);
                    window.scrollTo(scrollOffset, scrollOffset);
                }
            }), TIMER_NAME);
        }
        var capitalize = function(string) {
            return string.replace(/(?:^|\s)\S/g, (function(a) {
                return a.toUpperCase();
            }));
        };
        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }
        var KeyboardReturnType = cc.Enum({
            DEFAULT: 0,
            DONE: 1,
            SEND: 2,
            SEARCH: 3,
            GO: 4
        });
        var InputMode = cc.Enum({
            ANY: 0,
            EMAIL_ADDR: 1,
            NUMERIC: 2,
            PHONE_NUMBER: 3,
            URL: 4,
            DECIMAL: 5,
            SINGLE_LINE: 6
        });
        var InputFlag = cc.Enum({
            PASSWORD: 0,
            SENSITIVE: 1,
            INITIAL_CAPS_WORD: 2,
            INITIAL_CAPS_SENTENCE: 3,
            INITIAL_CAPS_ALL_CHARACTERS: 4,
            DEFAULT: 5
        });
        cc.EditBoxDelegate = cc._Class.extend({
            editBoxEditingDidBegan: function(sender) {},
            editBoxEditingDidEnded: function(sender) {},
            editBoxTextChanged: function(sender, text) {},
            editBoxEditingReturn: function(sender) {}
        });
        _ccsg.EditBox = _ccsg.Node.extend({
            _backgroundSprite: null,
            _delegate: null,
            _editBoxInputMode: InputMode.ANY,
            _editBoxInputFlag: InputFlag.DEFAULT,
            _keyboardReturnType: KeyboardReturnType.DEFAULT,
            _maxLength: 50,
            _text: "",
            _placeholderText: "",
            _alwaysOnTop: false,
            _placeholderFontName: "",
            _placeholderFontSize: 14,
            __fullscreen: false,
            __autoResize: false,
            _placeholderColor: null,
            _className: "EditBox",
            ctor: function(size, normal9SpriteBg) {
                _ccsg.Node.prototype.ctor.call(this);
                this._textColor = cc.Color.WHITE;
                this._placeholderColor = cc.Color.GRAY;
                this.initWithSizeAndBackgroundSprite(size, normal9SpriteBg);
                this._renderCmd._createLabels();
            },
            _createRenderCmd: function() {
                return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new _ccsg.EditBox.CanvasRenderCmd(this) : new _ccsg.EditBox.WebGLRenderCmd(this);
            },
            setContentSize: function(width, height) {
                if (void 0 !== width.width && void 0 !== width.height) {
                    height = width.height;
                    width = width.width;
                }
                _ccsg.Node.prototype.setContentSize.call(this, width, height);
                this._updateEditBoxSize(width, height);
            },
            setVisible: function(visible) {
                _ccsg.Node.prototype.setVisible.call(this, visible);
                this._renderCmd.updateVisibility();
            },
            createDomElementIfNeeded: function() {
                this._renderCmd._edTxt || this._renderCmd._createDomTextArea();
            },
            setTabIndex: function(index) {
                this._renderCmd._edTxt && (this._renderCmd._edTxt.tabIndex = index);
            },
            getTabIndex: function() {
                if (this._renderCmd._edTxt) {
                    return this._renderCmd._edTxt.tabIndex;
                }
                cc.warnID(4700);
                return -1;
            },
            setFocus: function() {
                this._renderCmd._edTxt && this._renderCmd._edTxt.focus();
            },
            isFocused: function() {
                if (this._renderCmd._edTxt) {
                    return document.activeElement === this._renderCmd._edTxt;
                }
                cc.warnID(4700);
                return false;
            },
            stayOnTop: function(flag) {
                if (this._alwaysOnTop === flag) {
                    return;
                }
                this._alwaysOnTop = flag;
                this._renderCmd.stayOnTop(this._alwaysOnTop);
            },
            cleanup: function() {
                this._super();
                this._renderCmd.removeDom();
            },
            _onTouchBegan: function(touch) {
                var touchPoint = touch.getLocation();
                var bb = cc.rect(0, 0, this._contentSize.width, this._contentSize.height);
                var hitted = cc.rectContainsPoint(bb, this.convertToNodeSpace(touchPoint));
                if (hitted) {
                    return true;
                }
                this._renderCmd._endEditing();
                return false;
            },
            _onTouchEnded: function() {
                this._renderCmd._beginEditing();
            },
            _updateBackgroundSpriteSize: function(width, height) {
                this._backgroundSprite && this._backgroundSprite.setContentSize(width, height);
            },
            _updateEditBoxSize: function(size, height) {
                var newWidth = "number" === typeof size.width ? size.width : size;
                var newHeight = "number" === typeof size.height ? size.height : height;
                this._updateBackgroundSpriteSize(newWidth, newHeight);
                this._renderCmd.updateSize(newWidth, newHeight);
            },
            setLineHeight: function(lineHeight) {
                this._renderCmd.setLineHeight(lineHeight);
            },
            setFont: function(fontName, fontSize) {
                this._renderCmd.setFont(fontName, fontSize);
            },
            _setFont: function(fontStyle) {
                this._renderCmd._setFont(fontStyle);
            },
            getBackgroundSprite: function() {
                return this._backgroundSprite;
            },
            setFontName: function(fontName) {
                this._renderCmd.setFontName(fontName);
            },
            setFontSize: function(fontSize) {
                this._renderCmd.setFontSize(fontSize);
            },
            setString: function(text) {
                text.length >= this._maxLength && (text = text.slice(0, this._maxLength));
                this._text = text;
                this._renderCmd.setString(text);
            },
            setFontColor: function(color) {
                this._textColor = color;
                this._renderCmd.setFontColor(color);
            },
            setMaxLength: function(maxLength) {
                if (!isNaN(maxLength)) {
                    maxLength < 0 && (maxLength = 65535);
                    this._maxLength = maxLength;
                    this._renderCmd.setMaxLength(maxLength);
                }
            },
            getMaxLength: function() {
                return this._maxLength;
            },
            setPlaceHolder: function(text) {
                if (null !== text) {
                    this._renderCmd.setPlaceHolder(text);
                    this._placeholderText = text;
                }
            },
            setPlaceholderFont: function(fontName, fontSize) {
                this._placeholderFontName = fontName;
                this._placeholderFontSize = fontSize;
                this._renderCmd._updateDOMPlaceholderFontStyle();
            },
            _setPlaceholderFont: function(fontStyle) {
                var res = cc.LabelTTF._fontStyleRE.exec(fontStyle);
                if (res) {
                    this._placeholderFontName = res[2];
                    this._placeholderFontSize = parseInt(res[1]);
                    this._renderCmd._updateDOMPlaceholderFontStyle();
                }
            },
            setPlaceholderFontName: function(fontName) {
                this._placeholderFontName = fontName;
                this._renderCmd._updateDOMPlaceholderFontStyle();
            },
            setPlaceholderFontSize: function(fontSize) {
                this._placeholderFontSize = fontSize;
                this._renderCmd._updateDOMPlaceholderFontStyle();
            },
            setPlaceholderFontColor: function(color) {
                this._placeholderColor = color;
                this._renderCmd.setPlaceholderFontColor(color);
            },
            setInputFlag: function(inputFlag) {
                this._editBoxInputFlag = inputFlag;
                this._renderCmd.setInputFlag(inputFlag);
            },
            getString: function() {
                return this._text;
            },
            initWithSizeAndBackgroundSprite: function(size, normal9SpriteBg) {
                this._backgroundSprite && this._backgroundSprite.removeFromParent();
                this._backgroundSprite = normal9SpriteBg;
                _ccsg.Node.prototype.setContentSize.call(this, size);
                if (this._backgroundSprite && !this._backgroundSprite.parent) {
                    this._backgroundSprite.setAnchorPoint(cc.p(0, 0));
                    this.addChild(this._backgroundSprite);
                    this._updateBackgroundSpriteSize(size.width, size.height);
                }
                this.x = 0;
                this.y = 0;
                return true;
            },
            setDelegate: function(delegate) {
                this._delegate = delegate;
            },
            getPlaceHolder: function() {
                return this._placeholderText;
            },
            setInputMode: function(inputMode) {
                if (this._editBoxInputMode === inputMode) {
                    return;
                }
                var oldText = this.getString();
                this._editBoxInputMode = inputMode;
                this._renderCmd.setInputMode(inputMode);
                this._renderCmd.transform();
                this.setString(oldText);
                this._renderCmd._updateLabelPosition(this.getContentSize());
            },
            setReturnType: function(returnType) {
                this._keyboardReturnType = returnType;
                this._renderCmd._updateDomInputType();
            },
            initWithBackgroundColor: function(size, bgColor) {
                this._edWidth = size.width;
                this.dom.style.width = this._edWidth.toString() + "px";
                this._edHeight = size.height;
                this.dom.style.height = this._edHeight.toString() + "px";
                this.dom.style.backgroundColor = cc.colorToHex(bgColor);
            }
        });
        var _p = _ccsg.EditBox.prototype;
        cc.defineGetterSetter(_p, "font", null, _p._setFont);
        cc.defineGetterSetter(_p, "fontName", null, _p.setFontName);
        cc.defineGetterSetter(_p, "fontSize", null, _p.setFontSize);
        cc.defineGetterSetter(_p, "fontColor", null, _p.setFontColor);
        cc.defineGetterSetter(_p, "string", _p.getString, _p.setString);
        cc.defineGetterSetter(_p, "maxLength", _p.getMaxLength, _p.setMaxLength);
        cc.defineGetterSetter(_p, "placeholder", _p.getPlaceHolder, _p.setPlaceHolder);
        cc.defineGetterSetter(_p, "placeholderFont", null, _p._setPlaceholderFont);
        cc.defineGetterSetter(_p, "placeholderFontName", null, _p.setPlaceholderFontName);
        cc.defineGetterSetter(_p, "placeholderFontSize", null, _p.setPlaceholderFontSize);
        cc.defineGetterSetter(_p, "placeholderFontColor", null, _p.setPlaceholderFontColor);
        cc.defineGetterSetter(_p, "inputFlag", null, _p.setInputFlag);
        cc.defineGetterSetter(_p, "delegate", null, _p.setDelegate);
        cc.defineGetterSetter(_p, "inputMode", null, _p.setInputMode);
        cc.defineGetterSetter(_p, "returnType", null, _p.setReturnType);
        _p = null;
        _ccsg.EditBox.InputMode = InputMode;
        _ccsg.EditBox.InputFlag = InputFlag;
        _ccsg.EditBox.KeyboardReturnType = KeyboardReturnType;
        (function(editbox) {
            editbox._polyfill = {
                zoomInvalid: false
            };
            cc.sys.OS_ANDROID !== cc.sys.os || cc.sys.browserType !== cc.sys.BROWSER_TYPE_SOUGOU && cc.sys.browserType !== cc.sys.BROWSER_TYPE_360 || (editbox._polyfill.zoomInvalid = true);
        })(_ccsg.EditBox);
        (function(polyfill) {
            var EditBoxImpl = function() {};
            var proto = EditBoxImpl.prototype = Object.create(Object.prototype);
            proto.updateMatrix = function() {
                if (!this._edTxt) {
                    return;
                }
                var node = this._node, scaleX = cc.view._scaleX, scaleY = cc.view._scaleY;
                var dpr = cc.view._devicePixelRatio;
                var t = this._worldTransform;
                scaleX /= dpr;
                scaleY /= dpr;
                var container = cc.game.container;
                var a = t.a * scaleX, b = t.b, c = t.c, d = t.d * scaleY;
                var offsetX = container && container.style.paddingLeft && parseInt(container.style.paddingLeft);
                var offsetY = container && container.style.paddingBottom && parseInt(container.style.paddingBottom);
                var tx = t.tx * scaleX + offsetX, ty = t.ty * scaleY + offsetY;
                if (polyfill.zoomInvalid) {
                    this.updateSize(node._contentSize.width * a, node._contentSize.height * d);
                    a = 1;
                    d = 1;
                }
                var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
                this._edTxt.style["transform"] = matrix;
                this._edTxt.style["-webkit-transform"] = matrix;
                this._edTxt.style["transform-origin"] = "0px 100% 0px";
                this._edTxt.style["-webkit-transform-origin"] = "0px 100% 0px";
            };
            proto.updateVisibility = function() {
                if (!this._edTxt) {
                    return;
                }
                this._node.visible ? this._edTxt.style.visibility = "visible" : this._edTxt.style.visibility = "hidden";
            };
            proto.stayOnTop = function(flag) {
                if (flag) {
                    this._removeLabels();
                    this._edTxt.style.display = "";
                } else {
                    this._createLabels();
                    this._edTxt.style.display = "none";
                    this._showLabels();
                }
            };
            proto._beginEditingOnMobile = function(editBox) {
                this.__orientationChanged = function() {
                    adjustEditBoxPosition(editBox);
                };
                window.addEventListener("orientationchange", this.__orientationChanged);
                if (cc.view.isAutoFullScreenEnabled()) {
                    this.__fullscreen = true;
                    cc.view.enableAutoFullScreen(false);
                    cc.screen.exitFullScreen();
                } else {
                    this.__fullscreen = false;
                }
                this.__autoResize = cc.view.__resizeWithBrowserSize;
                cc.view.resizeWithBrowserSize(false);
            };
            proto._endEditingOnMobile = function() {
                if (this.__rotateScreen) {
                    cc.container.style["-webkit-transform"] = "rotate(90deg)";
                    cc.container.style.transform = "rotate(90deg)";
                    var view = cc.view;
                    var width = view._originalDesignResolutionSize.width;
                    var height = view._originalDesignResolutionSize.height;
                    width > 0 && view.setDesignResolutionSize(width, height, view._resolutionPolicy);
                    this.__rotateScreen = false;
                }
                window.removeEventListener("orientationchange", this.__orientationChanged);
                window.scrollTo(0, 0);
                this.__fullscreen && cc.view.enableAutoFullScreen(true);
                this.__autoResize && cc.view.resizeWithBrowserSize(true);
            };
            proto._onFocusOnMobile = function(editBox) {
                if (cc.view._isRotated) {
                    cc.container.style["-webkit-transform"] = "rotate(0deg)";
                    cc.container.style.transform = "rotate(0deg)";
                    cc.view._isRotated = false;
                    var policy = cc.view.getResolutionPolicy();
                    policy.apply(cc.view, cc.view.getDesignResolutionSize());
                    cc.view._isRotated = true;
                    window.scrollTo(35, 35);
                    this.__rotateScreen = true;
                } else {
                    this.__rotateScreen = false;
                }
                adjustEditBoxPosition(editBox);
            };
            proto._createDomInput = function() {
                this.removeDom();
                var thisPointer = this;
                var tmpEdTxt = this._edTxt = document.createElement("input");
                tmpEdTxt.type = "text";
                tmpEdTxt.style.fontSize = this._edFontSize + "px";
                tmpEdTxt.style.color = "#000000";
                tmpEdTxt.style.border = 0;
                tmpEdTxt.style.background = "transparent";
                tmpEdTxt.style.width = "100%";
                tmpEdTxt.style.height = "100%";
                tmpEdTxt.style.active = 0;
                tmpEdTxt.style.outline = "medium";
                tmpEdTxt.style.padding = "0";
                tmpEdTxt.style.textTransform = "uppercase";
                tmpEdTxt.style.display = "none";
                tmpEdTxt.style.position = "absolute";
                tmpEdTxt.style.bottom = "0px";
                tmpEdTxt.style.left = LEFT_PADDING + "px";
                tmpEdTxt.style.className = "cocosEditBox";
                tmpEdTxt.addEventListener("input", (function() {
                    var editBox = thisPointer._editBox;
                    this.value.length > this.maxLength && (this.value = this.value.slice(0, this.maxLength));
                    if (editBox._delegate && editBox._delegate.editBoxTextChanged && editBox._text !== this.value) {
                        editBox._text = this.value;
                        thisPointer._updateDomTextCases();
                        editBox._delegate.editBoxTextChanged(editBox, editBox._text);
                    }
                }));
                tmpEdTxt.addEventListener("keypress", (function(e) {
                    var editBox = thisPointer._editBox;
                    if (e.keyCode === cc.KEY.enter) {
                        e.stopPropagation();
                        e.preventDefault();
                        if ("" === this.value) {
                            this.style.fontSize = editBox._placeholderFontSize + "px";
                            this.style.color = cc.colorToHex(editBox._placeholderColor);
                        }
                        editBox._text = this.value;
                        thisPointer._updateDomTextCases();
                        thisPointer._endEditing();
                        editBox._delegate && editBox._delegate.editBoxEditingReturn && editBox._delegate.editBoxEditingReturn(editBox);
                        cc._canvas.focus();
                    }
                }));
                tmpEdTxt.addEventListener("focus", (function() {
                    var editBox = thisPointer._editBox;
                    this.style.fontSize = thisPointer._edFontSize + "px";
                    this.style.color = cc.colorToHex(editBox._textColor);
                    thisPointer._hiddenLabels();
                    cc.sys.isMobile && thisPointer._onFocusOnMobile(editBox);
                    editBox._delegate && editBox._delegate.editBoxEditingDidBegan && editBox._delegate.editBoxEditingDidBegan(editBox);
                }));
                tmpEdTxt.addEventListener("blur", (function() {
                    var editBox = thisPointer._editBox;
                    editBox._text = this.value;
                    thisPointer._updateDomTextCases();
                    editBox._delegate && editBox._delegate.editBoxEditingDidEnded && editBox._delegate.editBoxEditingDidEnded(editBox);
                    if ("" === this.value) {
                        this.style.fontSize = editBox._placeholderFontSize + "px";
                        this.style.color = cc.colorToHex(editBox._placeholderColor);
                    }
                    thisPointer._endEditing();
                }));
                this._addDomToGameContainer();
                return tmpEdTxt;
            };
            proto._createDomTextArea = function() {
                this.removeDom();
                var thisPointer = this;
                var tmpEdTxt = this._edTxt = document.createElement("textarea");
                tmpEdTxt.type = "text";
                tmpEdTxt.style.fontSize = this._edFontSize + "px";
                tmpEdTxt.style.color = "#000000";
                tmpEdTxt.style.border = 0;
                tmpEdTxt.style.background = "transparent";
                tmpEdTxt.style.width = "100%";
                tmpEdTxt.style.height = "100%";
                tmpEdTxt.style.active = 0;
                tmpEdTxt.style.outline = "medium";
                tmpEdTxt.style.padding = "0";
                tmpEdTxt.style.resize = "none";
                tmpEdTxt.style.textTransform = "uppercase";
                tmpEdTxt.style.overflow_y = "scroll";
                tmpEdTxt.style.display = "none";
                tmpEdTxt.style.position = "absolute";
                tmpEdTxt.style.bottom = "0px";
                tmpEdTxt.style.left = LEFT_PADDING + "px";
                tmpEdTxt.style.className = "cocosEditBox";
                tmpEdTxt.addEventListener("input", (function() {
                    this.value.length > this.maxLength && (this.value = this.value.slice(0, this.maxLength));
                    var editBox = thisPointer._editBox;
                    if (editBox._delegate && editBox._delegate.editBoxTextChanged && editBox._text.toLowerCase() !== this.value.toLowerCase()) {
                        editBox._text = this.value;
                        thisPointer._updateDomTextCases();
                        editBox._delegate.editBoxTextChanged(editBox, editBox._text);
                    }
                }));
                tmpEdTxt.addEventListener("focus", (function() {
                    var editBox = thisPointer._editBox;
                    thisPointer._hiddenLabels();
                    this.style.fontSize = thisPointer._edFontSize + "px";
                    this.style.color = cc.colorToHex(editBox._textColor);
                    cc.sys.isMobile && thisPointer._onFocusOnMobile(editBox);
                    editBox._delegate && editBox._delegate.editBoxEditingDidBegan && editBox._delegate.editBoxEditingDidBegan(editBox);
                }));
                tmpEdTxt.addEventListener("keypress", (function(e) {
                    var editBox = thisPointer._editBox;
                    if (e.keyCode === cc.KEY.enter) {
                        e.stopPropagation();
                        editBox._delegate && editBox._delegate.editBoxEditingReturn && editBox._delegate.editBoxEditingReturn(editBox);
                    }
                }));
                tmpEdTxt.addEventListener("blur", (function() {
                    var editBox = thisPointer._editBox;
                    editBox._text = this.value;
                    thisPointer._updateDomTextCases();
                    editBox._delegate && editBox._delegate.editBoxEditingDidEnded && editBox._delegate.editBoxEditingDidEnded(editBox);
                    if ("" === this.value) {
                        this.style.fontSize = editBox._placeholderFontSize + "px";
                        this.style.color = cc.colorToHex(editBox._placeholderColor);
                    }
                    thisPointer._endEditing();
                }));
                this._addDomToGameContainer();
                return tmpEdTxt;
            };
            proto._createLabels = function() {
                var editBoxSize = this._editBox.getContentSize();
                if (!this._textLabel) {
                    this._textLabel = new _ccsg.Label();
                    this._textLabel.setAnchorPoint(cc.p(0, 1));
                    this._textLabel.setOverflow(_ccsg.Label.Overflow.CLAMP);
                    this._editBox.addChild(this._textLabel, 100);
                }
                if (!this._placeholderLabel) {
                    this._placeholderLabel = new _ccsg.Label();
                    this._placeholderLabel.setAnchorPoint(cc.p(0, 1));
                    this._placeholderLabel.setColor(cc.Color.GRAY);
                    this._editBox.addChild(this._placeholderLabel, 100);
                }
                this._updateLabelPosition(editBoxSize);
            };
            proto._removeLabels = function() {
                if (!this._textLabel) {
                    return;
                }
                this._editBox.removeChild(this._textLabel);
                this._textLabel = null;
            };
            proto._updateLabelPosition = function(editBoxSize) {
                if (!this._textLabel || !this._placeholderLabel) {
                    return;
                }
                var labelContentSize = cc.size(editBoxSize.width - LEFT_PADDING, editBoxSize.height);
                this._textLabel.setContentSize(labelContentSize);
                this._placeholderLabel.setLineHeight(editBoxSize.height);
                var placeholderLabelSize = this._placeholderLabel.getContentSize();
                if (this._editBox._editBoxInputMode === InputMode.ANY) {
                    this._textLabel.setPosition(LEFT_PADDING, editBoxSize.height);
                    this._placeholderLabel.setPosition(LEFT_PADDING, editBoxSize.height);
                    this._placeholderLabel.setVerticalAlign(cc.VerticalTextAlignment.TOP);
                    this._textLabel.setVerticalAlign(cc.VerticalTextAlignment.TOP);
                    this._textLabel.enableWrapText(true);
                } else {
                    this._textLabel.enableWrapText(false);
                    this._textLabel.setPosition(LEFT_PADDING, editBoxSize.height);
                    this._placeholderLabel.setPosition(LEFT_PADDING, (editBoxSize.height + placeholderLabelSize.height) / 2);
                    this._placeholderLabel.setVerticalAlign(cc.VerticalTextAlignment.CENTER);
                    this._textLabel.setVerticalAlign(cc.VerticalTextAlignment.CENTER);
                }
            };
            proto.setLineHeight = function(lineHeight) {
                this._textLabel && this._textLabel.setLineHeight(lineHeight);
            };
            proto._hiddenLabels = function() {
                this._textLabel && this._textLabel.setVisible(false);
                this._placeholderLabel && this._placeholderLabel.setVisible(false);
            };
            proto._updateDomTextCases = function() {
                var inputFlag = this._editBox._editBoxInputFlag;
                inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? this._editBox._text = this._editBox._text.toUpperCase() : inputFlag === InputFlag.INITIAL_CAPS_WORD ? this._editBox._text = capitalize(this._editBox._text) : inputFlag === InputFlag.INITIAL_CAPS_SENTENCE && (this._editBox._text = capitalizeFirstLetter(this._editBox._text));
            };
            proto._updateLabelStringStyle = function() {
                if ("password" === this._edTxt.type) {
                    var passwordString = "";
                    var len = this._editBox._text.length;
                    for (var i = 0; i < len; ++i) {
                        passwordString += "â—";
                    }
                    this._textLabel && this._textLabel.setString(passwordString);
                } else {
                    this._updateDomTextCases();
                    this._textLabel && this._textLabel.setString(this._editBox._text);
                }
            };
            proto._showLabels = function() {
                this._hiddenLabels();
                if ("" === this._edTxt.value) {
                    if (this._placeholderLabel) {
                        this._placeholderLabel.setVisible(true);
                        this._placeholderLabel.setString(this._editBox._placeholderText);
                    }
                } else {
                    if (this._textLabel) {
                        this._textLabel.setVisible(true);
                        this._textLabel.setString(this._editBox._text);
                    }
                }
                this._updateLabelStringStyle();
            };
            proto._beginEditing = function() {
                if (!this._editBox._alwaysOnTop && "none" === this._edTxt.style.display) {
                    this._edTxt.style.display = "";
                    this._edTxt.focus();
                }
                cc.sys.isMobile && !this._editingMode && this._beginEditingOnMobile(this._editBox);
                this._editingMode = true;
            };
            proto._endEditing = function() {
                this._editBox._alwaysOnTop || (this._edTxt.style.display = "none");
                this._showLabels();
                if (cc.sys.isMobile && this._editingMode) {
                    var self = this;
                    setTimeout((function() {
                        self._endEditingOnMobile();
                    }), TIMER_NAME);
                }
                this._editingMode = false;
            };
            proto._setFont = function(fontStyle) {
                var res = cc.LabelTTF._fontStyleRE.exec(fontStyle);
                var textFontName = res[2];
                var textFontSize = parseInt(res[1]);
                res && this.setFont(textFontName, textFontSize);
            };
            proto.setFont = function(fontName, fontSize) {
                this._edFontName = fontName || this._edFontName;
                this._edFontSize = fontSize || this._edFontSize;
                this._updateDOMFontStyle();
            };
            proto.setFontName = function(fontName) {
                this._edFontName = fontName || this._edFontName;
                this._updateDOMFontStyle();
            };
            proto.setFontSize = function(fontSize) {
                this._edFontSize = fontSize || this._edFontSize;
                this._updateDOMFontStyle();
            };
            proto.setFontColor = function(color) {
                if (!this._edTxt) {
                    return;
                }
                this._edTxt.value !== this._editBox._placeholderText && (this._edTxt.style.color = cc.colorToHex(color));
                this._textLabel && this._textLabel.setColor(color);
            };
            proto.setPlaceHolder = function(text) {
                this._placeholderLabel.setString(text);
            };
            proto.setMaxLength = function(maxLength) {
                if (!this._edTxt) {
                    return;
                }
                this._edTxt.maxLength = maxLength;
            };
            proto._updateDOMPlaceholderFontStyle = function() {
                this._placeholderLabel.setFontFileOrFamily(this._editBox._placeholderFontName);
                this._placeholderLabel.setFontSize(this._editBox._placeholderFontSize);
            };
            proto.setPlaceholderFontColor = function(color) {
                this._placeholderLabel.setColor(color);
            };
            proto._updateDomInputType = function() {
                var inputMode = this._editBox._editBoxInputMode;
                if (inputMode === InputMode.EMAIL_ADDR) {
                    this._edTxt.type = "email";
                } else {
                    if (inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL) {
                        this._edTxt.type = "number";
                    } else {
                        if (inputMode === InputMode.PHONE_NUMBER) {
                            this._edTxt.type = "number";
                            this._edTxt.pattern = "[0-9]*";
                        } else {
                            if (inputMode === InputMode.URL) {
                                this._edTxt.type = "url";
                            } else {
                                this._edTxt.type = "text";
                                this._editBox._keyboardReturnType === KeyboardReturnType.SEARCH && (this._edTxt.type = "search");
                            }
                        }
                    }
                }
                this._editBox._editBoxInputFlag === InputFlag.PASSWORD && (this._edTxt.type = "password");
            };
            proto.setInputFlag = function(inputFlag) {
                if (!this._edTxt) {
                    return;
                }
                this._updateDomInputType();
                this._edTxt.style.textTransform = "none";
                inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? this._edTxt.style.textTransform = "uppercase" : inputFlag === InputFlag.INITIAL_CAPS_WORD && (this._edTxt.style.textTransform = "capitalize");
                this._updateLabelStringStyle();
            };
            proto.setInputMode = function(inputMode) {
                inputMode === InputMode.ANY ? this._createDomTextArea() : this._createDomInput();
                this._updateDomInputType();
                var contentSize = this._node.getContentSize();
                this.updateSize(contentSize.width, contentSize.height);
            };
            proto.setString = function(text) {
                if (!this._edTxt) {
                    return;
                }
                if (null !== text) {
                    this._edTxt.value = text;
                    if ("" === text) {
                        if (this._placeholderLabel) {
                            this._placeholderLabel.setString(this._editBox._placeholderText);
                            this._placeholderLabel.setColor(this._editBox._placeholderColor);
                        }
                        if (!this._editingMode) {
                            this._placeholderLabel && this._placeholderLabel.setVisible(true);
                            this._textLabel && this._textLabel.setVisible(false);
                        }
                    } else {
                        this._edTxt.style.color = cc.colorToHex(this._editBox._textColor);
                        this._textLabel && this._textLabel.setColor(this._editBox._textColor);
                        if (!this._editingMode) {
                            this._placeholderLabel && this._placeholderLabel.setVisible(false);
                            this._textLabel && this._textLabel.setVisible(true);
                        }
                        this._updateLabelStringStyle();
                    }
                }
            };
            proto._updateDOMFontStyle = function() {
                if (!this._edTxt) {
                    return;
                }
                if ("" !== this._edTxt.value) {
                    this._edTxt.style.fontFamily = this._edFontName;
                    this._edTxt.style.fontSize = this._edFontSize + "px";
                }
                if (this._textLabel) {
                    this._textLabel.setFontSize(this._edFontSize);
                    this._textLabel.setFontFileOrFamily(this._edFontName);
                }
            };
            proto.updateSize = function(newWidth, newHeight) {
                var editboxDomNode = this._edTxt;
                if (!editboxDomNode) {
                    return;
                }
                editboxDomNode.style["width"] = newWidth + "px";
                editboxDomNode.style["height"] = newHeight + "px";
                this._updateLabelPosition(cc.size(newWidth, newHeight));
            };
            proto._addDomToGameContainer = function() {
                cc.game.container.appendChild(this._edTxt);
            };
            proto.removeDom = function() {
                var editBox = this._edTxt;
                if (editBox) {
                    var hasChild = Utils.contains(cc.game.container, editBox);
                    hasChild && cc.game.container.removeChild(editBox);
                }
                this._edTxt = null;
            };
            proto.initializeRenderCmd = function(node) {
                this._editBox = node;
                this._edFontSize = 14;
                this._edFontName = "Arial";
                this._textLabel = null;
                this._placeholderLabel = null;
                this._editingMode = false;
                this.__fullscreen = false;
                this.__autoResize = false;
                this.__rotateScreen = false;
                this.__orientationChanged = null;
            };
            _ccsg.EditBox.CanvasRenderCmd = function(node) {
                this._rootCtor(node);
                this.initializeRenderCmd(node);
            };
            var canvasRenderCmdProto = _ccsg.EditBox.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
            cc.js.mixin(canvasRenderCmdProto, proto);
            canvasRenderCmdProto.constructor = _ccsg.EditBox.CanvasRenderCmd;
            canvasRenderCmdProto.transform = function(parentCmd, recursive) {
                this.originTransform(parentCmd, recursive);
                this.updateMatrix();
            };
            _ccsg.EditBox.WebGLRenderCmd = function(node) {
                this._rootCtor(node);
                this.initializeRenderCmd(node);
            };
            var webGLRenderCmdProto = _ccsg.EditBox.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
            cc.js.mixin(webGLRenderCmdProto, proto);
            webGLRenderCmdProto.constructor = _ccsg.EditBox.WebGLRenderCmd;
            webGLRenderCmdProto.transform = function(parentCmd, recursive) {
                this.originTransform(parentCmd, recursive);
                this.updateMatrix();
            };
        })(_ccsg.EditBox._polyfill);
    }), {
        "../platform/utils": 198
    } ],
    105: [ (function(require, module, exports) {
        var JS = cc.js;
        var Event = cc.Event;
        var EventMouse = function(eventType, bubbles) {
            cc.Event.call(this, cc.Event.MOUSE, bubbles);
            this._eventType = eventType;
            this._button = 0;
            this._x = 0;
            this._y = 0;
            this._prevX = 0;
            this._prevY = 0;
            this._scrollX = 0;
            this._scrollY = 0;
        };
        JS.extend(EventMouse, cc.Event);
        var proto = EventMouse.prototype;
        proto.setScrollData = function(scrollX, scrollY) {
            this._scrollX = scrollX;
            this._scrollY = scrollY;
        };
        proto.getScrollX = function() {
            return this._scrollX;
        };
        proto.getScrollY = function() {
            return this._scrollY;
        };
        proto.setLocation = function(x, y) {
            this._x = x;
            this._y = y;
        };
        proto.getLocation = function() {
            return {
                x: this._x,
                y: this._y
            };
        };
        proto.getLocationInView = function() {
            return {
                x: this._x,
                y: cc.view._designResolutionSize.height - this._y
            };
        };
        proto._setPrevCursor = function(x, y) {
            this._prevX = x;
            this._prevY = y;
        };
        proto.getPreviousLocation = function() {
            return {
                x: this._prevX,
                y: this._prevY
            };
        };
        proto.getDelta = function() {
            return {
                x: this._x - this._prevX,
                y: this._y - this._prevY
            };
        };
        proto.getDeltaX = function() {
            return this._x - this._prevX;
        };
        proto.getDeltaY = function() {
            return this._y - this._prevY;
        };
        proto.setButton = function(button) {
            this._button = button;
        };
        proto.getButton = function() {
            return this._button;
        };
        proto.getLocationX = function() {
            return this._x;
        };
        proto.getLocationY = function() {
            return this._y;
        };
        EventMouse.NONE = 0;
        EventMouse.DOWN = 1;
        EventMouse.UP = 2;
        EventMouse.MOVE = 3;
        EventMouse.SCROLL = 4;
        EventMouse.BUTTON_LEFT = 0;
        EventMouse.BUTTON_RIGHT = 2;
        EventMouse.BUTTON_MIDDLE = 1;
        EventMouse.BUTTON_4 = 3;
        EventMouse.BUTTON_5 = 4;
        EventMouse.BUTTON_6 = 5;
        EventMouse.BUTTON_7 = 6;
        EventMouse.BUTTON_8 = 7;
        var EventTouch = function(touchArr, bubbles) {
            cc.Event.call(this, cc.Event.TOUCH, bubbles);
            this._eventCode = 0;
            this._touches = touchArr || [];
            this.currentTouch = null;
        };
        JS.extend(EventTouch, cc.Event);
        proto = EventTouch.prototype;
        proto.getEventCode = function() {
            return this._eventCode;
        };
        proto.getTouches = function() {
            return this._touches;
        };
        proto._setEventCode = function(eventCode) {
            this._eventCode = eventCode;
        };
        proto._setTouches = function(touches) {
            this._touches = touches;
        };
        proto.setLocation = function(x, y) {
            this.touch && this.touch.setTouchInfo(this.touch.getID(), x, y);
        };
        proto.getLocation = function() {
            return this.touch ? this.touch.getLocation() : cc.v2();
        };
        proto.getLocationInView = function() {
            return this.touch ? this.touch.getLocationInView() : cc.v2();
        };
        proto.getPreviousLocation = function() {
            return this.touch ? this.touch.getPreviousLocation() : cc.v2();
        };
        proto.getStartLocation = function() {
            return this.touch ? this.touch.getStartLocation() : cc.v2();
        };
        proto.getID = function() {
            return this.touch ? this.touch.getID() : null;
        };
        proto.getDelta = function() {
            return this.touch ? this.touch.getDelta() : cc.v2();
        };
        proto.getDeltaX = function() {
            return this.touch ? this.touch.getDelta().x : 0;
        };
        proto.getDeltaY = function() {
            return this.touch ? this.touch.getDelta().y : 0;
        };
        proto.getLocationX = function() {
            return this.touch ? this.touch.getLocationX() : 0;
        };
        proto.getLocationY = function() {
            return this.touch ? this.touch.getLocationY() : 0;
        };
        EventTouch.MAX_TOUCHES = 5;
        EventTouch.BEGAN = 0;
        EventTouch.MOVED = 1;
        EventTouch.ENDED = 2;
        EventTouch.CANCELED = 3;
        var EventAcceleration = function(acc, bubbles) {
            cc.Event.call(this, Event.ACCELERATION, bubbles);
            this.acc = acc;
        };
        JS.extend(EventAcceleration, cc.Event);
        var EventKeyboard = function(keyCode, isPressed, bubbles) {
            cc.Event.call(this, Event.KEYBOARD, bubbles);
            this.keyCode = keyCode;
            this.isPressed = isPressed;
        };
        JS.extend(EventKeyboard, cc.Event);
        cc.Event.EventMouse = EventMouse;
        cc.Event.EventTouch = EventTouch;
        cc.Event.EventAcceleration = EventAcceleration;
        cc.Event.EventKeyboard = EventKeyboard;
        module.exports = Event;
    }), {} ],
    106: [ (function(require, module, exports) {
        cc.EventListener = cc._Class.extend({
            ctor: function(type, listenerID, callback) {
                this._onEvent = callback;
                this._type = type || 0;
                this._listenerID = listenerID || "";
                this._registered = false;
                this._fixedPriority = 0;
                this._node = null;
                this._target = null;
                this._paused = true;
                this._isEnabled = true;
            },
            _setPaused: function(paused) {
                this._paused = paused;
            },
            _isPaused: function() {
                return this._paused;
            },
            _setRegistered: function(registered) {
                this._registered = registered;
            },
            _isRegistered: function() {
                return this._registered;
            },
            _getType: function() {
                return this._type;
            },
            _getListenerID: function() {
                return this._listenerID;
            },
            _setFixedPriority: function(fixedPriority) {
                this._fixedPriority = fixedPriority;
            },
            _getFixedPriority: function() {
                return this._fixedPriority;
            },
            _setSceneGraphPriority: function(node) {
                this._target = node;
                this._node = node;
            },
            _getSceneGraphPriority: function() {
                return this._node;
            },
            checkAvailable: function() {
                return null !== this._onEvent;
            },
            clone: function() {
                return null;
            },
            setEnabled: function(enabled) {
                this._isEnabled = enabled;
            },
            isEnabled: function() {
                return this._isEnabled;
            },
            retain: function() {},
            release: function() {}
        });
        cc.EventListener.UNKNOWN = 0;
        cc.EventListener.TOUCH_ONE_BY_ONE = 1;
        cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
        cc.EventListener.KEYBOARD = 3;
        cc.EventListener.MOUSE = 4;
        cc.EventListener.ACCELERATION = 6;
        cc.EventListener.CUSTOM = 8;
        cc._EventListenerCustom = cc.EventListener.extend({
            _onCustomEvent: null,
            ctor: function(listenerId, callback) {
                this._onCustomEvent = callback;
                cc.EventListener.prototype.ctor.call(this, cc.EventListener.CUSTOM, listenerId, this._callback);
            },
            _callback: function(event) {
                null !== this._onCustomEvent && this._onCustomEvent(event);
            },
            checkAvailable: function() {
                return cc.EventListener.prototype.checkAvailable.call(this) && null !== this._onCustomEvent;
            },
            clone: function() {
                return new cc._EventListenerCustom(this._listenerID, this._onCustomEvent);
            }
        });
        cc._EventListenerMouse = cc.EventListener.extend({
            onMouseDown: null,
            onMouseUp: null,
            onMouseMove: null,
            onMouseScroll: null,
            ctor: function() {
                cc.EventListener.prototype.ctor.call(this, cc.EventListener.MOUSE, cc._EventListenerMouse.LISTENER_ID, this._callback);
            },
            _callback: function(event) {
                var eventType = cc.Event.EventMouse;
                switch (event._eventType) {
                  case eventType.DOWN:
                    this.onMouseDown && this.onMouseDown(event);
                    break;

                  case eventType.UP:
                    this.onMouseUp && this.onMouseUp(event);
                    break;

                  case eventType.MOVE:
                    this.onMouseMove && this.onMouseMove(event);
                    break;

                  case eventType.SCROLL:
                    this.onMouseScroll && this.onMouseScroll(event);
                }
            },
            clone: function() {
                var eventListener = new cc._EventListenerMouse();
                eventListener.onMouseDown = this.onMouseDown;
                eventListener.onMouseUp = this.onMouseUp;
                eventListener.onMouseMove = this.onMouseMove;
                eventListener.onMouseScroll = this.onMouseScroll;
                return eventListener;
            },
            checkAvailable: function() {
                return true;
            }
        });
        cc._EventListenerMouse.LISTENER_ID = "__cc_mouse";
        cc._EventListenerTouchOneByOne = cc.EventListener.extend({
            _claimedTouches: null,
            swallowTouches: false,
            onTouchBegan: null,
            onTouchMoved: null,
            onTouchEnded: null,
            onTouchCancelled: null,
            ctor: function() {
                cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, cc._EventListenerTouchOneByOne.LISTENER_ID, null);
                this._claimedTouches = [];
            },
            setSwallowTouches: function(needSwallow) {
                this.swallowTouches = needSwallow;
            },
            isSwallowTouches: function() {
                return this.swallowTouches;
            },
            clone: function() {
                var eventListener = new cc._EventListenerTouchOneByOne();
                eventListener.onTouchBegan = this.onTouchBegan;
                eventListener.onTouchMoved = this.onTouchMoved;
                eventListener.onTouchEnded = this.onTouchEnded;
                eventListener.onTouchCancelled = this.onTouchCancelled;
                eventListener.swallowTouches = this.swallowTouches;
                return eventListener;
            },
            checkAvailable: function() {
                if (!this.onTouchBegan) {
                    cc.logID(1801);
                    return false;
                }
                return true;
            }
        });
        cc._EventListenerTouchOneByOne.LISTENER_ID = "__cc_touch_one_by_one";
        cc._EventListenerTouchAllAtOnce = cc.EventListener.extend({
            onTouchesBegan: null,
            onTouchesMoved: null,
            onTouchesEnded: null,
            onTouchesCancelled: null,
            ctor: function() {
                cc.EventListener.prototype.ctor.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, cc._EventListenerTouchAllAtOnce.LISTENER_ID, null);
            },
            clone: function() {
                var eventListener = new cc._EventListenerTouchAllAtOnce();
                eventListener.onTouchesBegan = this.onTouchesBegan;
                eventListener.onTouchesMoved = this.onTouchesMoved;
                eventListener.onTouchesEnded = this.onTouchesEnded;
                eventListener.onTouchesCancelled = this.onTouchesCancelled;
                return eventListener;
            },
            checkAvailable: function() {
                if (null === this.onTouchesBegan && null === this.onTouchesMoved && null === this.onTouchesEnded && null === this.onTouchesCancelled) {
                    cc.logID(1802);
                    return false;
                }
                return true;
            }
        });
        cc._EventListenerTouchAllAtOnce.LISTENER_ID = "__cc_touch_all_at_once";
        cc.EventListener.create = function(argObj) {
            cc.assertID(argObj && argObj.event, 1900);
            var listenerType = argObj.event;
            delete argObj.event;
            var listener = null;
            if (listenerType === cc.EventListener.TOUCH_ONE_BY_ONE) {
                listener = new cc._EventListenerTouchOneByOne();
            } else {
                if (listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE) {
                    listener = new cc._EventListenerTouchAllAtOnce();
                } else {
                    if (listenerType === cc.EventListener.MOUSE) {
                        listener = new cc._EventListenerMouse();
                    } else {
                        if (listenerType === cc.EventListener.CUSTOM) {
                            listener = new cc._EventListenerCustom(argObj.eventName, argObj.callback);
                            delete argObj.eventName;
                            delete argObj.callback;
                        } else {
                            if (listenerType === cc.EventListener.KEYBOARD) {
                                listener = new cc._EventListenerKeyboard();
                            } else {
                                if (listenerType === cc.EventListener.ACCELERATION) {
                                    listener = new cc._EventListenerAcceleration(argObj.callback);
                                    delete argObj.callback;
                                }
                            }
                        }
                    }
                }
            }
            for (var key in argObj) {
                listener[key] = argObj[key];
            }
            return listener;
        };
        cc._EventListenerAcceleration = cc.EventListener.extend({
            _onAccelerationEvent: null,
            ctor: function(callback) {
                this._onAccelerationEvent = callback;
                cc.EventListener.prototype.ctor.call(this, cc.EventListener.ACCELERATION, cc._EventListenerAcceleration.LISTENER_ID, this._callback);
            },
            _callback: function(event) {
                this._onAccelerationEvent(event.acc, event);
            },
            checkAvailable: function() {
                cc.assertID(this._onAccelerationEvent, 1803);
                return true;
            },
            clone: function() {
                return new cc._EventListenerAcceleration(this._onAccelerationEvent);
            }
        });
        cc._EventListenerAcceleration.LISTENER_ID = "__cc_acceleration";
        cc._EventListenerKeyboard = cc.EventListener.extend({
            onKeyPressed: null,
            onKeyReleased: null,
            ctor: function() {
                cc.EventListener.prototype.ctor.call(this, cc.EventListener.KEYBOARD, cc._EventListenerKeyboard.LISTENER_ID, this._callback);
            },
            _callback: function(event) {
                event.isPressed ? this.onKeyPressed && this.onKeyPressed(event.keyCode, event) : this.onKeyReleased && this.onKeyReleased(event.keyCode, event);
            },
            clone: function() {
                var eventListener = new cc._EventListenerKeyboard();
                eventListener.onKeyPressed = this.onKeyPressed;
                eventListener.onKeyReleased = this.onKeyReleased;
                return eventListener;
            },
            checkAvailable: function() {
                if (null === this.onKeyPressed && null === this.onKeyReleased) {
                    cc.logID(1800);
                    return false;
                }
                return true;
            }
        });
        cc._EventListenerKeyboard.LISTENER_ID = "__cc_keyboard";
    }), {} ],
    107: [ (function(require, module, exports) {
        var _EventListenerVector = cc._Class.extend({
            ctor: function() {
                this._fixedListeners = [];
                this._sceneGraphListeners = [];
                this.gt0Index = 0;
            },
            size: function() {
                return this._fixedListeners.length + this._sceneGraphListeners.length;
            },
            empty: function() {
                return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length;
            },
            push: function(listener) {
                0 === listener._getFixedPriority() ? this._sceneGraphListeners.push(listener) : this._fixedListeners.push(listener);
            },
            clearSceneGraphListeners: function() {
                this._sceneGraphListeners.length = 0;
            },
            clearFixedListeners: function() {
                this._fixedListeners.length = 0;
            },
            clear: function() {
                this._sceneGraphListeners.length = 0;
                this._fixedListeners.length = 0;
            },
            getFixedPriorityListeners: function() {
                return this._fixedListeners;
            },
            getSceneGraphPriorityListeners: function() {
                return this._sceneGraphListeners;
            }
        });
        var __getListenerID = function(event) {
            var eventType = cc.Event, type = event.type;
            if (type === eventType.ACCELERATION) {
                return cc._EventListenerAcceleration.LISTENER_ID;
            }
            if (type === eventType.KEYBOARD) {
                return cc._EventListenerKeyboard.LISTENER_ID;
            }
            if (type.startsWith(eventType.MOUSE)) {
                return cc._EventListenerMouse.LISTENER_ID;
            }
            type.startsWith(eventType.TOUCH) && cc.logID(2e3);
            return "";
        };
        cc.eventManager = {
            DIRTY_NONE: 0,
            DIRTY_FIXED_PRIORITY: 1,
            DIRTY_SCENE_GRAPH_PRIORITY: 2,
            DIRTY_ALL: 3,
            _listenersMap: {},
            _priorityDirtyFlagMap: {},
            _nodeListenersMap: {},
            _nodePriorityMap: {},
            _globalZOrderNodeMap: {},
            _toAddedListeners: [],
            _toRemovedListeners: [],
            _dirtyNodes: [],
            _inDispatch: 0,
            _isEnabled: false,
            _nodePriorityIndex: 0,
            _internalCustomListenerIDs: [],
            _setDirtyForNode: function(node) {
                void 0 !== this._nodeListenersMap[node.__instanceId] && this._dirtyNodes.push(node);
                if (node.getChildren) {
                    var _children = node.getChildren();
                    for (var i = 0, len = _children ? _children.length : 0; i < len; i++) {
                        this._setDirtyForNode(_children[i]);
                    }
                }
            },
            pauseTarget: function(node, recursive) {
                if (!(node instanceof cc._BaseNode || node instanceof _ccsg.Node)) {
                    cc.warnID(3506);
                    return;
                }
                var listeners = this._nodeListenersMap[node.__instanceId], i, len;
                if (listeners) {
                    for (i = 0, len = listeners.length; i < len; i++) {
                        listeners[i]._setPaused(true);
                    }
                }
                if (true === recursive) {
                    var locChildren = node.getChildren();
                    for (i = 0, len = locChildren ? locChildren.length : 0; i < len; i++) {
                        this.pauseTarget(locChildren[i], true);
                    }
                }
            },
            resumeTarget: function(node, recursive) {
                if (!(node instanceof cc._BaseNode || node instanceof _ccsg.Node)) {
                    cc.warnID(3506);
                    return;
                }
                var listeners = this._nodeListenersMap[node.__instanceId], i, len;
                if (listeners) {
                    for (i = 0, len = listeners.length; i < len; i++) {
                        listeners[i]._setPaused(false);
                    }
                }
                this._setDirtyForNode(node);
                if (true === recursive && node.getChildren) {
                    var locChildren = node.getChildren();
                    for (i = 0, len = locChildren ? locChildren.length : 0; i < len; i++) {
                        this.resumeTarget(locChildren[i], true);
                    }
                }
            },
            _addListener: function(listener) {
                0 === this._inDispatch ? this._forceAddEventListener(listener) : this._toAddedListeners.push(listener);
            },
            _forceAddEventListener: function(listener) {
                var listenerID = listener._getListenerID();
                var listeners = this._listenersMap[listenerID];
                if (!listeners) {
                    listeners = new _EventListenerVector();
                    this._listenersMap[listenerID] = listeners;
                }
                listeners.push(listener);
                if (0 === listener._getFixedPriority()) {
                    this._setDirty(listenerID, this.DIRTY_SCENE_GRAPH_PRIORITY);
                    var node = listener._getSceneGraphPriority();
                    null === node && cc.logID(3507);
                    this._associateNodeAndEventListener(node, listener);
                    node.isRunning() && this.resumeTarget(node);
                } else {
                    this._setDirty(listenerID, this.DIRTY_FIXED_PRIORITY);
                }
            },
            _getListeners: function(listenerID) {
                return this._listenersMap[listenerID];
            },
            _updateDirtyFlagForSceneGraph: function() {
                if (0 === this._dirtyNodes.length) {
                    return;
                }
                var locDirtyNodes = this._dirtyNodes, selListeners, selListener, locNodeListenersMap = this._nodeListenersMap;
                for (var i = 0, len = locDirtyNodes.length; i < len; i++) {
                    selListeners = locNodeListenersMap[locDirtyNodes[i].__instanceId];
                    if (selListeners) {
                        for (var j = 0, listenersLen = selListeners.length; j < listenersLen; j++) {
                            selListener = selListeners[j];
                            selListener && this._setDirty(selListener._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
                        }
                    }
                }
                this._dirtyNodes.length = 0;
            },
            _removeAllListenersInVector: function(listenerVector) {
                if (!listenerVector) {
                    return;
                }
                var selListener;
                for (var i = 0; i < listenerVector.length; ) {
                    selListener = listenerVector[i];
                    selListener._setRegistered(false);
                    if (null != selListener._getSceneGraphPriority()) {
                        this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
                        selListener._setSceneGraphPriority(null);
                    }
                    0 === this._inDispatch ? cc.js.array.remove(listenerVector, selListener) : ++i;
                }
            },
            _removeListenersForListenerID: function(listenerID) {
                var listeners = this._listenersMap[listenerID], i;
                if (listeners) {
                    var fixedPriorityListeners = listeners.getFixedPriorityListeners();
                    var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                    this._removeAllListenersInVector(sceneGraphPriorityListeners);
                    this._removeAllListenersInVector(fixedPriorityListeners);
                    delete this._priorityDirtyFlagMap[listenerID];
                    if (!this._inDispatch) {
                        listeners.clear();
                        delete this._listenersMap[listenerID];
                    }
                }
                var locToAddedListeners = this._toAddedListeners, listener;
                for (i = 0; i < locToAddedListeners.length; ) {
                    listener = locToAddedListeners[i];
                    listener && listener._getListenerID() === listenerID ? cc.js.array.remove(locToAddedListeners, listener) : ++i;
                }
            },
            _sortEventListeners: function(listenerID) {
                var dirtyFlag = this.DIRTY_NONE, locFlagMap = this._priorityDirtyFlagMap;
                locFlagMap[listenerID] && (dirtyFlag = locFlagMap[listenerID]);
                if (dirtyFlag !== this.DIRTY_NONE) {
                    locFlagMap[listenerID] = this.DIRTY_NONE;
                    dirtyFlag & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(listenerID);
                    if (dirtyFlag & this.DIRTY_SCENE_GRAPH_PRIORITY) {
                        var rootEntity = cc.director.getScene();
                        rootEntity && this._sortListenersOfSceneGraphPriority(listenerID, rootEntity);
                    }
                }
            },
            _sortListenersOfSceneGraphPriority: function(listenerID, rootNode) {
                var listeners = this._getListeners(listenerID);
                if (!listeners) {
                    return;
                }
                var sceneGraphListener = listeners.getSceneGraphPriorityListeners();
                if (!sceneGraphListener || 0 === sceneGraphListener.length) {
                    return;
                }
                this._nodePriorityIndex = 0;
                this._nodePriorityMap = {};
                this._visitTarget(rootNode, true);
                listeners.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes);
            },
            _sortEventListenersOfSceneGraphPriorityDes: function(l1, l2) {
                var locNodePriorityMap = cc.eventManager._nodePriorityMap, node1 = l1._getSceneGraphPriority(), node2 = l2._getSceneGraphPriority();
                if (!(l2 && node2 && locNodePriorityMap[node2.__instanceId])) {
                    return -1;
                }
                if (!l1 || !node1 || !locNodePriorityMap[node1.__instanceId]) {
                    return 1;
                }
                return locNodePriorityMap[node2.__instanceId] - locNodePriorityMap[node1.__instanceId];
            },
            _sortListenersOfFixedPriority: function(listenerID) {
                var listeners = this._listenersMap[listenerID];
                if (!listeners) {
                    return;
                }
                var fixedListeners = listeners.getFixedPriorityListeners();
                if (!fixedListeners || 0 === fixedListeners.length) {
                    return;
                }
                fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
                var index = 0;
                for (var len = fixedListeners.length; index < len; ) {
                    if (fixedListeners[index]._getFixedPriority() >= 0) {
                        break;
                    }
                    ++index;
                }
                listeners.gt0Index = index;
            },
            _sortListenersOfFixedPriorityAsc: function(l1, l2) {
                return l1._getFixedPriority() - l2._getFixedPriority();
            },
            _onUpdateListeners: function(listeners) {
                var fixedPriorityListeners = listeners.getFixedPriorityListeners();
                var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                var i, selListener, idx, toRemovedListeners = this._toRemovedListeners;
                if (sceneGraphPriorityListeners) {
                    for (i = 0; i < sceneGraphPriorityListeners.length; ) {
                        selListener = sceneGraphPriorityListeners[i];
                        if (selListener._isRegistered()) {
                            ++i;
                        } else {
                            cc.js.array.remove(sceneGraphPriorityListeners, selListener);
                            idx = toRemovedListeners.indexOf(selListener);
                            idx !== -1 && toRemovedListeners.splice(idx, 1);
                        }
                    }
                }
                if (fixedPriorityListeners) {
                    for (i = 0; i < fixedPriorityListeners.length; ) {
                        selListener = fixedPriorityListeners[i];
                        if (selListener._isRegistered()) {
                            ++i;
                        } else {
                            cc.js.array.remove(fixedPriorityListeners, selListener);
                            idx = toRemovedListeners.indexOf(selListener);
                            idx !== -1 && toRemovedListeners.splice(idx, 1);
                        }
                    }
                }
                sceneGraphPriorityListeners && 0 === sceneGraphPriorityListeners.length && listeners.clearSceneGraphListeners();
                fixedPriorityListeners && 0 === fixedPriorityListeners.length && listeners.clearFixedListeners();
            },
            frameUpdateListeners: function() {
                var locListenersMap = this._listenersMap, locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;
                for (var selKey in locListenersMap) {
                    if (locListenersMap[selKey].empty()) {
                        delete locPriorityDirtyFlagMap[selKey];
                        delete locListenersMap[selKey];
                    }
                }
                var locToAddedListeners = this._toAddedListeners;
                if (0 !== locToAddedListeners.length) {
                    for (var i = 0, len = locToAddedListeners.length; i < len; i++) {
                        this._forceAddEventListener(locToAddedListeners[i]);
                    }
                    locToAddedListeners.length = 0;
                }
                0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
            },
            _updateTouchListeners: function(event) {
                var locInDispatch = this._inDispatch;
                cc.assertID(locInDispatch > 0, 3508);
                if (locInDispatch > 1) {
                    return;
                }
                var listeners;
                listeners = this._listenersMap[cc._EventListenerTouchOneByOne.LISTENER_ID];
                listeners && this._onUpdateListeners(listeners);
                listeners = this._listenersMap[cc._EventListenerTouchAllAtOnce.LISTENER_ID];
                listeners && this._onUpdateListeners(listeners);
                cc.assertID(1 === locInDispatch, 3509);
                var locToAddedListeners = this._toAddedListeners;
                if (0 !== locToAddedListeners.length) {
                    for (var i = 0, len = locToAddedListeners.length; i < len; i++) {
                        this._forceAddEventListener(locToAddedListeners[i]);
                    }
                    this._toAddedListeners.length = 0;
                }
                0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
            },
            _cleanToRemovedListeners: function() {
                var toRemovedListeners = this._toRemovedListeners;
                for (var i = 0; i < toRemovedListeners.length; i++) {
                    var selListener = toRemovedListeners[i];
                    var listeners = this._listenersMap[selListener._getListenerID()];
                    if (!listeners) {
                        continue;
                    }
                    var idx, fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                    if (sceneGraphPriorityListeners) {
                        idx = sceneGraphPriorityListeners.indexOf(selListener);
                        idx !== -1 && sceneGraphPriorityListeners.splice(idx, 1);
                    }
                    if (fixedPriorityListeners) {
                        idx = fixedPriorityListeners.indexOf(selListener);
                        idx !== -1 && fixedPriorityListeners.splice(idx, 1);
                    }
                }
                toRemovedListeners.length = 0;
            },
            _onTouchEventCallback: function(listener, argsObj) {
                if (!listener._isRegistered) {
                    return false;
                }
                var event = argsObj.event, selTouch = event.currentTouch;
                event.currentTarget = listener._node;
                var isClaimed = false, removedIdx;
                var getCode = event.getEventCode(), EventTouch = cc.Event.EventTouch;
                if (getCode === EventTouch.BEGAN) {
                    if (listener.onTouchBegan) {
                        isClaimed = listener.onTouchBegan(selTouch, event);
                        isClaimed && listener._registered && listener._claimedTouches.push(selTouch);
                    }
                } else {
                    if (listener._claimedTouches.length > 0 && (removedIdx = listener._claimedTouches.indexOf(selTouch)) !== -1) {
                        isClaimed = true;
                        if (getCode === EventTouch.MOVED && listener.onTouchMoved) {
                            listener.onTouchMoved(selTouch, event);
                        } else {
                            if (getCode === EventTouch.ENDED) {
                                listener.onTouchEnded && listener.onTouchEnded(selTouch, event);
                                listener._registered && listener._claimedTouches.splice(removedIdx, 1);
                            } else {
                                if (getCode === EventTouch.CANCELLED) {
                                    listener.onTouchCancelled && listener.onTouchCancelled(selTouch, event);
                                    listener._registered && listener._claimedTouches.splice(removedIdx, 1);
                                }
                            }
                        }
                    }
                }
                if (event.isStopped()) {
                    cc.eventManager._updateTouchListeners(event);
                    return true;
                }
                if (isClaimed && listener._registered && listener.swallowTouches) {
                    argsObj.needsMutableSet && argsObj.touches.splice(selTouch, 1);
                    return true;
                }
                return false;
            },
            _dispatchTouchEvent: function(event) {
                this._sortEventListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
                this._sortEventListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
                var oneByOneListeners = this._getListeners(cc._EventListenerTouchOneByOne.LISTENER_ID);
                var allAtOnceListeners = this._getListeners(cc._EventListenerTouchAllAtOnce.LISTENER_ID);
                if (null === oneByOneListeners && null === allAtOnceListeners) {
                    return;
                }
                var originalTouches = event.getTouches(), mutableTouches = cc.js.array.copy(originalTouches);
                var oneByOneArgsObj = {
                    event: event,
                    needsMutableSet: oneByOneListeners && allAtOnceListeners,
                    touches: mutableTouches,
                    selTouch: null
                };
                if (oneByOneListeners) {
                    for (var i = 0; i < originalTouches.length; i++) {
                        event.currentTouch = originalTouches[i];
                        this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
                        if (event.isStopped()) {
                            return;
                        }
                    }
                }
                if (allAtOnceListeners && mutableTouches.length > 0) {
                    this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {
                        event: event,
                        touches: mutableTouches
                    });
                    if (event.isStopped()) {
                        return;
                    }
                }
                this._updateTouchListeners(event);
            },
            _onTouchesEventCallback: function(listener, callbackParams) {
                if (!listener._registered) {
                    return false;
                }
                var EventTouch = cc.Event.EventTouch, event = callbackParams.event, touches = callbackParams.touches, getCode = event.getEventCode();
                event.currentTarget = listener._node;
                getCode === EventTouch.BEGAN && listener.onTouchesBegan ? listener.onTouchesBegan(touches, event) : getCode === EventTouch.MOVED && listener.onTouchesMoved ? listener.onTouchesMoved(touches, event) : getCode === EventTouch.ENDED && listener.onTouchesEnded ? listener.onTouchesEnded(touches, event) : getCode === EventTouch.CANCELLED && listener.onTouchesCancelled && listener.onTouchesCancelled(touches, event);
                if (event.isStopped()) {
                    cc.eventManager._updateTouchListeners(event);
                    return true;
                }
                return false;
            },
            _associateNodeAndEventListener: function(node, listener) {
                var listeners = this._nodeListenersMap[node.__instanceId];
                if (!listeners) {
                    listeners = [];
                    this._nodeListenersMap[node.__instanceId] = listeners;
                }
                listeners.push(listener);
            },
            _dissociateNodeAndEventListener: function(node, listener) {
                var listeners = this._nodeListenersMap[node.__instanceId];
                if (listeners) {
                    cc.js.array.remove(listeners, listener);
                    0 === listeners.length && delete this._nodeListenersMap[node.__instanceId];
                }
            },
            _dispatchEventToListeners: function(listeners, onEvent, eventOrArgs) {
                var shouldStopPropagation = false;
                var fixedPriorityListeners = listeners.getFixedPriorityListeners();
                var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                var i = 0, j, selListener;
                if (fixedPriorityListeners && 0 !== fixedPriorityListeners.length) {
                    for (;i < listeners.gt0Index; ++i) {
                        selListener = fixedPriorityListeners[i];
                        if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                            shouldStopPropagation = true;
                            break;
                        }
                    }
                }
                if (sceneGraphPriorityListeners && !shouldStopPropagation) {
                    for (j = 0; j < sceneGraphPriorityListeners.length; j++) {
                        selListener = sceneGraphPriorityListeners[j];
                        if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                            shouldStopPropagation = true;
                            break;
                        }
                    }
                }
                if (fixedPriorityListeners && !shouldStopPropagation) {
                    for (;i < fixedPriorityListeners.length; ++i) {
                        selListener = fixedPriorityListeners[i];
                        if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                            shouldStopPropagation = true;
                            break;
                        }
                    }
                }
            },
            _setDirty: function(listenerID, flag) {
                var locDirtyFlagMap = this._priorityDirtyFlagMap;
                null == locDirtyFlagMap[listenerID] ? locDirtyFlagMap[listenerID] = flag : locDirtyFlagMap[listenerID] = flag | locDirtyFlagMap[listenerID];
            },
            _visitTarget: function(node, isRootNode) {
                node._reorderChildDirty && node.sortAllChildren();
                var children = node.getChildren(), i = 0;
                var childrenCount = children.length, locGlobalZOrderNodeMap = this._globalZOrderNodeMap, locNodeListenersMap = this._nodeListenersMap;
                if (childrenCount > 0) {
                    var child;
                    for (;i < childrenCount; i++) {
                        child = children[i];
                        if (!(child && child.getLocalZOrder() < 0)) {
                            break;
                        }
                        this._visitTarget(child, false);
                    }
                    if (void 0 !== locNodeListenersMap[node.__instanceId]) {
                        locGlobalZOrderNodeMap[node.getGlobalZOrder()] || (locGlobalZOrderNodeMap[node.getGlobalZOrder()] = []);
                        locGlobalZOrderNodeMap[node.getGlobalZOrder()].push(node.__instanceId);
                    }
                    for (;i < childrenCount; i++) {
                        child = children[i];
                        child && this._visitTarget(child, false);
                    }
                } else {
                    if (void 0 !== locNodeListenersMap[node.__instanceId]) {
                        locGlobalZOrderNodeMap[node.getGlobalZOrder()] || (locGlobalZOrderNodeMap[node.getGlobalZOrder()] = []);
                        locGlobalZOrderNodeMap[node.getGlobalZOrder()].push(node.__instanceId);
                    }
                }
                if (isRootNode) {
                    var globalZOrders = [];
                    for (var selKey in locGlobalZOrderNodeMap) {
                        globalZOrders.push(selKey);
                    }
                    globalZOrders.sort(this._sortNumberAsc);
                    var zOrdersLen = globalZOrders.length, selZOrders, j, locNodePriorityMap = this._nodePriorityMap;
                    for (i = 0; i < zOrdersLen; i++) {
                        selZOrders = locGlobalZOrderNodeMap[globalZOrders[i]];
                        for (j = 0; j < selZOrders.length; j++) {
                            locNodePriorityMap[selZOrders[j]] = ++this._nodePriorityIndex;
                        }
                    }
                    this._globalZOrderNodeMap = {};
                }
            },
            _sortNumberAsc: function(a, b) {
                return a - b;
            },
            hasEventListener: function(listenerID) {
                return !!this._getListeners(listenerID);
            },
            addListener: function(listener, nodeOrPriority) {
                cc.assertID(listener && nodeOrPriority, 3503);
                if (!(cc.js.isNumber(nodeOrPriority) || nodeOrPriority instanceof cc._BaseNode || nodeOrPriority instanceof _ccsg.Node)) {
                    cc.warnID(3506);
                    return;
                }
                if (listener instanceof cc.EventListener) {
                    if (listener._isRegistered()) {
                        cc.logID(3505);
                        return;
                    }
                } else {
                    cc.assertID(!cc.js.isNumber(nodeOrPriority), 3504);
                    listener = cc.EventListener.create(listener);
                }
                if (!listener.checkAvailable()) {
                    return;
                }
                if (cc.js.isNumber(nodeOrPriority)) {
                    if (0 === nodeOrPriority) {
                        cc.logID(3500);
                        return;
                    }
                    listener._setSceneGraphPriority(null);
                    listener._setFixedPriority(nodeOrPriority);
                    listener._setRegistered(true);
                    listener._setPaused(false);
                    this._addListener(listener);
                } else {
                    listener._setSceneGraphPriority(nodeOrPriority);
                    listener._setFixedPriority(0);
                    listener._setRegistered(true);
                    this._addListener(listener);
                }
                return listener;
            },
            addCustomListener: function(eventName, callback) {
                var listener = new cc._EventListenerCustom(eventName, callback);
                this.addListener(listener, 1);
                return listener;
            },
            removeListener: function(listener) {
                if (null == listener) {
                    return;
                }
                var isFound, locListener = this._listenersMap;
                for (var selKey in locListener) {
                    var listeners = locListener[selKey];
                    var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                    isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener);
                    if (isFound) {
                        this._setDirty(listener._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY);
                    } else {
                        isFound = this._removeListenerInVector(fixedPriorityListeners, listener);
                        isFound && this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
                    }
                    if (listeners.empty()) {
                        delete this._priorityDirtyFlagMap[listener._getListenerID()];
                        delete locListener[selKey];
                    }
                    if (isFound) {
                        break;
                    }
                }
                if (!isFound) {
                    var locToAddedListeners = this._toAddedListeners;
                    for (var i = 0, len = locToAddedListeners.length; i < len; i++) {
                        var selListener = locToAddedListeners[i];
                        if (selListener === listener) {
                            cc.js.array.remove(locToAddedListeners, selListener);
                            selListener._setRegistered(false);
                            break;
                        }
                    }
                }
            },
            _removeListenerInCallback: function(listeners, callback) {
                if (null == listeners) {
                    return false;
                }
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var selListener = listeners[i];
                    if (selListener._onCustomEvent === callback || selListener._onEvent === callback) {
                        selListener._setRegistered(false);
                        if (null != selListener._getSceneGraphPriority()) {
                            this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
                            selListener._setSceneGraphPriority(null);
                        }
                        0 === this._inDispatch ? cc.js.array.remove(listeners, selListener) : this._toRemovedListeners.push(selListener);
                        return true;
                    }
                }
                return false;
            },
            _removeListenerInVector: function(listeners, listener) {
                if (null == listeners) {
                    return false;
                }
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var selListener = listeners[i];
                    if (selListener === listener) {
                        selListener._setRegistered(false);
                        if (null != selListener._getSceneGraphPriority()) {
                            this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
                            selListener._setSceneGraphPriority(null);
                        }
                        0 === this._inDispatch ? cc.js.array.remove(listeners, selListener) : this._toRemovedListeners.push(selListener);
                        return true;
                    }
                }
                return false;
            },
            removeListeners: function(listenerType, recursive) {
                var i, _t = this;
                if (!(cc.js.isNumber(listenerType) || listenerType instanceof cc._BaseNode || listenerType instanceof _ccsg.Node)) {
                    cc.warnID(3506);
                    return;
                }
                if (void 0 !== listenerType.__instanceId) {
                    delete _t._nodePriorityMap[listenerType.__instanceId];
                    cc.js.array.remove(_t._dirtyNodes, listenerType);
                    var listeners = _t._nodeListenersMap[listenerType.__instanceId], i;
                    if (listeners) {
                        var listenersCopy = cc.js.array.copy(listeners);
                        for (i = 0; i < listenersCopy.length; i++) {
                            _t.removeListener(listenersCopy[i]);
                        }
                        delete _t._nodeListenersMap[listenerType.__instanceId];
                    }
                    var locToAddedListeners = _t._toAddedListeners;
                    for (i = 0; i < locToAddedListeners.length; ) {
                        var listener = locToAddedListeners[i];
                        if (listener._getSceneGraphPriority() === listenerType) {
                            listener._setSceneGraphPriority(null);
                            listener._setRegistered(false);
                            locToAddedListeners.splice(i, 1);
                        } else {
                            ++i;
                        }
                    }
                    if (true === recursive) {
                        var locChildren = listenerType.getChildren(), len;
                        for (i = 0, len = locChildren.length; i < len; i++) {
                            _t.removeListeners(locChildren[i], true);
                        }
                    }
                } else {
                    listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? _t._removeListenersForListenerID(cc._EventListenerTouchOneByOne.LISTENER_ID) : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? _t._removeListenersForListenerID(cc._EventListenerTouchAllAtOnce.LISTENER_ID) : listenerType === cc.EventListener.MOUSE ? _t._removeListenersForListenerID(cc._EventListenerMouse.LISTENER_ID) : listenerType === cc.EventListener.ACCELERATION ? _t._removeListenersForListenerID(cc._EventListenerAcceleration.LISTENER_ID) : listenerType === cc.EventListener.KEYBOARD ? _t._removeListenersForListenerID(cc._EventListenerKeyboard.LISTENER_ID) : cc.logID(3501);
                }
            },
            removeCustomListeners: function(customEventName) {
                this._removeListenersForListenerID(customEventName);
            },
            removeAllListeners: function() {
                var locListeners = this._listenersMap, locInternalCustomEventIDs = this._internalCustomListenerIDs;
                for (var selKey in locListeners) {
                    locInternalCustomEventIDs.indexOf(selKey) === -1 && this._removeListenersForListenerID(selKey);
                }
            },
            setPriority: function(listener, fixedPriority) {
                if (null == listener) {
                    return;
                }
                var locListeners = this._listenersMap;
                for (var selKey in locListeners) {
                    var selListeners = locListeners[selKey];
                    var fixedPriorityListeners = selListeners.getFixedPriorityListeners();
                    if (fixedPriorityListeners) {
                        var found = fixedPriorityListeners.indexOf(listener);
                        if (found !== -1) {
                            null != listener._getSceneGraphPriority() && cc.logID(3502);
                            if (listener._getFixedPriority() !== fixedPriority) {
                                listener._setFixedPriority(fixedPriority);
                                this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
                            }
                            return;
                        }
                    }
                }
            },
            setEnabled: function(enabled) {
                this._isEnabled = enabled;
            },
            isEnabled: function() {
                return this._isEnabled;
            },
            dispatchEvent: function(event) {
                if (!this._isEnabled) {
                    return;
                }
                this._updateDirtyFlagForSceneGraph();
                this._inDispatch++;
                if (!event || !event.getType) {
                    throw new Error("event is undefined");
                }
                if (event.getType().startsWith(cc.Event.TOUCH)) {
                    this._dispatchTouchEvent(event);
                    this._inDispatch--;
                    return;
                }
                var listenerID = __getListenerID(event);
                this._sortEventListeners(listenerID);
                var selListeners = this._listenersMap[listenerID];
                if (null != selListeners) {
                    this._dispatchEventToListeners(selListeners, this._onListenerCallback, event);
                    this._onUpdateListeners(selListeners);
                }
                this._inDispatch--;
            },
            _onListenerCallback: function(listener, event) {
                event.currentTarget = listener._target;
                listener._onEvent(event);
                return event.isStopped();
            },
            dispatchCustomEvent: function(eventName, optionalUserData) {
                var ev = new cc.Event.EventCustom(eventName);
                ev.setUserData(optionalUserData);
                this.dispatchEvent(ev);
            }
        };
    }), {} ],
    108: [ (function(require, module, exports) {
        var EventTarget = require("../event/event-target");
        var EventType = cc.Enum({
            KEY_DOWN: "keydown",
            KEY_UP: "keyup",
            DEVICEMOTION: "devicemotion"
        });
        var keyboardListener = null;
        var accelerationListener = null;
        var keyboardListenerAddFrame = 0;
        var SystemEvent = cc.Class({
            name: "SystemEvent",
            extends: EventTarget,
            statics: {
                EventType: EventType
            },
            on: function(type, callback, target, useCapture) {
                this._super(type, callback, target, useCapture);
                if (type === EventType.KEY_DOWN || type === EventType.KEY_UP) {
                    keyboardListener || (keyboardListener = cc.EventListener.create({
                        event: cc.EventListener.KEYBOARD,
                        onKeyPressed: function(keyCode, event) {
                            event.type = EventType.KEY_DOWN;
                            cc.systemEvent.dispatchEvent(event);
                        },
                        onKeyReleased: function(keyCode, event) {
                            event.type = EventType.KEY_UP;
                            cc.systemEvent.dispatchEvent(event);
                        }
                    }));
                    if (!cc.eventManager.hasEventListener(cc._EventListenerKeyboard.LISTENER_ID)) {
                        var currentFrame = cc.director.getTotalFrames();
                        if (currentFrame !== keyboardListenerAddFrame) {
                            cc.eventManager.addListener(keyboardListener, 1);
                            keyboardListenerAddFrame = currentFrame;
                        }
                    }
                }
                if (type === EventType.DEVICEMOTION) {
                    accelerationListener || (accelerationListener = cc.EventListener.create({
                        event: cc.EventListener.ACCELERATION,
                        callback: function(acc, event) {
                            event.type = EventType.DEVICEMOTION;
                            cc.systemEvent.dispatchEvent(event);
                        }
                    }));
                    cc.eventManager.hasEventListener(cc._EventListenerAcceleration.LISTENER_ID) || cc.eventManager.addListener(accelerationListener, 1);
                }
            },
            off: function(type, callback, target, useCapture) {
                this._super(type, callback, target, useCapture);
                if (keyboardListener && (type === EventType.KEY_DOWN || type === EventType.KEY_UP)) {
                    var hasKeyDownEventListener = this.hasEventListener(EventType.KEY_DOWN);
                    var hasKeyUpEventListener = this.hasEventListener(EventType.KEY_UP);
                    hasKeyDownEventListener || hasKeyUpEventListener || cc.eventManager.removeListener(keyboardListener);
                }
                accelerationListener && type === EventType.DEVICEMOTION && cc.eventManager.removeListener(accelerationListener);
            }
        });
        cc.SystemEvent = module.exports = SystemEvent;
        cc.systemEvent = new cc.SystemEvent();
    }), {
        "../event/event-target": 112
    } ],
    109: [ (function(require, module, exports) {
        cc.Touch = cc._Class.extend({
            ctor: function(x, y, id) {
                this._lastModified = 0;
                this.setTouchInfo(id, x, y);
            },
            getLocation: function() {
                return {
                    x: this._point.x,
                    y: this._point.y
                };
            },
            getLocationX: function() {
                return this._point.x;
            },
            getLocationY: function() {
                return this._point.y;
            },
            getPreviousLocation: function() {
                return {
                    x: this._prevPoint.x,
                    y: this._prevPoint.y
                };
            },
            getStartLocation: function() {
                return {
                    x: this._startPoint.x,
                    y: this._startPoint.y
                };
            },
            getDelta: function() {
                return cc.pSub(this._point, this._prevPoint);
            },
            getLocationInView: function() {
                return {
                    x: this._point.x,
                    y: cc.view._designResolutionSize.height - this._point.y
                };
            },
            getPreviousLocationInView: function() {
                return {
                    x: this._prevPoint.x,
                    y: cc.view._designResolutionSize.height - this._prevPoint.y
                };
            },
            getStartLocationInView: function() {
                return {
                    x: this._startPoint.x,
                    y: cc.view._designResolutionSize.height - this._startPoint.y
                };
            },
            getID: function() {
                return this._id;
            },
            setTouchInfo: function(id, x, y) {
                this._prevPoint = this._point;
                this._point = cc.p(x || 0, y || 0);
                this._id = id;
                if (!this._startPointCaptured) {
                    this._startPoint = cc.p(this._point);
                    cc.view._convertPointWithScale(this._startPoint);
                    this._startPointCaptured = true;
                }
            },
            _setPoint: function(x, y) {
                if (void 0 === y) {
                    this._point.x = x.x;
                    this._point.y = x.y;
                } else {
                    this._point.x = x;
                    this._point.y = y;
                }
            },
            _setPrevPoint: function(x, y) {
                void 0 === y ? this._prevPoint = cc.p(x.x, x.y) : this._prevPoint = cc.p(x || 0, y || 0);
            }
        });
    }), {} ],
    110: [ (function(require, module, exports) {
        require("./CCTouch");
        require("./CCEventListener");
        require("./CCEventManager");
        require("./CCEvent");
        require("./CCSystemEvent");
    }), {
        "./CCEvent": 105,
        "./CCEventListener": 106,
        "./CCEventManager": 107,
        "./CCSystemEvent": 108,
        "./CCTouch": 109
    } ],
    111: [ (function(require, module, exports) {
        var JS = cc.js;
        var CallbacksHandler = require("../platform/callbacks-invoker").CallbacksHandler;
        var REMOVE_PLACEHOLDER = CallbacksHandler.REMOVE_PLACEHOLDER;
        function EventListeners() {
            CallbacksHandler.call(this);
        }
        JS.extend(EventListeners, CallbacksHandler);
        EventListeners.prototype.invoke = function(event, captureListeners) {
            var key = event.type, list = this._callbackTable[key], i, endIndex, callingFunc, target, hasTarget;
            this._invoking[key] = true;
            if (list) {
                if (1 === list.length) {
                    callingFunc = list[0];
                    callingFunc !== REMOVE_PLACEHOLDER && callingFunc.call(event.currentTarget, event, captureListeners);
                } else {
                    endIndex = list.length - 1;
                    for (i = 0; i <= endIndex; ) {
                        callingFunc = list[i];
                        var increment = 1;
                        if (callingFunc !== REMOVE_PLACEHOLDER) {
                            target = list[i + 1];
                            hasTarget = target && "object" === typeof target;
                            if (hasTarget) {
                                callingFunc.call(target, event, captureListeners);
                                increment = 2;
                            } else {
                                callingFunc.call(event.currentTarget, event, captureListeners);
                            }
                            if (event._propagationImmediateStopped || i + increment > endIndex) {
                                break;
                            }
                        }
                        i += increment;
                    }
                }
            }
            this._invoking[key] = false;
            this._clearToRemove(key);
        };
        module.exports = EventListeners;
    }), {
        "../platform/callbacks-invoker": 187
    } ],
    112: [ (function(require, module, exports) {
        var EventListeners = require("./event-listeners");
        require("./event");
        var JS = cc.js;
        var fastRemove = JS.array.fastRemove;
        var cachedArray = new Array(16);
        cachedArray.length = 0;
        var _doDispatchEvent = function(owner, event) {
            var target, i;
            event.target = owner;
            cachedArray.length = 0;
            owner._getCapturingTargets(event.type, cachedArray);
            event.eventPhase = 1;
            for (i = cachedArray.length - 1; i >= 0; --i) {
                target = cachedArray[i];
                if (target._isTargetActive(event.type) && target._capturingListeners) {
                    event.currentTarget = target;
                    target._capturingListeners.invoke(event, cachedArray);
                    if (event._propagationStopped) {
                        cachedArray.length = 0;
                        return;
                    }
                }
            }
            cachedArray.length = 0;
            if (owner._isTargetActive(event.type)) {
                event.eventPhase = 2;
                event.currentTarget = owner;
                owner._capturingListeners && owner._capturingListeners.invoke(event);
                !event._propagationImmediateStopped && owner._bubblingListeners && owner._bubblingListeners.invoke(event);
            }
            if (!event._propagationStopped && event.bubbles) {
                owner._getBubblingTargets(event.type, cachedArray);
                event.eventPhase = 3;
                for (i = 0; i < cachedArray.length; ++i) {
                    target = cachedArray[i];
                    if (target._isTargetActive(event.type) && target._bubblingListeners) {
                        event.currentTarget = target;
                        target._bubblingListeners.invoke(event);
                        if (event._propagationStopped) {
                            cachedArray.length = 0;
                            return;
                        }
                    }
                }
            }
            cachedArray.length = 0;
        };
        function EventTarget() {
            this._capturingListeners = null;
            this._bubblingListeners = null;
        }
        var proto = EventTarget.prototype;
        proto.hasEventListener = function(type, checkCapture) {
            if (checkCapture && this._capturingListeners && this._capturingListeners.has(type)) {
                return true;
            }
            if (!checkCapture && this._bubblingListeners && this._bubblingListeners.has(type)) {
                return true;
            }
            return false;
        };
        proto.on = function(type, callback, target, useCapture) {
            if ("boolean" === typeof target) {
                useCapture = target;
                target = void 0;
            } else {
                useCapture = !!useCapture;
            }
            if (!callback) {
                cc.errorID(6800);
                return;
            }
            var listeners = null;
            listeners = useCapture ? this._capturingListeners = this._capturingListeners || new EventListeners() : this._bubblingListeners = this._bubblingListeners || new EventListeners();
            if (!listeners.has(type, callback, target)) {
                listeners.add(type, callback, target);
                target && target.__eventTargets && target.__eventTargets.push(this);
            }
            return callback;
        };
        proto.off = function(type, callback, target, useCapture) {
            if ("boolean" === typeof target) {
                useCapture = target;
                target = void 0;
            } else {
                useCapture = !!useCapture;
            }
            if (!callback) {
                return;
            }
            var listeners = useCapture ? this._capturingListeners : this._bubblingListeners;
            if (listeners) {
                listeners.remove(type, callback, target);
                target && target.__eventTargets && fastRemove(target.__eventTargets, this);
            }
        };
        proto.targetOff = function(target) {
            this._capturingListeners && this._capturingListeners.removeAll(target);
            this._bubblingListeners && this._bubblingListeners.removeAll(target);
        };
        proto.once = function(type, callback, target, useCapture) {
            var self = this;
            var cb = function(event) {
                self.off(type, cb, target, useCapture);
                callback.call(this, event);
            };
            this.on(type, cb, target, useCapture);
        };
        proto.dispatchEvent = function(event) {
            _doDispatchEvent(this, event);
            cachedArray.length = 0;
        };
        proto.emit = function(message, detail) {
            if ("string" !== typeof message) {
                cc.errorID(6801);
                return;
            }
            var caplisteners = this._capturingListeners && this._capturingListeners._callbackTable[message];
            var bublisteners = this._bubblingListeners && this._bubblingListeners._callbackTable[message];
            if ((!caplisteners || 0 === caplisteners.length) && (!bublisteners || 0 === bublisteners.length)) {
                return;
            }
            var event = cc.Event.EventCustom.get(message);
            event.detail = detail;
            event.eventPhase = 2;
            event.target = event.currentTarget = this;
            caplisteners && this._capturingListeners.invoke(event);
            bublisteners && !event._propagationImmediateStopped && this._bubblingListeners.invoke(event);
            cc.Event.EventCustom.put(event);
        };
        proto._isTargetActive = function(type) {
            return true;
        };
        proto._getCapturingTargets = function(type, array) {};
        proto._getBubblingTargets = function(type, array) {};
        EventTarget.prototype._EventTargetOn = EventTarget.prototype.on;
        EventTarget.prototype._EventTargetOnce = EventTarget.prototype.once;
        EventTarget.prototype._EventTargetOff = EventTarget.prototype.off;
        EventTarget.prototype._EventTargetTargetOff = EventTarget.prototype.targetOff;
        cc.EventTarget = module.exports = EventTarget;
    }), {
        "./event": 113,
        "./event-listeners": 111
    } ],
    113: [ (function(require, module, exports) {
        var JS = require("../platform/js");
        cc.Event = function(type, bubbles) {
            this.type = type;
            this.bubbles = !!bubbles;
            this.target = null;
            this.currentTarget = null;
            this.eventPhase = 0;
            this._propagationStopped = false;
            this._propagationImmediateStopped = false;
        };
        cc.Event.prototype = {
            constructor: cc.Event,
            unuse: function() {
                this.type = cc.Event.NO_TYPE;
                this.target = null;
                this.currentTarget = null;
                this.eventPhase = cc.Event.NONE;
                this._propagationStopped = false;
                this._propagationImmediateStopped = false;
            },
            reuse: function(type, bubbles) {
                this.type = type;
                this.bubbles = bubbles || false;
            },
            stopPropagation: function() {
                this._propagationStopped = true;
            },
            stopPropagationImmediate: function() {
                this._propagationImmediateStopped = true;
            },
            isStopped: function() {
                return this._propagationStopped || this._propagationImmediateStopped;
            },
            getCurrentTarget: function() {
                return this.currentTarget;
            },
            getType: function() {
                return this.type;
            }
        };
        cc.Event.NO_TYPE = "no_type";
        cc.Event.TOUCH = "touch";
        cc.Event.MOUSE = "mouse";
        cc.Event.KEYBOARD = "keyboard";
        cc.Event.ACCELERATION = "acceleration";
        cc.Event.NONE = 0;
        cc.Event.CAPTURING_PHASE = 1;
        cc.Event.AT_TARGET = 2;
        cc.Event.BUBBLING_PHASE = 3;
        var EventCustom = function(type, bubbles) {
            cc.Event.call(this, type, bubbles);
            this.detail = null;
        };
        JS.extend(EventCustom, cc.Event);
        EventCustom.prototype.reset = EventCustom;
        EventCustom.prototype.setUserData = function(data) {
            this.detail = data;
        };
        EventCustom.prototype.getUserData = function() {
            return this.detail;
        };
        EventCustom.prototype.getEventName = cc.Event.prototype.getType;
        var MAX_POOL_SIZE = 10;
        var _eventPool = new JS.Pool(MAX_POOL_SIZE);
        EventCustom.put = function(event) {
            _eventPool.put(event);
        };
        EventCustom.get = function(type, bubbles) {
            var event = _eventPool._get();
            event ? event.reset(type, bubbles) : event = new EventCustom(type, bubbles);
            return event;
        };
        cc.Event.EventCustom = EventCustom;
        module.exports = cc.Event;
    }), {
        "../platform/js": 193
    } ],
    114: [ (function(require, module, exports) {
        require("./event.js");
        require("./event-listeners.js");
        require("./event-target.js");
    }), {
        "./event-listeners.js": 111,
        "./event-target.js": 112,
        "./event.js": 113
    } ],
    115: [ (function(require, module, exports) {
        "use strict";
        module.exports = earcut;
        function earcut(data, holeIndices, dim) {
            dim = dim || 2;
            var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
            if (!outerNode) {
                return triangles;
            }
            var minX, minY, maxX, maxY, x, y, size;
            hasHoles && (outerNode = eliminateHoles(data, holeIndices, outerNode, dim));
            if (data.length > 80 * dim) {
                minX = maxX = data[0];
                minY = maxY = data[1];
                for (var i = dim; i < outerLen; i += dim) {
                    x = data[i];
                    y = data[i + 1];
                    x < minX && (minX = x);
                    y < minY && (minY = y);
                    x > maxX && (maxX = x);
                    y > maxY && (maxY = y);
                }
                size = Math.max(maxX - minX, maxY - minY);
            }
            earcutLinked(outerNode, triangles, dim, minX, minY, size);
            return triangles;
        }
        function linkedList(data, start, end, dim, clockwise) {
            var i, last;
            if (clockwise === signedArea(data, start, end, dim) > 0) {
                for (i = start; i < end; i += dim) {
                    last = insertNode(i, data[i], data[i + 1], last);
                }
            } else {
                for (i = end - dim; i >= start; i -= dim) {
                    last = insertNode(i, data[i], data[i + 1], last);
                }
            }
            if (last && equals(last, last.next)) {
                removeNode(last);
                last = last.next;
            }
            return last;
        }
        function filterPoints(start, end) {
            if (!start) {
                return start;
            }
            end || (end = start);
            var p = start, again;
            do {
                again = false;
                if (p.steiner || !equals(p, p.next) && 0 !== area(p.prev, p, p.next)) {
                    p = p.next;
                } else {
                    removeNode(p);
                    p = end = p.prev;
                    if (p === p.next) {
                        return null;
                    }
                    again = true;
                }
            } while (again || p !== end);
            return end;
        }
        function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
            if (!ear) {
                return;
            }
            !pass && size && indexCurve(ear, minX, minY, size);
            var stop = ear, prev, next;
            while (ear.prev !== ear.next) {
                prev = ear.prev;
                next = ear.next;
                if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
                    triangles.push(prev.i / dim);
                    triangles.push(ear.i / dim);
                    triangles.push(next.i / dim);
                    removeNode(ear);
                    ear = next.next;
                    stop = next.next;
                    continue;
                }
                ear = next;
                if (ear === stop) {
                    if (pass) {
                        if (1 === pass) {
                            ear = cureLocalIntersections(ear, triangles, dim);
                            earcutLinked(ear, triangles, dim, minX, minY, size, 2);
                        } else {
                            2 === pass && splitEarcut(ear, triangles, dim, minX, minY, size);
                        }
                    } else {
                        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
                    }
                    break;
                }
            }
        }
        function isEar(ear) {
            var a = ear.prev, b = ear, c = ear.next;
            if (area(a, b, c) >= 0) {
                return false;
            }
            var p = ear.next.next;
            while (p !== ear.prev) {
                if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                    return false;
                }
                p = p.next;
            }
            return true;
        }
        function isEarHashed(ear, minX, minY, size) {
            var a = ear.prev, b = ear, c = ear.next;
            if (area(a, b, c) >= 0) {
                return false;
            }
            var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
            var minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size);
            var p = ear.nextZ;
            while (p && p.z <= maxZ) {
                if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                    return false;
                }
                p = p.nextZ;
            }
            p = ear.prevZ;
            while (p && p.z >= minZ) {
                if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                    return false;
                }
                p = p.prevZ;
            }
            return true;
        }
        function cureLocalIntersections(start, triangles, dim) {
            var p = start;
            do {
                var a = p.prev, b = p.next.next;
                if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                    triangles.push(a.i / dim);
                    triangles.push(p.i / dim);
                    triangles.push(b.i / dim);
                    removeNode(p);
                    removeNode(p.next);
                    p = start = b;
                }
                p = p.next;
            } while (p !== start);
            return p;
        }
        function splitEarcut(start, triangles, dim, minX, minY, size) {
            var a = start;
            do {
                var b = a.next.next;
                while (b !== a.prev) {
                    if (a.i !== b.i && isValidDiagonal(a, b)) {
                        var c = splitPolygon(a, b);
                        a = filterPoints(a, a.next);
                        c = filterPoints(c, c.next);
                        earcutLinked(a, triangles, dim, minX, minY, size);
                        earcutLinked(c, triangles, dim, minX, minY, size);
                        return;
                    }
                    b = b.next;
                }
                a = a.next;
            } while (a !== start);
        }
        function eliminateHoles(data, holeIndices, outerNode, dim) {
            var queue = [], i, len, start, end, list;
            for (i = 0, len = holeIndices.length; i < len; i++) {
                start = holeIndices[i] * dim;
                end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                list = linkedList(data, start, end, dim, false);
                list === list.next && (list.steiner = true);
                queue.push(getLeftmost(list));
            }
            queue.sort(compareX);
            for (i = 0; i < queue.length; i++) {
                eliminateHole(queue[i], outerNode);
                outerNode = filterPoints(outerNode, outerNode.next);
            }
            return outerNode;
        }
        function compareX(a, b) {
            return a.x - b.x;
        }
        function eliminateHole(hole, outerNode) {
            outerNode = findHoleBridge(hole, outerNode);
            if (outerNode) {
                var b = splitPolygon(outerNode, hole);
                filterPoints(b, b.next);
            }
        }
        function findHoleBridge(hole, outerNode) {
            var p = outerNode, hx = hole.x, hy = hole.y, qx = -(1 / 0), m;
            do {
                if (hy <= p.y && hy >= p.next.y) {
                    var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                    if (x <= hx && x > qx) {
                        qx = x;
                        if (x === hx) {
                            if (hy === p.y) {
                                return p;
                            }
                            if (hy === p.next.y) {
                                return p.next;
                            }
                        }
                        m = p.x < p.next.x ? p : p.next;
                    }
                }
                p = p.next;
            } while (p !== outerNode);
            if (!m) {
                return null;
            }
            if (hx === qx) {
                return m.prev;
            }
            var stop = m, mx = m.x, my = m.y, tanMin = 1 / 0, tan;
            p = m.next;
            while (p !== stop) {
                if (hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                    tan = Math.abs(hy - p.y) / (hx - p.x);
                    if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
                        m = p;
                        tanMin = tan;
                    }
                }
                p = p.next;
            }
            return m;
        }
        function indexCurve(start, minX, minY, size) {
            var p = start;
            do {
                null === p.z && (p.z = zOrder(p.x, p.y, minX, minY, size));
                p.prevZ = p.prev;
                p.nextZ = p.next;
                p = p.next;
            } while (p !== start);
            p.prevZ.nextZ = null;
            p.prevZ = null;
            sortLinked(p);
        }
        function sortLinked(list) {
            var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
            do {
                p = list;
                list = null;
                tail = null;
                numMerges = 0;
                while (p) {
                    numMerges++;
                    q = p;
                    pSize = 0;
                    for (i = 0; i < inSize; i++) {
                        pSize++;
                        q = q.nextZ;
                        if (!q) {
                            break;
                        }
                    }
                    qSize = inSize;
                    while (pSize > 0 || qSize > 0 && q) {
                        if (0 === pSize) {
                            e = q;
                            q = q.nextZ;
                            qSize--;
                        } else {
                            if (0 !== qSize && q) {
                                if (p.z <= q.z) {
                                    e = p;
                                    p = p.nextZ;
                                    pSize--;
                                } else {
                                    e = q;
                                    q = q.nextZ;
                                    qSize--;
                                }
                            } else {
                                e = p;
                                p = p.nextZ;
                                pSize--;
                            }
                        }
                        tail ? tail.nextZ = e : list = e;
                        e.prevZ = tail;
                        tail = e;
                    }
                    p = q;
                }
                tail.nextZ = null;
                inSize *= 2;
            } while (numMerges > 1);
            return list;
        }
        function zOrder(x, y, minX, minY, size) {
            x = 32767 * (x - minX) / size;
            y = 32767 * (y - minY) / size;
            x = 16711935 & (x | x << 8);
            x = 252645135 & (x | x << 4);
            x = 858993459 & (x | x << 2);
            x = 1431655765 & (x | x << 1);
            y = 16711935 & (y | y << 8);
            y = 252645135 & (y | y << 4);
            y = 858993459 & (y | y << 2);
            y = 1431655765 & (y | y << 1);
            return x | y << 1;
        }
        function getLeftmost(start) {
            var p = start, leftmost = start;
            do {
                p.x < leftmost.x && (leftmost = p);
                p = p.next;
            } while (p !== start);
            return leftmost;
        }
        function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
        }
        function isValidDiagonal(a, b) {
            return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
        }
        function area(p, q, r) {
            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        }
        function equals(p1, p2) {
            return p1.x === p2.x && p1.y === p2.y;
        }
        function intersects(p1, q1, p2, q2) {
            if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) {
                return true;
            }
            return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
        }
        function intersectsPolygon(a, b) {
            var p = a;
            do {
                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
                    return true;
                }
                p = p.next;
            } while (p !== a);
            return false;
        }
        function locallyInside(a, b) {
            return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
        }
        function middleInside(a, b) {
            var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
            do {
                p.y > py !== p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x && (inside = !inside);
                p = p.next;
            } while (p !== a);
            return inside;
        }
        function splitPolygon(a, b) {
            var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
            a.next = b;
            b.prev = a;
            a2.next = an;
            an.prev = a2;
            b2.next = a2;
            a2.prev = b2;
            bp.next = b2;
            b2.prev = bp;
            return b2;
        }
        function insertNode(i, x, y, last) {
            var p = new Node(i, x, y);
            if (last) {
                p.next = last.next;
                p.prev = last;
                last.next.prev = p;
                last.next = p;
            } else {
                p.prev = p;
                p.next = p;
            }
            return p;
        }
        function removeNode(p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            p.prevZ && (p.prevZ.nextZ = p.nextZ);
            p.nextZ && (p.nextZ.prevZ = p.prevZ);
        }
        function Node(i, x, y) {
            this.i = i;
            this.x = x;
            this.y = y;
            this.prev = null;
            this.next = null;
            this.z = null;
            this.prevZ = null;
            this.nextZ = null;
            this.steiner = false;
        }
        earcut.deviation = function(data, holeIndices, dim, triangles) {
            var hasHoles = holeIndices && holeIndices.length;
            var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
            var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
            if (hasHoles) {
                for (var i = 0, len = holeIndices.length; i < len; i++) {
                    var start = holeIndices[i] * dim;
                    var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                    polygonArea -= Math.abs(signedArea(data, start, end, dim));
                }
            }
            var trianglesArea = 0;
            for (i = 0; i < triangles.length; i += 3) {
                var a = triangles[i] * dim;
                var b = triangles[i + 1] * dim;
                var c = triangles[i + 2] * dim;
                trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
            }
            return 0 === polygonArea && 0 === trianglesArea ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
        };
        function signedArea(data, start, end, dim) {
            var sum = 0;
            for (var i = start, j = end - dim; i < end; i += dim) {
                sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                j = i;
            }
            return sum;
        }
        earcut.flatten = function(data) {
            var dim = data[0][0].length, result = {
                vertices: [],
                holes: [],
                dimensions: dim
            }, holeIndex = 0;
            for (var i = 0; i < data.length; i++) {
                for (var j = 0; j < data[i].length; j++) {
                    for (var d = 0; d < dim; d++) {
                        result.vertices.push(data[i][j][d]);
                    }
                }
                if (i > 0) {
                    holeIndex += data[i - 1].length;
                    result.holes.push(holeIndex);
                }
            }
            return result;
        };
    }), {} ],
    116: [ (function(require, module, exports) {
        var Js = cc.js;
        var LineCap = require("./types").LineCap;
        var LineJoin = require("./types").LineJoin;
        var Helper = require("./helper");
        var CanvasRenderCmd = function(renderable) {
            this._rootCtor(renderable);
            this._needDraw = true;
            this.cmds = [];
            this.style = {
                strokeStyle: "black",
                fillStyle: "white",
                lineCap: "butt",
                lineJoin: "miter",
                miterLimit: 10
            };
        };
        var _p = CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
        _p.constructor = CanvasRenderCmd;
        _p._updateCurrentRegions = function() {
            var temp = this._currentRegion;
            this._currentRegion = this._oldRegion;
            this._oldRegion = temp;
            this._currentRegion.setTo(0, 0, cc.visibleRect.width, cc.visibleRect.height);
        };
        _p.rendering = function(ctx, scaleX, scaleY) {
            var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
            wrapper.setTransform(this._worldTransform, scaleX, scaleY);
            context.save();
            context.scale(1, -1);
            var style = this.style;
            context.strokeStyle = style.strokeStyle;
            context.fillStyle = style.fillStyle;
            context.lineWidth = style.lineWidth;
            context.lineJoin = style.lineJoin;
            context.miterLimit = style.miterLimit;
            var endPath = true;
            var cmds = this.cmds;
            for (var i = 0, l = cmds.length; i < l; i++) {
                var cmd = cmds[i];
                var ctxCmd = cmd[0], args = cmd[1];
                if ("moveTo" === ctxCmd && endPath) {
                    context.beginPath();
                    endPath = false;
                } else {
                    "fill" !== ctxCmd && "stroke" !== ctxCmd && "fillRect" !== ctxCmd || (endPath = true);
                }
                "function" === typeof context[ctxCmd] ? context[ctxCmd].apply(context, args) : context[ctxCmd] = args;
            }
            context.restore();
        };
        _p.setStrokeColor = function(v) {
            var strokeStyle = "rgba(" + (0 | v.r) + "," + (0 | v.g) + "," + (0 | v.b) + "," + v.a / 255 + ")";
            this.cmds.push([ "strokeStyle", strokeStyle ]);
            this.style.strokeStyle = strokeStyle;
        };
        _p.setFillColor = function(v) {
            var fillStyle = "rgba(" + (0 | v.r) + "," + (0 | v.g) + "," + (0 | v.b) + "," + v.a / 255 + ")";
            this.cmds.push([ "fillStyle", fillStyle ]);
            this.style.fillStyle = fillStyle;
        };
        _p.setLineWidth = function(v) {
            this.cmds.push([ "lineWidth", v ]);
            this.style.lineWidth = v;
        };
        _p.setLineCap = function(v) {
            var lineCap = "butt";
            v === LineCap.BUTT ? lineCap = "butt" : v === LineCap.ROUND ? lineCap = "round" : v === LineCap.SQUARE && (lineCap = "square");
            this.cmds.push([ "lineCap", lineCap ]);
            this.style.lineCap = lineCap;
        };
        _p.setLineJoin = function(v) {
            var lineJoin = "bevel";
            v === LineJoin.BEVEL ? lineJoin = "bevel" : v === LineJoin.ROUND ? lineJoin = "round" : v === LineJoin.MITER && (lineJoin = "miter");
            this.cmds.push([ "lineJoin", lineJoin ]);
            this.style.lineJoin = lineJoin;
        };
        _p.setMiterLimit = function(v) {
            this.cmds.push([ "miterLimit", v ]);
            this.style.miterLimit = v;
        };
        _p.beginPath = function() {};
        _p.moveTo = function(x, y) {
            this.cmds.push([ "moveTo", [ x, y ] ]);
        };
        _p.lineTo = function(x, y) {
            this.cmds.push([ "lineTo", [ x, y ] ]);
        };
        _p.bezierCurveTo = function(c1x, c1y, c2x, c2y, x, y) {
            this.cmds.push([ "bezierCurveTo", [ c1x, c1y, c2x, c2y, x, y ] ]);
        };
        _p.quadraticCurveTo = function(cx, cy, x, y) {
            this.cmds.push([ "quadraticCurveTo", [ cx, cy, x, y ] ]);
        };
        _p.arc = function(cx, cy, r, startAngle, endAngle, counterclockwise) {
            Helper.arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
        };
        _p.ellipse = function(cx, cy, rx, ry) {
            Helper.ellipse(this, cx, cy, rx, ry);
        };
        _p.circle = function(cx, cy, r) {
            Helper.ellipse(this, cx, cy, r, r);
        };
        _p.rect = function(x, y, w, h) {
            this.moveTo(x, y);
            this.lineTo(x + w, y);
            this.lineTo(x + w, y + h);
            this.lineTo(x, y + h);
            this.close();
        };
        _p.roundRect = function(x, y, w, h, r) {
            Helper.roundRect(this, x, y, w, h, r);
        };
        _p.fillRect = function(x, y, w, h) {
            this.cmds.push([ "fillRect", [ x, y, w, h ] ]);
            this.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
        };
        _p.close = function() {
            this.cmds.push([ "closePath", [] ]);
        };
        _p.stroke = function() {
            this.cmds.push([ "stroke", [] ]);
            this.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
        };
        _p.fill = function() {
            this.cmds.push([ "fill", [] ]);
            this.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
        };
        _p.clear = function() {
            this.cmds.length = 0;
            this.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
        };
        module.exports = CanvasRenderCmd;
    }), {
        "./helper": 120,
        "./types": 123
    } ],
    117: [ (function(require, module, exports) {
        var CanvasRenderCmd = require("./graphics-canvas-cmd");
        var WebGLRenderCmd = require("./graphics-webgl-cmd");
        var LineCap = require("./types").LineCap;
        var LineJoin = require("./types").LineJoin;
        var Js = cc.js;
        var GraphicsNode = _ccsg.Node.extend({
            ctor: function() {
                this._super();
                this.strokeColor = cc.Color.BLACK;
                this.fillColor = cc.Color.WHITE;
            },
            clear: function(clean) {
                this._renderCmd.clear(clean);
            },
            _createRenderCmd: function() {
                return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new CanvasRenderCmd(this) : new WebGLRenderCmd(this);
            }
        });
        var _p = GraphicsNode.prototype;
        _p._strokeColor = null;
        _p._fillColor = null;
        _p._lineWidth = 1;
        _p._lineCap = LineCap.BUTT;
        _p._lineJoin = LineJoin.MITER;
        _p._miterLimit = 10;
        _p.setStrokeColor = function(v) {
            this._strokeColor = v;
            this._renderCmd.setStrokeColor(v);
        };
        _p.getStrokeColor = function() {
            return this._strokeColor;
        };
        _p.setFillColor = function(v) {
            this._fillColor = v;
            this._renderCmd.setFillColor(v);
        };
        _p.getFillColor = function() {
            return this._fillColor;
        };
        _p.setLineWidth = function(v) {
            this._lineWidth = v;
            this._renderCmd.setLineWidth(v);
        };
        _p.getLineWidth = function() {
            return this._lineWidth;
        };
        _p.setLineCap = function(v) {
            this._lineCap = v;
            this._renderCmd.setLineCap(v);
        };
        _p.getLineCap = function() {
            return this._lineCap;
        };
        _p.setLineJoin = function(v) {
            this._lineJoin = v;
            this._renderCmd.setLineJoin(v);
        };
        _p.getLineJoin = function() {
            return this._lineJoin;
        };
        _p.setMiterLimit = function(v) {
            this._miterLimit = v;
            this._renderCmd.setMiterLimit(v);
        };
        _p.getMiterLimit = function() {
            return this._miterLimit;
        };
        _p.beginPath = function() {
            this._renderCmd.beginPath();
        };
        _p.moveTo = function(x, y) {
            this._renderCmd.moveTo(x, y);
        };
        _p.lineTo = function(x, y) {
            this._renderCmd.lineTo(x, y);
        };
        _p.bezierCurveTo = function(c1x, c1y, c2x, c2y, x, y) {
            this._renderCmd.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
        };
        _p.quadraticCurveTo = function(cx, cy, x, y) {
            this._renderCmd.quadraticCurveTo(cx, cy, x, y);
        };
        _p.arc = function(cx, cy, r, a0, a1, counterclockwise) {
            this._renderCmd.arc(cx, cy, r, a0, a1, counterclockwise);
        };
        _p.ellipse = function(cx, cy, rx, ry) {
            this._renderCmd.ellipse(cx, cy, rx, ry);
        };
        _p.circle = function(cx, cy, r) {
            this._renderCmd.circle(cx, cy, r);
        };
        _p.rect = function(x, y, w, h) {
            this._renderCmd.rect(x, y, w, h);
        };
        _p.roundRect = function(x, y, w, h, r) {
            this._renderCmd.roundRect(x, y, w, h, r);
        };
        _p.fillRect = function(x, y, w, h) {
            this._renderCmd.fillRect(x, y, w, h);
        };
        _p.close = function() {
            this._renderCmd.close();
        };
        _p.stroke = function() {
            this._renderCmd.stroke();
        };
        _p.fill = function() {
            this._renderCmd.fill();
        };
        module.exports = GraphicsNode;
    }), {
        "./graphics-canvas-cmd": 116,
        "./graphics-webgl-cmd": 118,
        "./types": 123
    } ],
    118: [ (function(require, module, exports) {
        var Shader = require("./shader");
        var LineCap = require("./types").LineCap;
        var LineJoin = require("./types").LineJoin;
        var Earcut = require("./earcut");
        var Helper = require("./helper");
        var Vec2 = cc.Vec2;
        var Js = cc.js;
        var INIT_VERTS_SIZE = 32;
        var VERTS_FLOAT_LENGTH = 2;
        var VERTS_BYTE_LENGTH = 8;
        var PI = Math.PI;
        var min = Math.min;
        var max = Math.max;
        var ceil = Math.ceil;
        var acos = Math.acos;
        var cos = Math.cos;
        var sin = Math.sin;
        var atan2 = Math.atan2;
        var abs = Math.abs;
        function clamp(v, min, max) {
            if (v < min) {
                return min;
            }
            if (v > max) {
                return max;
            }
            return v;
        }
        var PointFlags = cc.Enum({
            PT_CORNER: 1,
            PT_LEFT: 2,
            PT_BEVEL: 4,
            PT_INNERBEVEL: 8
        });
        function Point(x, y) {
            Vec2.call(this, x, y);
            this.reset();
        }
        Js.extend(Point, Vec2);
        Point.prototype.reset = function() {
            this.dx = 0;
            this.dy = 0;
            this.dmx = 0;
            this.dmy = 0;
            this.flags = 0;
            this.len = 0;
        };
        function Path() {
            this.reset();
        }
        Path.prototype.reset = function() {
            this.closed = false;
            this.nbevel = 0;
            this.complex = true;
            this.points ? this.points.length = 0 : this.points = [];
        };
        function WebGLRenderCmd(renderable) {
            this._rootCtor(renderable);
            this._needDraw = true;
            var gl = cc._renderContext;
            this._vertsOffset = 0;
            this._vertsVBO = gl.createBuffer();
            this._vertsBuffer = null;
            this._vertsDirty = false;
            this._indicesOffset = 0;
            this._indicesVBO = gl.createBuffer();
            this._indicesBuffer = null;
            this._indicesDirty = false;
            this._matrix = new cc.math.Matrix4();
            this._matrix.identity();
            this._paths = [];
            this._points = [];
            this._cmds = [];
            this._blendFunc = new cc.BlendFunc(cc.macro.BLEND_SRC, cc.macro.BLEND_DST);
            this._shader = new cc.GLProgram();
            this._shader.initWithVertexShaderByteArray(Shader.vert, Shader.frag);
            this._shader.retain();
            this._shader.addAttribute(cc.macro.ATTRIBUTE_NAME_POSITION, cc.macro.VERTEX_ATTRIB_POSITION);
            this._shader.link();
            this._shader.updateUniforms();
            this._allocVerts(INIT_VERTS_SIZE);
        }
        WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
        WebGLRenderCmd.prototype.constructor = WebGLRenderCmd;
        var _p = WebGLRenderCmd.prototype;
        _p._tessTol = .25;
        _p._distTol = .01;
        _p.lineWidth = 1;
        _p.lineCap = LineCap.BUTT;
        _p.lineJoin = LineJoin.MITER;
        _p.miterLimit = 10;
        _p.beginPath = function() {
            this._pathOffset = this._pathLength;
        };
        _p.moveTo = function(x, y) {
            if (this._updatePathOffset) {
                this._pathOffset = this._pathLength;
                this._updatePathOffset = false;
            }
            this._addPath();
            this._addPoint(x, y, PointFlags.PT_CORNER);
            this._commandx = x;
            this._commandy = y;
        };
        _p.lineTo = function(x, y) {
            this._addPoint(x, y, PointFlags.PT_CORNER);
            this._commandx = x;
            this._commandy = y;
        };
        _p.bezierCurveTo = function(c1x, c1y, c2x, c2y, x, y) {
            var path = this._curPath;
            var last = path.points[path.points.length - 1];
            if (last.x === c1x && last.y === c1y && c2x === x && c2y === y) {
                this.lineTo(x, y);
                return;
            }
            this._tesselateBezier(last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER);
            this._commandx = x;
            this._commandy = y;
        };
        _p.quadraticCurveTo = function(cx, cy, x, y) {
            var x0 = this._commandx;
            var y0 = this._commandy;
            this.bezierCurveTo(x0 + 2 / 3 * (cx - x0), y0 + 2 / 3 * (cy - y0), x + 2 / 3 * (cx - x), y + 2 / 3 * (cy - y), x, y);
        };
        _p.arc = function(cx, cy, r, startAngle, endAngle, counterclockwise) {
            Helper.arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
        };
        _p.ellipse = function(cx, cy, rx, ry) {
            Helper.ellipse(this, cx, cy, rx, ry);
            this._curPath.complex = false;
        };
        _p.circle = function(cx, cy, r) {
            Helper.ellipse(this, cx, cy, r, r);
            this._curPath.complex = false;
        };
        _p.rect = function(x, y, w, h) {
            this.moveTo(x, y);
            this.lineTo(x, y + h);
            this.lineTo(x + w, y + h);
            this.lineTo(x + w, y);
            this.close();
            this._curPath.complex = false;
        };
        _p.roundRect = function(x, y, w, h, r) {
            Helper.roundRect(this, x, y, w, h, r);
            this._curPath.complex = false;
        };
        _p.fillRect = function(x, y, w, h) {
            this.rect(x, y, w, h);
            this.fill();
        };
        _p.close = function() {
            this._curPath.closed = true;
        };
        _p.stroke = function() {
            this._flattenPaths();
            this._expandStroke();
            this._vertsDirty = true;
            this._updatePathOffset = true;
        };
        _p.fill = function() {
            this._expandFill();
            this._vertsDirty = true;
            this._updatePathOffset = true;
            this._filling = false;
        };
        _p._strokeColor = null;
        _p._fillColor = null;
        _p.setStrokeColor = function(c) {
            this._strokeColor = c;
        };
        _p.getStrokeColor = function() {
            return this._strokeColor;
        };
        _p.setFillColor = function(c) {
            this._fillColor = c;
        };
        _p.getFillColor = function() {
            return this._fillColor;
        };
        _p.setLineWidth = function(v) {
            this.lineWidth = v;
        };
        _p.setLineJoin = function(v) {
            this.lineJoin = v;
        };
        _p.setLineCap = function(v) {
            this.lineCap = v;
        };
        _p.setMiterLimit = function(v) {
            this.miterLimit = v;
        };
        Js.getset(_p, "strokeColor", _p.getStrokeColor, _p.setStrokeColor);
        Js.getset(_p, "fillColor", _p.getFillColor, _p.setFillColor);
        _p._render = function() {
            var vertsBuffer = this._vertsBuffer;
            if (!vertsBuffer || 0 === vertsBuffer.length || 0 === this._cmds.length) {
                return;
            }
            var gl = cc._renderContext;
            gl.bindBuffer(gl.ARRAY_BUFFER, this._vertsVBO);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indicesVBO);
            if (this._vertsDirty) {
                gl.bufferData(gl.ARRAY_BUFFER, vertsBuffer, gl.STREAM_DRAW);
                this._vertsDirty = false;
            }
            if (this._indicesDirty && this._indicesBuffer) {
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indicesBuffer, gl.STREAM_DRAW);
                this._indicesDirty = false;
            }
            this._vertsOffset > 65536 && cc.warnID(2401);
            gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_POSITION);
            gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_POSITION, 2, gl.FLOAT, false, VERTS_BYTE_LENGTH, 0);
            var shader = this._shader;
            var colorLocation = shader.getUniformLocationForName("color");
            var cmds = this._cmds;
            for (var i = 0, l = cmds.length; i < l; i++) {
                var cmd = cmds[i];
                if (cmd.nIndices) {
                    var color = cmd.color;
                    gl.uniform4f(colorLocation, color.r / 255, color.g / 255, color.b / 255, color.a / 255);
                    gl.drawElements(gl.TRIANGLES, cmd.nIndices, gl.UNSIGNED_SHORT, 2 * cmd.indicesOffset);
                    cc.incrementGLDraws(cmd.nverts);
                }
            }
            cc.checkGLErrorDebug();
        };
        _p.rendering = function() {
            cc.gl.blendFunc(this._blendFunc.src, this._blendFunc.dst);
            var wt = this._worldTransform, mat = this._matrix.mat;
            mat[0] = wt.a;
            mat[4] = wt.c;
            mat[12] = wt.tx;
            mat[1] = wt.b;
            mat[5] = wt.d;
            mat[13] = wt.ty;
            var shader = this._shader;
            shader.use();
            shader._setUniformForMVPMatrixWithMat4(this._matrix);
            this._render();
        };
        _p.clear = function(clean) {
            this._vertsOffset = 0;
            this._indicesOffset = 0;
            this._pathLength = 0;
            this._pathOffset = 0;
            this._pointsOffset = 0;
            this._curPath = null;
            this._cmds.length = 0;
            if (clean) {
                this._paths.length = 0;
                this._points.length = 0;
                this._vertsBuffer = null;
                this._indicesBuffer = null;
            }
        };
        _p._updatePathOffset = false;
        _p._paths = null;
        _p._pathLength = 0;
        _p._pathOffset = 0;
        _p._points = null;
        _p._pointsOffset = 0;
        _p._commandx = 0;
        _p._commandy = 0;
        _p._addPath = function() {
            var offset = this._pathLength;
            var path = this._paths[offset];
            if (path) {
                path.reset();
            } else {
                path = new Path();
                this._paths.push(path);
            }
            this._pathLength++;
            this._curPath = path;
            return path;
        };
        _p._addPoint = function(x, y, flags) {
            var path = this._curPath;
            if (!path) {
                return;
            }
            var pt;
            var points = this._points;
            var pathPoints = path.points;
            var offset = this._pointsOffset++;
            pt = points[offset];
            if (pt) {
                pt.x = x;
                pt.y = y;
            } else {
                pt = new Point(x, y);
                points.push(pt);
            }
            pt.flags = flags;
            pathPoints.push(pt);
        };
        _p._flattenPaths = function() {
            var paths = this._paths;
            for (var i = this._pathOffset, l = this._pathLength; i < l; i++) {
                var path = paths[i];
                var pts = path.points;
                var p0 = pts[pts.length - 1];
                var p1 = pts[0];
                if (p0.equals(p1)) {
                    path.closed = true;
                    pts.pop();
                    p0 = pts[pts.length - 1];
                }
                for (var j = 0, size = pts.length; j < size; j++) {
                    var dPos = p1.sub(p0);
                    p0.len = dPos.mag();
                    (dPos.x || dPos.y) && dPos.normalizeSelf();
                    p0.dx = dPos.x;
                    p0.dy = dPos.y;
                    p0 = p1;
                    p1 = pts[j + 1];
                }
            }
        };
        _p._allocVerts = function(cverts) {
            var dnverts = this._vertsOffset + cverts;
            var buffer = this._vertsBuffer;
            var nverts = buffer ? buffer.length / VERTS_FLOAT_LENGTH : 0;
            if (dnverts > nverts) {
                0 === nverts && (nverts = INIT_VERTS_SIZE);
                while (dnverts > nverts) {
                    nverts *= 2;
                }
                var newBuffer = new Float32Array(nverts * VERTS_FLOAT_LENGTH);
                if (buffer) {
                    for (var i = 0, l = buffer.length; i < l; i++) {
                        newBuffer[i] = buffer[i];
                    }
                }
                this._vertsBuffer = newBuffer;
            }
        };
        _p._allocIndices = function(cindices) {
            var indices = this._indicesBuffer;
            var dnindices = this._indicesOffset + cindices;
            var nindices = indices ? indices.length : 0;
            if (dnindices > nindices) {
                0 === nindices && (nindices = 3 * INIT_VERTS_SIZE);
                while (dnindices > nindices) {
                    nindices *= 2;
                }
                var newIndices = new Uint16Array(nindices);
                if (indices) {
                    for (var i = 0, l = indices.length; i < l; i++) {
                        newIndices[i] = indices[i];
                    }
                }
                this._indicesBuffer = newIndices;
            }
        };
        _p._pushCmd = function(cmd) {
            var cmds = this._cmds;
            var lastCmd = cmds[cmds.length - 1];
            if (lastCmd) {
                var lastColor = lastCmd.color;
                var color = cmd.color;
                if (lastColor.r === color.r && lastColor.g === color.g && lastColor.b === color.b && lastColor.a === color.a && lastCmd.indicesOffset + lastCmd.nIndices === cmd.indicesOffset) {
                    lastCmd.nIndices += cmd.nIndices;
                    lastCmd.nverts += cmd.nverts;
                } else {
                    cmds.push(cmd);
                }
            } else {
                cmds.push(cmd);
            }
        };
        _p._expandStroke = function() {
            var w = .5 * this.lineWidth, lineCap = this.lineCap, lineJoin = this.lineJoin, miterLimit = this.miterLimit;
            var ncap = this._curveDivs(w, PI, this._tessTol);
            var paths = this._paths;
            this._calculateJoins(w, lineJoin, miterLimit);
            var cverts = 0;
            for (var i = this._pathOffset, l = this._pathLength; i < l; i++) {
                var path = paths[i];
                var pointsLength = path.points.length;
                cverts += lineJoin === LineJoin.ROUND ? 2 * (pointsLength + path.nbevel * (ncap + 2) + 1) : 2 * (pointsLength + 5 * path.nbevel + 1);
                path.closed || (cverts += lineCap === LineCap.ROUND ? 2 * (2 * ncap + 2) : 12);
            }
            this._allocVerts(cverts);
            this._allocIndices(3 * (cverts - 2 * (this._pathLength - this._pathOffset)));
            for (var i = this._pathOffset, l = this._pathLength; i < l; i++) {
                var path = paths[i];
                var pts = path.points;
                var pointsLength = path.points.length;
                var p0, p1;
                var s, e, loop;
                loop = path.closed;
                var offset = this._vertsOffset;
                if (loop) {
                    p0 = pts[pointsLength - 1];
                    p1 = pts[0];
                    s = 0;
                    e = pointsLength;
                } else {
                    p0 = pts[0];
                    p1 = pts[1];
                    s = 1;
                    e = pointsLength - 1;
                }
                if (!loop) {
                    var dPos = p1.sub(p0);
                    dPos.normalizeSelf();
                    var dx = dPos.x;
                    var dy = dPos.y;
                    lineCap === LineCap.BUTT ? this._buttCap(p0, dx, dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCap(p0, dx, dy, w, w) : lineCap === LineCap.ROUND && this._roundCapStart(p0, dx, dy, w, ncap);
                }
                for (var j = s; j < e; ++j) {
                    if (lineJoin === LineJoin.ROUND) {
                        this._roundJoin(p0, p1, w, w, ncap);
                    } else {
                        if (0 !== (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL))) {
                            this._bevelJoin(p0, p1, w, w);
                        } else {
                            this._vset(p1.x + p1.dmx * w, p1.y + p1.dmy * w);
                            this._vset(p1.x - p1.dmx * w, p1.y - p1.dmy * w);
                        }
                    }
                    p0 = p1;
                    p1 = pts[j + 1];
                }
                if (loop) {
                    var v0 = this._vget(offset);
                    var v1 = this._vget(offset + 1);
                    this._vset(v0.x, v0.y);
                    this._vset(v1.x, v1.y);
                } else {
                    var dPos = p1.sub(p0);
                    dPos.normalizeSelf();
                    var dx = dPos.x;
                    var dy = dPos.y;
                    lineCap === LineCap.BUTT ? this._buttCap(p1, dx, dy, w, 0) : lineCap === LineCap.BUTT || lineCap === LineCap.SQUARE ? this._buttCap(p1, dx, dy, w, w) : lineCap === LineCap.ROUND && this._roundCapEnd(p1, dx, dy, w, ncap);
                }
                var indicesOffset = this._indicesOffset;
                var indicesBuffer = this._indicesBuffer;
                for (var start = offset + 2, end = this._vertsOffset; start < end; start++) {
                    indicesBuffer[indicesOffset++] = start - 2;
                    indicesBuffer[indicesOffset++] = start - 1;
                    indicesBuffer[indicesOffset++] = start;
                }
                this._pushCmd({
                    color: this._strokeColor,
                    indicesOffset: this._indicesOffset,
                    nIndices: indicesOffset - this._indicesOffset,
                    vertsOffset: offset,
                    nverts: this._vertsOffset - offset
                });
                this._indicesOffset = indicesOffset;
                this._indicesDirty = true;
            }
        };
        _p._expandFill = function() {
            var paths = this._paths;
            var cverts = 0;
            for (var i = this._pathOffset, l = this._pathLength; i < l; i++) {
                var path = paths[i];
                var pointsLength = path.points.length;
                cverts += pointsLength;
            }
            this._allocVerts(cverts);
            this._allocIndices(3 * (cverts - 2 * (this._pathLength - this._pathOffset)));
            for (var i = this._pathOffset, l = this._pathLength; i < l; i++) {
                var path = paths[i];
                var pts = path.points;
                var pointsLength = pts.length;
                if (0 === pointsLength) {
                    continue;
                }
                var offset = this._vertsOffset;
                for (var j = 0; j < pointsLength; ++j) {
                    this._vset(pts[j].x, pts[j].y, .5, 1);
                }
                var indicesOffset = path.indicesOffset = this._indicesOffset;
                var indicesBuffer = this._indicesBuffer;
                var nIndices = 0;
                if (path.complex) {
                    var data = new Float32Array(this._vertsBuffer.buffer, 8 * offset, 2 * (this._vertsOffset - offset));
                    var newIndices = Earcut(data, null, 2);
                    if (!newIndices || 0 === newIndices.length) {
                        continue;
                    }
                    nIndices = newIndices.length;
                    for (var j = 0, l3 = nIndices; j < l3; j++) {
                        indicesBuffer[indicesOffset + j] = newIndices[j] + offset;
                    }
                } else {
                    var first = offset;
                    for (var start = offset + 2, end = this._vertsOffset; start < end; start++) {
                        indicesBuffer[indicesOffset++] = first;
                        indicesBuffer[indicesOffset++] = start - 1;
                        indicesBuffer[indicesOffset++] = start;
                    }
                    nIndices = indicesOffset - this._indicesOffset;
                }
                this._pushCmd({
                    color: this._fillColor,
                    indicesOffset: this._indicesOffset,
                    nIndices: nIndices,
                    vertsOffset: offset,
                    nverts: this._vertsOffset - offset
                });
                this._indicesOffset += nIndices;
                this._indicesDirty = true;
            }
        };
        _p._curveDivs = function(r, arc, tol) {
            var da = 2 * acos(r / (r + tol));
            return max(2, ceil(arc / da));
        };
        _p._calculateJoins = function(w, lineJoin, miterLimit) {
            var iw = 0;
            w > 0 && (iw = 1 / w);
            var paths = this._paths;
            for (var i = this._pathOffset, l = this._pathLength; i < l; i++) {
                var path = paths[i];
                var pts = path.points;
                var ptsLength = pts.length;
                var p0 = pts[ptsLength - 1];
                var p1 = pts[0];
                var nleft = 0;
                path.nbevel = 0;
                for (var j = 0; j < ptsLength; j++) {
                    var dmr2, cross, limit;
                    var dlx0 = p0.dy;
                    var dly0 = -p0.dx;
                    var dlx1 = p1.dy;
                    var dly1 = -p1.dx;
                    p1.dmx = .5 * (dlx0 + dlx1);
                    p1.dmy = .5 * (dly0 + dly1);
                    dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy;
                    if (dmr2 > 1e-6) {
                        var scale = 1 / dmr2;
                        scale > 600 && (scale = 600);
                        p1.dmx *= scale;
                        p1.dmy *= scale;
                    }
                    cross = p1.dx * p0.dy - p0.dx * p1.dy;
                    if (cross > 0) {
                        nleft++;
                        p1.flags |= PointFlags.PT_LEFT;
                    }
                    limit = max(11, min(p0.len, p1.len) * iw);
                    dmr2 * limit * limit < 1 && (p1.flags |= PointFlags.PT_INNERBEVEL);
                    p1.flags & PointFlags.PT_CORNER && (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) && (p1.flags |= PointFlags.PT_BEVEL);
                    0 !== (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) && path.nbevel++;
                    p0 = p1;
                    p1 = pts[j + 1];
                }
            }
        };
        _p._vset = function(x, y) {
            var offset = this._vertsOffset * VERTS_FLOAT_LENGTH;
            var buffer = this._vertsBuffer;
            buffer[offset] = x;
            buffer[offset + 1] = y;
            this._vertsOffset++;
        };
        _p._vget = function(index) {
            var buffer = this._vertsBuffer;
            var offset = index * VERTS_FLOAT_LENGTH;
            return {
                x: buffer[offset],
                y: buffer[offset + 1]
            };
        };
        _p._chooseBevel = function(bevel, p0, p1, w) {
            var x = p1.x;
            var y = p1.y;
            var x0, y0, x1, y1;
            if (0 !== bevel) {
                x0 = x + p0.dy * w;
                y0 = y - p0.dx * w;
                x1 = x + p1.dy * w;
                y1 = y - p1.dx * w;
            } else {
                x0 = x1 = x + p1.dmx * w;
                y0 = y1 = y + p1.dmy * w;
            }
            return [ x0, y0, x1, y1 ];
        };
        _p._buttCap = function(p, dx, dy, w, d) {
            var px = p.x - dx * d;
            var py = p.y - dy * d;
            var dlx = dy;
            var dly = -dx;
            this._vset(px + dlx * w, py + dly * w);
            this._vset(px - dlx * w, py - dly * w);
        };
        _p._roundCapStart = function(p, dx, dy, w, ncap) {
            var px = p.x;
            var py = p.y;
            var dlx = dy;
            var dly = -dx;
            for (var i = 0; i < ncap; i++) {
                var a = i / (ncap - 1) * PI;
                var ax = cos(a) * w, ay = sin(a) * w;
                this._vset(px - dlx * ax - dx * ay, py - dly * ax - dy * ay);
                this._vset(px, py);
            }
            this._vset(px + dlx * w, py + dly * w);
            this._vset(px - dlx * w, py - dly * w);
        };
        _p._roundCapEnd = function(p, dx, dy, w, ncap) {
            var px = p.x;
            var py = p.y;
            var dlx = dy;
            var dly = -dx;
            this._vset(px + dlx * w, py + dly * w);
            this._vset(px - dlx * w, py - dly * w);
            for (var i = 0; i < ncap; i++) {
                var a = i / (ncap - 1) * PI;
                var ax = cos(a) * w, ay = sin(a) * w;
                this._vset(px, py);
                this._vset(px - dlx * ax + dx * ay, py - dly * ax + dy * ay);
            }
        };
        _p._roundJoin = function(p0, p1, lw, rw, ncap) {
            var dlx0 = p0.dy;
            var dly0 = -p0.dx;
            var dlx1 = p1.dy;
            var dly1 = -p1.dx;
            var p1x = p1.x;
            var p1y = p1.y;
            if (0 !== (p1.flags & PointFlags.PT_LEFT)) {
                var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
                var lx0 = out[0];
                var ly0 = out[1];
                var lx1 = out[2];
                var ly1 = out[3];
                var a0 = atan2(-dly0, -dlx0);
                var a1 = atan2(-dly1, -dlx1);
                a1 > a0 && (a1 -= 2 * PI);
                this._vset(lx0, ly0);
                this._vset(p1x - dlx0 * rw, p1.y - dly0 * rw);
                var n = clamp(ceil((a0 - a1) / PI) * ncap, 2, ncap);
                for (var i = 0; i < n; i++) {
                    var u = i / (n - 1);
                    var a = a0 + u * (a1 - a0);
                    var rx = p1x + cos(a) * rw;
                    var ry = p1y + sin(a) * rw;
                    this._vset(p1x, p1y);
                    this._vset(rx, ry);
                }
                this._vset(lx1, ly1);
                this._vset(p1x - dlx1 * rw, p1y - dly1 * rw);
            } else {
                var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
                var rx0 = out[0];
                var ry0 = out[1];
                var rx1 = out[2];
                var ry1 = out[3];
                var a0 = atan2(dly0, dlx0);
                var a1 = atan2(dly1, dlx1);
                a1 < a0 && (a1 += 2 * PI);
                this._vset(p1x + dlx0 * rw, p1y + dly0 * rw);
                this._vset(rx0, ry0);
                var n = clamp(ceil((a1 - a0) / PI) * ncap, 2, ncap);
                for (var i = 0; i < n; i++) {
                    var u = i / (n - 1);
                    var a = a0 + u * (a1 - a0);
                    var lx = p1x + cos(a) * lw;
                    var ly = p1y + sin(a) * lw;
                    this._vset(lx, ly);
                    this._vset(p1x, p1y);
                }
                this._vset(p1x + dlx1 * rw, p1y + dly1 * rw);
                this._vset(rx1, ry1);
            }
        };
        _p._bevelJoin = function(p0, p1, lw, rw) {
            var rx0, ry0, rx1, ry1;
            var lx0, ly0, lx1, ly1;
            var dlx0 = p0.dy;
            var dly0 = -p0.dx;
            var dlx1 = p1.dy;
            var dly1 = -p1.dx;
            if (p1.flags & PointFlags.PT_LEFT) {
                var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
                lx0 = out[0];
                ly0 = out[1];
                lx1 = out[2];
                ly1 = out[3];
                this._vset(lx0, ly0);
                this._vset(p1.x - dlx0 * rw, p1.y - dly0 * rw);
                this._vset(lx1, ly1);
                this._vset(p1.x - dlx1 * rw, p1.y - dly1 * rw);
            } else {
                var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
                rx0 = out[0];
                ry0 = out[1];
                rx1 = out[2];
                ry1 = out[3];
                this._vset(p1.x + dlx0 * lw, p1.y + dly0 * lw);
                this._vset(rx0, ry0);
                this._vset(p1.x + dlx1 * lw, p1.y + dly1 * lw);
                this._vset(rx1, ry1);
            }
        };
        _p._tesselateBezier = function(x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
            var x12, y12, x23, y23, x34, y34, x123, y123, x234, y234, x1234, y1234;
            var dx, dy, d2, d3;
            if (level > 10) {
                return;
            }
            x12 = .5 * (x1 + x2);
            y12 = .5 * (y1 + y2);
            x23 = .5 * (x2 + x3);
            y23 = .5 * (y2 + y3);
            x34 = .5 * (x3 + x4);
            y34 = .5 * (y3 + y4);
            x123 = .5 * (x12 + x23);
            y123 = .5 * (y12 + y23);
            dx = x4 - x1;
            dy = y4 - y1;
            d2 = abs((x2 - x4) * dy - (y2 - y4) * dx);
            d3 = abs((x3 - x4) * dy - (y3 - y4) * dx);
            if ((d2 + d3) * (d2 + d3) < this._tessTol * (dx * dx + dy * dy)) {
                this._addPoint(x4, y4, 0 === type ? type | PointFlags.PT_BEVEL : type);
                return;
            }
            x234 = .5 * (x23 + x34);
            y234 = .5 * (y23 + y34);
            x1234 = .5 * (x123 + x234);
            y1234 = .5 * (y123 + y234);
            this._tesselateBezier(x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1, 0);
            this._tesselateBezier(x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type);
        };
        module.exports = WebGLRenderCmd;
    }), {
        "./earcut": 115,
        "./helper": 120,
        "./shader": 122,
        "./types": 123
    } ],
    119: [ (function(require, module, exports) {
        var LineCap = require("./types").LineCap;
        var LineJoin = require("./types").LineJoin;
        var Graphics = cc.Class({
            name: "cc.Graphics",
            extends: cc._RendererUnderSG,
            editor: false,
            properties: {
                _lineWidth: 1,
                _strokeColor: cc.Color.BLACK,
                _lineJoin: LineJoin.MITER,
                _lineCap: LineCap.BUTT,
                _fillColor: cc.Color.WHITE,
                _miterLimit: 10,
                lineWidth: {
                    get: function() {
                        return this._lineWidth;
                    },
                    set: function(value) {
                        this._sgNode.lineWidth = this._lineWidth = value;
                    }
                },
                lineJoin: {
                    get: function() {
                        return this._lineJoin;
                    },
                    set: function(value) {
                        this._sgNode.lineJoin = this._lineJoin = value;
                    },
                    type: LineJoin
                },
                lineCap: {
                    get: function() {
                        return this._lineCap;
                    },
                    set: function(value) {
                        this._sgNode.lineCap = this._lineCap = value;
                    },
                    type: LineCap
                },
                strokeColor: {
                    get: function() {
                        return this._strokeColor;
                    },
                    set: function(value) {
                        this._sgNode.strokeColor = this._strokeColor = value;
                    }
                },
                fillColor: {
                    get: function() {
                        return this._fillColor;
                    },
                    set: function(value) {
                        this._sgNode.fillColor = this._fillColor = value;
                    }
                },
                miterLimit: {
                    get: function() {
                        return this._miterLimit;
                    },
                    set: function(value) {
                        this._sgNode.miterLimit = this._miterLimit = value;
                    }
                }
            },
            statics: {
                LineJoin: LineJoin,
                LineCap: LineCap
            },
            _createSgNode: function() {
                var sgNode;
                var func;
                return new _ccsg.GraphicsNode();
            },
            _initSgNode: function() {
                var sgNode = this._sgNode;
                sgNode.lineWidth = this._lineWidth;
                sgNode.lineJoin = this._lineJoin;
                sgNode.lineCap = this._lineCap;
                sgNode.strokeColor = this._strokeColor;
                sgNode.fillColor = this._fillColor;
                sgNode.miterLimit = this._miterLimit;
                sgNode.setContentSize(this.node.getContentSize(true));
            },
            moveTo: function(x, y) {
                this._sgNode.moveTo(x, y);
            },
            lineTo: function(x, y) {
                this._sgNode.lineTo(x, y);
            },
            bezierCurveTo: function(c1x, c1y, c2x, c2y, x, y) {
                this._sgNode.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
            },
            quadraticCurveTo: function(cx, cy, x, y) {
                this._sgNode.quadraticCurveTo(cx, cy, x, y);
            },
            arc: function(cx, cy, r, startAngle, endAngle, counterclockwise) {
                counterclockwise = counterclockwise || false;
                this._sgNode.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
            },
            ellipse: function(cx, cy, rx, ry) {
                this._sgNode.ellipse(cx, cy, rx, ry);
            },
            circle: function(cx, cy, r) {
                this._sgNode.circle(cx, cy, r);
            },
            rect: function(x, y, w, h) {
                this._sgNode.rect(x, y, w, h);
            },
            roundRect: function(x, y, w, h, r) {
                this._sgNode.roundRect(x, y, w, h, r);
            },
            fillRect: function(x, y, w, h) {
                this._sgNode.fillRect(x, y, w, h);
            },
            clear: function() {
                this._sgNode.clear();
            },
            close: function() {
                this._sgNode.close();
            },
            stroke: function() {
                this._sgNode.stroke();
            },
            fill: function() {
                this._sgNode.fill();
            }
        });
        cc.Graphics = module.exports = Graphics;
    }), {
        "./types": 123
    } ],
    120: [ (function(require, module, exports) {
        var PI = Math.PI;
        var min = Math.min;
        var max = Math.max;
        var cos = Math.cos;
        var sin = Math.sin;
        var abs = Math.abs;
        var sign = Math.sign;
        var KAPPA90 = .5522847493;
        function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
            counterclockwise = counterclockwise || false;
            var a = 0, da = 0, hda = 0, kappa = 0;
            var dx = 0, dy = 0, x = 0, y = 0, tanx = 0, tany = 0;
            var px = 0, py = 0, ptanx = 0, ptany = 0;
            var i, ndivs;
            da = endAngle - startAngle;
            if (counterclockwise) {
                if (abs(da) >= 2 * PI) {
                    da = 2 * PI;
                } else {
                    while (da < 0) {
                        da += 2 * PI;
                    }
                }
            } else {
                if (abs(da) >= 2 * PI) {
                    da = 2 * -PI;
                } else {
                    while (da > 0) {
                        da -= 2 * PI;
                    }
                }
            }
            ndivs = 0 | max(1, min(abs(da) / (.5 * PI) + .5, 5));
            hda = da / ndivs / 2;
            kappa = abs(4 / 3 * (1 - cos(hda)) / sin(hda));
            counterclockwise || (kappa = -kappa);
            for (i = 0; i <= ndivs; i++) {
                a = startAngle + da * (i / ndivs);
                dx = cos(a);
                dy = sin(a);
                x = cx + dx * r;
                y = cy + dy * r;
                tanx = -dy * r * kappa;
                tany = dx * r * kappa;
                0 === i ? ctx.moveTo(x, y) : ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y);
                px = x;
                py = y;
                ptanx = tanx;
                ptany = tany;
            }
        }
        function ellipse(ctx, cx, cy, rx, ry) {
            ctx.moveTo(cx - rx, cy);
            ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry);
            ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy);
            ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry);
            ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy);
            ctx.close();
        }
        function roundRect(ctx, x, y, w, h, r) {
            if (r < .1) {
                ctx.rect(x, y, w, h);
                return;
            }
            var rx = min(r, .5 * abs(w)) * sign(w), ry = min(r, .5 * abs(h)) * sign(h);
            ctx.moveTo(x, y + ry);
            ctx.lineTo(x, y + h - ry);
            ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h);
            ctx.lineTo(x + w - rx, y + h);
            ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry);
            ctx.lineTo(x + w, y + ry);
            ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y);
            ctx.lineTo(x + rx, y);
            ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry);
            ctx.close();
        }
        module.exports = {
            arc: arc,
            ellipse: ellipse,
            roundRect: roundRect
        };
    }), {} ],
    121: [ (function(require, module, exports) {
        "use strict";
        var GraphicsNode;
        GraphicsNode = cc.sys.isNative ? _ccsg.GraphicsNode = cc.GraphicsNode : _ccsg.GraphicsNode = require("./graphics-node");
        if (GraphicsNode) {
            var misc = require("../utils/misc");
            misc.propertyDefine(GraphicsNode, [ "lineWidth", "lineCap", "lineJoin", "miterLimit", "strokeColor", "fillColor" ], {});
        }
        require("./graphics");
    }), {
        "../utils/misc": 223,
        "./graphics": 119,
        "./graphics-node": 117
    } ],
    122: [ (function(require, module, exports) {
        var vert = [ "attribute vec4 a_position;", "", "void main()", "{", "gl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;", "}" ];
        var frag = [ "#ifdef GL_ES", "precision mediump float;", "#endif", "", "uniform vec4 color;", "", "void main(void) {", "gl_FragColor = color;", "}" ];
        module.exports = {
            vert: vert.join(" \n"),
            frag: frag.join(" \n")
        };
    }), {} ],
    123: [ (function(require, module, exports) {
        "use strict";
        var LineCap = cc.Enum({
            BUTT: 0,
            ROUND: 1,
            SQUARE: 2
        });
        var LineJoin = cc.Enum({
            BEVEL: 0,
            ROUND: 1,
            MITER: 2
        });
        module.exports = {
            LineCap: LineCap,
            LineJoin: LineJoin
        };
    }), {} ],
    124: [ (function(require, module, exports) {
        require("./platform");
        require("./assets");
        require("./CCNode");
        require("./CCScene");
        require("./components");
        require("./graphics");
        require("./collider");
        require("./physics");
        require("./camera/CCCamera");
        require("./base-ui/CCWidgetManager");
    }), {
        "./CCNode": 41,
        "./CCScene": 42,
        "./assets": 55,
        "./base-ui/CCWidgetManager": 60,
        "./camera/CCCamera": 61,
        "./collider": 70,
        "./components": 102,
        "./graphics": 121,
        "./physics": 156,
        "./platform": 190
    } ],
    125: [ (function(require, module, exports) {
        var eventRegx = /^(click)(\s)*=/;
        cc.HtmlTextParser = function() {
            this._parsedObject = {};
            this._specialSymbolArray = [];
            this._specialSymbolArray.push([ /&lt;/g, "<" ]);
            this._specialSymbolArray.push([ /&gt;/g, ">" ]);
            this._specialSymbolArray.push([ /&amp;/g, "&" ]);
            this._specialSymbolArray.push([ /&quot;/g, '"' ]);
            this._specialSymbolArray.push([ /&apos;/g, "'" ]);
        };
        cc.HtmlTextParser.prototype = {
            constructor: cc.HtmlTextParser,
            parse: function(htmlString) {
                this._resultObjectArray = [];
                this._stack = [];
                var startIndex = 0;
                var length = htmlString.length;
                while (startIndex < length) {
                    var tagBeginIndex = htmlString.indexOf("<", startIndex);
                    if (tagBeginIndex < 0) {
                        this._stack.pop();
                        this._processResult(htmlString.substring(startIndex));
                        startIndex = length;
                    } else {
                        this._processResult(htmlString.substring(startIndex, tagBeginIndex));
                        var tagEndIndex = htmlString.indexOf(">", startIndex);
                        tagEndIndex === -1 ? tagEndIndex = tagBeginIndex : "/" === htmlString.charAt(tagBeginIndex + 1) ? this._stack.pop() : this._addToStack(htmlString.substring(tagBeginIndex + 1, tagEndIndex));
                        startIndex = tagEndIndex + 1;
                    }
                }
                return this._resultObjectArray;
            },
            _attributeToObject: function(attribute) {
                attribute = attribute.trim();
                var obj = {};
                var header = attribute.match(/^(color|size)(\s)*=/);
                var tagName;
                var nextSpace;
                var eventObj;
                var eventHanlderString;
                if (header) {
                    tagName = header[0];
                    attribute = attribute.substring(tagName.length).trim();
                    if ("" === attribute) {
                        return obj;
                    }
                    nextSpace = attribute.indexOf(" ");
                    switch (tagName[0]) {
                      case "c":
                        nextSpace > -1 ? obj.color = attribute.substring(0, nextSpace).trim() : obj.color = attribute;
                        break;

                      case "s":
                        obj.size = parseInt(attribute);
                    }
                    if (nextSpace > -1) {
                        eventHanlderString = attribute.substring(nextSpace + 1).trim();
                        eventObj = this._processEventHandler(eventHanlderString);
                        obj.event = eventObj;
                    }
                    return obj;
                }
                header = attribute.match(/^(br(\s)*\/)/);
                if (header && header[0].length > 0) {
                    tagName = header[0].trim();
                    if (tagName.startsWith("br") && "/" === tagName[tagName.length - 1]) {
                        obj.isNewLine = true;
                        this._resultObjectArray.push({
                            text: "",
                            style: {
                                newline: true
                            }
                        });
                        return obj;
                    }
                }
                header = attribute.match(/^(img(\s)*src(\s)*=[^>]+\/)/);
                if (header && header[0].length > 0) {
                    tagName = header[0].trim();
                    if (tagName.startsWith("img") && "/" === tagName[tagName.length - 1]) {
                        var srcBegin = tagName.indexOf("=");
                        var remainingArgument = tagName.substring(srcBegin + 1).trim();
                        var imageSrc;
                        var endQuotIndex = -1;
                        var isValidImageTag = false;
                        switch (remainingArgument[0]) {
                          case "'":
                            endQuotIndex = remainingArgument.indexOf("'", 1);
                            if (endQuotIndex > -1) {
                                imageSrc = remainingArgument.substring(1, endQuotIndex);
                                isValidImageTag = true;
                            }
                            break;

                          case '"':
                            endQuotIndex = remainingArgument.indexOf('"', 1);
                            if (endQuotIndex > -1) {
                                imageSrc = remainingArgument.substring(1, endQuotIndex);
                                isValidImageTag = true;
                            }
                        }
                        if (isValidImageTag) {
                            obj.isImage = true;
                            obj.src = imageSrc;
                            eventHanlderString = remainingArgument.substring(endQuotIndex + 1).trim();
                            if (eventHanlderString.match(eventRegx)) {
                                eventObj = this._processEventHandler(eventHanlderString);
                                obj.event = eventObj;
                            }
                            this._resultObjectArray.push({
                                text: "",
                                style: obj
                            });
                        }
                        return {};
                    }
                }
                header = attribute.match(/^(outline(\s)*[^>]*)/);
                if (header) {
                    attribute = header[0].substring("outline".length).trim();
                    var defaultOutlineObject = {
                        color: "#ffffff",
                        width: 1
                    };
                    if (attribute) {
                        var outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=/;
                        header = attribute.match(outlineAttrReg);
                        var tagValue;
                        while (header) {
                            attribute = attribute.substring(attribute.indexOf(header[0]));
                            tagName = attribute.substr(0, header[0].length);
                            remainingArgument = attribute.substring(tagName.length).trim();
                            nextSpace = remainingArgument.indexOf(" ");
                            tagValue = nextSpace > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument;
                            tagName = tagName.replace(/[^a-zA-Z]/g, "").trim();
                            tagName = tagName.toLocaleLowerCase();
                            attribute = remainingArgument.substring(nextSpace).trim();
                            "click" === tagName ? obj.event = this._processEventHandler(tagName + "=" + tagValue) : "color" === tagName ? defaultOutlineObject.color = tagValue : "width" === tagName && (defaultOutlineObject.width = parseInt(tagValue));
                            header = attribute.match(outlineAttrReg);
                        }
                    }
                    obj.outline = defaultOutlineObject;
                }
                header = attribute.match(/^(on|u|b|i)(\s)*/);
                if (header && header[0].length > 0) {
                    tagName = header[0];
                    attribute = attribute.substring(tagName.length).trim();
                    switch (tagName[0]) {
                      case "u":
                        obj.underline = true;
                        break;

                      case "i":
                        obj.italic = true;
                        break;

                      case "b":
                        obj.bold = true;
                    }
                    if ("" === attribute) {
                        return obj;
                    }
                    eventObj = this._processEventHandler(attribute);
                    obj.event = eventObj;
                }
                return obj;
            },
            _processEventHandler: function(eventString) {
                var index = 0;
                var obj = {};
                var eventNames = eventString.match(eventRegx);
                var isValidTag = false;
                while (eventNames) {
                    var eventName = eventNames[0];
                    var eventValue = "";
                    isValidTag = false;
                    eventString = eventString.substring(eventName.length).trim();
                    if ('"' === eventString.charAt(0)) {
                        index = eventString.indexOf('"', 1);
                        if (index > -1) {
                            eventValue = eventString.substring(1, index).trim();
                            isValidTag = true;
                        }
                        index++;
                    } else {
                        if ("'" === eventString.charAt(0)) {
                            index = eventString.indexOf("'", 1);
                            if (index > -1) {
                                eventValue = eventString.substring(1, index).trim();
                                isValidTag = true;
                            }
                            index++;
                        } else {
                            var match = eventString.match(/(\S)+/);
                            eventValue = match ? match[0] : "";
                            index = eventValue.length;
                        }
                    }
                    if (isValidTag) {
                        eventName = eventName.substring(0, eventName.length - 1).trim();
                        obj[eventName] = eventValue;
                    }
                    eventString = eventString.substring(index).trim();
                    eventNames = eventString.match(eventRegx);
                }
                return obj;
            },
            _addToStack: function(attribute) {
                var obj = this._attributeToObject(attribute);
                if (0 === this._stack.length) {
                    this._stack.push(obj);
                } else {
                    if (obj.isNewLine || obj.isImage) {
                        return;
                    }
                    var previousTagObj = this._stack[this._stack.length - 1];
                    for (var key in previousTagObj) {
                        obj[key] || (obj[key] = previousTagObj[key]);
                    }
                    this._stack.push(obj);
                }
            },
            _processResult: function(value) {
                if ("" === value) {
                    return;
                }
                value = this._escapeSpecialSymbol(value);
                this._stack.length > 0 ? this._resultObjectArray.push({
                    text: value,
                    style: this._stack[this._stack.length - 1]
                }) : this._resultObjectArray.push({
                    text: value
                });
            },
            _escapeSpecialSymbol: function(str) {
                for (var i = 0; i < this._specialSymbolArray.length; ++i) {
                    var key = this._specialSymbolArray[i][0];
                    var value = this._specialSymbolArray[i][1];
                    str = str.replace(key, value);
                }
                return str;
            }
        };
        cc.htmlTextParser = new cc.HtmlTextParser();
    }), {} ],
    126: [ (function(require, module, exports) {
        require("./CCTextUtils.js");
        var EventTarget = require("../event/event-target");
        var FntLoader = {
            INFO_EXP: /info [^\n]*(\n|$)/gi,
            COMMON_EXP: /common [^\n]*(\n|$)/gi,
            PAGE_EXP: /page [^\n]*(\n|$)/gi,
            CHAR_EXP: /char [^\n]*(\n|$)/gi,
            KERNING_EXP: /kerning [^\n]*(\n|$)/gi,
            ITEM_EXP: /\w+=[^ \r\n]+/gi,
            INT_EXP: /^[\-]?\d+$/,
            _parseStrToObj: function(str) {
                var arr = str.match(this.ITEM_EXP);
                var obj = {};
                if (arr) {
                    for (var i = 0, li = arr.length; i < li; i++) {
                        var tempStr = arr[i];
                        var index = tempStr.indexOf("=");
                        var key = tempStr.substring(0, index);
                        var value = tempStr.substring(index + 1);
                        value.match(this.INT_EXP) ? value = parseInt(value) : '"' === value[0] && (value = value.substring(1, value.length - 1));
                        obj[key] = value;
                    }
                }
                return obj;
            },
            parseFnt: function(fntStr) {
                var self = this, fnt = {};
                var infoResult = fntStr.match(self.INFO_EXP);
                if (!infoResult) {
                    return fnt;
                }
                var infoObj = self._parseStrToObj(infoResult[0]);
                var paddingArr = infoObj["padding"].split(",");
                var padding = {
                    left: parseInt(paddingArr[0]),
                    top: parseInt(paddingArr[1]),
                    right: parseInt(paddingArr[2]),
                    bottom: parseInt(paddingArr[3])
                };
                var commonObj = self._parseStrToObj(fntStr.match(self.COMMON_EXP)[0]);
                fnt.commonHeight = commonObj["lineHeight"];
                fnt.fontSize = infoObj["size"];
                if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                    var texSize = cc.configuration.getMaxTextureSize();
                    (commonObj["scaleW"] > texSize.width || commonObj["scaleH"] > texSize.height) && cc.log("cc.LabelBMFont._parseCommonArguments(): page can't be larger than supported");
                }
                1 !== commonObj["pages"] && cc.log("cc.LabelBMFont._parseCommonArguments(): only supports 1 page");
                var pageObj = self._parseStrToObj(fntStr.match(self.PAGE_EXP)[0]);
                0 !== pageObj["id"] && cc.log("cc.LabelBMFont._parseImageFileName() : file could not be found");
                fnt.atlasName = pageObj["file"];
                var charLines = fntStr.match(self.CHAR_EXP);
                var fontDefDictionary = fnt.fontDefDictionary = {};
                for (var i = 0, li = charLines.length; i < li; i++) {
                    var charObj = self._parseStrToObj(charLines[i]);
                    var charId = charObj["id"];
                    fontDefDictionary[charId] = {
                        rect: {
                            x: charObj["x"],
                            y: charObj["y"],
                            width: charObj["width"],
                            height: charObj["height"]
                        },
                        xOffset: charObj["xoffset"],
                        yOffset: charObj["yoffset"],
                        xAdvance: charObj["xadvance"]
                    };
                }
                var kerningDict = fnt.kerningDict = {};
                var kerningLines = fntStr.match(self.KERNING_EXP);
                if (kerningLines) {
                    for (i = 0, li = kerningLines.length; i < li; i++) {
                        var kerningObj = self._parseStrToObj(kerningLines[i]);
                        kerningDict[kerningObj["first"] << 16 | 65535 & kerningObj["second"]] = kerningObj["amount"];
                    }
                }
                return fnt;
            }
        };
        var FontLetterDefinition = function() {
            this._u = 0;
            this._v = 0;
            this._width = 0;
            this._height = 0;
            this._offsetX = 0;
            this._offsetY = 0;
            this._textureID = 0;
            this._validDefinition = false;
            this._xAdvance = 0;
        };
        cc.FontAtlas = function(fntConfig) {
            this._lineHeight = fntConfig.commonHeight;
            this._fontSize = fntConfig.fontSize;
            this._letterDefinitions = {};
            this._fntConfig = fntConfig;
        };
        cc.FontAtlas.prototype = {
            constructor: cc.FontAtlas,
            setFontSize: function(fontSize) {
                this._fontSize = fontSize;
            },
            getOriginalFontSize: function() {
                return this._fntConfig.fontSize;
            },
            addLetterDefinitions: function(letter, letterDefinition) {
                this._letterDefinitions[letter] = letterDefinition;
            },
            cloneLetterDefinition: function() {
                var copyLetterDefinitions = {};
                for (var key in this._letterDefinitions) {
                    var value = new FontLetterDefinition();
                    cc.js.mixin(value, this._letterDefinitions[key]);
                    copyLetterDefinitions[key] = value;
                }
                return copyLetterDefinitions;
            },
            assignLetterDefinitions: function(letterDefinition) {
                for (var key in this._letterDefinitions) {
                    var newValue = letterDefinition[key];
                    var oldValue = this._letterDefinitions[key];
                    cc.js.mixin(oldValue, newValue);
                }
            },
            scaleFontLetterDefinition: function(scaleFactor) {
                for (var fontDefinition in this._letterDefinitions) {
                    var letterDefinitions = this._letterDefinitions[fontDefinition];
                    letterDefinitions._width *= scaleFactor;
                    letterDefinitions._height *= scaleFactor;
                    letterDefinitions._offsetX *= scaleFactor;
                    letterDefinitions._offsetY *= scaleFactor;
                    letterDefinitions._xAdvance *= scaleFactor;
                }
            },
            getLetterDefinitionForChar: function(char) {
                var hasKey = this._letterDefinitions.hasOwnProperty(char.charCodeAt(0));
                var letterDefinition;
                letterDefinition = hasKey ? this._letterDefinitions[char.charCodeAt(0)] : null;
                return letterDefinition;
            }
        };
        var LetterInfo = function() {
            this._char = "";
            this._valid = true;
            this._positionX = 0;
            this._positionY = 0;
            this._atlasIndex = 0;
            this._lineIndex = 0;
        };
        _ccsg.Label = _ccsg.Node.extend({
            _hAlign: cc.TextAlignment.LEFT,
            _vAlign: cc.VerticalTextAlignment.TOP,
            _string: "",
            _fontSize: 40,
            _drawFontsize: 40,
            _overFlow: 0,
            _isWrapText: true,
            _spacingX: 0,
            _blendFunc: null,
            _labelType: 0,
            _fontHandle: "",
            _lineSpacing: 0,
            _maxLineWidth: 0,
            _labelDimensions: cc.size(0, 0),
            _labelWidth: 0,
            _labelHeight: 0,
            _lineHeight: 40,
            _outlined: false,
            _outlineColor: null,
            _outlineWidth: 1,
            _gradientEnabled: false,
            _gradientStartColor: cc.color(255, 255, 255, 255),
            _gradientEndColor: cc.color(255, 255, 255, 255),
            _gradientDirection: 0,
            _className: "Label",
            _margin: 0,
            _isBold: false,
            _isItalic: false,
            _isUnderline: false,
            _fontAsset: null,
            ctor: function(string, fontHandle, spriteFrame, fontAsset) {
                EventTarget.call(this);
                fontHandle = fontHandle || "";
                this._fontHandle = fontHandle;
                "string" !== typeof string && (string = "" + string);
                this._string = string;
                _ccsg.Node.prototype.ctor.call(this);
                this.setAnchorPoint(cc.p(.5, .5));
                _ccsg.Node.prototype.setContentSize.call(this, cc.size(128, 128));
                this._blendFunc = cc.BlendFunc._alphaNonPremultiplied();
                this.setFontFileOrFamily(fontHandle, spriteFrame, fontAsset);
                this.setString(this._string);
            },
            _resetBMFont: function() {
                this._imageOffset = cc.p(0, 0);
                this._cascadeColorEnabled = true;
                this._cascadeOpacityEnabled = true;
                this._fontAtlas = null;
                this._config = null;
                this._numberOfLines = 0;
                this._lettersInfo = [];
                this._linesWidth = [];
                this._linesOffsetX = [];
                this._textDesiredHeight = 0;
                this._letterOffsetY = 0;
                this._tailoredTopY = 0;
                this._tailoredBottomY = 0;
                this._bmfontScale = 1;
                this._horizontalKernings = [];
                this._lineBreakWithoutSpaces = false;
                this._reusedRect = cc.rect(0, 0, 0, 0);
                this._textureLoaded = false;
                if (this._spriteBatchNode) {
                    this.removeChild(this._spriteBatchNode);
                    this._spriteBatchNode = null;
                }
            },
            setHorizontalAlign: function(align) {
                if (this._hAlign === align) {
                    return;
                }
                this._hAlign = align;
                this._notifyLabelSkinDirty();
            },
            getHorizontalAlign: function() {
                return this._hAlign;
            },
            setVerticalAlign: function(align) {
                if (this._vAlign === align) {
                    return;
                }
                this._vAlign = align;
                this._notifyLabelSkinDirty();
            },
            getVerticalAlign: function() {
                return this._vAlign;
            },
            setString: function(string) {
                "string" !== typeof string && (string = "" + string);
                if (this._string === string) {
                    return;
                }
                this._string = string;
                this._notifyLabelSkinDirty();
            },
            setMargin: function(value) {
                if (this._margin === value) {
                    return;
                }
                this._margin = value;
                this._notifyLabelSkinDirty();
            },
            getString: function() {
                return this._string;
            },
            getStringLength: function() {
                return this._string.length;
            },
            enableWrapText: function(enabled) {
                if (this._isWrapText === enabled) {
                    return;
                }
                if (this._overFlow === _ccsg.Label.Overflow.RESIZE_HEIGHT || this._overFlow === _ccsg.Label.Overflow.NONE) {
                    return;
                }
                this._isWrapText = enabled;
                this._rescaleWithOriginalFontSize();
                this._notifyLabelSkinDirty();
            },
            enableItalics: function(enabled) {
                this._isItalic = enabled;
                enabled ? this.setSkewX(12) : this.setSkewX(0);
            },
            enableBold: function(enabled) {
                if (this._isBold === enabled) {
                    return;
                }
                this._isBold = enabled;
                this._notifyLabelSkinDirty();
            },
            enableUnderline: function(enabled) {
                if (this._isUnderline === enabled) {
                    return;
                }
                this._isUnderline = enabled;
                this._notifyLabelSkinDirty();
            },
            isWrapTextEnabled: function() {
                return this._isWrapText;
            },
            getFontName: function() {
                return this._fontHandle;
            },
            setFontSize: function(fntSize) {
                if (this._fontSize === fntSize) {
                    return;
                }
                this._fontSize = fntSize;
                this._drawFontsize = fntSize;
                this._notifyLabelSkinDirty();
            },
            getFontSize: function() {
                return this._fontSize;
            },
            isOutlined: function() {
                return this._outlined;
            },
            setOutlined: function(value) {
                if (this._outlined === value) {
                    return;
                }
                this._outlined = !!value;
                this._notifyLabelSkinDirty();
            },
            setFillColorGradientEnabled: function(value) {
                if (this._gradientEnabled === value) {
                    return;
                }
                this._gradientEnabled = !!value;
                this._notifyLabelSkinDirty();
            },
            getFillColorGradientEnabled: function() {
                return this._gradientEnabled;
            },
            setGradientStartColor: function(value) {
                if (this._gradientStartColor === value) {
                    return;
                }
                this._gradientStartColor = value;
                this._notifyLabelSkinDirty();
            },
            getGradientStartColor: function() {
                return this._gradientStartColor;
            },
            setGradientEndColor: function(value) {
                if (this._gradientEndColor === value) {
                    return;
                }
                this._gradientEndColor = value;
                this._notifyLabelSkinDirty();
            },
            getGradientEndColor: function() {
                return this._gradientEndColor;
            },
            setFillColorGradientDirection: function(direction) {
                this._gradientDirection = direction;
                this._notifyLabelSkinDirty();
            },
            getFillColorGradientDirection: function() {
                return this._gradientDirection;
            },
            getOutlineColor: function() {
                return this._outlineColor;
            },
            setOutlineColor: function(value) {
                if (this._outlineColor === value) {
                    return;
                }
                this._outlineColor = cc.color(value);
                this._notifyLabelSkinDirty();
            },
            setOutlineWidth: function(value) {
                if (this._outlineWidth === value) {
                    return;
                }
                this._outlineWidth = value;
                this._notifyLabelSkinDirty();
            },
            getOutlineWidth: function() {
                return this._outlineWidth;
            },
            _updateWrapText: function(overflow) {
                overflow === _ccsg.Label.Overflow.RESIZE_HEIGHT && (this._isWrapText = true);
                overflow === _ccsg.Label.Overflow.NONE && (this._isWrapText = false);
            },
            _setOverflowBMFont: function() {
                if (this._labelType === _ccsg.Label.Type.BMFont) {
                    this._overFlow === _ccsg.Label.Overflow.RESIZE_HEIGHT && this._setDimensions(this._labelDimensions.width, 0);
                    this._overFlow === _ccsg.Label.Overflow.NONE && this._setDimensions(0, 0);
                    this._rescaleWithOriginalFontSize();
                }
            },
            setOverflow: function(overflow) {
                if (this._overFlow === overflow) {
                    return;
                }
                this._overFlow = overflow;
                this._updateWrapText(this._overFlow);
                this._setOverflowBMFont();
                this._notifyLabelSkinDirty();
            },
            getOverflow: function() {
                return this._overFlow;
            },
            setSpacingX: function(spacing) {
                if (this._spacingX === spacing) {
                    return;
                }
                this._spacingX = spacing;
                this._notifyLabelSkinDirty();
            },
            setLineHeight: function(lineHeight) {
                if (this._lineHeight === lineHeight) {
                    return;
                }
                this._lineHeight = lineHeight;
                this._notifyLabelSkinDirty();
            },
            setLineBreakWithoutSpace: function(lineBreakFlag) {
                if (this._lineBreakWithoutSpaces === lineBreakFlag) {
                    return;
                }
                this._lineBreakWithoutSpaces = lineBreakFlag;
                this._notifyLabelSkinDirty();
            },
            getSpacingX: function() {
                return this._spacingX;
            },
            getLineHeight: function() {
                return this._lineHeight;
            },
            getBMFontLineHeight: function() {
                if (this._fontAtlas) {
                    return this._fontAtlas._lineHeight;
                }
            },
            setFontFileOrFamily: function(fontHandle, spriteFrame, fontAsset) {
                fontHandle = fontHandle || "Arial";
                this._fontAsset = fontAsset;
                var extName = cc.path.extname(fontHandle);
                this._resetBMFont();
                if (!extName && !spriteFrame) {
                    this._fontHandle = fontHandle;
                    this._labelType = _ccsg.Label.Type.SystemFont;
                    this._blendFunc = cc.BlendFunc._alphaPremultiplied();
                    this._renderCmd._needDraw = true;
                    this._notifyLabelSkinDirty();
                    this.emit("load");
                    return;
                }
                if (".ttf" === extName) {
                    this._labelType = _ccsg.Label.Type.TTF;
                    this._blendFunc = cc.BlendFunc._alphaPremultiplied();
                    this._renderCmd._needDraw = true;
                    this._fontHandle = this._loadTTFFont(fontHandle);
                } else {
                    if (spriteFrame) {
                        this._labelType = _ccsg.Label.Type.BMFont;
                        this._blendFunc = cc.BlendFunc._alphaNonPremultiplied();
                        this._renderCmd._needDraw = false;
                        this._initBMFontWithString(this._string, fontHandle, spriteFrame);
                    }
                }
                this._notifyLabelSkinDirty();
            },
            _loadTTFFont: function(fontHandle) {
                var self = this;
                var fontFamilyName = cc.CustomFontLoader._getFontFamily(fontHandle);
                var callback = function() {
                    self._notifyLabelSkinDirty();
                    self.emit("load");
                };
                cc.CustomFontLoader.loadTTF(fontHandle, callback);
                return fontFamilyName;
            },
            setContentSize: function(size, height) {
                if (this._overFlow === _ccsg.Label.Overflow.NONE) {
                    return;
                }
                this._setDimensions(size, height);
            },
            setBlendFunc: function(src, dst) {
                var locBlendFunc = this._blendFunc;
                if (void 0 === dst) {
                    locBlendFunc.src = src.src;
                    locBlendFunc.dst = src.dst;
                } else {
                    locBlendFunc.src = src;
                    locBlendFunc.dst = dst;
                }
            },
            getBlendFunc: function() {
                return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
            },
            _setupBMFontOverflowMetrics: function(newWidth, newHeight) {
                this._overFlow === _ccsg.Label.Overflow.RESIZE_HEIGHT && (newHeight = 0);
                if (this._overFlow === _ccsg.Label.Overflow.NONE) {
                    newWidth = 0;
                    newHeight = 0;
                }
                this._labelWidth = newWidth;
                this._labelHeight = newHeight;
                this._labelDimensions.width = newWidth;
                this._labelDimensions.height = newHeight;
                this._maxLineWidth = newWidth;
            },
            _updateLabel: function() {
                if (this._labelType === _ccsg.Label.Type.BMFont) {
                    var contentSize = this._contentSize;
                    var newWidth = contentSize.width;
                    var newHeight = contentSize.height;
                    this._setupBMFontOverflowMetrics(newWidth, newHeight);
                    this._updateContent();
                    this.setColor(this.color);
                } else {
                    this._labelType !== _ccsg.Label.Type.TTF && this._labelType !== _ccsg.Label.Type.SystemFont || this._renderCmd._bakeLabel();
                }
            },
            _notifyLabelSkinDirty: function() {
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.textDirty | _ccsg.Node._dirtyFlags.contentDirty);
            },
            _createRenderCmd: function() {
                return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new _ccsg.Label.WebGLRenderCmd(this) : new _ccsg.Label.CanvasRenderCmd(this);
            },
            getContentSize: function() {
                var locFlag = this._renderCmd._dirtyFlag;
                if (locFlag & _ccsg.Node._dirtyFlags.textDirty) {
                    this._updateLabel();
                    this._renderCmd._dirtyFlag &= ~_ccsg.Node._dirtyFlags.textDirty;
                }
                return _ccsg.Node.prototype.getContentSize.call(this);
            },
            _getWidth: function() {
                var locFlag = this._renderCmd._dirtyFlag;
                if (locFlag & _ccsg.Node._dirtyFlags.textDirty) {
                    this._updateLabel();
                    this._renderCmd._dirtyFlag &= ~_ccsg.Node._dirtyFlags.textDirty;
                }
                return _ccsg.Node.prototype._getWidth.call(this);
            },
            _getHeight: function() {
                var locFlag = this._renderCmd._dirtyFlag;
                if (locFlag & _ccsg.Node._dirtyFlags.textDirty) {
                    this._updateLabel();
                    this._renderCmd._dirtyFlag &= ~_ccsg.Node._dirtyFlags.textDirty;
                }
                return _ccsg.Node.prototype._getHeight.call(this);
            },
            _alignText: function() {
                var ret = true;
                do {
                    if (!this._spriteBatchNode) {
                        return true;
                    }
                    this._textDesiredHeight = 0;
                    this._linesWidth = [];
                    this._lineBreakWithoutSpaces ? this._multilineTextWrapByChar() : this._multilineTextWrapByWord();
                    this._computeAlignmentOffset();
                    if (this._overFlow === _ccsg.Label.Overflow.SHRINK) {
                        var fontSize = this.getFontSize();
                        fontSize > 0 && this._isVerticalClamp() && this._shrinkLabelToContentSize(this._isVerticalClamp.bind(this));
                    }
                    if (!this._updateQuads()) {
                        ret = false;
                        this._overFlow === _ccsg.Label.Overflow.SHRINK && this._shrinkLabelToContentSize(this._isHorizontalClamp.bind(this));
                        break;
                    }
                } while (0);
                return ret;
            },
            _isHorizontalClamped: function(px, lineIndex) {
                var wordWidth = this._linesWidth[lineIndex];
                var letterOverClamp = px > this._contentSize.width || px < 0;
                return this._isWrapText ? wordWidth > this._contentSize.width && letterOverClamp : letterOverClamp;
            },
            _updateQuads: function() {
                var ret = true;
                this._spriteBatchNode.removeAllChildren();
                for (var ctr = 0; ctr < this._string.length; ++ctr) {
                    if (this._lettersInfo[ctr]._valid) {
                        var letterDef = this._fontAtlas._letterDefinitions[this._lettersInfo[ctr]._char];
                        this._reusedRect.height = letterDef._height;
                        this._reusedRect.width = letterDef._width;
                        this._reusedRect.x = letterDef._u;
                        this._reusedRect.y = letterDef._v;
                        var py = this._lettersInfo[ctr]._positionY + this._letterOffsetY;
                        if (this._labelHeight > 0) {
                            if (py > this._tailoredTopY) {
                                var clipTop = py - this._tailoredTopY;
                                this._reusedRect.y += clipTop;
                                this._reusedRect.height -= clipTop;
                                py -= clipTop;
                            }
                            py - letterDef._height * this._bmfontScale < this._tailoredBottomY && (this._reusedRect.height = py < this._tailoredBottomY ? 0 : py - this._tailoredBottomY);
                        }
                        var lineIndex = this._lettersInfo[ctr]._lineIndex;
                        var px = this._lettersInfo[ctr]._positionX + letterDef._width / 2 * this._bmfontScale + this._linesOffsetX[lineIndex];
                        if (this._labelWidth > 0 && this._isHorizontalClamped(px, lineIndex)) {
                            if (this._overFlow === _ccsg.Label.Overflow.CLAMP) {
                                this._reusedRect.width = 0;
                            } else {
                                if (this._overFlow === _ccsg.Label.Overflow.SHRINK) {
                                    if (this._contentSize.width > letterDef._width) {
                                        ret = false;
                                        break;
                                    }
                                    this._reusedRect.width = 0;
                                }
                            }
                        }
                        if (this._reusedRect.height > 0 && this._reusedRect.width > 0) {
                            var fontChar = this.getChildByTag(ctr);
                            var locTexture = this._spriteBatchNode._texture;
                            var spriteFrame = this._spriteFrame;
                            var isRotated = this._spriteFrame.isRotated();
                            var originalSize = spriteFrame._originalSize;
                            var rect = spriteFrame._rect;
                            var offset = spriteFrame._offset;
                            var trimmedLeft = offset.x + (originalSize.width - rect.width) / 2;
                            var trimmedTop = offset.y - (originalSize.height - rect.height) / 2;
                            if (isRotated) {
                                var originalX = this._reusedRect.x;
                                this._reusedRect.x = rect.x + rect.height - this._reusedRect.y - this._reusedRect.height - trimmedTop;
                                this._reusedRect.y = originalX + rect.y - trimmedLeft;
                                this._reusedRect.y < 0 && (this._reusedRect.height = this._reusedRect.height + trimmedTop);
                            } else {
                                this._reusedRect.x += rect.x - trimmedLeft;
                                this._reusedRect.y += rect.y + trimmedTop;
                            }
                            if (fontChar) {
                                fontChar.setTextureRect(this._reusedRect, isRotated);
                            } else {
                                fontChar = new _ccsg.Sprite();
                                fontChar.initWithTexture(locTexture, this._reusedRect, isRotated);
                                fontChar.setAnchorPoint(cc.p(0, 1));
                            }
                            var letterPositionX = this._lettersInfo[ctr]._positionX + this._linesOffsetX[this._lettersInfo[ctr]._lineIndex];
                            fontChar.setPosition(letterPositionX, py);
                            var index = this._spriteBatchNode.getChildrenCount();
                            this._lettersInfo[ctr]._atlasIndex = index;
                            this._updateLetterSpriteScale(fontChar);
                            this._spriteBatchNode.addChild(fontChar);
                        }
                    }
                }
                return ret;
            },
            _updateLetterSpriteScale: function(sprite) {
                this._labelType === _ccsg.Label.Type.BMFont && this._fontSize > 0 && sprite.setScale(this._bmfontScale);
            },
            _recordPlaceholderInfo: function(letterIndex, char) {
                if (letterIndex >= this._lettersInfo.length) {
                    var tmpInfo = new LetterInfo();
                    this._lettersInfo.push(tmpInfo);
                }
                this._lettersInfo[letterIndex]._char = char;
                this._lettersInfo[letterIndex]._valid = false;
            },
            _recordLetterInfo: function(letterPosition, character, letterIndex, lineIndex) {
                if (letterIndex >= this._lettersInfo.length) {
                    var tmpInfo = new LetterInfo();
                    this._lettersInfo.push(tmpInfo);
                }
                character = character.charCodeAt(0);
                this._lettersInfo[letterIndex]._lineIndex = lineIndex;
                this._lettersInfo[letterIndex]._char = character;
                this._lettersInfo[letterIndex]._valid = this._fontAtlas._letterDefinitions[character]._validDefinition;
                this._lettersInfo[letterIndex]._positionX = letterPosition.x;
                this._lettersInfo[letterIndex]._positionY = letterPosition.y;
            },
            _setDimensions: function(size, height) {
                var newWidth = "number" === typeof size.width ? size.width : size;
                var newHeight = "number" === typeof size.height ? size.height : height;
                var oldSize = this.getContentSize();
                _ccsg.Node.prototype.setContentSize.call(this, size, height);
                if (newHeight !== oldSize.height || newWidth !== oldSize.width) {
                    this._setupBMFontOverflowMetrics(newWidth, newHeight);
                    this._drawFontsize > 0 && this._restoreFontSize();
                    this._notifyLabelSkinDirty();
                }
            },
            _restoreFontSize: function() {
                this._fontSize = this._drawFontsize;
            },
            _multilineTextWrap: function(nextTokenFunc) {
                var textLen = this.getStringLength();
                var lineIndex = 0;
                var nextTokenX = 0;
                var nextTokenY = 0;
                var longestLine = 0;
                var letterRight = 0;
                var lineSpacing = this._lineSpacing;
                var highestY = 0;
                var lowestY = 0;
                var letterDef = null;
                var letterPosition = cc.p(0, 0);
                this._updateBMFontScale();
                for (var index = 0; index < textLen; ) {
                    var character = this._string.charAt(index);
                    if ("\n" === character) {
                        this._linesWidth.push(letterRight);
                        letterRight = 0;
                        lineIndex++;
                        nextTokenX = 0;
                        nextTokenY -= this._lineHeight * this._bmfontScale + lineSpacing;
                        this._recordPlaceholderInfo(index, character);
                        index++;
                        continue;
                    }
                    var tokenLen = nextTokenFunc(this._string, index, textLen);
                    var tokenHighestY = highestY;
                    var tokenLowestY = lowestY;
                    var tokenRight = letterRight;
                    var nextLetterX = nextTokenX;
                    var newLine = false;
                    for (var tmp = 0; tmp < tokenLen; ++tmp) {
                        var letterIndex = index + tmp;
                        character = this._string.charAt(letterIndex);
                        if ("\r" === character) {
                            this._recordPlaceholderInfo(letterIndex, character);
                            continue;
                        }
                        letterDef = this._fontAtlas.getLetterDefinitionForChar(character);
                        if (!letterDef) {
                            this._recordPlaceholderInfo(letterIndex, character);
                            console.log("Can't find letter definition in texture atlas " + this._config.atlasName + " for letter:" + character);
                            continue;
                        }
                        var letterX = nextLetterX + letterDef._offsetX * this._bmfontScale;
                        if (this._isWrapText && this._maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef._width * this._bmfontScale > this._maxLineWidth && !cc.TextUtils.isUnicodeSpace(character)) {
                            this._linesWidth.push(letterRight);
                            letterRight = 0;
                            lineIndex++;
                            nextTokenX = 0;
                            nextTokenY -= this._lineHeight * this._bmfontScale + lineSpacing;
                            newLine = true;
                            break;
                        }
                        letterPosition.x = letterX;
                        letterPosition.y = nextTokenY - letterDef._offsetY * this._bmfontScale;
                        this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex);
                        letterIndex + 1 < this._horizontalKernings.length && letterIndex < textLen - 1 && (nextLetterX += this._horizontalKernings[letterIndex + 1]);
                        nextLetterX += letterDef._xAdvance * this._bmfontScale + this._spacingX;
                        tokenRight = letterPosition.x + letterDef._width * this._bmfontScale;
                        tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y);
                        tokenLowestY > letterPosition.y - letterDef._height * this._bmfontScale && (tokenLowestY = letterPosition.y - letterDef._height * this._bmfontScale);
                    }
                    if (newLine) {
                        continue;
                    }
                    nextTokenX = nextLetterX;
                    letterRight = tokenRight;
                    highestY < tokenHighestY && (highestY = tokenHighestY);
                    lowestY > tokenLowestY && (lowestY = tokenLowestY);
                    longestLine < letterRight && (longestLine = letterRight);
                    index += tokenLen;
                }
                this._linesWidth.push(letterRight);
                this._numberOfLines = lineIndex + 1;
                this._textDesiredHeight = this._numberOfLines * this._lineHeight * this._bmfontScale;
                this._numberOfLines > 1 && (this._textDesiredHeight += (this._numberOfLines - 1) * this._lineSpacing);
                var contentSize = cc.size(this._labelWidth, this._labelHeight);
                this._labelWidth <= 0 && (contentSize.width = parseFloat(longestLine.toFixed(2)));
                this._labelHeight <= 0 && (contentSize.height = parseFloat(this._textDesiredHeight.toFixed(2)));
                _ccsg.Node.prototype.setContentSize.call(this, contentSize);
                this._tailoredTopY = contentSize.height;
                this._tailoredBottomY = 0;
                highestY > 0 && (this._tailoredTopY = contentSize.height + highestY);
                lowestY < -this._textDesiredHeight && (this._tailoredBottomY = this._textDesiredHeight + lowestY);
                return true;
            },
            _multilineTextWrapByWord: function() {
                return this._multilineTextWrap(this._getFirstWordLen.bind(this));
            },
            _multilineTextWrapByChar: function() {
                return this._multilineTextWrap(this._getFirstCharLen.bind(this));
            },
            _isVerticalClamp: function() {
                return this._textDesiredHeight > this._contentSize.height;
            },
            _isHorizontalClamp: function() {
                var letterClamp = false;
                for (var ctr = 0; ctr < this.getStringLength(); ++ctr) {
                    if (this._lettersInfo[ctr]._valid) {
                        var letterDef = this._fontAtlas._letterDefinitions[this._lettersInfo[ctr]._char];
                        var px = this._lettersInfo[ctr]._positionX + letterDef._width / 2 * this._bmfontScale;
                        var lineIndex = this._lettersInfo[ctr]._lineIndex;
                        if (this._labelWidth > 0) {
                            if (this._isWrapText) {
                                var wordWidth = this._linesWidth[lineIndex];
                                if (wordWidth > this._contentSize.width && (px > this._contentSize.width || px < 0)) {
                                    letterClamp = true;
                                    break;
                                }
                            } else {
                                if (px > this._contentSize.width) {
                                    letterClamp = true;
                                    break;
                                }
                            }
                        }
                    }
                }
                return letterClamp;
            },
            _shrinkLabelToContentSize: function(lambda) {
                var fontSize = this.getFontSize();
                var i = 0;
                var tempLetterDefinition = this._fontAtlas.cloneLetterDefinition();
                var originalLineHeight = this._lineHeight;
                var flag = true;
                while (lambda()) {
                    ++i;
                    var newFontSize = fontSize - i;
                    flag = false;
                    if (newFontSize <= 0) {
                        break;
                    }
                    var scale = newFontSize / fontSize;
                    this._fontAtlas.assignLetterDefinitions(tempLetterDefinition);
                    this._fontAtlas.scaleFontLetterDefinition(scale);
                    this._lineHeight = originalLineHeight * scale;
                    this._lineBreakWithoutSpaces ? this._multilineTextWrapByChar() : this._multilineTextWrapByWord();
                    this._computeAlignmentOffset();
                }
                this._lineHeight = originalLineHeight;
                this._fontAtlas.assignLetterDefinitions(tempLetterDefinition);
                flag || fontSize - i >= 0 && this._scaleFontSizeDown(fontSize - i);
            },
            _scaleFontSizeDown: function(fontSize) {
                var shouldUpdateContent = true;
                if (this._labelType === _ccsg.Label.Type.BMFont) {
                    if (!fontSize) {
                        fontSize = .1;
                        shouldUpdateContent = false;
                    }
                    this._fontSize = fontSize;
                    shouldUpdateContent && this._updateContent();
                }
            },
            _updateContent: function() {
                if (this._fontAtlas) {
                    this._computeHorizontalKerningForText(this._string);
                    this._alignText();
                }
            },
            _computeAlignmentOffset: function() {
                this._linesOffsetX = [];
                switch (this._hAlign) {
                  case cc.TextAlignment.LEFT:
                    for (var i = 0; i < this._numberOfLines; ++i) {
                        this._linesOffsetX.push(0);
                    }
                    break;

                  case cc.TextAlignment.CENTER:
                    this._linesWidth.forEach(function(lineWidth) {
                        this._linesOffsetX.push((this._contentSize.width - lineWidth) / 2);
                    }.bind(this));
                    break;

                  case cc.TextAlignment.RIGHT:
                    this._linesWidth.forEach(function(lineWidth) {
                        this._linesOffsetX.push(this._contentSize.width - lineWidth);
                    }.bind(this));
                }
                switch (this._vAlign) {
                  case cc.VerticalTextAlignment.TOP:
                    this._letterOffsetY = this._contentSize.height;
                    break;

                  case cc.VerticalTextAlignment.CENTER:
                    this._letterOffsetY = (this._contentSize.height + this._textDesiredHeight) / 2;
                    break;

                  case cc.VerticalTextAlignment.BOTTOM:
                    this._letterOffsetY = this._textDesiredHeight;
                }
            },
            _getFirstCharLen: function() {
                return 1;
            },
            _getFirstWordLen: function(text, startIndex, textLen) {
                var character = text.charAt(startIndex);
                if (cc.TextUtils.isUnicodeCJK(character) || "\n" === character || cc.TextUtils.isUnicodeSpace(character)) {
                    return 1;
                }
                var len = 1;
                letterDef = this._fontAtlas.getLetterDefinitionForChar(character);
                if (!letterDef) {
                    return len;
                }
                var nextLetterX = letterDef._xAdvance * this._bmfontScale + this._spacingX;
                var letterDef;
                var letterX;
                for (var index = startIndex + 1; index < textLen; ++index) {
                    character = text.charAt(index);
                    letterDef = this._fontAtlas.getLetterDefinitionForChar(character);
                    if (!letterDef) {
                        break;
                    }
                    letterX = nextLetterX + letterDef._offsetX * this._bmfontScale;
                    if (letterX + letterDef._width * this._bmfontScale > this._maxLineWidth && !cc.TextUtils.isUnicodeSpace(character) && this._maxLineWidth > 0) {
                        return len;
                    }
                    nextLetterX += letterDef._xAdvance * this._bmfontScale + this._spacingX;
                    if ("\n" === character || cc.TextUtils.isUnicodeSpace(character) || cc.TextUtils.isUnicodeCJK(character)) {
                        break;
                    }
                    len++;
                }
                return len;
            },
            _updateBMFontScale: function() {
                if (this._labelType === _ccsg.Label.Type.BMFont) {
                    var originalFontSize = this._fontAtlas._fontSize;
                    this._bmfontScale = this._fontSize / originalFontSize;
                } else {
                    this._bmfontScale = 1;
                }
            },
            _initBMFontWithString: function(str, fntFile, spriteFrame) {
                var self = this;
                if (self._config) {
                    cc.logID(4002);
                    return false;
                }
                this._string = str;
                this._setBMFontFile(fntFile, spriteFrame);
            },
            _createSpriteBatchNode: function(texture) {
                this._spriteBatchNode = new cc.SpriteBatchNode(texture, this._string.length);
                this._spriteBatchNode.setCascadeColorEnabled(true);
                this._spriteBatchNode.setCascadeOpacityEnabled(true);
                this.addChild(this._spriteBatchNode);
                this._updateContent();
                this.setColor(this.color);
            },
            _createFontChars: function() {
                if (!this._config) {
                    return;
                }
                this._fontAtlas = new cc.FontAtlas(this._config);
                this._lineHeight || (this._lineHeight = this._fontAtlas._lineHeight);
                var locCfg = this._config;
                var locFontDict = locCfg.fontDefDictionary;
                for (var fontDef in locFontDict) {
                    var letterDefinition = new FontLetterDefinition();
                    var tempRect = locFontDict[fontDef].rect;
                    letterDefinition._offsetX = locFontDict[fontDef].xOffset;
                    letterDefinition._offsetY = locFontDict[fontDef].yOffset;
                    letterDefinition._width = tempRect.width;
                    letterDefinition._height = tempRect.height;
                    letterDefinition._u = tempRect.x + this._imageOffset.x;
                    letterDefinition._v = tempRect.y + this._imageOffset.y;
                    letterDefinition._textureID = 0;
                    letterDefinition._validDefinition = true;
                    letterDefinition._xAdvance = locFontDict[fontDef].xAdvance;
                    this._fontAtlas.addLetterDefinitions(fontDef, letterDefinition);
                }
            },
            _rescaleWithOriginalFontSize: function() {
                var renderingFontSize = this.getFontSize();
                this._drawFontsize - renderingFontSize >= 1 && this._overFlow === _ccsg.Label.Overflow.SHRINK && (this._labelType === _ccsg.Label.Type.BMFont ? this._scaleFontSizeDown(this._drawFontsize) : this._fontSize = this._drawFontsize);
            },
            _computeHorizontalKerningForText: function() {
                var stringLen = this.getStringLength();
                var locKerningDict = this._config.kerningDict;
                var prev = -1;
                for (var i = 0; i < stringLen; ++i) {
                    var key = this._string.charCodeAt(i);
                    var kerningAmount = locKerningDict[prev << 16 | 65535 & key] || 0;
                    i < stringLen - 1 ? this._horizontalKernings[i] = kerningAmount : this._horizontalKernings[i] = 0;
                    prev = key;
                }
            },
            _setBMFontFile: function(fntDataStr, spriteFrame) {
                if (fntDataStr) {
                    this._fontHandle = fntDataStr;
                    if (this._labelType === _ccsg.Label.Type.BMFont) {
                        var self = this;
                        this._resetBMFont();
                        var fntConfig = this._fontAsset._fntConfig;
                        if (fntConfig) {
                            self._config = fntConfig;
                        } else {
                            self._config = FntLoader.parseFnt(fntDataStr);
                            this._fontAsset._fntConfig = self._config;
                        }
                        self._createFontChars();
                        self._spriteFrame = spriteFrame;
                        var createLabelSprites = function() {
                            var texture = spriteFrame.getTexture();
                            self._textureLoaded = texture.isLoaded();
                            self._createSpriteBatchNode(texture);
                            self.emit("load");
                        };
                        if (spriteFrame.textureLoaded()) {
                            createLabelSprites();
                        } else {
                            spriteFrame.once("load", createLabelSprites);
                            spriteFrame.ensureLoadTexture();
                        }
                    }
                }
            }
        });
        var _p = _ccsg.Label.prototype;
        cc.js.addon(_p, EventTarget.prototype);
        _ccsg.Label.Type = cc.Enum({
            TTF: 0,
            BMFont: 1,
            SystemFont: 2
        });
        _ccsg.Label.Overflow = cc.Enum({
            NONE: 0,
            CLAMP: 1,
            SHRINK: 2,
            RESIZE_HEIGHT: 3
        });
        var labelPro = _ccsg.Label.prototype;
        Object.defineProperty(labelPro, "width", {
            get: labelPro._getWidth,
            set: _ccsg.Node.prototype._setWidth
        });
        Object.defineProperty(labelPro, "height", {
            get: labelPro._getHeight,
            set: _ccsg.Node.prototype._setHeight
        });
    }), {
        "../event/event-target": 112,
        "./CCTextUtils.js": 129
    } ],
    127: [ (function(require, module, exports) {
        (function() {
            _ccsg.Label.TTFLabelBaker = function() {};
            var proto = _ccsg.Label.TTFLabelBaker.prototype = Object.create(Object.prototype);
            proto.updateStatus = function() {
                var flags = _ccsg.Node._dirtyFlags, locFlag = this._dirtyFlag;
                var colorDirty = locFlag & flags.colorDirty, opacityDirty = locFlag & flags.opacityDirty;
                colorDirty && this._updateDisplayColor();
                if (opacityDirty) {
                    this._updateDisplayOpacity();
                    this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
                }
                if (locFlag & flags.contentDirty) {
                    this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
                    this._dirtyFlag &= ~flags.contentDirty;
                }
                if (colorDirty || locFlag & flags.textDirty) {
                    this._notifyRegionStatus && this._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
                    this._rebuildLabelSkin();
                }
                if (this._dirtyFlag & flags.transformDirty) {
                    this.transform(this.getParentRenderCmd(), true);
                    this._dirtyFlag &= ~flags.transformDirty;
                }
            };
            proto._syncStatus = function(parentCmd) {
                var flags = _ccsg.Node._dirtyFlags, locFlag = this._dirtyFlag;
                var parentNode = parentCmd ? parentCmd._node : null;
                parentNode && parentNode._cascadeColorEnabled && parentCmd._dirtyFlag & flags.colorDirty && (locFlag |= flags.colorDirty);
                parentNode && parentNode._cascadeOpacityEnabled && parentCmd._dirtyFlag & flags.opacityDirty && (locFlag |= flags.opacityDirty);
                parentCmd && parentCmd._dirtyFlag & flags.transformDirty && (locFlag |= flags.transformDirty);
                var colorDirty = locFlag & flags.colorDirty, opacityDirty = locFlag & flags.opacityDirty;
                this._dirtyFlag = locFlag;
                colorDirty && this._syncDisplayColor();
                opacityDirty && this._syncDisplayOpacity();
                (colorDirty || opacityDirty || this._dirtyFlag & flags.textDirty) && this._rebuildLabelSkin();
                this._dirtyFlag & flags.transformDirty && this.transform(parentCmd);
            };
            proto._getLineHeight = function() {
                var nodeSpacingY = this._node.getLineHeight();
                var node = this._node;
                nodeSpacingY = 0 === nodeSpacingY ? node._fontSize : nodeSpacingY * node._fontSize / this._drawFontsize;
                var lineHeight = 0 | nodeSpacingY;
                return lineHeight;
            };
            proto._constructFontDesc = function() {
                var node = this._node;
                var fontDesc = node._fontSize.toString() + "px ";
                var fontFamily = 0 === node._fontHandle.length ? "serif" : node._fontHandle;
                fontDesc += fontFamily;
                node._isBold && (fontDesc = "bold " + fontDesc);
                return fontDesc;
            };
            proto._measureText = function(ctx) {
                return function(string) {
                    return ctx.measureText(string).width;
                };
            };
            proto._calculateLabelFont = function() {
                var node = this._node;
                var paragraphedStrings = node._string.split("\n");
                node._fontSize = node._drawFontsize;
                var fontDesc = this._constructFontDesc();
                this._labelContext.font = fontDesc;
                var paragraphLength = this._calculateParagraphLength(paragraphedStrings, this._labelContext);
                if (_ccsg.Label.Overflow.SHRINK === node._overFlow) {
                    this._splitedStrings = paragraphedStrings;
                    var i = 0;
                    var totalHeight = 0;
                    var maxLength = 0;
                    if (node._isWrapText) {
                        var canvasWidthNoMargin = this._canvasSize.width - 2 * this._getMargin();
                        var canvasHeightNoMargin = this._canvasSize.height - 2 * this._getMargin();
                        if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) {
                            fontDesc = this._constructFontDesc();
                            this._labelContext.font = fontDesc;
                            return fontDesc;
                        }
                        totalHeight = canvasHeightNoMargin + 1;
                        maxLength = canvasWidthNoMargin + 1;
                        var actualFontSize = this._drawFontsize + 1;
                        var textFragment = "";
                        var tryDivideByTwo = true;
                        var startShrinkFontSize = 0 | actualFontSize;
                        while (totalHeight > canvasHeightNoMargin || maxLength > canvasWidthNoMargin) {
                            if (tryDivideByTwo) {
                                actualFontSize = startShrinkFontSize / 2 | 0;
                            } else {
                                actualFontSize = startShrinkFontSize - 1;
                                startShrinkFontSize = actualFontSize;
                            }
                            if (actualFontSize <= 0) {
                                cc.logID(4003);
                                break;
                            }
                            node._fontSize = actualFontSize;
                            fontDesc = this._constructFontDesc();
                            this._labelContext.font = fontDesc;
                            this._splitedStrings = [];
                            totalHeight = 0;
                            for (i = 0; i < paragraphedStrings.length; ++i) {
                                var j = 0;
                                var allWidth = this._labelContext.measureText(paragraphedStrings[i]).width;
                                textFragment = cc.TextUtils.fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(this._labelContext));
                                while (j < textFragment.length) {
                                    var measureWidth = this._labelContext.measureText(textFragment[j]).width;
                                    maxLength = measureWidth;
                                    totalHeight += this._getLineHeight();
                                    ++j;
                                }
                                this._splitedStrings = this._splitedStrings.concat(textFragment);
                            }
                            if (tryDivideByTwo) {
                                if (totalHeight > canvasHeightNoMargin) {
                                    startShrinkFontSize = 0 | actualFontSize;
                                } else {
                                    tryDivideByTwo = false;
                                    totalHeight = canvasHeightNoMargin + 1;
                                }
                            }
                        }
                    } else {
                        totalHeight = paragraphedStrings.length * this._getLineHeight();
                        for (i = 0; i < paragraphedStrings.length; ++i) {
                            maxLength < paragraphLength[i] && (maxLength = paragraphLength[i]);
                        }
                        var scaleX = (this._canvasSize.width - 2 * this._getMargin()) / maxLength;
                        var scaleY = this._canvasSize.height / totalHeight;
                        node._fontSize = this._drawFontsize * Math.min(1, scaleX, scaleY) | 0;
                        fontDesc = this._constructFontDesc();
                        this._labelContext.font = fontDesc;
                    }
                }
                return fontDesc;
            };
            proto._getMargin = function() {
                return this._node && this._node._margin || 0;
            };
            proto._calculateParagraphLength = function(paragraphedStrings, ctx) {
                var paragraphLength = [];
                for (var i = 0; i < paragraphedStrings.length; ++i) {
                    var textMetric = ctx.measureText(paragraphedStrings[i]);
                    paragraphLength.push(textMetric.width);
                }
                return paragraphLength;
            };
            proto._calculateCanvasSize = function() {
                var node = this._node;
                var canvasWidth = node._contentSize.width;
                var canvasHeight = node._contentSize.height;
                canvasWidth <= 0 && (canvasWidth = 1);
                canvasHeight <= 0 && (canvasHeight = 1);
                return cc.size(canvasWidth, canvasHeight);
            };
            proto._calculateSplitedStrings = function() {
                var node = this._node;
                var paragraphedStrings = node._string.split("\n");
                var i;
                if (node._isWrapText) {
                    this._splitedStrings = [];
                    var canvasWidthNoMargin = this._canvasSize.width - 2 * this._getMargin();
                    for (i = 0; i < paragraphedStrings.length; ++i) {
                        var allWidth = this._labelContext.measureText(paragraphedStrings[i]).width;
                        var textFragment = cc.TextUtils.fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(this._labelContext));
                        this._splitedStrings = this._splitedStrings.concat(textFragment);
                    }
                } else {
                    this._splitedStrings = paragraphedStrings;
                }
            };
            proto._updateLabelDimensions = function() {
                var node = this._node;
                var paragraphedStrings = node._string.split("\n");
                var i;
                var ctx = this._labelContext;
                if (_ccsg.Label.Overflow.RESIZE_HEIGHT === node._overFlow) {
                    this._canvasSize.height = this._splitedStrings.length * this._getLineHeight();
                    _ccsg.Node.prototype.setContentSize.call(node, this._canvasSize);
                } else {
                    if (_ccsg.Label.Overflow.NONE === node._overFlow) {
                        this._splitedStrings = paragraphedStrings;
                        var canvasSizeX = 0;
                        var canvasSizeY = 0;
                        for (i = 0; i < paragraphedStrings.length; ++i) {
                            var paraLength = ctx.measureText(paragraphedStrings[i]).width;
                            canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
                        }
                        canvasSizeY = this._splitedStrings.length * this._getLineHeight();
                        this._canvasSize.width = parseFloat(canvasSizeX.toFixed(2)) + 2 * this._getMargin();
                        this._canvasSize.height = parseFloat(canvasSizeY.toFixed(2));
                        node._isItalic && (this._canvasSize.width += node._drawFontsize * Math.tan(.20943951));
                        _ccsg.Node.prototype.setContentSize.call(node, this._canvasSize);
                    }
                }
                this._labelCanvas.width = this._canvasSize.width;
                this._labelCanvas.height = this._canvasSize.height;
            };
            proto._calculateFillTextStartPosition = function() {
                var node = this._node;
                var lineHeight = this._getLineHeight();
                var lineCount = this._splitedStrings.length;
                var labelX;
                var firstLinelabelY;
                labelX = cc.TextAlignment.RIGHT === node._hAlign ? this._canvasSize.width - this._getMargin() : cc.TextAlignment.CENTER === node._hAlign ? this._canvasSize.width / 2 : 0 + this._getMargin();
                firstLinelabelY = cc.VerticalTextAlignment.TOP === node._vAlign ? 0 : cc.VerticalTextAlignment.CENTER === node._vAlign ? this._canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 : this._canvasSize.height - lineHeight * (lineCount - 1);
                return cc.p(labelX, firstLinelabelY);
            };
            proto._calculateTextBaseline = function() {
                var node = this._node;
                var hAlign;
                var vAlign;
                hAlign = cc.TextAlignment.RIGHT === node._hAlign ? "right" : cc.TextAlignment.CENTER === node._hAlign ? "center" : "left";
                this._labelContext.textAlign = hAlign;
                vAlign = cc.VerticalTextAlignment.TOP === node._vAlign ? "top" : cc.VerticalTextAlignment.CENTER === node._vAlign ? "middle" : "bottom";
                this._labelContext.textBaseline = vAlign;
            };
            proto._bakeLabel = function() {
                var node = this._node;
                this._drawFontsize = node._drawFontsize;
                this._canvasSize = this._calculateCanvasSize();
                this._fontDesc = this._calculateLabelFont();
                this._calculateSplitedStrings();
                this._updateLabelDimensions();
                this._calculateTextBaseline();
                this._updateTexture();
            };
            proto._calculateUnderlineStartPosition = function() {
                var node = this._node;
                var lineHeight = this._getLineHeight();
                var lineCount = this._splitedStrings.length;
                var labelX;
                var firstLinelabelY;
                labelX = 0 + this._getMargin();
                firstLinelabelY = cc.VerticalTextAlignment.TOP === node._vAlign ? node._fontSize : cc.VerticalTextAlignment.CENTER === node._vAlign ? this._canvasSize.height / 2 - lineHeight * (lineCount - 1) / 2 + node._fontSize / 2 : this._canvasSize.height - lineHeight * (lineCount - 1);
                return cc.p(labelX, firstLinelabelY);
            };
            proto._updateTexture = function() {
                this._labelContext.clearRect(0, 0, this._labelCanvas.width, this._labelCanvas.height);
                this._labelContext.font = this._fontDesc;
                var startPosition = this._calculateFillTextStartPosition();
                var lineHeight = this._getLineHeight();
                this._labelContext.lineJoin = "round";
                var color = this._displayedColor;
                this._labelContext.fillStyle = "rgb(" + color.r + "," + color.g + "," + color.b + ")";
                var underlineStartPosition;
                for (var i = 0; i < this._splitedStrings.length; ++i) {
                    if (this._node.isOutlined()) {
                        var strokeColor = this._node.getOutlineColor() || cc.color(255, 255, 255, 255);
                        this._labelContext.globalCompositeOperation = "source-over";
                        this._labelContext.strokeStyle = "rgb(" + strokeColor.r + "," + strokeColor.g + "," + strokeColor.b + ")";
                        this._labelContext.lineWidth = 2 * this._node.getOutlineWidth();
                        this._labelContext.strokeText(this._splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight);
                    }
                    if (this._node.getFillColorGradientEnabled()) {
                        var gradientStartColor = this._node.getGradientStartColor() || cc.color(255, 255, 255, 255);
                        var gradientEndColor = this._node.getGradientEndColor() || cc.color(255, 255, 255, 255);
                        var gradientArgument = this._getGradientArgs();
                        var gradient = this._labelContext.createLinearGradient(gradientArgument.left, gradientArgument.top, gradientArgument.right, gradientArgument.bottom);
                        gradient.addColorStop(0, cc.colorToHex(gradientStartColor));
                        gradient.addColorStop(1, cc.colorToHex(gradientEndColor));
                        this._labelContext.fillStyle = gradient;
                    }
                    this._labelContext.fillText(this._splitedStrings[i], startPosition.x, startPosition.y + i * lineHeight);
                    if (this._node._isUnderline) {
                        underlineStartPosition = this._calculateUnderlineStartPosition();
                        this._labelContext.save();
                        this._labelContext.beginPath();
                        this._labelContext.lineWidth = this._node._fontSize / 8;
                        this._labelContext.strokeStyle = "rgb(" + color.r + "," + color.g + "," + color.b + ")";
                        this._labelContext.moveTo(underlineStartPosition.x, underlineStartPosition.y + i * lineHeight - 1);
                        this._labelContext.lineTo(underlineStartPosition.x + this._labelCanvas.width, underlineStartPosition.y + i * lineHeight - 1);
                        this._labelContext.stroke();
                        this._labelContext.restore();
                    }
                }
                this._texture._textureLoaded = false;
                this._texture._htmlElementObj = this._labelCanvas;
                this._texture.handleLoadedTexture(true);
            };
            proto._getGradientArgs = function() {
                this._gradientArgument = {};
                this._gradientArgument.left = 0;
                this._gradientArgument.top = 0;
                var contentSize = this._node._contentSize;
                switch (this._node.getFillColorGradientDirection()) {
                  case 0:
                    this._gradientArgument.right = contentSize.width;
                    this._gradientArgument.bottom = 0;
                    break;

                  case 1:
                    this._gradientArgument.right = 0;
                    this._gradientArgument.bottom = contentSize.height;
                    break;

                  case 2:
                    this._gradientArgument.right = contentSize.width;
                    this._gradientArgument.bottom = contentSize.height;
                }
                return this._gradientArgument;
            };
            proto._rebuildLabelSkin = function() {
                this._dirtyFlag &= ~_ccsg.Node._dirtyFlags.textDirty;
                var node = this._node;
                node._updateLabel();
            };
        })();
        (function() {
            _ccsg.Label.CanvasRenderCmd = function(renderableObject) {
                this._rootCtor(renderableObject);
                this._needDraw = true;
                this._texture = new cc.Texture2D();
                this._labelCanvas = document.createElement("canvas");
                this._labelCanvas.width = 1;
                this._labelCanvas.height = 1;
                this._labelContext = this._labelCanvas.getContext("2d");
                this._texture.initWithElement(this._labelCanvas);
                this._splitedStrings = null;
            };
            var proto = _ccsg.Label.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
            cc.js.mixin(proto, _ccsg.Label.TTFLabelBaker.prototype);
            proto.constructor = _ccsg.Label.CanvasRenderCmd;
            proto.transform = function(parentCmd, recursive) {
                this.originTransform(parentCmd, recursive);
                var bb = this._currentRegion, l = bb._minX, r = bb._maxX, b = bb._minY, t = bb._maxY, rect = cc.visibleRect, vl = rect.left.x, vr = rect.right.x, vt = rect.top.y, vb = rect.bottom.y;
                r < vl || l > vr || t < vb || b > vt ? this._needDraw = false : this._needDraw = true;
            };
            proto.rendering = function(ctx, scaleX, scaleY) {
                var node = this._node;
                if (node._labelType === _ccsg.Label.Type.TTF || node._labelType === _ccsg.Label.Type.SystemFont) {
                    var locDisplayOpacity = this._displayedOpacity;
                    var alpha = locDisplayOpacity / 255;
                    if (0 === locDisplayOpacity) {
                        return;
                    }
                    var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
                    wrapper.setTransform(this._worldTransform, scaleX, scaleY);
                    wrapper.setCompositeOperation(_ccsg.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(node._blendFunc));
                    wrapper.setGlobalAlpha(alpha);
                    if (this._texture) {
                        var sx, sy, sw, sh;
                        var x, y, w, h;
                        x = 0;
                        y = -this._node._contentSize.height;
                        w = this._node._contentSize.width;
                        h = this._node._contentSize.height;
                        var textureWidth = this._texture.getPixelWidth();
                        var textureHeight = this._texture.getPixelHeight();
                        sx = 0;
                        sy = 0;
                        sw = textureWidth;
                        sh = textureHeight;
                        var image = this._texture._htmlElementObj;
                        if ("" !== this._texture._pattern) {
                            wrapper.setFillStyle(context.createPattern(image, this._texture._pattern));
                            context.fillRect(x, y, w, h);
                        } else {
                            0 !== sw && 0 !== sh && 0 !== w && 0 !== h && context.drawImage(image, sx, sy, sw, sh, x, y, w, h);
                        }
                    }
                    cc.g_NumberOfDraws = cc.g_NumberOfDraws + 1;
                }
            };
        })();
    }), {} ],
    128: [ (function(require, module, exports) {
        _ccsg.Label.WebGLRenderCmd = function(renderableObject) {
            this._rootCtor(renderableObject);
            this._needDraw = true;
            this._texture = new cc.Texture2D();
            this._labelCanvas = document.createElement("canvas");
            this._texture.initWithElement(this._labelCanvas);
            this._labelContext = this._labelCanvas.getContext("2d");
            this._labelCanvas.width = 1;
            this._labelCanvas.height = 1;
            this._splitedStrings = null;
            this._drawFontsize = 0;
            this._vertices = [ {
                x: 0,
                y: 0,
                u: 0,
                v: 0
            }, {
                x: 0,
                y: 0,
                u: 0,
                v: 1
            }, {
                x: 0,
                y: 0,
                u: 1,
                v: 0
            }, {
                x: 0,
                y: 0,
                u: 1,
                v: 1
            } ];
            this._color = new Uint32Array(1);
            this._dirty = false;
            this._shaderProgram = cc.shaderCache.programForKey(cc.macro.SHADER_SPRITE_POSITION_TEXTURECOLOR);
        };
        var proto = _ccsg.Label.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
        cc.js.mixin(proto, _ccsg.Label.TTFLabelBaker.prototype);
        proto.constructor = _ccsg.Label.WebGLRenderCmd;
        proto.transform = function(parentCmd, recursive) {
            this.originTransform(parentCmd, recursive);
            var node = this._node, lx = 0, rx = this._labelCanvas.width, by = 0, ty = this._labelCanvas.height, wt = this._worldTransform;
            var vert = this._vertices;
            vert[0].x = lx * wt.a + ty * wt.c + wt.tx;
            vert[0].y = lx * wt.b + ty * wt.d + wt.ty;
            vert[1].x = lx * wt.a + by * wt.c + wt.tx;
            vert[1].y = lx * wt.b + by * wt.d + wt.ty;
            vert[2].x = rx * wt.a + ty * wt.c + wt.tx;
            vert[2].y = rx * wt.b + ty * wt.d + wt.ty;
            vert[3].x = rx * wt.a + by * wt.c + wt.tx;
            vert[3].y = rx * wt.b + by * wt.d + wt.ty;
            if (!node._string || node._labelType !== _ccsg.Label.Type.TTF && node._labelType !== _ccsg.Label.Type.SystemFont) {
                return;
            }
            var rect = cc.visibleRect, vl = rect.left.x, vr = rect.right.x, vt = rect.top.y, vb = rect.bottom.y;
            (vert[0].x - vl & vert[1].x - vl & vert[2].x - vl & vert[3].x - vl) >> 31 || (vr - vert[0].x & vr - vert[1].x & vr - vert[2].x & vr - vert[3].x) >> 31 || (vert[0].y - vb & vert[1].y - vb & vert[2].y - vb & vert[3].y - vb) >> 31 || (vt - vert[0].y & vt - vert[1].y & vt - vert[2].y & vt - vert[3].y) >> 31 ? this._needDraw = false : this._needDraw = true;
        };
        proto.uploadData = function(f32buffer, ui32buffer, vertexDataOffset) {
            var node = this._node;
            if (!node._string || node._labelType !== _ccsg.Label.Type.TTF && node._labelType !== _ccsg.Label.Type.SystemFont) {
                return 0;
            }
            var opacity = this._displayedOpacity;
            this._color[0] = opacity << 24 | opacity << 16 | opacity << 8 | opacity;
            var z = node._vertexZ;
            var vertices = this._vertices;
            var i, len = vertices.length, vertex, offset = vertexDataOffset;
            for (i = 0; i < len; ++i) {
                vertex = vertices[i];
                f32buffer[offset] = vertex.x;
                f32buffer[offset + 1] = vertex.y;
                f32buffer[offset + 2] = z;
                ui32buffer[offset + 3] = this._color[0];
                f32buffer[offset + 4] = vertex.u;
                f32buffer[offset + 5] = vertex.v;
                offset += 6;
            }
            return len;
        };
    }), {} ],
    129: [ (function(require, module, exports) {
        var CustomFontDescriptor = function() {
            this._status = "unloaded";
            this._observers = [];
            this._isLoadWithCSS = false;
        };
        CustomFontDescriptor.prototype.onLoaded = function() {
            this._status = "loaded";
            this._observers.forEach((function(item) {
                item();
            }));
        };
        CustomFontDescriptor.prototype.isLoaded = function() {
            return "loaded" === this._status;
        };
        CustomFontDescriptor.prototype.addHandler = function(callback) {
            this._observers.indexOf(callback) === -1 && this._observers.push(callback);
        };
        var CustomFontLoader = {
            _fontCache: {},
            _fontWidthCache: {},
            _canvasContext: null,
            _testString: "BESbswy",
            _allFontsLoaded: false,
            _intervalId: 0,
            loadTTF: function(url, callback) {
                var useFontFace = cc.sys.browserType !== cc.sys.BROWSER_TYPE_BAIDU && cc.sys.browserType !== cc.sys.BROWSER_TYPE_BAIDU_APP && cc.sys.browserType !== cc.sys.BROWSER_TYPE_MOBILE_QQ;
                window.FontFace && useFontFace ? this._loadWithFontFace(url, callback) : this._loadWithCSS(url, callback);
                0 === this._intervalId && (this._intervalId = setInterval(this._checkFontLoaded.bind(this), 100));
            },
            _checkFontLoaded: function() {
                this._allFontsLoaded = true;
                for (var k in this._fontCache) {
                    var fontDescriptor = this._fontCache[k];
                    if (fontDescriptor.isLoaded() || !fontDescriptor._isLoadWithCSS) {
                        continue;
                    }
                    var oldWidth = this._fontWidthCache[k];
                    this._canvasContext.font = "40px " + k;
                    var newWidth = this._canvasContext.measureText(this._testString).width;
                    oldWidth !== newWidth ? fontDescriptor.onLoaded() : this._allFontsLoaded = false;
                }
                if (this._allFontsLoaded) {
                    clearInterval(this._intervalId);
                    this._intervalId = 0;
                }
            },
            _loadWithFontFace: function(url, callback) {
                var fontFamilyName = this._getFontFamily(url);
                var fontDescriptor = this._fontCache[fontFamilyName];
                if (fontDescriptor) {
                    fontDescriptor.isLoaded() || fontDescriptor.addHandler(callback);
                } else {
                    var fontFace = new FontFace(fontFamilyName, "url('" + url + "')");
                    document.fonts.add(fontFace);
                    fontDescriptor = new CustomFontDescriptor();
                    fontDescriptor.addHandler(callback);
                    this._fontCache[fontFamilyName] = fontDescriptor;
                    fontFace.loaded.then((function() {
                        fontDescriptor.onLoaded();
                    }));
                }
            },
            _loadWithCSS: function(url, callback) {
                var fontFamilyName = this._getFontFamily(url);
                var fontDescriptor = this._fontCache[fontFamilyName];
                if (fontDescriptor) {
                    fontDescriptor.isLoaded() || fontDescriptor.addHandler(callback);
                } else {
                    var doc = document;
                    var fontStyle = document.createElement("style");
                    fontStyle.type = "text/css";
                    doc.body.appendChild(fontStyle);
                    var fontStr = "";
                    fontStr += isNaN(fontFamilyName - 0) ? "@font-face { font-family:" + fontFamilyName + "; src:" : "@font-face { font-family:'" + fontFamilyName + "'; src:";
                    fontStr += "url('" + url + "');";
                    fontStyle.textContent = fontStr + "}";
                    var preloadDiv = document.createElement("div");
                    var _divStyle = preloadDiv.style;
                    _divStyle.fontFamily = fontFamilyName;
                    preloadDiv.innerHTML = ".";
                    _divStyle.position = "absolute";
                    _divStyle.left = "-100px";
                    _divStyle.top = "-100px";
                    doc.body.appendChild(preloadDiv);
                    fontDescriptor = new CustomFontDescriptor();
                    fontDescriptor.addHandler(callback);
                    this._fontCache[fontFamilyName] = fontDescriptor;
                    fontDescriptor._isLoadWithCSS = true;
                    if (!this._canvasContext) {
                        var labelCanvas = document.createElement("canvas");
                        labelCanvas.width = 100;
                        labelCanvas.height = 100;
                        this._canvasContext = labelCanvas.getContext("2d");
                    }
                    var fontDesc = "40px " + fontFamilyName;
                    this._canvasContext.font = fontDesc;
                    var width = this._canvasContext.measureText(this._testString).width;
                    this._fontWidthCache[fontFamilyName] = width;
                    var self = this;
                    fontStyle.onload = function() {
                        setTimeout((function() {
                            if (!self._allFontsLoaded) {
                                cc.logID(4004);
                                fontDescriptor.onLoaded();
                                cc.director.getScheduler().unschedule(this._checkFontLoaded, this);
                            }
                        }), 2e4);
                    };
                }
            },
            _getFontFamily: function(fontHandle) {
                var ttfIndex = fontHandle.lastIndexOf(".ttf");
                if (ttfIndex === -1) {
                    return fontHandle;
                }
                var slashPos = fontHandle.lastIndexOf("/");
                var fontFamilyName;
                fontFamilyName = slashPos === -1 ? fontHandle.substring(0, ttfIndex) + "_LABEL" : fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
                return fontFamilyName;
            }
        };
        var TextUtils = {
            label_wordRex: /([a-zA-Z0-9Ã„Ã–ÃœÃ¤Ã¶Ã¼ÃŸÃ©Ã¨Ã§Ã Ã¹ÃªÃ¢Ã®Ã´Ã»Ð°-ÑÐ-Ð¯ÐÑ‘]+|\S)/,
            label_symbolRex: /^[!,.:;}\]%\?>ã€â€˜â€œã€‹ï¼Ÿã€‚ï¼Œï¼]/,
            label_lastWordRex: /([a-zA-Z0-9Ã„Ã–ÃœÃ¤Ã¶Ã¼ÃŸÃ©Ã¨Ã§Ã Ã¹ÃªÃ¢Ã®Ã´Ã»Ð°-ÑÐ-Ð¯ÐÑ‘]+|\S)$/,
            label_lastEnglish: /[a-zA-Z0-9Ã„Ã–ÃœÃ¤Ã¶Ã¼ÃŸÃ©Ã¨Ã§Ã Ã¹ÃªÃ¢Ã®Ã´Ã»Ð°-ÑÐ-Ð¯ÐÑ‘]+$/,
            label_firsrEnglish: /^[a-zA-Z0-9Ã„Ã–ÃœÃ¤Ã¶Ã¼ÃŸÃ©Ã¨Ã§Ã Ã¹ÃªÃ¢Ã®Ã´Ã»Ð°-ÑÐ-Ð¯ÐÑ‘]/,
            label_wrapinspection: true,
            isUnicodeCJK: function(ch) {
                var __CHINESE_REG = /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/;
                var __JAPANESE_REG = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
                var __KOREAN_REG = /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/;
                return __CHINESE_REG.test(ch) || __JAPANESE_REG.test(ch) || __KOREAN_REG.test(ch);
            },
            isUnicodeSpace: function(ch) {
                ch = ch.charCodeAt(0);
                return ch >= 9 && ch <= 13 || 32 === ch || 133 === ch || 160 === ch || 5760 === ch || ch >= 8192 && ch <= 8202 || 8232 === ch || 8233 === ch || 8239 === ch || 8287 === ch || 12288 === ch;
            },
            fragmentText: function(stringToken, allWidth, maxWidth, measureText) {
                var wrappedWords = [];
                if (0 === stringToken.length || maxWidth < 0) {
                    wrappedWords.push("");
                    return wrappedWords;
                }
                var text = stringToken;
                while (allWidth > maxWidth && text.length > 1) {
                    var fuzzyLen = text.length * (maxWidth / allWidth) | 0;
                    var tmpText = text.substr(fuzzyLen);
                    var width = allWidth - measureText(tmpText);
                    var sLine = tmpText;
                    var pushNum = 0;
                    var checkWhile = 0;
                    var checkCount = 10;
                    while (width > maxWidth && checkWhile++ < checkCount) {
                        fuzzyLen *= maxWidth / width;
                        fuzzyLen |= 0;
                        tmpText = text.substr(fuzzyLen);
                        width = allWidth - measureText(tmpText);
                    }
                    checkWhile = 0;
                    while (width < maxWidth && checkWhile++ < checkCount) {
                        if (tmpText) {
                            var exec = this.label_wordRex.exec(tmpText);
                            pushNum = exec ? exec[0].length : 1;
                            sLine = tmpText;
                        }
                        fuzzyLen += pushNum;
                        tmpText = text.substr(fuzzyLen);
                        width = allWidth - measureText(tmpText);
                    }
                    fuzzyLen -= pushNum;
                    if (0 === fuzzyLen) {
                        fuzzyLen = 1;
                        sLine = sLine.substr(1);
                    }
                    var sText = text.substr(0, fuzzyLen), result;
                    if (this.label_wrapinspection && this.label_symbolRex.test(sLine || tmpText)) {
                        result = this.label_lastWordRex.exec(sText);
                        fuzzyLen -= result ? result[0].length : 0;
                        0 === fuzzyLen && (fuzzyLen = 1);
                        sLine = text.substr(fuzzyLen);
                        sText = text.substr(0, fuzzyLen);
                    }
                    if (this.label_firsrEnglish.test(sLine)) {
                        result = this.label_lastEnglish.exec(sText);
                        if (result && sText !== result[0]) {
                            fuzzyLen -= result[0].length;
                            sLine = text.substr(fuzzyLen);
                            sText = text.substr(0, fuzzyLen);
                        }
                    }
                    sText.trim().length > 0 && wrappedWords.push(sText);
                    text = sLine || tmpText;
                    allWidth = measureText(text);
                }
                text.length > 0 && wrappedWords.push(text);
                return wrappedWords;
            }
        };
        cc.TextUtils = module.exports = TextUtils;
        cc.CustomFontLoader = module.exports = CustomFontLoader;
    }), {} ],
    130: [ (function(require, module, exports) {
        var JS = require("../platform/js");
        var Pipeline = require("./pipeline");
        var LoadingItems = require("./loading-items");
        var AssetLoader = require("./asset-loader");
        var Downloader = require("./downloader");
        var Loader = require("./loader");
        var AssetTable = require("./asset-table");
        var callInNextTick = require("../platform/utils").callInNextTick;
        var AutoReleaseUtils = require("./auto-release-utils");
        var resources = new AssetTable();
        function getXMLHttpRequest() {
            return window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject("MSXML2.XMLHTTP");
        }
        var _info = {
            url: null,
            raw: false
        };
        function getResWithUrl(res) {
            var id, result, isUuid;
            if ("object" === typeof res) {
                result = res;
                if (res.url) {
                    return result;
                }
                id = res.uuid;
            } else {
                result = {};
                id = res;
            }
            isUuid = result.type ? "uuid" === result.type : cc.AssetLibrary._getAssetUrl(id);
            _info.url = null;
            _info.raw = false;
            cc.AssetLibrary._getAssetInfoInRuntime(id, _info);
            result.url = isUuid ? _info.url : id;
            if (_info.url && "uuid" === result.type && _info.raw) {
                result.type = null;
                result.isRawAsset = true;
            } else {
                isUuid || (result.isRawAsset = true);
            }
            return result;
        }
        var _sharedResources = [];
        var _sharedList = [];
        function CCLoader() {
            var assetLoader = new AssetLoader();
            var downloader = new Downloader();
            var loader = new Loader();
            Pipeline.call(this, [ assetLoader, downloader, loader ]);
            this.assetLoader = assetLoader;
            this.downloader = downloader;
            this.loader = loader;
            this.onProgress = null;
            this._autoReleaseSetting = {};
        }
        JS.extend(CCLoader, Pipeline);
        var proto = CCLoader.prototype;
        proto.getXMLHttpRequest = getXMLHttpRequest;
        proto.addDownloadHandlers = function(extMap) {
            this.downloader.addHandlers(extMap);
        };
        proto.addLoadHandlers = function(extMap) {
            this.loader.addHandlers(extMap);
        };
        proto.load = function(resources, progressCallback, completeCallback) {
            if (void 0 === completeCallback) {
                completeCallback = progressCallback;
                progressCallback = this.onProgress || null;
            }
            var self = this;
            var singleRes = false;
            if (!(resources instanceof Array)) {
                singleRes = true;
                resources = resources ? [ resources ] : [];
            }
            _sharedResources.length = 0;
            for (var i = 0; i < resources.length; ++i) {
                var resource = resources[i];
                if (resource && resource.id) {
                    cc.warnID(4920, resource.id);
                    resource.uuid || resource.url || (resource.url = resource.id);
                }
                var res = getResWithUrl(resource);
                if (!res.url && !res.uuid) {
                    continue;
                }
                var item = this.getItem(res.url);
                _sharedResources.push(item || res);
            }
            var queue = LoadingItems.create(this, progressCallback, (function(errors, items) {
                callInNextTick((function() {
                    if (!completeCallback) {
                        return;
                    }
                    if (singleRes) {
                        var id = res.url;
                        completeCallback.call(self, items.getError(id), items.getContent(id));
                    } else {
                        completeCallback.call(self, errors, items);
                    }
                    completeCallback = null;
                    var id;
                    items.destroy();
                }));
            }));
            LoadingItems.initQueueDeps(queue);
            queue.append(_sharedResources);
            _sharedResources.length = 0;
        };
        proto.flowInDeps = function(owner, urlList, callback) {
            owner && !owner.deps && (owner.deps = []);
            _sharedList.length = 0;
            for (var i = 0; i < urlList.length; ++i) {
                var res = getResWithUrl(urlList[i]);
                if (!res.url && !res.uuid) {
                    continue;
                }
                var item = this.getItem(res.url);
                if (item) {
                    _sharedList.push(item);
                    owner && owner.deps.push(item);
                } else {
                    _sharedList.push(res);
                }
            }
            var queue = LoadingItems.create(this, owner ? function(completedCount, totalCount, item) {
                this._ownerQueue && this._ownerQueue.onProgress && this._ownerQueue._childOnProgress(item);
            } : null, (function(errors, items) {
                callback(errors, items);
                owner && (owner.deps.length = 0);
                items.destroy();
            }));
            if (owner) {
                var ownerQueue = LoadingItems.getQueue(owner);
                queue._ownerQueue = ownerQueue._ownerQueue || ownerQueue;
            }
            var accepted = queue.append(_sharedList, owner);
            _sharedList.length = 0;
            return accepted;
        };
        proto._resources = resources;
        proto._getResUuid = function(url, type, quiet) {
            if (!url) {
                return null;
            }
            var index = url.indexOf("?");
            index !== -1 && (url = url.substr(0, index));
            var uuid = resources.getUuid(url, type);
            if (!uuid) {
                var extname = cc.path.extname(url);
                if (extname) {
                    url = url.slice(0, -extname.length);
                    uuid = resources.getUuid(url, type);
                    uuid && !quiet && cc.warnID(4901, url, extname);
                }
            }
            return uuid;
        };
        proto._getReferenceKey = function(assetOrUrlOrUuid) {
            var key;
            "object" === typeof assetOrUrlOrUuid ? key = assetOrUrlOrUuid._uuid || null : "string" === typeof assetOrUrlOrUuid && (key = this._getResUuid(assetOrUrlOrUuid, null, true) || assetOrUrlOrUuid);
            if (!key) {
                cc.warnID(4800, assetOrUrlOrUuid);
                return key;
            }
            _info.url = null;
            _info.raw = false;
            cc.AssetLibrary._getAssetInfoInRuntime(key, _info);
            return this._cache[_info.url] ? _info.url : key;
        };
        proto._urlNotFound = function(url, type, completeCallback) {
            callInNextTick((function() {
                url = cc.url.normalize(url);
                var info = (type ? JS.getClassName(type) : "Asset") + ' in "resources/' + url + '" does not exist.';
                completeCallback && completeCallback(new Error(info), []);
            }));
        };
        proto._parseLoadResArgs = function(type, onProgress, onComplete) {
            if (void 0 === onComplete) {
                var isValidType = cc.isChildClassOf(type, cc.RawAsset);
                if (onProgress) {
                    onComplete = onProgress;
                    isValidType && (onProgress = this.onProgress || null);
                } else {
                    if (void 0 === onProgress && !isValidType) {
                        onComplete = type;
                        onProgress = this.onProgress || null;
                        type = null;
                    }
                }
                if (void 0 !== onProgress && !isValidType) {
                    onProgress = type;
                    type = null;
                }
            }
            return {
                type: type,
                onProgress: onProgress,
                onComplete: onComplete
            };
        };
        proto.loadRes = function(url, type, progressCallback, completeCallback) {
            var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
            type = args.type;
            progressCallback = args.onProgress;
            completeCallback = args.onComplete;
            var self = this;
            var uuid = self._getResUuid(url, type);
            uuid ? this.load({
                type: "uuid",
                uuid: uuid
            }, progressCallback, (function(err, asset) {
                asset && self.setAutoReleaseRecursively(uuid, false);
                completeCallback && completeCallback(err, asset);
            })) : self._urlNotFound(url, type, completeCallback);
        };
        proto._loadResUuids = function(uuids, progressCallback, completeCallback, urls) {
            if (uuids.length > 0) {
                var self = this;
                var res = uuids.map((function(uuid) {
                    return {
                        type: "uuid",
                        uuid: uuid
                    };
                }));
                this.load(res, progressCallback, (function(errors, items) {
                    if (completeCallback) {
                        var assetRes = [];
                        var urlRes = urls && [];
                        for (var i = 0; i < res.length; ++i) {
                            var uuid = res[i].uuid;
                            var id = this._getReferenceKey(uuid);
                            var item = items.getContent(id);
                            if (item) {
                                self.setAutoReleaseRecursively(uuid, false);
                                assetRes.push(item);
                                urlRes && urlRes.push(urls[i]);
                            }
                        }
                        urls ? completeCallback(errors, assetRes, urlRes) : completeCallback(errors, assetRes);
                    }
                }));
            } else {
                completeCallback && callInNextTick((function() {
                    urls ? completeCallback(null, [], []) : completeCallback(null, []);
                }));
            }
        };
        proto.loadResArray = function(urls, type, progressCallback, completeCallback) {
            var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
            type = args.type;
            progressCallback = args.onProgress;
            completeCallback = args.onComplete;
            var uuids = [];
            for (var i = 0; i < urls.length; i++) {
                var url = urls[i];
                var uuid = this._getResUuid(url, type);
                if (!uuid) {
                    this._urlNotFound(url, type, completeCallback);
                    return;
                }
                uuids.push(uuid);
            }
            this._loadResUuids(uuids, progressCallback, completeCallback);
        };
        proto.loadResDir = function(url, type, progressCallback, completeCallback) {
            var args = this._parseLoadResArgs(type, progressCallback, completeCallback);
            type = args.type;
            progressCallback = args.onProgress;
            completeCallback = args.onComplete;
            var urls = [];
            var uuids = resources.getUuidArray(url, type, urls);
            this._loadResUuids(uuids, progressCallback, completeCallback, urls);
        };
        proto.getRes = function(url, type) {
            var item = this._cache[url];
            if (!item) {
                var uuid = this._getResUuid(url, type, true);
                if (!uuid) {
                    return null;
                }
                var ref = this._getReferenceKey(uuid);
                item = this._cache[ref];
            }
            item && item.alias && (item = this._cache[item.alias]);
            return item && item.complete ? item.content : null;
        };
        proto.getResCount = function() {
            return Object.keys(this._cache).length;
        };
        proto.getDependsRecursively = function(owner) {
            if (owner) {
                var key = this._getReferenceKey(owner);
                var assets = AutoReleaseUtils.getDependsRecursively(key);
                assets.push(key);
                return assets;
            }
            return [];
        };
        proto.release = function(asset) {
            if (Array.isArray(asset)) {
                for (var i = 0; i < asset.length; i++) {
                    var key = asset[i];
                    this.release(key);
                }
            } else {
                if (asset) {
                    var id = this._getReferenceKey(asset);
                    var item = this.getItem(id);
                    if (item) {
                        var removed = this.removeItem(id);
                        asset = item.content;
                        if (asset instanceof cc.Asset) {
                            var urls = asset.rawUrls;
                            for (var _i = 0; _i < urls.length; _i++) {
                                this.release(urls[_i]);
                            }
                        } else {
                            asset instanceof cc.Texture2D && cc.textureCache.removeTextureForKey(item.url);
                        }
                    }
                }
            }
        };
        proto.releaseAsset = function(asset) {
            var uuid = asset._uuid;
            uuid && this.release(uuid);
        };
        proto.releaseRes = function(url, type) {
            var uuid = this._getResUuid(url, type);
            uuid ? this.release(uuid) : cc.errorID(4914, url);
        };
        proto.releaseResDir = function(url, type) {
            var uuids = resources.getUuidArray(url, type);
            for (var i = 0; i < uuids.length; i++) {
                var uuid = uuids[i];
                this.release(uuid);
            }
        };
        proto.releaseAll = function() {
            for (var id in this._cache) {
                this.release(id);
            }
        };
        proto.removeItem = function(key) {
            var removed = Pipeline.prototype.removeItem.call(this, key);
            delete this._autoReleaseSetting[key];
            return removed;
        };
        proto.setAutoRelease = function(assetOrUrlOrUuid, autoRelease) {
            var key = this._getReferenceKey(assetOrUrlOrUuid);
            key ? this._autoReleaseSetting[key] = !!autoRelease : cc.warnID(4902);
        };
        proto.setAutoReleaseRecursively = function(assetOrUrlOrUuid, autoRelease) {
            autoRelease = !!autoRelease;
            var key = this._getReferenceKey(assetOrUrlOrUuid);
            if (key) {
                this._autoReleaseSetting[key] = autoRelease;
                var depends = AutoReleaseUtils.getDependsRecursively(key);
                for (var i = 0; i < depends.length; i++) {
                    var depend = depends[i];
                    this._autoReleaseSetting[depend] = autoRelease;
                }
            } else {
                cc.warnID(4902);
            }
        };
        proto.isAutoRelease = function(assetOrUrl) {
            var key = this._getReferenceKey(assetOrUrl);
            if (key) {
                return !!this._autoReleaseSetting[key];
            }
            return false;
        };
        cc.loader = new CCLoader();
        module.exports = cc.loader;
    }), {
        "../platform/js": 193,
        "../platform/utils": 198,
        "./asset-loader": 131,
        "./asset-table": 132,
        "./auto-release-utils": 134,
        "./downloader": 135,
        "./loader": 138,
        "./loading-items": 139,
        "./pipeline": 141
    } ],
    131: [ (function(require, module, exports) {
        var Path = require("../utils/CCPath");
        var Pipeline = require("./pipeline");
        var LoadingItems = require("./loading-items");
        var ID = "AssetLoader";
        var AssetLoader = function(extMap) {
            this.id = ID;
            this.async = true;
            this.pipeline = null;
        };
        AssetLoader.ID = ID;
        var reusedArray = [];
        AssetLoader.prototype.handle = function(item, callback) {
            var uuid = item.uuid;
            if (!uuid) {
                return !item.content ? null : item.content;
            }
            var self = this;
            cc.AssetLibrary.queryAssetInfo(uuid, (function(error, url, isRawAsset) {
                if (error) {
                    callback(error);
                } else {
                    item.url = url;
                    item.isRawAsset = isRawAsset;
                    if (isRawAsset) {
                        var ext = Path.extname(url).toLowerCase();
                        if (!ext) {
                            callback(new Error("Download Uuid: can not find type of raw asset[" + uuid + "]: " + url));
                            return;
                        }
                        ext = ext.substr(1);
                        var queue = LoadingItems.getQueue(item);
                        reusedArray[0] = {
                            queueId: item.queueId,
                            id: url,
                            url: url,
                            type: ext,
                            error: null,
                            alias: item.id,
                            complete: true
                        };
                        queue.append(reusedArray);
                        item.type = ext;
                        callback(null, item.content);
                    } else {
                        item.type = "uuid";
                        callback(null, item.content);
                    }
                }
            }));
        };
        Pipeline.AssetLoader = module.exports = AssetLoader;
    }), {
        "../utils/CCPath": 217,
        "./loading-items": 139,
        "./pipeline": 141
    } ],
    132: [ (function(require, module, exports) {
        function Entry(uuid, type) {
            this.uuid = uuid;
            this.type = type;
        }
        function AssetTable() {
            this._pathToUuid = {};
        }
        function isMatchByWord(path, test) {
            if (path.length > test.length) {
                var nextAscii = path.charCodeAt(test.length);
                return 46 === nextAscii || 47 === nextAscii;
            }
            return true;
        }
        var proto = AssetTable.prototype;
        proto.getUuid = function(path, type) {
            path = cc.url.normalize(path);
            var item = this._pathToUuid[path];
            if (item) {
                if (Array.isArray(item)) {
                    if (!type) {
                        return item[0].uuid;
                    }
                    for (var i = 0; i < item.length; i++) {
                        var entry = item[i];
                        if (cc.isChildClassOf(entry.type, type)) {
                            return entry.uuid;
                        }
                    }
                } else {
                    if (!type || cc.isChildClassOf(item.type, type)) {
                        return item.uuid;
                    }
                }
            }
            return "";
        };
        proto.getUuidArray = function(path, type, out_urls) {
            path = cc.url.normalize(path);
            "/" === path[path.length - 1] && (path = path.slice(0, -1));
            var path2uuid = this._pathToUuid;
            var uuids = [];
            var isChildClassOf = cc.isChildClassOf;
            for (var p in path2uuid) {
                if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
                    var item = path2uuid[p];
                    if (Array.isArray(item)) {
                        for (var i = 0; i < item.length; i++) {
                            var entry = item[i];
                            if (!type || isChildClassOf(entry.type, type)) {
                                uuids.push(entry.uuid);
                                out_urls && out_urls.push(p);
                            }
                        }
                    } else {
                        if (!type || isChildClassOf(item.type, type)) {
                            uuids.push(item.uuid);
                            out_urls && out_urls.push(p);
                        }
                    }
                }
            }
            return uuids;
        };
        proto.getAllPaths = function() {
            return Object.keys(this._pathToUuid);
        };
        proto.add = function(path, uuid, type, isMainAsset) {
            path = path.substring(0, path.length - cc.path.extname(path).length);
            var newEntry = new Entry(uuid, type);
            var pathToUuid = this._pathToUuid;
            var exists = pathToUuid[path];
            exists ? Array.isArray(exists) ? isMainAsset ? exists.unshift(newEntry) : exists.push(newEntry) : isMainAsset ? pathToUuid[path] = [ newEntry, exists ] : pathToUuid[path] = [ exists, newEntry ] : pathToUuid[path] = newEntry;
        };
        proto.reset = function() {
            this._pathToUuid = {};
        };
        module.exports = AssetTable;
    }), {} ],
    133: [ (function(require, module, exports) {
        var Path = require("../utils/CCPath");
        var Sys = require("../platform/CCSys");
        var Pipeline = require("./pipeline");
        var audioEngine = require("../../audio/CCAudioEngine");
        var __audioSupport = Sys.__audioSupport;
        var formatSupport = __audioSupport.format;
        var context = __audioSupport.context;
        function loadDomAudio(item, callback) {
            var dom = document.createElement("audio");
            dom.src = item.url;
            var clearEvent = function() {
                clearTimeout(timer);
                dom.removeEventListener("canplaythrough", success, false);
                dom.removeEventListener("error", failure, false);
                __audioSupport.USE_LOADER_EVENT && dom.removeEventListener(__audioSupport.USE_LOADER_EVENT, success, false);
            };
            var timer = setTimeout((function() {
                0 === dom.readyState ? failure() : success();
            }), 8e3);
            var success = function() {
                clearEvent();
                item.element = dom;
                callback(null, item.url);
            };
            var failure = function() {
                clearEvent();
                var message = "load audio failure - " + item.url;
                cc.log(message);
                callback(message, item.url);
            };
            dom.addEventListener("canplaythrough", success, false);
            dom.addEventListener("error", failure, false);
            __audioSupport.USE_LOADER_EVENT && dom.addEventListener(__audioSupport.USE_LOADER_EVENT, success, false);
        }
        function loadWebAudio(item, callback) {
            context || callback(new Error("Audio Downloader: no web audio context."));
            var request = cc.loader.getXMLHttpRequest();
            request.open("GET", item.url, true);
            request.responseType = "arraybuffer";
            request.onload = function() {
                context["decodeAudioData"](request.response, (function(buffer) {
                    item.buffer = buffer;
                    callback(null, item.url);
                }), (function() {
                    callback("decode error - " + item.url, null);
                }));
            };
            request.onerror = function() {
                callback("request error - " + item.url, null);
            };
            request.send();
        }
        function downloadAudio(item, callback) {
            if (0 === formatSupport.length) {
                return new Error("Audio Downloader: audio not supported on this browser!");
            }
            item.content = item.url;
            !__audioSupport.WEB_AUDIO || item.urlParam && item.urlParam["useDom"] ? loadDomAudio(item, callback) : loadWebAudio(item, callback);
        }
        module.exports = downloadAudio;
    }), {
        "../../audio/CCAudioEngine": 24,
        "../platform/CCSys": 182,
        "../utils/CCPath": 217,
        "./pipeline": 141
    } ],
    134: [ (function(require, module, exports) {
        function parseDepends(key, parsed) {
            var item = cc.loader.getItem(key);
            if (item) {
                var depends = item.dependKeys;
                if (depends) {
                    for (var i = 0; i < depends.length; i++) {
                        var depend = depends[i];
                        if (!parsed[depend]) {
                            parsed[depend] = true;
                            parseDepends(depend, parsed);
                        }
                    }
                }
            }
        }
        function release(loader, key, nextSceneAssets) {
            nextSceneAssets && nextSceneAssets.indexOf(key) !== -1 || loader.release(key);
        }
        module.exports = {
            autoRelease: function(loader, oldSceneAssets, nextSceneAssets) {
                var releaseSettings = loader._autoReleaseSetting;
                var i, key;
                if (oldSceneAssets) {
                    for (i = 0; i < oldSceneAssets.length; i++) {
                        key = oldSceneAssets[i];
                        false !== releaseSettings[key] && release(loader, key, nextSceneAssets);
                    }
                }
                var keys = Object.keys(releaseSettings);
                for (i = 0; i < keys.length; i++) {
                    key = keys[i];
                    true === releaseSettings[key] && release(loader, key, nextSceneAssets);
                }
            },
            getDependsRecursively: function(key) {
                var depends = {};
                parseDepends(key, depends);
                return Object.keys(depends);
            }
        };
    }), {} ],
    135: [ (function(require, module, exports) {
        var JS = require("../platform/js");
        var Path = require("../utils/CCPath");
        var misc = require("../utils/misc");
        var Pipeline = require("./pipeline");
        var PackDownloader = require("./pack-downloader");
        var downloadText = require("./text-downloader");
        var urlAppendTimestamp = require("./utils").urlAppendTimestamp;
        var downloadAudio;
        downloadAudio = require("./audio-downloader");
        function downloadScript(item, callback, isAsync) {
            var url = item.url, d = document, s = document.createElement("script");
            s.async = isAsync;
            s.src = urlAppendTimestamp(url);
            function loadHandler() {
                s.parentNode.removeChild(s);
                s.removeEventListener("load", loadHandler, false);
                s.removeEventListener("error", errorHandler, false);
                callback(null, url);
            }
            function errorHandler() {
                s.parentNode.removeChild(s);
                s.removeEventListener("load", loadHandler, false);
                s.removeEventListener("error", errorHandler, false);
                callback(new Error("Load " + url + " failed!"), url);
            }
            s.addEventListener("load", loadHandler, false);
            s.addEventListener("error", errorHandler, false);
            d.body.appendChild(s);
        }
        function downloadWebp(item, callback, isCrossOrigin, img) {
            if (!cc.sys.capabilities.webp) {
                return new Error("Load Webp ( " + item.url + " ) failed");
            }
            return downloadImage(item, callback, isCrossOrigin, img);
        }
        function downloadImage(item, callback, isCrossOrigin, img) {
            void 0 === isCrossOrigin && (isCrossOrigin = true);
            var url = urlAppendTimestamp(item.url);
            img = img || misc.imagePool.get();
            isCrossOrigin && "file:" !== window.location.protocol ? img.crossOrigin = "anonymous" : img.crossOrigin = null;
            if (img.complete && img.naturalWidth > 0 && img.src === url) {
                return img;
            }
            (function() {
                function loadCallback() {
                    img.removeEventListener("load", loadCallback);
                    img.removeEventListener("error", errorCallback);
                    callback(null, img);
                }
                function errorCallback() {
                    img.removeEventListener("load", loadCallback);
                    img.removeEventListener("error", errorCallback);
                    "https:" !== window.location.protocol && img.crossOrigin && "anonymous" === img.crossOrigin.toLowerCase() ? downloadImage(item, callback, false, img) : callback(new Error("Load image (" + url + ") failed"));
                }
                img.addEventListener("load", loadCallback);
                img.addEventListener("error", errorCallback);
                img.src = url;
            })();
        }
        var FONT_TYPE = {
            ".eot": "embedded-opentype",
            ".ttf": "truetype",
            ".ttc": "truetype",
            ".woff": "woff",
            ".svg": "svg"
        };
        function _loadFont(name, srcs, type) {
            var doc = document, fontStyle = document.createElement("style");
            fontStyle.type = "text/css";
            doc.body.appendChild(fontStyle);
            var fontStr = "";
            fontStr += isNaN(name - 0) ? "@font-face { font-family:" + name + "; src:" : "@font-face { font-family:'" + name + "'; src:";
            if (srcs instanceof Array) {
                for (var i = 0, li = srcs.length; i < li; i++) {
                    var src = srcs[i];
                    type = Path.extname(src).toLowerCase();
                    fontStr += "url('" + srcs[i] + "') format('" + FONT_TYPE[type] + "')";
                    fontStr += i === li - 1 ? ";" : ",";
                }
            } else {
                type = type.toLowerCase();
                fontStr += "url('" + srcs + "') format('" + FONT_TYPE[type] + "');";
            }
            fontStyle.textContent += fontStr + "}";
            var preloadDiv = document.createElement("div");
            var _divStyle = preloadDiv.style;
            _divStyle.fontFamily = name;
            preloadDiv.innerHTML = ".";
            _divStyle.position = "absolute";
            _divStyle.left = "-100px";
            _divStyle.top = "-100px";
            doc.body.appendChild(preloadDiv);
        }
        function downloadFont(item, callback) {
            var url = item.url, type = item.type, name = item.name, srcs = item.srcs;
            if (name && srcs) {
                srcs.indexOf(url) === -1 && srcs.push(url);
                _loadFont(name, srcs);
            } else {
                type = Path.extname(url);
                name = Path.basename(url, type);
                _loadFont(name, url, type);
            }
            if (!document.fonts) {
                return null;
            }
            document.fonts.load("1em " + name).then((function() {
                callback(null, null);
            }), (function(err) {
                callback(err);
            }));
        }
        function downloadUuid(item, callback) {
            var result = PackDownloader.load(item, callback);
            if (void 0 === result) {
                return this.extMap["json"](item, callback);
            }
            if (!!result) {
                return result;
            }
        }
        var defaultMap = {
            js: downloadScript,
            png: downloadImage,
            jpg: downloadImage,
            bmp: downloadImage,
            jpeg: downloadImage,
            gif: downloadImage,
            ico: downloadImage,
            tiff: downloadImage,
            webp: downloadWebp,
            image: downloadImage,
            mp3: downloadAudio,
            ogg: downloadAudio,
            wav: downloadAudio,
            m4a: downloadAudio,
            txt: downloadText,
            xml: downloadText,
            vsh: downloadText,
            fsh: downloadText,
            atlas: downloadText,
            tmx: downloadText,
            tsx: downloadText,
            json: downloadText,
            ExportJson: downloadText,
            plist: downloadText,
            fnt: downloadText,
            font: downloadFont,
            eot: downloadFont,
            ttf: downloadFont,
            woff: downloadFont,
            svg: downloadFont,
            ttc: downloadFont,
            uuid: downloadUuid,
            default: downloadText
        };
        var ID = "Downloader";
        var Downloader = function(extMap) {
            this.id = ID;
            this.async = true;
            this.pipeline = null;
            this._curConcurrent = 0;
            this._loadQueue = [];
            this.extMap = JS.mixin(extMap, defaultMap);
        };
        Downloader.ID = ID;
        Downloader.prototype.addHandlers = function(extMap) {
            JS.mixin(this.extMap, extMap);
        };
        Downloader.prototype._handleLoadQueue = function() {
            while (this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT) {
                var nextOne = this._loadQueue.shift();
                if (!nextOne) {
                    break;
                }
                var syncRet = this.handle(nextOne.item, nextOne.callback);
                void 0 !== syncRet && (syncRet instanceof Error ? nextOne.callback(syncRet) : nextOne.callback(null, syncRet));
            }
        };
        Downloader.prototype.handle = function(item, callback) {
            var self = this;
            var downloadFunc = this.extMap[item.type] || this.extMap["default"];
            var syncRet = void 0;
            if (this._curConcurrent < cc.macro.DOWNLOAD_MAX_CONCURRENT) {
                this._curConcurrent++;
                syncRet = downloadFunc.call(this, item, (function(err, result) {
                    self._curConcurrent = Math.max(0, self._curConcurrent - 1);
                    self._handleLoadQueue();
                    callback && callback(err, result);
                }));
                if (void 0 !== syncRet) {
                    this._curConcurrent = Math.max(0, this._curConcurrent - 1);
                    this._handleLoadQueue();
                    return syncRet;
                }
            } else {
                if (item.ignoreMaxConcurrency) {
                    syncRet = downloadFunc.call(this, item, callback);
                    if (void 0 !== syncRet) {
                        return syncRet;
                    }
                } else {
                    this._loadQueue.push({
                        item: item,
                        callback: callback
                    });
                }
            }
        };
        Pipeline.Downloader = module.exports = Downloader;
    }), {
        "../platform/js": 193,
        "../utils/CCPath": 217,
        "../utils/misc": 223,
        "./audio-downloader": 133,
        "./pack-downloader": 140,
        "./pipeline": 141,
        "./text-downloader": 142,
        "./utils": 143
    } ],
    136: [ (function(require, module, exports) {
        require("./downloader");
        require("./loader");
        require("./json-unpacker");
        require("./loading-items");
        require("./pipeline");
        require("./CCLoader");
    }), {
        "./CCLoader": 130,
        "./downloader": 135,
        "./json-unpacker": 137,
        "./loader": 138,
        "./loading-items": 139,
        "./pipeline": 141
    } ],
    137: [ (function(require, module, exports) {
        function JsonUnpacker() {
            this.jsons = {};
            this.state = -1;
        }
        JsonUnpacker.prototype.read = function(indices, data) {
            var jsons = "string" === typeof data ? JSON.parse(data) : data;
            jsons.length !== indices.length && cc.errorID(4915);
            for (var i = 0; i < indices.length; i++) {
                var key = indices[i];
                var json = jsons[i];
                this.jsons[key] = json;
            }
        };
        JsonUnpacker.prototype.retrieve = function(key) {
            return this.jsons[key] || null;
        };
        module.exports = JsonUnpacker;
    }), {} ],
    138: [ (function(require, module, exports) {
        var JS = require("../platform/js");
        var Pipeline = require("./pipeline");
        var Texture2D = require("../textures/CCTexture2D");
        var loadUuid = require("./uuid-loader");
        var misc = require("../utils/misc");
        function loadNothing(item, callback) {
            return null;
        }
        function loadJSON(item, callback) {
            if ("string" !== typeof item.content) {
                return new Error("JSON Loader: Input item doesn't contain string content");
            }
            try {
                var result = JSON.parse(item.content);
                return result;
            } catch (e) {
                return new Error("JSON Loader: Parse json [" + item.id + "] failed : " + e);
            }
        }
        function loadImage(item, callback) {
            if (!(item.content instanceof Image)) {
                return new Error("Image Loader: Input item doesn't contain Image content");
            }
            var url = item.url;
            var tex = cc.textureCache.getTextureForKey(url) || new Texture2D();
            tex.url = url;
            tex.initWithElement(item.content);
            tex.handleLoadedTexture();
            cc._renderType === cc.game.RENDER_TYPE_WEBGL && misc.imagePool.put(item.content);
            cc.textureCache.cacheImage(url, tex);
            return tex;
        }
        function loadPlist(item, callback) {
            if ("string" !== typeof item.content) {
                return new Error("Plist Loader: Input item doesn't contain string content");
            }
            var result = cc.plistParser.parse(item.content);
            return result ? result : new Error("Plist Loader: Parse [" + item.id + "] failed");
        }
        var defaultMap = {
            png: loadImage,
            jpg: loadImage,
            bmp: loadImage,
            jpeg: loadImage,
            gif: loadImage,
            ico: loadImage,
            tiff: loadImage,
            webp: loadImage,
            image: loadImage,
            json: loadJSON,
            ExportJson: loadJSON,
            plist: loadPlist,
            uuid: loadUuid,
            prefab: loadUuid,
            fire: loadUuid,
            scene: loadUuid,
            default: loadNothing
        };
        var ID = "Loader";
        var Loader = function(extMap) {
            this.id = ID;
            this.async = true;
            this.pipeline = null;
            this.extMap = JS.mixin(extMap, defaultMap);
        };
        Loader.ID = ID;
        Loader.prototype.addHandlers = function(extMap) {
            this.extMap = JS.mixin(this.extMap, extMap);
        };
        Loader.prototype.handle = function(item, callback) {
            var loadFunc = this.extMap[item.type] || this.extMap["default"];
            return loadFunc.call(this, item, callback);
        };
        Pipeline.Loader = module.exports = Loader;
    }), {
        "../platform/js": 193,
        "../textures/CCTexture2D": 213,
        "../utils/misc": 223,
        "./pipeline": 141,
        "./uuid-loader": 144
    } ],
    139: [ (function(require, module, exports) {
        var CallbacksInvoker = require("../platform/callbacks-invoker");
        var Path = require("../utils/CCPath");
        var JS = require("../platform/js");
        var _qid = 0 | 998 * Math.random();
        var _queues = {};
        var _pool = [];
        var _POOL_MAX_LENGTH = 10;
        var ItemState = {
            WORKING: 1,
            COMPLETE: 2,
            ERROR: 3
        };
        var _queueDeps = {};
        var _parseUrl = function(url) {
            var result = {};
            if (!url) {
                return result;
            }
            var split = url.split("?");
            if (!split || !split[0]) {
                return result;
            }
            result.url = split[0];
            if (!split[1]) {
                return result;
            }
            result.param = {};
            split = split[1].split("&");
            split.forEach((function(item) {
                var itemSplit = item.split("=");
                result.param[itemSplit[0]] = itemSplit[1];
            }));
            return result;
        };
        function isIdValid(id) {
            var realId = id.url || id;
            return "string" === typeof realId;
        }
        function createItem(id, queueId) {
            var result, urlItem;
            if ("object" === typeof id) {
                id.url && !id.type && (id.type = Path.extname(id.url).toLowerCase().substr(1));
                urlItem = _parseUrl(id.url);
                result = {
                    queueId: queueId,
                    id: id.url,
                    url: urlItem.url,
                    urlParam: urlItem.param,
                    error: null,
                    content: null,
                    complete: false,
                    states: {},
                    deps: null
                };
                JS.mixin(result, id);
            } else {
                if ("string" === typeof id) {
                    urlItem = _parseUrl(id);
                    result = {
                        queueId: queueId,
                        id: id,
                        url: urlItem.url,
                        urlParam: urlItem.param,
                        type: Path.extname(id).toLowerCase().substr(1),
                        error: null,
                        content: null,
                        complete: false,
                        states: {},
                        deps: null
                    };
                }
            }
            if (result.skips) {
                for (var i = 0, l = result.skips.length; i < l; i++) {
                    var skip = result.skips[i];
                    result.states[skip] = ItemState.COMPLETE;
                }
            }
            return result;
        }
        var checkedIds = [];
        function checkCircleReference(owner, item, recursiveCall) {
            if (!owner || !item) {
                return false;
            }
            var result = false;
            checkedIds.push(item.id);
            if (item.deps) {
                var i, deps = item.deps, subDep;
                for (i = 0; i < deps.length; i++) {
                    subDep = deps[i];
                    if (subDep.id === owner.id) {
                        result = true;
                        break;
                    }
                    if (checkedIds.indexOf(subDep.id) >= 0) {
                        continue;
                    }
                    if (subDep.deps && checkCircleReference(owner, subDep, true)) {
                        result = true;
                        break;
                    }
                }
            }
            recursiveCall || (checkedIds.length = 0);
            return result;
        }
        var LoadingItems = function(pipeline, urlList, onProgress, onComplete) {
            CallbacksInvoker.call(this);
            this._id = ++_qid;
            _queues[this._id] = this;
            this._pipeline = pipeline;
            this._errorUrls = [];
            this._appending = false;
            this._ownerQueue = null;
            this.onProgress = onProgress;
            this.onComplete = onComplete;
            this.map = {};
            this.completed = {};
            this.totalCount = 0;
            this.completedCount = 0;
            this._pipeline ? this.active = true : this.active = false;
            urlList && (urlList.length > 0 ? this.append(urlList) : this.allComplete());
        };
        LoadingItems.ItemState = new cc.Enum(ItemState);
        LoadingItems.create = function(pipeline, urlList, onProgress, onComplete) {
            if (void 0 === onProgress) {
                if ("function" === typeof urlList) {
                    onComplete = urlList;
                    urlList = onProgress = null;
                }
            } else {
                if (void 0 === onComplete) {
                    if ("function" === typeof urlList) {
                        onComplete = onProgress;
                        onProgress = urlList;
                        urlList = null;
                    } else {
                        onComplete = onProgress;
                        onProgress = null;
                    }
                }
            }
            var queue = _pool.pop();
            if (queue) {
                queue._pipeline = pipeline;
                queue.onProgress = onProgress;
                queue.onComplete = onComplete;
                _queues[queue._id] = queue;
                queue._pipeline && (queue.active = true);
                urlList && queue.append(urlList);
            } else {
                queue = new LoadingItems(pipeline, urlList, onProgress, onComplete);
            }
            return queue;
        };
        LoadingItems.getQueue = function(item) {
            return item.queueId ? _queues[item.queueId] : null;
        };
        LoadingItems.itemComplete = function(item) {
            var queue = _queues[item.queueId];
            queue && queue.itemComplete(item.id);
        };
        LoadingItems.initQueueDeps = function(queue) {
            var dep = _queueDeps[queue._id];
            if (dep) {
                dep.completed.length = 0;
                dep.deps.length = 0;
            } else {
                dep = _queueDeps[queue._id] = {
                    completed: [],
                    deps: []
                };
            }
        };
        LoadingItems.registerDep = function(owner, depId) {
            var queueId = owner.queueId || owner;
            if (!queueId) {
                return false;
            }
            var queueDepList = _queueDeps[queueId];
            if (queueDepList) {
                queueDepList.deps.indexOf(depId) === -1 && queueDepList.deps.push(depId);
            } else {
                if (owner.id) {
                    for (var id in _queueDeps) {
                        var queue = _queueDeps[id];
                        queue.deps.indexOf(owner.id) !== -1 && queue.deps.indexOf(depId) === -1 && queue.deps.push(depId);
                    }
                }
            }
        };
        LoadingItems.finishDep = function(depId) {
            for (var id in _queueDeps) {
                var queue = _queueDeps[id];
                queue.deps.indexOf(depId) !== -1 && queue.completed.indexOf(depId) === -1 && queue.completed.push(depId);
            }
        };
        var proto = LoadingItems.prototype;
        JS.mixin(proto, CallbacksInvoker.prototype);
        proto.append = function(urlList, owner) {
            if (!this.active) {
                return [];
            }
            this._appending = true;
            var accepted = [], i, url, item;
            for (i = 0; i < urlList.length; ++i) {
                url = urlList[i];
                if (url.queueId && !this.map[url.id]) {
                    this.map[url.id] = url;
                    if (url.complete || checkCircleReference(owner, url)) {
                        this.totalCount++;
                        this.itemComplete(url.id);
                        continue;
                    }
                    var self = this;
                    var queue = _queues[url.queueId];
                    if (queue) {
                        this.totalCount++;
                        LoadingItems.registerDep(owner || this._id, url.id);
                        queue.addListener(url.id, (function(item) {
                            self.itemComplete(item.id);
                        }));
                    }
                    continue;
                }
                if (isIdValid(url)) {
                    item = createItem(url, this._id);
                    var key = item.id;
                    if (!this.map[key]) {
                        this.map[key] = item;
                        this.totalCount++;
                        LoadingItems.registerDep(owner || this._id, key);
                        accepted.push(item);
                    }
                }
            }
            this._appending = false;
            this.completedCount === this.totalCount ? this.allComplete() : this._pipeline.flowIn(accepted);
            return accepted;
        };
        proto._childOnProgress = function(item) {
            if (this.onProgress) {
                var dep = _queueDeps[this._id];
                this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
            }
        };
        proto.allComplete = function() {
            var errors = 0 === this._errorUrls.length ? null : this._errorUrls;
            this.onComplete && this.onComplete(errors, this);
        };
        proto.isCompleted = function() {
            return this.completedCount >= this.totalCount;
        };
        proto.isItemCompleted = function(id) {
            return !!this.completed[id];
        };
        proto.exists = function(id) {
            return !!this.map[id];
        };
        proto.getContent = function(id) {
            var item = this.map[id];
            var ret = null;
            item && (item.content ? ret = item.content : item.alias && (ret = this.getContent(item.alias)));
            return ret;
        };
        proto.getError = function(id) {
            var item = this.map[id];
            var ret = null;
            item && (item.error ? ret = item.error : item.alias && (ret = this.getError(item.alias)));
            return ret;
        };
        proto.addListener = CallbacksInvoker.prototype.add;
        proto.hasListener = CallbacksInvoker.prototype.has;
        proto.removeListener = CallbacksInvoker.prototype.remove;
        proto.removeAllListeners = CallbacksInvoker.prototype.removeAll;
        proto.removeItem = function(url) {
            var item = this.map[url];
            if (!item) {
                return;
            }
            if (!this.completed[item.alias || url]) {
                return;
            }
            delete this.completed[url];
            delete this.map[url];
            if (item.alias) {
                delete this.completed[item.alias];
                delete this.map[item.alias];
            }
            this.completedCount--;
            this.totalCount--;
        };
        proto.itemComplete = function(id) {
            var item = this.map[id];
            if (!item) {
                return;
            }
            var errorListId = this._errorUrls.indexOf(id);
            item.error && errorListId === -1 ? this._errorUrls.push(id) : item.error || errorListId === -1 || this._errorUrls.splice(errorListId, 1);
            this.completed[id] = item;
            this.completedCount++;
            LoadingItems.finishDep(item.id);
            if (this.onProgress) {
                var dep = _queueDeps[this._id];
                this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
            }
            this.invokeAndRemove(id, item);
            !this._appending && this.completedCount >= this.totalCount && this.allComplete();
        };
        proto.destroy = function() {
            this.active = false;
            this._appending = false;
            this._pipeline = null;
            this._ownerQueue = null;
            this._errorUrls.length = 0;
            this.onProgress = null;
            this.onComplete = null;
            this.map = {};
            this.completed = {};
            this.totalCount = 0;
            this.completedCount = 0;
            CallbacksInvoker.call(this);
            _queues[this._id] = null;
            if (_queueDeps[this._id]) {
                _queueDeps[this._id].completed.length = 0;
                _queueDeps[this._id].deps.length = 0;
            }
            _pool.indexOf(this) === -1 && _pool.length < _POOL_MAX_LENGTH && _pool.push(this);
        };
        cc.LoadingItems = module.exports = LoadingItems;
    }), {
        "../platform/callbacks-invoker": 187,
        "../platform/js": 193,
        "../utils/CCPath": 217
    } ],
    140: [ (function(require, module, exports) {
        var JsonUnpacker = require("./json-unpacker");
        var uuidToPack = {};
        var packIndices = {};
        var globalUnpackers = {};
        var PackState = {
            Invalid: 0,
            Removed: 1,
            Downloading: 2,
            Loaded: 3
        };
        function error(uuid, packUuid) {
            return new Error("Can not retrieve " + uuid + " from packer " + packUuid);
        }
        module.exports = {
            initPacks: function(packs) {
                packIndices = packs;
                for (var packUuid in packs) {
                    var uuids = packs[packUuid];
                    for (var i = 0; i < uuids.length; i++) {
                        var uuid = uuids[i];
                        var allIncludedPacks = uuidToPack[uuid];
                        if (allIncludedPacks) {
                            Array.isArray(allIncludedPacks) ? allIncludedPacks.push(packUuid) : uuidToPack[uuid] = allIncludedPacks = [ allIncludedPacks, packUuid ];
                            if (1 === uuids.length) {
                                var swapToLast = allIncludedPacks[0];
                                allIncludedPacks[0] = allIncludedPacks[allIncludedPacks.length - 1];
                                allIncludedPacks[allIncludedPacks.length - 1] = swapToLast;
                            }
                        } else {
                            uuidToPack[uuid] = packUuid;
                        }
                    }
                }
            },
            _loadNewPack: function(uuid, packUuid, callback) {
                var self = this;
                var packUrl = cc.AssetLibrary.getImportedDir(packUuid) + "/" + packUuid + ".json";
                cc.loader.load({
                    url: packUrl,
                    ignoreMaxConcurrency: true
                }, (function(err, packJson) {
                    if (err) {
                        cc.errorID(4916, uuid);
                        return callback(err);
                    }
                    var res = self._doLoadNewPack(uuid, packUuid, packJson);
                    res ? callback(null, res) : callback(error(uuid, packUuid));
                }));
            },
            _doLoadNewPack: function(uuid, packUuid, packJson) {
                var unpacker = globalUnpackers[packUuid];
                if (unpacker.state !== PackState.Loaded) {
                    unpacker.read(packIndices[packUuid], packJson);
                    unpacker.state = PackState.Loaded;
                }
                return unpacker.retrieve(uuid);
            },
            _selectLoadedPack: function(packUuids) {
                var existsPackState = PackState.Invalid;
                var existsPackUuid = "";
                for (var i = 0; i < packUuids.length; i++) {
                    var packUuid = packUuids[i];
                    var unpacker = globalUnpackers[packUuid];
                    if (unpacker) {
                        var state = unpacker.state;
                        if (state === PackState.Loaded) {
                            return packUuid;
                        }
                        if (state > existsPackState) {
                            existsPackState = state;
                            existsPackUuid = packUuid;
                        }
                    }
                }
                return existsPackState !== PackState.Invalid ? existsPackUuid : packUuids[0];
            },
            load: function(item, callback) {
                var uuid = item.uuid;
                var packUuid = uuidToPack[uuid];
                if (!packUuid) {
                    return;
                }
                Array.isArray(packUuid) && (packUuid = this._selectLoadedPack(packUuid));
                var unpacker = globalUnpackers[packUuid];
                if (unpacker && unpacker.state === PackState.Loaded) {
                    var json = unpacker.retrieve(uuid);
                    return json ? json : error(uuid, packUuid);
                }
                if (!unpacker) {
                    console.log("Create unpacker %s for %s", packUuid, uuid);
                    unpacker = globalUnpackers[packUuid] = new JsonUnpacker();
                    unpacker.state = PackState.Downloading;
                }
                this._loadNewPack(uuid, packUuid, callback);
                return null;
            }
        };
    }), {
        "./json-unpacker": 137
    } ],
    141: [ (function(require, module, exports) {
        var JS = require("../platform/js");
        var LoadingItems = require("./loading-items");
        var ItemState = LoadingItems.ItemState;
        function flow(pipe, item) {
            var pipeId = pipe.id;
            var itemState = item.states[pipeId];
            var next = pipe.next;
            var pipeline = pipe.pipeline;
            if (item.error || itemState === ItemState.WORKING || itemState === ItemState.ERROR) {
                return;
            }
            if (itemState === ItemState.COMPLETE) {
                next ? flow(next, item) : pipeline.flowOut(item);
            } else {
                item.states[pipeId] = ItemState.WORKING;
                var result = pipe.handle(item, (function(err, result) {
                    if (err) {
                        item.error = err;
                        item.states[pipeId] = ItemState.ERROR;
                        pipeline.flowOut(item);
                    } else {
                        result && (item.content = result);
                        item.states[pipeId] = ItemState.COMPLETE;
                        next ? flow(next, item) : pipeline.flowOut(item);
                    }
                }));
                if (result instanceof Error) {
                    item.error = result;
                    item.states[pipeId] = ItemState.ERROR;
                    pipeline.flowOut(item);
                } else {
                    if (void 0 !== result) {
                        null !== result && (item.content = result);
                        item.states[pipeId] = ItemState.COMPLETE;
                        next ? flow(next, item) : pipeline.flowOut(item);
                    }
                }
            }
        }
        var Pipeline = function(pipes) {
            this._pipes = pipes;
            this._cache = {};
            for (var i = 0; i < pipes.length; ++i) {
                var pipe = pipes[i];
                if (!pipe.handle || !pipe.id) {
                    continue;
                }
                pipe.pipeline = this;
                pipe.next = i < pipes.length - 1 ? pipes[i + 1] : null;
            }
        };
        Pipeline.ItemState = ItemState;
        var proto = Pipeline.prototype;
        proto.insertPipe = function(pipe, index) {
            if (!pipe.handle || !pipe.id) {
                return;
            }
            pipe.pipeline = this;
            if (index < this._pipes.length) {
                pipe.next = this._pipes[index];
                this._pipes.splice(index, 0, pipe);
            } else {
                pipe.next = null;
                this._pipes.push(pipe);
            }
        };
        proto.appendPipe = function(pipe) {
            if (!pipe.handle || !pipe.id) {
                return;
            }
            pipe.pipeline = this;
            pipe.next = null;
            this._pipes.push(pipe);
        };
        proto.flowIn = function(items) {
            var i, pipe = this._pipes[0], item;
            if (pipe) {
                for (i = 0; i < items.length; i++) {
                    item = items[i];
                    this._cache[item.id] = item;
                }
                for (i = 0; i < items.length; i++) {
                    item = items[i];
                    flow(pipe, item);
                }
            } else {
                for (i = 0; i < items.length; i++) {
                    this.flowOut(items[i]);
                }
            }
        };
        proto.flowInDeps = function(owner, urlList, callback) {
            var deps = LoadingItems.create(this, (function(errors, items) {
                callback(errors, items);
                items.destroy();
            }));
            return deps.append(urlList, owner);
        };
        proto.flowOut = function(item) {
            item.error ? delete this._cache[item.id] : this._cache[item.id] || (this._cache[item.id] = item);
            item.complete = true;
            LoadingItems.itemComplete(item);
        };
        proto.copyItemStates = function(srcItem, dstItems) {
            if (!(dstItems instanceof Array)) {
                dstItems.states = srcItem.states;
                return;
            }
            for (var i = 0; i < dstItems.length; ++i) {
                dstItems[i].states = srcItem.states;
            }
        };
        proto.isFlowing = function() {
            return true;
        };
        proto.getItems = function() {
            return null;
        };
        proto.getItem = function(id) {
            var item = this._cache[id];
            if (!item) {
                return item;
            }
            item.alias && (item = this._cache[item.alias]);
            return item;
        };
        proto.removeItem = function(id) {
            var removed = this._cache[id];
            removed && removed.complete && delete this._cache[id];
            return removed;
        };
        proto.clear = function() {
            for (var id in this._cache) {
                var item = this._cache[id];
                delete this._cache[id];
                if (!item.complete) {
                    item.error = new Error("Canceled manually");
                    this.flowOut(item);
                }
            }
        };
        cc.Pipeline = module.exports = Pipeline;
    }), {
        "../platform/js": 193,
        "./loading-items": 139
    } ],
    142: [ (function(require, module, exports) {
        var urlAppendTimestamp = require("./utils").urlAppendTimestamp;
        module.exports = function(item, callback) {
            var url = item.url, xhr = cc.loader.getXMLHttpRequest(), errInfo = "Load " + url + " failed!", navigator = window.navigator;
            url = urlAppendTimestamp(url);
            xhr.open("GET", url, true);
            if (/msie/i.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent)) {
                xhr.setRequestHeader("Accept-Charset", "utf-8");
                xhr.onreadystatechange = function() {
                    4 === xhr.readyState && (200 === xhr.status || 0 === xhr.status ? callback(null, xhr.responseText) : callback({
                        status: xhr.status,
                        errorMessage: errInfo
                    }));
                };
            } else {
                xhr.overrideMimeType && xhr.overrideMimeType("text/plain; charset=utf-8");
                xhr.onload = function() {
                    4 === xhr.readyState && (200 === xhr.status || 0 === xhr.status ? callback(null, xhr.responseText) : callback({
                        status: xhr.status,
                        errorMessage: errInfo
                    }));
                };
                xhr.onerror = function() {
                    callback({
                        status: xhr.status,
                        errorMessage: errInfo
                    });
                };
            }
            xhr.send(null);
        };
    }), {
        "./utils": 143
    } ],
    143: [ (function(require, module, exports) {
        var _noCacheRex = /\?/;
        module.exports = {
            urlAppendTimestamp: function(url) {
                cc.game.config["noCache"] && "string" === typeof url && (url += _noCacheRex.test(url) ? "&_t=" + (new Date() - 0) : "?_t=" + (new Date() - 0));
                return url;
            }
        };
    }), {} ],
    144: [ (function(require, module, exports) {
        var JS = require("../platform/js");
        require("../platform/deserialize");
        var LoadingItems = require("./loading-items");
        function isSceneObj(json) {
            var SCENE_ID = "cc.Scene";
            var PREFAB_ID = "cc.Prefab";
            return json && (json[0] && json[0].__type__ === SCENE_ID || json[1] && json[1].__type__ === SCENE_ID || json[0] && json[0].__type__ === PREFAB_ID);
        }
        function loadDepends(pipeline, item, asset, tdInfo, deferredLoadRawAssetsInRuntime, callback) {
            var uuidList = tdInfo.uuidList;
            var objList, propList, depends;
            var i, dependUuid;
            var dependKeys = item.dependKeys = [];
            if (deferredLoadRawAssetsInRuntime) {
                objList = [];
                propList = [];
                depends = [];
                for (i = 0; i < uuidList.length; i++) {
                    dependUuid = uuidList[i];
                    var obj = tdInfo.uuidObjList[i];
                    var prop = tdInfo.uuidPropList[i];
                    var info = cc.AssetLibrary._getAssetInfoInRuntime(dependUuid);
                    if (info.raw) {
                        var url = info.url;
                        obj[prop] = url;
                        dependKeys.push(url);
                    } else {
                        objList.push(obj);
                        propList.push(prop);
                        depends.push({
                            type: "uuid",
                            uuid: dependUuid,
                            deferredLoadRaw: true
                        });
                    }
                }
            } else {
                objList = tdInfo.uuidObjList;
                propList = tdInfo.uuidPropList;
                depends = new Array(uuidList.length);
                for (i = 0; i < uuidList.length; i++) {
                    dependUuid = uuidList[i];
                    depends[i] = {
                        type: "uuid",
                        uuid: dependUuid
                    };
                }
            }
            if (tdInfo.rawProp) {
                objList.push(asset);
                propList.push(tdInfo.rawProp);
                depends.push(item.url);
            }
            if (asset._preloadRawFiles) {
                var finalCallback = callback;
                callback = function() {
                    asset._preloadRawFiles((function(err) {
                        finalCallback(err || null, asset);
                    }));
                };
            }
            if (0 === depends.length) {
                cc.deserialize.Details.pool.put(tdInfo);
                return callback(null, asset);
            }
            item.content = asset;
            pipeline.flowInDeps(item, depends, (function(errors, items) {
                var item, missingAssetReporter;
                for (var src in items.map) {
                    item = items.map[src];
                    item.uuid && item.content && (item.content._uuid = item.uuid);
                }
                for (var i = 0; i < depends.length; i++) {
                    var dependSrc = depends[i].uuid;
                    var dependUrl = depends[i].url;
                    var dependObj = objList[i];
                    var dependProp = propList[i];
                    item = items.map[dependUrl];
                    if (item) {
                        var thisOfLoadCallback = {
                            obj: dependObj,
                            prop: dependProp
                        };
                        function loadCallback(item) {
                            var value = item.isRawAsset ? item.url : item.content;
                            this.obj[this.prop] = value;
                            item.uuid !== asset._uuid && dependKeys.indexOf(item.id) < 0 && dependKeys.push(item.id);
                        }
                        if (item.complete || item.content) {
                            if (item.error) {
                                var MissingObjectReporter;
                                cc._throw(item.error);
                            } else {
                                loadCallback.call(thisOfLoadCallback, item);
                            }
                        } else {
                            var queue = LoadingItems.getQueue(item);
                            var list = queue._callbackTable[dependSrc];
                            list ? list.unshift(loadCallback, thisOfLoadCallback) : queue.addListener(dependSrc, loadCallback, thisOfLoadCallback);
                        }
                    }
                }
                cc.deserialize.Details.pool.put(tdInfo);
                callback(null, asset);
            }));
        }
        function canDeferredLoad(asset, item, isScene) {
            var res = item.deferredLoadRaw;
            res ? asset instanceof cc.Asset && asset.constructor.preventDeferredLoadDependents && (res = false) : isScene && (asset instanceof cc.SceneAsset || asset instanceof cc.Prefab) && (res = asset.asyncLoadAssets);
            return res;
        }
        var MissingClass;
        function loadUuid(item, callback) {
            var json;
            if ("string" === typeof item.content) {
                try {
                    json = JSON.parse(item.content);
                } catch (e) {
                    return new Error("Uuid Loader: Parse asset [" + item.id + "] failed : " + e.stack);
                }
            } else {
                if ("object" !== typeof item.content) {
                    return new Error("JSON Loader: Input item doesn't contain string content");
                }
                json = item.content;
            }
            var classFinder;
            var isScene = isSceneObj(json);
            classFinder = isScene ? cc._MissingScript.safeFindClass : function(id) {
                var cls = JS._getClassById(id);
                if (cls) {
                    return cls;
                }
                cc.warnID(4903, id);
                return Object;
            };
            var tdInfo = cc.deserialize.Details.pool.get();
            var asset;
            try {
                asset = cc.deserialize(json, tdInfo, {
                    classFinder: classFinder,
                    target: item.existingAsset,
                    customEnv: item
                });
            } catch (e) {
                cc.deserialize.Details.pool.put(tdInfo);
                var err = e.stack;
                return new Error("Uuid Loader: Deserialize asset [" + item.id + "] failed : " + err);
            }
            asset._uuid = item.uuid;
            var deferredLoad = canDeferredLoad(asset, item, isScene);
            loadDepends(this.pipeline, item, asset, tdInfo, deferredLoad, callback);
        }
        module.exports = loadUuid;
        loadUuid.isSceneObj = isSceneObj;
    }), {
        "../platform/deserialize": 188,
        "../platform/js": 193,
        "./loading-items": 139
    } ],
    145: [ (function(require, module, exports) {
        var CompScheduler = require("./component-scheduler");
        var Flags = require("./platform/CCObject").Flags;
        var JS = require("./platform/js");
        var callerFunctor = false;
        var MAX_POOL_SIZE = 4;
        var IsPreloadStarted = Flags.IsPreloadStarted;
        var IsOnLoadStarted = Flags.IsOnLoadStarted;
        var IsOnLoadCalled = Flags.IsOnLoadCalled;
        var Deactivating = Flags.Deactivating;
        var callPreloadInTryCatch = false;
        var callOnLoadInTryCatch = false;
        var callOnDestroyInTryCatch = false;
        var callResetInTryCatch = false;
        var callOnFocusInTryCatch = false;
        var callOnLostFocusInTryCatch = false;
        var UnsortedInvoker = cc.Class({
            extends: CompScheduler.LifeCycleInvoker,
            add: function(comp) {
                this._zero.array.push(comp);
            },
            remove: function(comp) {
                this._zero.fastRemove(comp);
            },
            cancelInactive: function(flagToClear) {
                CompScheduler.LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
            },
            invoke: function() {
                this._invoke(this._zero);
                this._zero.array.length = 0;
            }
        });
        var invokePreload = CompScheduler.createInvokeImpl("c.__preload();");
        var invokeOnLoad = CompScheduler.createInvokeImpl("c.onLoad();c._objFlags|=" + IsOnLoadCalled);
        var activateTasksPool = new JS.Pool(MAX_POOL_SIZE);
        activateTasksPool.get = function getActivateTask() {
            var task = this._get() || {
                preload: new UnsortedInvoker(invokePreload),
                onLoad: new CompScheduler.OneOffInvoker(invokeOnLoad),
                onEnable: new CompScheduler.OneOffInvoker(CompScheduler.invokeOnEnable)
            };
            task.preload._zero.i = -1;
            var invoker = task.onLoad;
            invoker._zero.i = -1;
            invoker._neg.i = -1;
            invoker._pos.i = -1;
            invoker = task.onEnable;
            invoker._zero.i = -1;
            invoker._neg.i = -1;
            invoker._pos.i = -1;
            return task;
        };
        function _componentCorrupted(node, comp, index) {
            cc.errorID(3817, node.name, index);
            console.log("Corrupted component value:", comp);
            comp ? node._removeComponent(comp) : JS.array.removeAt(node._components, index);
        }
        function _onLoadInEditor(comp) {
            if (comp.onLoad && !cc.engine._isPlaying) {
                var focused = Editor.Selection.curActivate("node") === comp.node.uuid;
                focused && comp.onFocusInEditor ? callOnFocusInTryCatch(comp) : comp.onLostFocusInEditor && callOnLostFocusInTryCatch(comp);
            }
            _Scene.AssetsWatcher.start(comp);
        }
        function ctor() {
            this._activatingStack = [];
        }
        var NodeActivator = cc.Class({
            ctor: ctor,
            reset: ctor,
            _activateNodeRecursively: function(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                if (node._objFlags & Deactivating) {
                    cc.errorID(3816, node.name);
                    return;
                }
                node._activeInHierarchy = true;
                var originCount = node._components.length;
                for (var i = 0; i < originCount; ++i) {
                    var component = node._components[i];
                    if (component instanceof cc.Component) {
                        this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker);
                    } else {
                        _componentCorrupted(node, component, i);
                        --i;
                        --originCount;
                    }
                }
                for (var _i = 0, len = node._children.length; _i < len; ++_i) {
                    var child = node._children[_i];
                    child._active && this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
                }
                node._onPostActivated(true);
            },
            _deactivateNodeRecursively: function(node) {
                cc.assert(!(node._objFlags & Deactivating), "node should not deactivating");
                cc.assert(node._activeInHierarchy, "node should not deactivated");
                node._objFlags |= Deactivating;
                node._activeInHierarchy = false;
                var originCount = node._components.length;
                for (var c = 0; c < originCount; ++c) {
                    var component = node._components[c];
                    if (component._enabled) {
                        cc.director._compScheduler.disableComp(component);
                        if (node._activeInHierarchy) {
                            node._objFlags &= ~Deactivating;
                            return;
                        }
                    }
                }
                for (var i = 0, len = node._children.length; i < len; ++i) {
                    var child = node._children[i];
                    if (child._activeInHierarchy) {
                        this._deactivateNodeRecursively(child);
                        if (node._activeInHierarchy) {
                            node._objFlags &= ~Deactivating;
                            return;
                        }
                    }
                }
                node._onPostActivated(false);
                node._objFlags &= ~Deactivating;
            },
            activateNode: function(node, active) {
                if (active) {
                    var task = activateTasksPool.get();
                    this._activatingStack.push(task);
                    this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable);
                    task.preload.invoke();
                    task.onLoad.invoke();
                    task.onEnable.invoke();
                    this._activatingStack.pop();
                    activateTasksPool.put(task);
                } else {
                    this._deactivateNodeRecursively(node);
                    var stack = this._activatingStack;
                    for (var i = 0; i < stack.length; i++) {
                        var lastTask = stack[i];
                        lastTask.preload.cancelInactive(IsPreloadStarted);
                        lastTask.onLoad.cancelInactive(IsOnLoadStarted);
                        lastTask.onEnable.cancelInactive();
                    }
                }
                node.emit("active-in-hierarchy-changed", node);
            },
            activateComp: function(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                if (!(comp._objFlags & IsPreloadStarted)) {
                    comp._objFlags |= IsPreloadStarted;
                    "function" === typeof comp.__preload && (preloadInvoker ? preloadInvoker.add(comp) : comp.__preload());
                }
                if (!(comp._objFlags & IsOnLoadStarted)) {
                    comp._objFlags |= IsOnLoadStarted;
                    if (comp.onLoad) {
                        if (onLoadInvoker) {
                            onLoadInvoker.add(comp);
                        } else {
                            comp.onLoad();
                            comp._objFlags |= IsOnLoadCalled;
                        }
                    } else {
                        comp._objFlags |= IsOnLoadCalled;
                    }
                }
                if (comp._enabled) {
                    var deactivatedOnLoading = !comp.node._activeInHierarchy;
                    if (deactivatedOnLoading) {
                        return;
                    }
                    cc.director._compScheduler.enableComp(comp, onEnableInvoker);
                }
            },
            destroyComp: function(comp) {
                cc.director._compScheduler.disableComp(comp);
                comp.onDestroy && comp._objFlags & IsOnLoadCalled && comp.onDestroy();
            },
            resetComp: false
        });
        module.exports = NodeActivator;
    }), {
        "./component-scheduler": 71,
        "./platform/CCObject": 179,
        "./platform/js": 193,
        "./utils/misc": 223
    } ],
    146: [ (function(require, module, exports) {
        var PTM_RATIO = require("./CCPhysicsTypes").PTM_RATIO;
        var ContactType = require("./CCPhysicsTypes").ContactType;
        var pools = [];
        var pointCache = [ cc.v2(), cc.v2() ];
        var b2worldmanifold;
        b2worldmanifold = new b2.WorldManifold();
        var worldmanifold = {
            points: [],
            separations: [],
            normal: cc.v2()
        };
        function ManifoldPoint() {
            this.localPoint = cc.v2();
            this.normalImpulse = 0;
            this.tangentImpulse = 0;
        }
        var manifoldPointCache = [ new ManifoldPoint(), new ManifoldPoint() ];
        var b2manifold;
        b2manifold = new b2.Manifold();
        var manifold = {
            type: 0,
            localPoint: cc.v2(),
            localNormal: cc.v2(),
            points: []
        };
        var impulse = {
            normalImpulses: [],
            tangentImpulses: []
        };
        function PhysicsContact() {}
        PhysicsContact.prototype.init = function(b2contact) {
            this.colliderA = b2contact.GetFixtureA().collider;
            this.colliderB = b2contact.GetFixtureB().collider;
            this.disabled = false;
            this.disabledOnce = false;
            this._impulse = null;
            this._inverted = false;
            this._b2contact = b2contact;
            b2contact._contact = this;
        };
        PhysicsContact.prototype.reset = function() {
            this.colliderA = null;
            this.colliderB = null;
            this.disabled = false;
            this._impulse = null;
            this._b2contact._contact = null;
            this._b2contact = null;
        };
        PhysicsContact.prototype.getWorldManifold = function() {
            var points = worldmanifold.points;
            var separations = worldmanifold.separations;
            var normal = worldmanifold.normal;
            var wrapper;
            var count;
            var i;
            var _p2;
            this._b2contact.GetWorldManifold(b2worldmanifold);
            var b2points = b2worldmanifold.points;
            var b2separations = b2worldmanifold.separations;
            var count = this._b2contact.GetManifold().pointCount;
            points.length = separations.length = count;
            for (var i = 0; i < count; i++) {
                var p = pointCache[i];
                p.x = b2points[i].x * PTM_RATIO;
                p.y = b2points[i].y * PTM_RATIO;
                points[i] = p;
                separations[i] = b2separations[i] * PTM_RATIO;
            }
            normal.x = b2worldmanifold.normal.x;
            normal.y = b2worldmanifold.normal.y;
            if (this._inverted) {
                normal.x *= -1;
                normal.y *= -1;
            }
            return worldmanifold;
        };
        PhysicsContact.prototype.getManifold = function() {
            var points = manifold.points;
            var localNormal = manifold.localNormal;
            var localPoint = manifold.localPoint;
            var wrapper;
            var count;
            var i;
            var p;
            var b2manifold = this._b2contact.GetManifold();
            var b2points = b2manifold.points;
            var count = points.length = b2manifold.pointCount;
            for (var i = 0; i < count; i++) {
                var p = manifoldPointCache[i];
                var b2p = b2points[i];
                p.localPoint.x = b2p.localPoint.x * PTM_RATIO;
                p.localPoint.Y = b2p.localPoint.Y * PTM_RATIO;
                p.normalImpulse = b2p.normalImpulse * PTM_RATIO;
                p.tangentImpulse = b2p.tangentImpulse;
                points[i] = p;
            }
            localPoint.x = b2manifold.localPoint.x * PTM_RATIO;
            localPoint.y = b2manifold.localPoint.y * PTM_RATIO;
            localNormal.x = b2manifold.localNormal.x;
            localNormal.y = b2manifold.localNormal.y;
            manifold.type = b2manifold.type;
            if (this._inverted) {
                localNormal.x *= -1;
                localNormal.y *= -1;
            }
            return manifold;
        };
        PhysicsContact.prototype.getImpulse = function() {
            var b2impulse = this._impulse;
            if (!b2impulse) {
                return null;
            }
            var normalImpulses = impulse.normalImpulses;
            var tangentImpulses = impulse.tangentImpulses;
            var count;
            var i;
            count = b2impulse.count;
            for (var i = 0; i < count; i++) {
                normalImpulses[i] = b2impulse.normalImpulses[i] * PTM_RATIO;
                tangentImpulses[i] = b2impulse.tangentImpulses[i];
            }
            tangentImpulses.length = normalImpulses.length = count;
            return impulse;
        };
        PhysicsContact.prototype.emit = function(contactType) {
            var func;
            switch (contactType) {
              case ContactType.BEGIN_CONTACT:
                func = "onBeginContact";
                break;

              case ContactType.END_CONTACT:
                func = "onEndContact";
                break;

              case ContactType.PRE_SOLVE:
                func = "onPreSolve";
                break;

              case ContactType.POST_SOLVE:
                func = "onPostSolve";
            }
            var colliderA = this.colliderA;
            var colliderB = this.colliderB;
            var bodyA = colliderA.body;
            var bodyB = colliderB.body;
            var comps;
            var i, l, comp;
            if (bodyA.enabledContactListener) {
                comps = bodyA.node._components;
                this._inverted = false;
                for (i = 0, l = comps.length; i < l; i++) {
                    comp = comps[i];
                    comp[func] && comp[func](this, colliderA, colliderB);
                }
            }
            if (bodyB.enabledContactListener) {
                comps = bodyB.node._components;
                this._inverted = true;
                for (i = 0, l = comps.length; i < l; i++) {
                    comp = comps[i];
                    comp[func] && comp[func](this, colliderB, colliderA);
                }
            }
            if (this.disabled || this.disabledOnce) {
                this.setEnabled(false);
                this.disabledOnce = false;
            }
        };
        PhysicsContact.get = function(b2contact) {
            var c;
            c = 0 === pools.length ? new cc.PhysicsContact() : pools.pop();
            c.init(b2contact);
            return c;
        };
        PhysicsContact.put = function(b2contact) {
            var c = b2contact._contact;
            if (!c) {
                return;
            }
            pools.push(c);
            c.reset();
        };
        var _p = PhysicsContact.prototype;
        _p.setEnabled = function(value) {
            this._b2contact.SetEnabled(value);
        };
        _p.isTouching = function() {
            return this._b2contact.IsTouching();
        };
        _p.setTangentSpeed = function(value) {
            this._b2contact.SetTangentSpeed(value / PTM_RATIO);
        };
        _p.getTangentSpeed = function() {
            return this._b2contact.GetTangentSpeed() * PTM_RATIO;
        };
        _p.setFriction = function(value) {
            this._b2contact.SetFriction(value);
        };
        _p.getFriction = function() {
            return this._b2contact.GetFriction();
        };
        _p.resetFriction = function() {
            return this._b2contact.ResetFriction();
        };
        _p.setRestitution = function(value) {
            this._b2contact.SetRestitution(value);
        };
        _p.getRestitution = function() {
            return this._b2contact.GetRestitution();
        };
        _p.resetRestitution = function() {
            return this._b2contact.ResetRestitution();
        };
        PhysicsContact.ContactType = ContactType;
        cc.PhysicsContact = module.exports = PhysicsContact;
    }), {
        "./CCPhysicsTypes": 148
    } ],
    147: [ (function(require, module, exports) {
        var ContactType = require("./CCPhysicsTypes").ContactType;
        var BodyType = require("./CCPhysicsTypes").BodyType;
        var RayCastType = require("./CCPhysicsTypes").RayCastType;
        var PTM_RATIO = require("./CCPhysicsTypes").PTM_RATIO;
        var ANGLE_TO_PHYSICS_ANGLE = require("./CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
        var PHYSICS_ANGLE_TO_ANGLE = require("./CCPhysicsTypes").PHYSICS_ANGLE_TO_ANGLE;
        var tempB2AABB = new b2.AABB();
        var tempB2Vec21 = new b2.Vec2();
        var tempB2Vec22 = new b2.Vec2();
        var PhysicsManager = cc.Class({
            mixins: [ cc.EventTarget ],
            statics: {
                DrawBits: b2.Draw,
                PTM_RATIO: PTM_RATIO
            },
            ctor: function() {
                this.__instanceId = cc.ClassManager.getNewInstanceId();
                this._debugDrawFlags = 0;
                this._debugDrawer = null;
                this._world = null;
                this._bodies = [];
                this._contactMap = {};
                this._contactID = 0;
                this._delayEvents = [];
            },
            pushDelayEvent: function(target, func, args) {
                this._steping ? this._delayEvents.push({
                    target: target,
                    func: func,
                    args: args
                }) : target[func].apply(target, args);
            },
            update: function(dt) {
                var world = this._world;
                if (!world || !this.enabled) {
                    return;
                }
                this.emit("before-step");
                this._steping = true;
                var timeStep = 1 / cc.game.config["frameRate"];
                world.Step(timeStep, 10, 10);
                world.DrawDebugData();
                this._steping = false;
                var events = this._delayEvents;
                for (var i = 0, l = events.length; i < l; i++) {
                    var event = events[i];
                    event.target[event.func].apply(event.target, event.args);
                }
                events.length = 0;
                this._syncNode();
            },
            testPoint: function(point) {
                var x = tempB2Vec21.x = point.x / PTM_RATIO;
                var y = tempB2Vec21.y = point.y / PTM_RATIO;
                var d = .2 / PTM_RATIO;
                tempB2AABB.lowerBound.x = x - d;
                tempB2AABB.lowerBound.y = y - d;
                tempB2AABB.upperBound.x = x + d;
                tempB2AABB.upperBound.y = y + d;
                var callback = this._aabbQueryCallback;
                callback.init(tempB2Vec21);
                this._world.QueryAABB(callback, tempB2AABB);
                var fixture = callback.getFixture();
                if (fixture) {
                    return fixture.collider;
                }
                return null;
            },
            testAABB: function(rect) {
                tempB2AABB.lowerBound.x = rect.xMin / PTM_RATIO;
                tempB2AABB.lowerBound.y = rect.yMin / PTM_RATIO;
                tempB2AABB.upperBound.x = rect.xMax / PTM_RATIO;
                tempB2AABB.upperBound.y = rect.yMax / PTM_RATIO;
                var callback = this._aabbQueryCallback;
                callback.init();
                this._world.QueryAABB(callback, tempB2AABB);
                var fixtures = callback.getFixtures();
                var colliders = fixtures.map((function(fixture) {
                    return fixture.collider;
                }));
                return colliders;
            },
            rayCast: function(p1, p2, type) {
                if (p1.equals(p2)) {
                    return [];
                }
                type = type || RayCastType.Closest;
                tempB2Vec21.x = p1.x / PTM_RATIO;
                tempB2Vec21.y = p1.y / PTM_RATIO;
                tempB2Vec22.x = p2.x / PTM_RATIO;
                tempB2Vec22.y = p2.y / PTM_RATIO;
                var callback = this._raycastQueryCallback;
                callback.init(type);
                this._world.RayCast(callback, tempB2Vec21, tempB2Vec22);
                var fixtures = callback.getFixtures();
                if (fixtures.length > 0) {
                    var points = callback.getPoints();
                    var normals = callback.getNormals();
                    var fractions = callback.getFractions();
                    var results = [];
                    for (var i = 0, l = fixtures.length; i < l; i++) {
                        var fixture = fixtures[i];
                        var collider = fixture.collider;
                        if (type === RayCastType.AllClosest) {
                            var result = results.find((function(result) {
                                return result.collider === collider;
                            }));
                            if (result) {
                                if (fractions[i] < result.fraction) {
                                    result.fixtureIndex = collider._getFixtureIndex(fixture);
                                    result.point.x = points[i].x * PTM_RATIO;
                                    result.point.y = points[i].y * PTM_RATIO;
                                    result.normal.x = normals[i].x;
                                    result.normal.y = normals[i].y;
                                    result.fraction = fractions[i];
                                }
                                continue;
                            }
                        }
                        results.push({
                            collider: collider,
                            fixtureIndex: collider._getFixtureIndex(fixture),
                            point: cc.v2(points[i].x * PTM_RATIO, points[i].y * PTM_RATIO),
                            normal: cc.v2(normals[i]),
                            fraction: fractions[i]
                        });
                    }
                    return results;
                }
                return [];
            },
            syncPosition: function() {
                var bodies = this._bodies;
                for (var i = 0; i < bodies.length; i++) {
                    bodies[i].syncPosition();
                }
            },
            syncRotation: function() {
                var bodies = this._bodies;
                for (var i = 0; i < bodies.length; i++) {
                    bodies[i].syncRotation();
                }
            },
            attachDebugDrawToCamera: function(camera) {
                if (!this._debugDrawer) {
                    return;
                }
                camera.addTarget(this._debugDrawer.getDrawer());
            },
            detachDebugDrawFromCamera: function(camera) {
                if (!this._debugDrawer) {
                    return;
                }
                camera.removeTarget(this._debugDrawer.getDrawer());
            },
            _registerContactFixture: function(fixture) {
                this._contactListener.registerContactFixture(fixture);
            },
            _unregisterContactFixture: function(fixture) {
                this._contactListener.unregisterContactFixture(fixture);
            },
            _addBody: function(body, bodyDef) {
                var world = this._world;
                var node = body.node;
                if (!world || !node) {
                    return;
                }
                body._b2Body = world.CreateBody(bodyDef);
                body._b2Body.body = body;
                this._utils.addB2Body(body._b2Body);
                this._bodies.push(body);
            },
            _removeBody: function(body) {
                var world = this._world;
                if (!world) {
                    return;
                }
                body._b2Body.body = null;
                this._utils.removeB2Body(body._b2Body);
                world.DestroyBody(body._b2Body);
                body._b2Body = null;
                var index = this._bodies.indexOf(body);
                index !== -1 && this._bodies.splice(index, 1);
            },
            _initCallback: function() {
                if (!this._world) {
                    cc.warn("Please init PhysicsManager first");
                    return;
                }
                if (this._contactListener) {
                    return;
                }
                var listener = new cc.PhysicsContactListener();
                listener.setBeginContact(this._onBeginContact);
                listener.setEndContact(this._onEndContact);
                listener.setPreSolve(this._onPreSolve);
                listener.setPostSolve(this._onPostSolve);
                this._world.SetContactListener(listener);
                this._contactListener = listener;
                this._aabbQueryCallback = new cc.PhysicsAABBQueryCallback();
                this._raycastQueryCallback = new cc.PhysicsRayCastCallback();
            },
            _init: function() {
                this.enabled = true;
                this.debugDrawFlags = b2.Draw.e_shapeBit;
            },
            _getWorld: function() {
                return this._world;
            },
            _syncNode: function() {
                this._utils.syncNode();
                var bodies = this._bodies;
                for (var i = 0, l = bodies.length; i < l; i++) {
                    var body = bodies[i];
                    var node;
                    body.type === BodyType.Animated && body.resetVelocity();
                }
            },
            _onSceneLaunched: function() {
                this._debugDrawer.AddDrawerToNode(cc.director.getScene()._sgNode);
            },
            _onBeginContact: function(b2contact) {
                var c = cc.PhysicsContact.get(b2contact);
                c.emit(ContactType.BEGIN_CONTACT);
            },
            _onEndContact: function(b2contact) {
                var c = b2contact._contact;
                if (!c) {
                    return;
                }
                c.emit(ContactType.END_CONTACT);
                cc.PhysicsContact.put(b2contact);
            },
            _onPreSolve: function(b2contact) {
                var c = b2contact._contact;
                if (!c) {
                    return;
                }
                c.emit(ContactType.PRE_SOLVE);
            },
            _onPostSolve: function(b2contact, impulse) {
                var c = b2contact._contact;
                if (!c) {
                    return;
                }
                c._impulse = impulse;
                c.emit(ContactType.POST_SOLVE);
                c._impulse = null;
            }
        });
        cc.js.getset(PhysicsManager.prototype, "enabled", (function() {
            return this._enabled;
        }), (function(value) {
            if (value && !this._world) {
                var world = new b2.World(new b2.Vec2(0, -10));
                world.SetAllowSleeping(true);
                this._world = world;
                this._utils = new cc.PhysicsUtils();
                this._initCallback();
            }
            this._enabled = value;
        }));
        cc.js.getset(PhysicsManager.prototype, "debugDrawFlags", (function() {
            return this._debugDrawFlags;
        }), (function(value) {
            if (value && !this._debugDrawFlags) {
                if (!this._debugDrawer) {
                    this._debugDrawer = new cc.PhysicsDebugDraw(PTM_RATIO);
                    this._world.SetDebugDraw(this._debugDrawer);
                }
                var scene = cc.director.getScene();
                scene && this._debugDrawer.AddDrawerToNode(cc.director.getScene()._sgNode);
                cc.director.on(cc.Director.EVENT_AFTER_SCENE_LAUNCH, this._onSceneLaunched, this);
            } else {
                !value && this._debugDrawFlags && cc.director.off(cc.Director.EVENT_AFTER_SCENE_LAUNCH, this._onSceneLaunched, this);
            }
            this._debugDrawFlags = value;
            this._debugDrawer && this._debugDrawer.SetFlags(value);
        }));
        cc.js.getset(PhysicsManager.prototype, "gravity", (function() {
            if (this._world) {
                var g = this._world.GetGravity();
                return cc.v2(g.x * PTM_RATIO, g.y * PTM_RATIO);
            }
            return cc.v2();
        }), (function(value) {
            this._world && this._world.SetGravity(new b2.Vec2(value.x / PTM_RATIO, value.y / PTM_RATIO));
        }));
        cc.PhysicsManager = module.exports = PhysicsManager;
    }), {
        "./CCPhysicsTypes": 148
    } ],
    148: [ (function(require, module, exports) {
        var ContactType = {
            BEGIN_CONTACT: "begin-contact",
            END_CONTACT: "end-contact",
            PRE_SOLVE: "pre-solve",
            POST_SOLVE: "post-solve"
        };
        var BodyType = cc.Enum({
            Static: 0,
            Kinematic: 1,
            Dynamic: 2,
            Animated: 3
        });
        cc.RigidBodyType = BodyType;
        var RayCastType = cc.Enum({
            Closest: 0,
            Any: 1,
            AllClosest: 2,
            All: 3
        });
        cc.RayCastType = RayCastType;
        module.exports = {
            BodyType: BodyType,
            ContactType: ContactType,
            RayCastType: RayCastType,
            PTM_RATIO: 32,
            ANGLE_TO_PHYSICS_ANGLE: -Math.PI / 180,
            PHYSICS_ANGLE_TO_ANGLE: -180 / Math.PI
        };
    }), {} ],
    149: [ (function(require, module, exports) {
        var validate = function(verticesArray) {
            var i, n = verticesArray.length, j, j2, i2, i3, d, ret = 0;
            var fl, fl2 = false;
            for (i = 0; i < n; i++) {
                i2 = i < n - 1 ? i + 1 : 0;
                i3 = i > 0 ? i - 1 : n - 1;
                fl = false;
                for (j = 0; j < n; j++) {
                    if (j != i && j != i2) {
                        if (!fl) {
                            d = det(verticesArray[i].x, verticesArray[i].y, verticesArray[i2].x, verticesArray[i2].y, verticesArray[j].x, verticesArray[j].y);
                            d > 0 && (fl = true);
                        }
                        if (j != i3) {
                            j2 = j < n - 1 ? j + 1 : 0;
                            hitSegment(verticesArray[i].x, verticesArray[i].y, verticesArray[i2].x, verticesArray[i2].y, verticesArray[j].x, verticesArray[j].y, verticesArray[j2].x, verticesArray[j2].y) && (ret = 1);
                        }
                    }
                }
                fl || (fl2 = true);
            }
            fl2 && (ret = 1 == ret ? 3 : 2);
            return ret;
        };
        function calcShapes(verticesArray) {
            var vec;
            var i, n, j;
            var d, t, dx, dy, minLen;
            var i1, i2, i3, p1, p2, p3;
            var j1, j2, v1, v2, k, h;
            var vec1, vec2;
            var v, hitV;
            var isConvex;
            var figsVec = [], queue = [];
            queue.push(verticesArray);
            while (queue.length) {
                vec = queue[0];
                n = vec.length;
                isConvex = true;
                for (i = 0; i < n; i++) {
                    i1 = i;
                    i2 = i < n - 1 ? i + 1 : i + 1 - n;
                    i3 = i < n - 2 ? i + 2 : i + 2 - n;
                    p1 = vec[i1];
                    p2 = vec[i2];
                    p3 = vec[i3];
                    d = det(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
                    if (d < 0) {
                        isConvex = false;
                        minLen = Number.MAX_VALUE;
                        for (j = 0; j < n; j++) {
                            if (j != i1 && j != i2) {
                                j1 = j;
                                j2 = j < n - 1 ? j + 1 : 0;
                                v1 = vec[j1];
                                v2 = vec[j2];
                                v = hitRay(p1.x, p1.y, p2.x, p2.y, v1.x, v1.y, v2.x, v2.y);
                                if (v) {
                                    dx = p2.x - v.x;
                                    dy = p2.y - v.y;
                                    t = dx * dx + dy * dy;
                                    if (t < minLen) {
                                        h = j1;
                                        k = j2;
                                        hitV = v;
                                        minLen = t;
                                    }
                                }
                            }
                        }
                        minLen == Number.MAX_VALUE && err();
                        vec1 = new Array();
                        vec2 = new Array();
                        j1 = h;
                        j2 = k;
                        v1 = vec[j1];
                        v2 = vec[j2];
                        pointsMatch(hitV.x, hitV.y, v2.x, v2.y) || vec1.push(hitV);
                        pointsMatch(hitV.x, hitV.y, v1.x, v1.y) || vec2.push(hitV);
                        h = -1;
                        k = i1;
                        while (true) {
                            if (k == j2) {
                                (h < 0 || h >= n) && err();
                                isOnSegment(v2.x, v2.y, vec[h].x, vec[h].y, p1.x, p1.y) || vec1.push(vec[k]);
                                break;
                            }
                            vec1.push(vec[k]);
                            h = k;
                            k - 1 < 0 ? k = n - 1 : k--;
                        }
                        vec1 = vec1.reverse();
                        h = -1;
                        k = i2;
                        while (true) {
                            if (k == j1) {
                                (h < 0 || h >= n) && err();
                                k != j1 || isOnSegment(v1.x, v1.y, vec[h].x, vec[h].y, p2.x, p2.y) || vec2.push(vec[k]);
                                break;
                            }
                            vec2.push(vec[k]);
                            h = k;
                            k + 1 > n - 1 ? k = 0 : k++;
                        }
                        queue.push(vec1, vec2);
                        queue.shift();
                        break;
                    }
                }
                isConvex && figsVec.push(queue.shift());
            }
            return figsVec;
        }
        function hitRay(x1, y1, x2, y2, x3, y3, x4, y4) {
            var t1 = x3 - x1, t2 = y3 - y1, t3 = x2 - x1, t4 = y2 - y1, t5 = x4 - x3, t6 = y4 - y3, t7 = t4 * t5 - t3 * t6, a;
            a = (t5 * t2 - t6 * t1) / t7;
            var px = x1 + a * t3, py = y1 + a * t4;
            var b1 = isOnSegment(x2, y2, x1, y1, px, py);
            var b2 = isOnSegment(px, py, x3, y3, x4, y4);
            if (b1 && b2) {
                return cc.v2(px, py);
            }
            return null;
        }
        function hitSegment(x1, y1, x2, y2, x3, y3, x4, y4) {
            var t1 = x3 - x1, t2 = y3 - y1, t3 = x2 - x1, t4 = y2 - y1, t5 = x4 - x3, t6 = y4 - y3, t7 = t4 * t5 - t3 * t6, a;
            a = (t5 * t2 - t6 * t1) / t7;
            var px = x1 + a * t3, py = y1 + a * t4;
            var b1 = isOnSegment(px, py, x1, y1, x2, y2);
            var b2 = isOnSegment(px, py, x3, y3, x4, y4);
            if (b1 && b2) {
                return cc.v2(px, py);
            }
            return null;
        }
        function isOnSegment(px, py, x1, y1, x2, y2) {
            var b1 = x1 + .1 >= px && px >= x2 - .1 || x1 - .1 <= px && px <= x2 + .1;
            var b2 = y1 + .1 >= py && py >= y2 - .1 || y1 - .1 <= py && py <= y2 + .1;
            return b1 && b2 && isOnLine(px, py, x1, y1, x2, y2);
        }
        function pointsMatch(x1, y1, x2, y2) {
            var dx = x2 >= x1 ? x2 - x1 : x1 - x2, dy = y2 >= y1 ? y2 - y1 : y1 - y2;
            return dx < .1 && dy < .1;
        }
        function isOnLine(px, py, x1, y1, x2, y2) {
            if (x2 - x1 > .1 || x1 - x2 > .1) {
                var a = (y2 - y1) / (x2 - x1), possibleY = a * (px - x1) + y1, diff = possibleY > py ? possibleY - py : py - possibleY;
                return diff < .1;
            }
            return px - x1 < .1 || x1 - px < .1;
        }
        function det(x1, y1, x2, y2, x3, y3) {
            return x1 * y2 + x2 * y3 + x3 * y1 - y1 * x2 - y2 * x3 - y3 * x1;
        }
        function err() {
            throw new Error("A problem has occurred. Use the Validate() method to see where the problem is.");
        }
        exports.calcShapes = calcShapes;
        exports.validate = validate;
    }), {} ],
    150: [ (function(require, module, exports) {
        var PTM_RATIO = require("./CCPhysicsTypes").PTM_RATIO;
        var ANGLE_TO_PHYSICS_ANGLE = require("./CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
        var PHYSICS_ANGLE_TO_ANGLE = require("./CCPhysicsTypes").PHYSICS_ANGLE_TO_ANGLE;
        var getWorldRotation = require("./utils").getWorldRotation;
        var BodyType = require("./CCPhysicsTypes").BodyType;
        var tempb2Vec21 = new b2.Vec2();
        var tempb2Vec22 = new b2.Vec2();
        var VEC2_ZERO = cc.Vec2.ZERO;
        var RigidBody = cc.Class({
            name: "cc.RigidBody",
            extends: cc.Component,
            editor: false,
            properties: {
                _type: BodyType.Dynamic,
                _allowSleep: true,
                _gravityScale: 1,
                _linearDamping: 0,
                _angularDamping: 0,
                _linearVelocity: cc.v2(0, 0),
                _angularVelocity: 0,
                _fixedRotation: false,
                enabled: {
                    get: function() {
                        return this._enabled;
                    },
                    set: function() {
                        cc.warnID("8200");
                    },
                    visible: false,
                    override: true
                },
                enabledContactListener: {
                    default: false,
                    tooltip: "i18n:COMPONENT.physics.rigidbody.enabledContactListener"
                },
                bullet: {
                    default: false,
                    tooltip: "i18n:COMPONENT.physics.rigidbody.bullet"
                },
                type: {
                    type: BodyType,
                    tooltip: "i18n:COMPONENT.physics.rigidbody.type",
                    get: function() {
                        return this._type;
                    },
                    set: function(value) {
                        this._type = value;
                        this._b2Body && (value === BodyType.Animated ? this._b2Body.SetType(BodyType.Kinematic) : this._b2Body.SetType(value));
                    }
                },
                allowSleep: {
                    tooltip: "i18n:COMPONENT.physics.rigidbody.allowSleep",
                    get: function() {
                        if (this._b2Body) {
                            return this._b2Body.IsSleepingAllowed();
                        }
                        return this._allowSleep;
                    },
                    set: function(value) {
                        this._allowSleep = value;
                        this._b2Body && this._b2Body.SetAllowSleeping(value);
                    }
                },
                gravityScale: {
                    tooltip: "i18n:COMPONENT.physics.rigidbody.gravityScale",
                    get: function() {
                        return this._gravityScale;
                    },
                    set: function(value) {
                        this._gravityScale = value;
                        this._b2Body && this._b2Body.SetGravityScale(value);
                    }
                },
                linearDamping: {
                    tooltip: "i18n:COMPONENT.physics.rigidbody.linearDamping",
                    get: function() {
                        return this._linearDamping;
                    },
                    set: function(value) {
                        this._linearDamping = value;
                        this._b2Body && this._b2Body.SetLinearDamping(this._linearDamping);
                    }
                },
                angularDamping: {
                    tooltip: "i18n:COMPONENT.physics.rigidbody.angularDamping",
                    get: function() {
                        return this._angularDamping;
                    },
                    set: function(value) {
                        this._angularDamping = value;
                        this._b2Body && this._b2Body.SetAngularDamping(value);
                    }
                },
                linearVelocity: {
                    tooltip: "i18n:COMPONENT.physics.rigidbody.linearVelocity",
                    type: cc.Vec2,
                    get: function() {
                        var lv = this._linearVelocity;
                        if (this._b2Body) {
                            var velocity = this._b2Body.GetLinearVelocity();
                            lv.x = velocity.x * PTM_RATIO;
                            lv.y = velocity.y * PTM_RATIO;
                        }
                        return lv;
                    },
                    set: function(value) {
                        this._linearVelocity = value;
                        var b2body = this._b2Body;
                        if (b2body) {
                            var temp = b2body.m_linearVelocity;
                            temp.Set(value.x / PTM_RATIO, value.y / PTM_RATIO);
                            b2body.SetLinearVelocity(temp);
                        }
                    }
                },
                angularVelocity: {
                    tooltip: "i18n:COMPONENT.physics.rigidbody.angularVelocity",
                    get: function() {
                        if (this._b2Body) {
                            return this._b2Body.GetAngularVelocity() * PHYSICS_ANGLE_TO_ANGLE;
                        }
                        return this._angularVelocity;
                    },
                    set: function(value) {
                        this._angularVelocity = value;
                        this._b2Body && this._b2Body.SetAngularVelocity(value * ANGLE_TO_PHYSICS_ANGLE);
                    }
                },
                fixedRotation: {
                    tooltip: "i18n:COMPONENT.physics.rigidbody.fixedRotation",
                    get: function() {
                        return this._fixedRotation;
                    },
                    set: function(value) {
                        this._fixedRotation = value;
                        this._b2Body && this._b2Body.SetFixedRotation(value);
                    }
                },
                awake: {
                    tooltip: "i18n:COMPONENT.physics.rigidbody.awake",
                    get: function() {
                        return !!this._b2Body && this._b2Body.IsAwake();
                    },
                    set: function(value) {
                        this._b2Body && this._b2Body.SetAwake(value);
                    }
                },
                active: {
                    visible: false,
                    get: function() {
                        return !!this._b2Body && this._b2Body.IsActive();
                    },
                    set: function(value) {
                        this._b2Body && this._b2Body.SetActive(value);
                    }
                }
            },
            getLocalPoint: function(worldPoint, out) {
                out = out || cc.v2();
                if (this._b2Body) {
                    tempb2Vec21.Set(worldPoint.x / PTM_RATIO, worldPoint.y / PTM_RATIO);
                    var pos = this._b2Body.GetLocalPoint(tempb2Vec21);
                    out.x = pos.x * PTM_RATIO;
                    out.y = pos.y * PTM_RATIO;
                }
                return out;
            },
            getWorldPoint: function(localPoint, out) {
                out = out || cc.v2();
                if (this._b2Body) {
                    tempb2Vec21.Set(localPoint.x / PTM_RATIO, localPoint.y / PTM_RATIO);
                    var pos = this._b2Body.GetWorldPoint(tempb2Vec21);
                    out.x = pos.x * PTM_RATIO;
                    out.y = pos.y * PTM_RATIO;
                }
                return out;
            },
            getWorldVector: function(localVector, out) {
                out = out || cc.v2();
                if (this._b2Body) {
                    tempb2Vec21.Set(localVector.x / PTM_RATIO, localVector.y / PTM_RATIO);
                    var vector = this._b2Body.GetWorldVector(tempb2Vec21);
                    out.x = vector.x * PTM_RATIO;
                    out.y = vector.y * PTM_RATIO;
                }
                return out;
            },
            getLocalVector: function(worldVector, out) {
                out = out || cc.v2();
                if (this._b2Body) {
                    tempb2Vec21.Set(worldVector.x / PTM_RATIO, worldVector.y / PTM_RATIO);
                    var vector = this._b2Body.GetLocalVector(tempb2Vec21);
                    out.x = vector.x * PTM_RATIO;
                    out.y = vector.y * PTM_RATIO;
                }
                return out;
            },
            getWorldPosition: function(out) {
                out = out || cc.v2();
                if (this._b2Body) {
                    var pos = this._b2Body.GetPosition();
                    out.x = pos.x * PTM_RATIO;
                    out.y = pos.y * PTM_RATIO;
                }
                return out;
            },
            getWorldRotation: function() {
                if (this._b2Body) {
                    return this._b2Body.GetAngle() * PHYSICS_ANGLE_TO_ANGLE;
                }
                return 0;
            },
            getLocalCenter: function(out) {
                out = out || cc.v2();
                if (this._b2Body) {
                    var pos = this._b2Body.GetLocalCenter();
                    out.x = pos.x * PTM_RATIO;
                    out.y = pos.y * PTM_RATIO;
                }
                return out;
            },
            getWorldCenter: function(out) {
                out = out || cc.v2();
                if (this._b2Body) {
                    var pos = this._b2Body.GetWorldCenter();
                    out.x = pos.x * PTM_RATIO;
                    out.y = pos.y * PTM_RATIO;
                }
                return out;
            },
            getLinearVelocityFromWorldPoint: function(worldPoint, out) {
                out = out || cc.v2();
                if (this._b2Body) {
                    tempb2Vec21.Set(worldPoint.x / PTM_RATIO, worldPoint.y / PTM_RATIO);
                    var velocity = this._b2Body.GetLinearVelocityFromWorldPoint(tempb2Vec21);
                    out.x = velocity.x * PTM_RATIO;
                    out.y = velocity.y * PTM_RATIO;
                }
                return out;
            },
            getMass: function() {
                return this._b2Body ? this._b2Body.GetMass() : 0;
            },
            getInertia: function() {
                return this._b2Body ? this._b2Body.GetInertia() * PTM_RATIO * PTM_RATIO : 0;
            },
            getJointList: function() {
                if (!this._b2Body) {
                    return [];
                }
                var joints;
                var i;
                var joints = [];
                var list = this._b2Body.GetJointList();
                if (!list) {
                    return [];
                }
                joints.push(list.joint._joint);
                var prev = list.prev;
                while (prev) {
                    joints.push(prev.joint._joint);
                    prev = prev.prev;
                }
                var next = list.next;
                while (next) {
                    joints.push(next.joint._joint);
                    next = next.next;
                }
                return joints;
            },
            applyForce: function(force, point, wake) {
                if (this._b2Body) {
                    tempb2Vec21.Set(force.x / PTM_RATIO, force.y / PTM_RATIO);
                    tempb2Vec22.Set(point.x / PTM_RATIO, point.y / PTM_RATIO);
                    this._b2Body.ApplyForce(tempb2Vec21, tempb2Vec22, wake);
                }
            },
            applyForceToCenter: function(force, wake) {
                if (this._b2Body) {
                    tempb2Vec21.Set(force.x / PTM_RATIO, force.y / PTM_RATIO);
                    this._b2Body.ApplyForceToCenter(tempb2Vec21, wake);
                }
            },
            applyTorque: function(torque, wake) {
                this._b2Body && this._b2Body.ApplyTorque(torque / PTM_RATIO, wake);
            },
            applyLinearImpulse: function(impulse, point, wake) {
                if (this._b2Body) {
                    tempb2Vec21.Set(impulse.x / PTM_RATIO, impulse.y / PTM_RATIO);
                    tempb2Vec22.Set(point.x / PTM_RATIO, point.y / PTM_RATIO);
                    this._b2Body.ApplyLinearImpulse(tempb2Vec21, tempb2Vec22, wake);
                }
            },
            applyAngularImpulse: function(impulse, wake) {
                this._b2Body && this._b2Body.ApplyAngularImpulse(impulse / PTM_RATIO / PTM_RATIO, wake);
            },
            syncPosition: function(enableAnimated) {
                var b2body = this._b2Body;
                if (!b2body) {
                    return;
                }
                var pos = this.node.convertToWorldSpaceAR(VEC2_ZERO);
                var temp;
                temp = this.type === BodyType.Animated ? b2body.GetLinearVelocity() : b2body.GetPosition();
                temp.x = pos.x / PTM_RATIO;
                temp.y = pos.y / PTM_RATIO;
                if (this.type === BodyType.Animated && enableAnimated) {
                    var b2Pos = b2body.GetPosition();
                    var timeStep = cc.game.config["frameRate"];
                    temp.x = (temp.x - b2Pos.x) * timeStep;
                    temp.y = (temp.y - b2Pos.y) * timeStep;
                    b2body.SetAwake(true);
                    b2body.SetLinearVelocity(temp);
                } else {
                    b2body.SetTransform(temp, b2body.GetAngle());
                }
            },
            syncRotation: function(enableAnimated) {
                var b2body = this._b2Body;
                if (!b2body) {
                    return;
                }
                var rotation = ANGLE_TO_PHYSICS_ANGLE * getWorldRotation(this.node);
                if (this.type === BodyType.Animated && enableAnimated) {
                    var b2Rotation = b2body.GetAngle();
                    var timeStep = cc.game.config["frameRate"];
                    b2body.SetAwake(true);
                    b2body.SetAngularVelocity((rotation - b2Rotation) * timeStep);
                } else {
                    b2body.SetTransform(b2body.GetPosition(), rotation);
                }
            },
            resetVelocity: function() {
                var b2body = this._b2Body;
                if (!b2body) {
                    return;
                }
                var temp = b2body.m_linearVelocity;
                temp.Set(0, 0);
                b2body.SetLinearVelocity(temp);
                b2body.SetAngularVelocity(0);
            },
            onEnable: function() {
                this._init();
            },
            onDisable: function() {
                this._destroy();
            },
            _registerNodeEvents: function() {
                var node = this.node;
                node.on("position-changed", this._onNodePositionChanged, this);
                node.on("rotation-changed", this._onNodeRotationChanged, this);
                node.on("scale-changed", this._onNodeScaleChanged, this);
            },
            _unregisterNodeEvents: function() {
                var node = this.node;
                node.off("position-changed", this._onNodePositionChanged, this);
                node.off("rotation-changed", this._onNodeRotationChanged, this);
                node.off("scale-changed", this._onNodeScaleChanged, this);
            },
            _onNodePositionChanged: function() {
                this.syncPosition(true);
            },
            _onNodeRotationChanged: function(event) {
                this.syncRotation(true);
            },
            _onNodeScaleChanged: function(event) {
                if (this._b2Body) {
                    var colliders = this.getComponents(cc.PhysicsCollider);
                    for (var i = 0; i < colliders.length; i++) {
                        colliders[i].apply();
                    }
                }
            },
            _init: function() {
                cc.director.getPhysicsManager().pushDelayEvent(this, "__init", []);
            },
            _destroy: function() {
                cc.director.getPhysicsManager().pushDelayEvent(this, "__destroy", []);
            },
            __init: function() {
                if (this._inited) {
                    return;
                }
                this._registerNodeEvents();
                var bodyDef = new b2.BodyDef();
                this.type === BodyType.Animated ? bodyDef.type = BodyType.Kinematic : bodyDef.type = this.type;
                bodyDef.allowSleep = this.allowSleep;
                bodyDef.gravityScale = this.gravityScale;
                bodyDef.linearDamping = this.linearDamping;
                bodyDef.angularDamping = this.angularDamping;
                var linearVelocity = this.linearVelocity;
                bodyDef.linearVelocity = new b2.Vec2(linearVelocity.x / PTM_RATIO, linearVelocity.y / PTM_RATIO);
                bodyDef.angularVelocity = this.angularVelocity * ANGLE_TO_PHYSICS_ANGLE;
                bodyDef.fixedRotation = this.fixedRotation;
                bodyDef.bullet = this.bullet;
                var node = this.node;
                var pos = node.convertToWorldSpaceAR(VEC2_ZERO);
                bodyDef.position = new b2.Vec2(pos.x / PTM_RATIO, pos.y / PTM_RATIO);
                bodyDef.angle = -(Math.PI / 180) * getWorldRotation(node);
                cc.director.getPhysicsManager()._addBody(this, bodyDef);
                this._inited = true;
            },
            __destroy: function() {
                if (!this._inited) {
                    return;
                }
                cc.director.getPhysicsManager()._removeBody(this);
                this._unregisterNodeEvents();
                this._inited = false;
            },
            _getBody: function() {
                return this._b2Body;
            }
        });
        cc.RigidBody = module.exports = RigidBody;
    }), {
        "./CCPhysicsTypes": 148,
        "./utils": 171
    } ],
    151: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var PhysicsBoxCollider = cc.Class({
            name: "cc.PhysicsBoxCollider",
            extends: cc.PhysicsCollider,
            mixins: [ cc.Collider.Box ],
            editor: {
                menu: false,
                requireComponent: cc.RigidBody
            },
            _createShape: function(scale) {
                var scaleX = Math.abs(scale.x);
                var scaleY = Math.abs(scale.y);
                var width = this.size.width / 2 / PTM_RATIO * scaleX;
                var height = this.size.height / 2 / PTM_RATIO * scaleY;
                var offsetX = this.offset.x / PTM_RATIO * scaleX;
                var offsetY = this.offset.y / PTM_RATIO * scaleY;
                var shape = new b2.PolygonShape();
                shape.SetAsBox(width, height, new b2.Vec2(offsetX, offsetY), 0);
                return shape;
            }
        });
        cc.PhysicsBoxCollider = module.exports = PhysicsBoxCollider;
    }), {
        "../CCPhysicsTypes": 148
    } ],
    152: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var PhysicsChainCollider = cc.Class({
            name: "cc.PhysicsChainCollider",
            extends: cc.PhysicsCollider,
            editor: {
                menu: false,
                inspector: false,
                requireComponent: cc.RigidBody
            },
            properties: {
                loop: false,
                points: {
                    default: function() {
                        return [ cc.v2(-50, 0), cc.v2(50, 0) ];
                    },
                    type: [ cc.Vec2 ]
                },
                threshold: {
                    default: 1,
                    serializable: false,
                    visible: false
                }
            },
            _createShape: function(scale) {
                var shape = new b2.ChainShape();
                var points = this.points;
                var vertices = [];
                for (var i = 0; i < points.length; i++) {
                    var p = points[i];
                    vertices.push(new b2.Vec2(p.x / PTM_RATIO * scale.x, p.y / PTM_RATIO * scale.y));
                }
                this.loop ? shape.CreateLoop(vertices, vertices.length) : shape.CreateChain(vertices, vertices.length);
                return shape;
            },
            resetInEditor: false,
            resetPointsByContour: false
        });
        cc.PhysicsChainCollider = module.exports = PhysicsChainCollider;
    }), {
        "../CCPhysicsTypes": 148
    } ],
    153: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var PhysicsCircleCollider = cc.Class({
            name: "cc.PhysicsCircleCollider",
            extends: cc.PhysicsCollider,
            mixins: [ cc.Collider.Circle ],
            editor: {
                menu: false,
                requireComponent: cc.RigidBody
            },
            _createShape: function(scale) {
                var scaleX = Math.abs(scale.x);
                var scaleY = Math.abs(scale.y);
                var offsetX = this.offset.x / PTM_RATIO * scaleX;
                var offsetY = this.offset.y / PTM_RATIO * scaleY;
                var shape = new b2.CircleShape();
                shape.m_radius = this.radius / PTM_RATIO * scaleX;
                shape.m_p = new b2.Vec2(offsetX, offsetY);
                return shape;
            }
        });
        cc.PhysicsCircleCollider = module.exports = PhysicsCircleCollider;
    }), {
        "../CCPhysicsTypes": 148
    } ],
    154: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var getWorldScale = require("../utils").getWorldScale;
        var PhysicsCollider = cc.Class({
            name: "cc.PhysicsCollider",
            extends: cc.Collider,
            ctor: function() {
                this._fixtures = [];
                this._shapes = [];
                this._inited = false;
                this._rect = cc.rect();
            },
            properties: {
                _density: 1,
                _sensor: false,
                _friction: .2,
                _restitution: 0,
                density: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.density",
                    get: function() {
                        return this._density;
                    },
                    set: function(value) {
                        this._density = value;
                    }
                },
                sensor: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.sensor",
                    get: function() {
                        return this._sensor;
                    },
                    set: function(value) {
                        this._sensor = value;
                    }
                },
                friction: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.friction",
                    get: function() {
                        return this._friction;
                    },
                    set: function(value) {
                        this._friction = value;
                    }
                },
                restitution: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.restitution",
                    get: function() {
                        return this._restitution;
                    },
                    set: function(value) {
                        this._restitution = value;
                    }
                },
                body: {
                    default: null,
                    type: cc.RigidBody,
                    visible: false
                }
            },
            onDisable: function() {
                this._destroy();
            },
            onEnable: function() {
                this._init();
            },
            start: function() {
                this._init();
            },
            _getFixtureIndex: function(fixture) {
                return this._fixtures.indexOf(fixture);
            },
            _init: function() {
                cc.director.getPhysicsManager().pushDelayEvent(this, "__init", []);
            },
            _destroy: function() {
                cc.director.getPhysicsManager().pushDelayEvent(this, "__destroy", []);
            },
            __init: function() {
                if (this._inited) {
                    return;
                }
                var body = this.body || this.getComponent(cc.RigidBody);
                if (!body) {
                    return;
                }
                var innerBody = body._getBody();
                if (!innerBody) {
                    return;
                }
                var node = body.node;
                var scale = getWorldScale(node);
                var shapes = 0 === scale.x && 0 === scale.y ? [] : this._createShape(scale);
                shapes instanceof Array || (shapes = [ shapes ]);
                var categoryBits = 1 << node.groupIndex;
                var maskBits = 0;
                var bits = cc.game.collisionMatrix[node.groupIndex];
                for (var i = 0; i < bits.length; i++) {
                    if (!bits[i]) {
                        continue;
                    }
                    maskBits |= 1 << i;
                }
                var filter = {
                    categoryBits: categoryBits,
                    maskBits: maskBits,
                    groupIndex: 0
                };
                var manager = cc.director.getPhysicsManager();
                for (var _i = 0; _i < shapes.length; _i++) {
                    var shape = shapes[_i];
                    var fixDef = new b2.FixtureDef();
                    fixDef.density = this.density;
                    fixDef.isSensor = this.sensor;
                    fixDef.friction = this.friction;
                    fixDef.restitution = this.restitution;
                    fixDef.shape = shape;
                    fixDef.filter = filter;
                    var fixture = innerBody.CreateFixture(fixDef);
                    fixture.collider = this;
                    body.enabledContactListener && manager._registerContactFixture(fixture);
                    this._shapes.push(shape);
                    this._fixtures.push(fixture);
                }
                this.body = body;
                this._inited = true;
            },
            __destroy: function() {
                if (!this._inited) {
                    return;
                }
                var fixtures = this._fixtures;
                var body = this.body._getBody();
                var manager = cc.director.getPhysicsManager();
                for (var i = fixtures.length - 1; i >= 0; i--) {
                    var fixture = fixtures[i];
                    fixture.collider = null;
                    manager._unregisterContactFixture(fixture);
                    body && body.DestroyFixture(fixture);
                }
                this.body = null;
                this._fixtures.length = 0;
                this._shapes.length = 0;
                this._inited = false;
            },
            _createShape: function() {},
            apply: function() {
                this._destroy();
                this._init();
            },
            getAABB: function() {
                var MAX = 1e7;
                var minX = MAX, minY = MAX;
                var maxX = -MAX, maxY = -MAX;
                var fixtures = this._fixtures;
                for (var i = 0; i < fixtures.length; i++) {
                    var fixture = fixtures[i];
                    var count = fixture.GetShape().GetChildCount();
                    for (var j = 0; j < count; j++) {
                        var aabb = fixture.GetAABB(j);
                        aabb.lowerBound.x < minX && (minX = aabb.lowerBound.x);
                        aabb.lowerBound.y < minY && (minY = aabb.lowerBound.y);
                        aabb.upperBound.x > maxX && (maxX = aabb.upperBound.x);
                        aabb.upperBound.y > maxY && (maxY = aabb.upperBound.y);
                    }
                }
                minX *= PTM_RATIO;
                minY *= PTM_RATIO;
                maxX *= PTM_RATIO;
                maxY *= PTM_RATIO;
                var r = this._rect;
                r.x = minX;
                r.y = minY;
                r.width = maxX - minX;
                r.height = maxY - minY;
                return r;
            }
        });
        cc.PhysicsCollider = module.exports = PhysicsCollider;
    }), {
        "../CCPhysicsTypes": 148,
        "../utils": 171
    } ],
    155: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var PolygonSeprator = require("../CCPolygonSeprator");
        var PhysicsPolygonCollider = cc.Class({
            name: "cc.PhysicsPolygonCollider",
            extends: cc.PhysicsCollider,
            mixins: [ cc.Collider.Polygon ],
            editor: {
                menu: false,
                inspector: false,
                requireComponent: cc.RigidBody
            },
            _createShape: function(scale) {
                var shapes = [];
                var points = this.points;
                points.length > 0 && points[0].equals(points[points.length - 1]) && (points.length -= 1);
                var ret = PolygonSeprator.validate(points);
                if (2 === ret) {
                    points = points.reverse();
                    ret = PolygonSeprator.validate(points);
                }
                if (0 === ret) {
                    var polys = PolygonSeprator.calcShapes(points);
                    var offset = this.offset;
                    for (var i = 0; i < polys.length; i++) {
                        var poly = polys[i];
                        var shape = null, vertices = [];
                        var firstVertice;
                        for (var j = 0, l = poly.length; j < l; j++) {
                            shape || (shape = new b2.PolygonShape());
                            var p = poly[j];
                            var x = (p.x + offset.x) / PTM_RATIO * scale.x;
                            var y = (p.y + offset.y) / PTM_RATIO * scale.y;
                            var v = new b2.Vec2(x, y);
                            vertices.push(v);
                            firstVertice || (firstVertice = v);
                            if (vertices.length === b2.maxPolygonVertices) {
                                shape.Set(vertices, vertices.length);
                                shapes.push(shape);
                                shape = null;
                                j < l - 1 && (vertices = [ firstVertice, vertices[vertices.length - 1] ]);
                            }
                        }
                        if (shape) {
                            shape.Set(vertices, vertices.length);
                            shapes.push(shape);
                        }
                    }
                } else {
                    console.log("Failed to create convex polygon : " + ret);
                }
                return shapes;
            }
        });
        cc.PhysicsPolygonCollider = module.exports = PhysicsPolygonCollider;
    }), {
        "../CCPhysicsTypes": 148,
        "../CCPolygonSeprator": 149
    } ],
    156: [ (function(require, module, exports) {
        window.b2 = require("../../../external/box2d/box2d");
        require("./CCPhysicsManager");
        require("./CCRigidBody");
        require("./CCPhysicsContact");
        require("./collider/CCPhysicsCollider");
        require("./collider/CCPhysicsChainCollider");
        require("./collider/CCPhysicsCircleCollider");
        require("./collider/CCPhysicsBoxCollider");
        require("./collider/CCPhysicsPolygonCollider");
        require("./joint/CCJoint");
        require("./joint/CCDistanceJoint");
        require("./joint/CCRevoluteJoint");
        require("./joint/CCMouseJoint");
        require("./joint/CCMotorJoint");
        require("./joint/CCPrismaticJoint");
        require("./joint/CCWeldJoint");
        require("./joint/CCWheelJoint");
        require("./joint/CCRopeJoint");
        require("./platform/CCPhysicsDebugDraw");
        require("./platform/CCPhysicsUtils");
        require("./platform/CCPhysicsContactListner");
        require("./platform/CCPhysicsAABBQueryCallback");
        require("./platform/CCPhysicsRayCastCallback");
    }), {
        "../../../external/box2d/box2d": 310,
        "./CCPhysicsContact": 146,
        "./CCPhysicsManager": 147,
        "./CCRigidBody": 150,
        "./collider/CCPhysicsBoxCollider": 151,
        "./collider/CCPhysicsChainCollider": 152,
        "./collider/CCPhysicsCircleCollider": 153,
        "./collider/CCPhysicsCollider": 154,
        "./collider/CCPhysicsPolygonCollider": 155,
        "./joint/CCDistanceJoint": 157,
        "./joint/CCJoint": 158,
        "./joint/CCMotorJoint": 159,
        "./joint/CCMouseJoint": 160,
        "./joint/CCPrismaticJoint": 161,
        "./joint/CCRevoluteJoint": 162,
        "./joint/CCRopeJoint": 163,
        "./joint/CCWeldJoint": 164,
        "./joint/CCWheelJoint": 165,
        "./platform/CCPhysicsAABBQueryCallback": 166,
        "./platform/CCPhysicsContactListner": 167,
        "./platform/CCPhysicsDebugDraw": 168,
        "./platform/CCPhysicsRayCastCallback": 169,
        "./platform/CCPhysicsUtils": 170
    } ],
    157: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var DistanceJoint = cc.Class({
            name: "cc.DistanceJoint",
            extends: cc.Joint,
            editor: false,
            properties: {
                _distance: 1,
                _frequency: 0,
                _dampingRatio: 0,
                distance: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.distance",
                    get: function() {
                        return this._distance;
                    },
                    set: function(value) {
                        this._distance = value;
                        this._joint && this._joint.SetLength(value);
                    }
                },
                frequency: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.frequency",
                    get: function() {
                        return this._frequency;
                    },
                    set: function(value) {
                        this._frequency = value;
                        this._joint && this._joint.SetFrequency(value);
                    }
                },
                dampingRatio: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.dampingRatio",
                    get: function() {
                        return this._dampingRatio;
                    },
                    set: function(value) {
                        this._dampingRatio = value;
                        this._joint && this._joint.SetDampingRatio(value);
                    }
                }
            },
            _createJointDef: function() {
                var def = new b2.DistanceJointDef();
                def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
                def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
                def.length = this.distance / PTM_RATIO;
                def.dampingRatio = this.dampingRatio;
                def.frequencyHz = this.frequency;
                return def;
            }
        });
        cc.DistanceJoint = module.exports = DistanceJoint;
    }), {
        "../CCPhysicsTypes": 148
    } ],
    158: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var Joint = cc.Class({
            name: "cc.Joint",
            extends: cc.Component,
            editor: {
                requireComponent: cc.RigidBody
            },
            properties: {
                anchor: {
                    default: cc.v2(0, 0),
                    tooltip: "i18n:COMPONENT.physics.physics_collider.anchor"
                },
                connectedAnchor: {
                    default: cc.v2(0, 0),
                    tooltip: "i18n:COMPONENT.physics.physics_collider.connectedAnchor"
                },
                connectedBody: {
                    default: null,
                    type: cc.RigidBody,
                    tooltip: "i18n:COMPONENT.physics.physics_collider.connectedBody"
                },
                collideConnected: {
                    default: false,
                    tooltip: "i18n:COMPONENT.physics.physics_collider.collideConnected"
                }
            },
            onDisable: function() {
                this._destroy();
            },
            onEnable: function() {
                this._init();
            },
            start: function() {
                this._init();
            },
            apply: function() {
                this._destroy();
                this._init();
            },
            getWorldAnchor: function() {
                if (this._joint) {
                    var anchor = this._joint.GetAnchorA();
                    return cc.v2(anchor.x * PTM_RATIO, anchor.y * PTM_RATIO);
                }
                return cc.Vec2.ZERO;
            },
            getWorldConnectedAnchor: function() {
                if (this._joint) {
                    var anchor = this._joint.GetAnchorB();
                    return cc.v2(anchor.x * PTM_RATIO, anchor.y * PTM_RATIO);
                }
                return cc.Vec2.ZERO;
            },
            getReactionForce: function(timeStep) {
                if (this._joint) {
                    return this._joint.GetReactionForce(timeStep);
                }
                return 0;
            },
            getReactionTorque: function(timeStep) {
                if (this._joint) {
                    return this._joint.GetReactionTorque(timeStep);
                }
                return 0;
            },
            _init: function() {
                cc.director.getPhysicsManager().pushDelayEvent(this, "__init", []);
            },
            _destroy: function() {
                cc.director.getPhysicsManager().pushDelayEvent(this, "__destroy", []);
            },
            __init: function() {
                if (this._inited) {
                    return;
                }
                this.body = this.getComponent(cc.RigidBody);
                if (this.body && this.body._getBody() && this.connectedBody && this.connectedBody._getBody()) {
                    var world = cc.director.getPhysicsManager()._getWorld();
                    var def = this._createJointDef();
                    if (!def) {
                        return;
                    }
                    def.bodyA = this.body._getBody();
                    def.bodyB = this.connectedBody._getBody();
                    def.collideConnected = this.collideConnected;
                    this._joint = world.CreateJoint(def);
                    this._joint && (this._joint._joint = this);
                    this._inited = true;
                }
            },
            __destroy: function() {
                if (!this._inited) {
                    return;
                }
                this.body && this.body._getBody() && cc.director.getPhysicsManager()._getWorld().DestroyJoint(this._joint);
                this._joint && (this._joint._joint = null);
                this._joint = null;
                this._inited = false;
            },
            _createJointDef: function() {
                return null;
            }
        });
        cc.Joint = module.exports = Joint;
    }), {
        "../CCPhysicsTypes": 148
    } ],
    159: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
        var MotorJoint = cc.Class({
            name: "cc.MotorJoint",
            extends: cc.Joint,
            editor: false,
            properties: {
                _linearOffset: cc.v2(0, 0),
                _angularOffset: 0,
                _maxForce: 1,
                _maxTorque: 1,
                _correctionFactor: .3,
                anchor: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.anchor",
                    default: cc.v2(0, 0),
                    override: true,
                    visible: false
                },
                connectedAnchor: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.connectedAnchor",
                    default: cc.v2(0, 0),
                    override: true,
                    visible: false
                },
                linearOffset: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.linearOffset",
                    get: function() {
                        return this._linearOffset;
                    },
                    set: function(value) {
                        this._linearOffset = value;
                        this._joint && this._joint.SetLinearOffset(new b2.Vec2(value.x / PTM_RATIO, value.y / PTM_RATIO));
                    }
                },
                angularOffset: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.angularOffset",
                    get: function() {
                        return this._angularOffset;
                    },
                    set: function(value) {
                        this._angularOffset = value;
                        this._joint && this._joint.SetAngularOffset(value);
                    }
                },
                maxForce: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.maxForce",
                    get: function() {
                        return this._maxForce;
                    },
                    set: function(value) {
                        this._maxForce = value;
                        this._joint && this._joint.SetMaxForce(value);
                    }
                },
                maxTorque: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.maxTorque",
                    get: function() {
                        return this._maxTorque;
                    },
                    set: function(value) {
                        this._maxTorque = value;
                        this._joint && this._joint.SetMaxTorque(value);
                    }
                },
                correctionFactor: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.correctionFactor",
                    get: function() {
                        return this._correctionFactor;
                    },
                    set: function(value) {
                        this._correctionFactor = value;
                        this._joint && this._joint.SetCorrectionFactor(value);
                    }
                }
            },
            _createJointDef: function() {
                var def = new b2.MotorJointDef();
                def.linearOffset = new b2.Vec2(this.linearOffset.x / PTM_RATIO, this.linearOffset.y / PTM_RATIO);
                def.angularOffset = this.angularOffset * ANGLE_TO_PHYSICS_ANGLE;
                def.maxForce = this.maxForce;
                def.maxTorque = this.maxTorque;
                def.correctionFactor = this.correctionFactor;
                return def;
            }
        });
        cc.MotorJoint = module.exports = MotorJoint;
    }), {
        "../CCPhysicsTypes": 148
    } ],
    160: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var tempB2Vec2 = new b2.Vec2();
        var MouseJoint = cc.Class({
            name: "cc.MouseJoint",
            extends: cc.Joint,
            editor: false,
            properties: {
                _target: 1,
                _frequency: 5,
                _dampingRatio: .7,
                _maxForce: 0,
                connectedBody: {
                    default: null,
                    type: cc.RigidBody,
                    visible: false,
                    override: true
                },
                collideConnected: {
                    default: true,
                    visible: false,
                    override: true
                },
                anchor: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.anchor",
                    default: cc.v2(0, 0),
                    override: true,
                    visible: false
                },
                connectedAnchor: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.connectedAnchor",
                    default: cc.v2(0, 0),
                    override: true,
                    visible: false
                },
                mouseRegion: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.mouseRegion",
                    default: null,
                    type: cc.Node
                },
                target: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.target",
                    visible: false,
                    get: function() {
                        return this._target;
                    },
                    set: function(value) {
                        this._target = value;
                        if (this._joint) {
                            tempB2Vec2.x = value.x / PTM_RATIO;
                            tempB2Vec2.y = value.y / PTM_RATIO;
                            this._joint.SetTarget(tempB2Vec2);
                        }
                    }
                },
                frequency: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.frequency",
                    get: function() {
                        return this._frequency;
                    },
                    set: function(value) {
                        this._frequency = value;
                        this._joint && this._joint.SetFrequency(value);
                    }
                },
                dampingRatio: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.dampingRatio",
                    get: function() {
                        return this._dampingRatio;
                    },
                    set: function(value) {
                        this._dampingRatio = value;
                        this._joint && this._joint.SetDampingRatio(value);
                    }
                },
                maxForce: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.maxForce",
                    visible: false,
                    get: function() {
                        return this._maxForce;
                    },
                    set: function(value) {
                        this._maxForce = value;
                        this._joint && this._joint.SetMaxForce(value);
                    }
                }
            },
            onLoad: function() {
                var mouseRegion = this.mouseRegion || this.node;
                mouseRegion.on(cc.Node.EventType.TOUCH_START, this.onTouchBegan, this);
                mouseRegion.on(cc.Node.EventType.TOUCH_MOVE, this.onTouchMove, this);
                mouseRegion.on(cc.Node.EventType.TOUCH_END, this.onTouchEnd, this);
            },
            onEnable: function() {},
            start: function() {},
            onTouchBegan: function(event) {
                var manager = cc.director.getPhysicsManager();
                var target = event.touch.getLocation();
                var collider = manager.testPoint(target);
                if (!collider) {
                    return;
                }
                var body = this.connectedBody = collider.body;
                body.awake = true;
                this.maxForce = 1e3 * this.connectedBody.getMass();
                this.target = target;
                this._init();
            },
            onTouchMove: function(event) {
                this.target = event.touch.getLocation();
            },
            onTouchEnd: function(event) {
                this._destroy();
            },
            _createJointDef: function() {
                var def = new b2.MouseJointDef();
                tempB2Vec2.x = this.target.x / PTM_RATIO;
                tempB2Vec2.y = this.target.y / PTM_RATIO;
                def.target = tempB2Vec2;
                def.maxForce = this.maxForce;
                def.dampingRatio = this.dampingRatio;
                def.frequencyHz = this.frequency;
                return def;
            }
        });
        cc.MouseJoint = module.exports = MouseJoint;
    }), {
        "../CCPhysicsTypes": 148
    } ],
    161: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
        var PrismaticJoint = cc.Class({
            name: "cc.PrismaticJoint",
            extends: cc.Joint,
            editor: false,
            properties: {
                localAxisA: {
                    default: cc.v2(1, 0),
                    tooltip: "i18n:COMPONENT.physics.physics_collider.localAxisA"
                },
                referenceAngle: {
                    default: 0,
                    tooltip: "i18n:COMPONENT.physics.physics_collider.referenceAngle"
                },
                enableLimit: {
                    default: false,
                    tooltip: "i18n:COMPONENT.physics.physics_collider.enableLimit"
                },
                enableMotor: {
                    default: false,
                    tooltip: "i18n:COMPONENT.physics.physics_collider.enableMotor"
                },
                lowerLimit: {
                    default: 0,
                    tooltip: "i18n:COMPONENT.physics.physics_collider.lowerLimit"
                },
                upperLimit: {
                    default: 0,
                    tooltip: "i18n:COMPONENT.physics.physics_collider.upperLimit"
                },
                _maxMotorForce: 0,
                _motorSpeed: 0,
                maxMotorForce: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.maxMotorForce",
                    get: function() {
                        return this._maxMotorForce;
                    },
                    set: function(value) {
                        this._maxMotorForce = value;
                        this._joint && this._joint.SetMaxMotorForce(value);
                    }
                },
                motorSpeed: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.motorSpeed",
                    get: function() {
                        return this._motorSpeed;
                    },
                    set: function(value) {
                        this._motorSpeed = value;
                        this._joint && this._joint.SetMotorSpeed(value);
                    }
                }
            },
            _createJointDef: function() {
                var def = new b2.PrismaticJointDef();
                def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
                def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
                def.localAxisA = new b2.Vec2(this.localAxisA.x, this.localAxisA.y);
                def.referenceAngle = this.referenceAngle * ANGLE_TO_PHYSICS_ANGLE;
                def.enableLimit = this.enableLimit;
                def.lowerTranslation = this.lowerLimit / PTM_RATIO;
                def.upperTranslation = this.upperLimit / PTM_RATIO;
                def.enableMotor = this.enableMotor;
                def.maxMotorForce = this.maxMotorForce;
                def.motorSpeed = this.motorSpeed;
                return def;
            }
        });
        cc.PrismaticJoint = module.exports = PrismaticJoint;
    }), {
        "../CCPhysicsTypes": 148
    } ],
    162: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
        var PHYSICS_ANGLE_TO_ANGLE = require("../CCPhysicsTypes").PHYSICS_ANGLE_TO_ANGLE;
        var RevoluteJoint = cc.Class({
            name: "cc.RevoluteJoint",
            extends: cc.Joint,
            editor: false,
            properties: {
                _maxMotorTorque: 0,
                _motorSpeed: 0,
                _enableLimit: false,
                _enableMotor: false,
                referenceAngle: {
                    default: 0,
                    tooltip: "i18n:COMPONENT.physics.physics_collider.referenceAngle"
                },
                lowerAngle: {
                    default: 0,
                    tooltip: "i18n:COMPONENT.physics.physics_collider.lowerAngle"
                },
                upperAngle: {
                    default: 0,
                    tooltip: "i18n:COMPONENT.physics.physics_collider.upperAngle"
                },
                maxMotorTorque: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.maxMotorTorque",
                    get: function() {
                        return this._maxMotorTorque;
                    },
                    set: function(value) {
                        this._maxMotorTorque = value;
                        this._joint && this._joint.SetMaxMotorTorque(value);
                    }
                },
                motorSpeed: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.motorSpeed",
                    get: function() {
                        return this._motorSpeed;
                    },
                    set: function(value) {
                        this._motorSpeed = value;
                        this._joint && this._joint.SetMotorSpeed(value * ANGLE_TO_PHYSICS_ANGLE);
                    }
                },
                enableLimit: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.enableLimit",
                    get: function() {
                        return this._enableLimit;
                    },
                    set: function(value) {
                        this._enableLimit = value;
                        this._joint && this._joint.EnableLimit(value);
                    }
                },
                enableMotor: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.enableMotor",
                    get: function() {
                        return this._enableMotor;
                    },
                    set: function(value) {
                        this._enableMotor = value;
                        this._joint && this._joint.EnableMotor(value);
                    }
                }
            },
            getJointAngle: function() {
                if (this._joint) {
                    return this._joint.GetJointAngle() * PHYSICS_ANGLE_TO_ANGLE;
                }
                return 0;
            },
            _createJointDef: function() {
                var def = new b2.RevoluteJointDef();
                def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
                def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
                def.lowerAngle = (this.upperAngle + 90) * ANGLE_TO_PHYSICS_ANGLE;
                def.upperAngle = (this.lowerAngle + 90) * ANGLE_TO_PHYSICS_ANGLE;
                def.maxMotorTorque = this.maxMotorTorque;
                def.motorSpeed = this.motorSpeed * ANGLE_TO_PHYSICS_ANGLE;
                def.enableLimit = this.enableLimit;
                def.enableMotor = this.enableMotor;
                def.referenceAngle = this.referenceAngle * ANGLE_TO_PHYSICS_ANGLE;
                return def;
            }
        });
        cc.RevoluteJoint = module.exports = RevoluteJoint;
    }), {
        "../CCPhysicsTypes": 148
    } ],
    163: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var RopeJoint = cc.Class({
            name: "cc.RopeJoint",
            extends: cc.Joint,
            editor: false,
            properties: {
                _maxLength: 1,
                maxLength: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.maxLength",
                    get: function() {
                        return this._maxLength;
                    },
                    set: function(value) {
                        this._maxLength = value;
                        this._joint && this._joint.SetMaxLength(value);
                    }
                }
            },
            _createJointDef: function() {
                var def = new b2.RopeJointDef();
                def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
                def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
                def.maxLength = this.maxLength / PTM_RATIO;
                return def;
            }
        });
        cc.RopeJoint = module.exports = RopeJoint;
    }), {
        "../CCPhysicsTypes": 148
    } ],
    164: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
        var WeldJoint = cc.Class({
            name: "cc.WeldJoint",
            extends: cc.Joint,
            editor: false,
            properties: {
                referenceAngle: {
                    default: 0,
                    tooltip: "i18n:COMPONENT.physics.physics_collider.referenceAngle"
                },
                _frequency: 0,
                _dampingRatio: 0,
                frequency: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.frequency",
                    get: function() {
                        return this._frequency;
                    },
                    set: function(value) {
                        this._frequency = value;
                        this._joint && this._joint.SetFrequency(value);
                    }
                },
                dampingRatio: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.dampingRatio",
                    get: function() {
                        return this._dampingRatio;
                    },
                    set: function(value) {
                        this._dampingRatio = value;
                        this._joint && this._joint.SetDampingRatio(value);
                    }
                }
            },
            _createJointDef: function() {
                var def = new b2.WeldJointDef();
                def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
                def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
                def.referenceAngle = this.referenceAngle * ANGLE_TO_PHYSICS_ANGLE;
                def.frequencyHz = this.frequency;
                def.dampingRatio = this.dampingRatio;
                return def;
            }
        });
        cc.WeldJoint = module.exports = WeldJoint;
    }), {
        "../CCPhysicsTypes": 148
    } ],
    165: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
        var WheelJoint = cc.Class({
            name: "cc.WheelJoint",
            extends: cc.Joint,
            editor: false,
            properties: {
                _maxMotorTorque: 0,
                _motorSpeed: 0,
                _enableMotor: false,
                _frequency: 2,
                _dampingRatio: .7,
                localAxisA: {
                    default: cc.v2(1, 0),
                    tooltip: "i18n:COMPONENT.physics.physics_collider.localAxisA"
                },
                maxMotorTorque: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.maxMotorTorque",
                    get: function() {
                        return this._maxMotorTorque;
                    },
                    set: function(value) {
                        this._maxMotorTorque = value;
                        this._joint && this._joint.SetMaxMotorTorque(value);
                    }
                },
                motorSpeed: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.motorSpeed",
                    get: function() {
                        return this._motorSpeed;
                    },
                    set: function(value) {
                        this._motorSpeed = value;
                        this._joint && this._joint.SetMotorSpeed(value * ANGLE_TO_PHYSICS_ANGLE);
                    }
                },
                enableMotor: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.enableMotor",
                    get: function() {
                        return this._enableMotor;
                    },
                    set: function(value) {
                        this._enableMotor = value;
                        this._joint && this._joint.EnableMotor(value);
                    }
                },
                frequency: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.frequency",
                    get: function() {
                        return this._frequency;
                    },
                    set: function(value) {
                        this._frequency = value;
                        this._joint && this._joint.SetFrequency(value);
                    }
                },
                dampingRatio: {
                    tooltip: "i18n:COMPONENT.physics.physics_collider.dampingRatio",
                    get: function() {
                        return this._dampingRatio;
                    },
                    set: function(value) {
                        this._dampingRatio = value;
                        this._joint && this._joint.SetDampingRatio(value);
                    }
                }
            },
            _createJointDef: function() {
                var def = new b2.WheelJointDef();
                def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
                def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
                def.localAxisA = new b2.Vec2(this.localAxisA.x, this.localAxisA.y);
                def.maxMotorTorque = this.maxMotorTorque;
                def.motorSpeed = this.motorSpeed * ANGLE_TO_PHYSICS_ANGLE;
                def.enableMotor = this.enableMotor;
                def.dampingRatio = this.dampingRatio;
                def.frequencyHz = this.frequency;
                return def;
            }
        });
        cc.WheelJoint = module.exports = WheelJoint;
    }), {
        "../CCPhysicsTypes": 148
    } ],
    166: [ (function(require, module, exports) {
        function PhysicsAABBQueryCallback() {
            this._point = new b2.Vec2();
            this._fixtures = [];
        }
        PhysicsAABBQueryCallback.prototype.init = function(point) {
            this._point.x = point.x;
            this._point.y = point.y;
            this._fixtures.length = 0;
        };
        PhysicsAABBQueryCallback.prototype.ReportFixture = function(fixture) {
            var body = fixture.GetBody();
            if (body.GetType() === b2.Body.b2_dynamicBody) {
                if (this._point) {
                    if (fixture.TestPoint(this._point)) {
                        this._fixtures.push(fixture);
                        return false;
                    }
                } else {
                    this._fixtures.push(fixture);
                }
            }
            return true;
        };
        PhysicsAABBQueryCallback.prototype.getFixture = function() {
            return this._fixtures[0];
        };
        PhysicsAABBQueryCallback.prototype.getFixtures = function() {
            return this._fixtures;
        };
        cc.PhysicsAABBQueryCallback = module.exports = PhysicsAABBQueryCallback;
    }), {} ],
    167: [ (function(require, module, exports) {
        function PhysicsContactListener() {
            this._contactFixtures = [];
        }
        PhysicsContactListener.prototype.setBeginContact = function(cb) {
            this._BeginContact = cb;
        };
        PhysicsContactListener.prototype.setEndContact = function(cb) {
            this._EndContact = cb;
        };
        PhysicsContactListener.prototype.setPreSolve = function(cb) {
            this._PreSolve = cb;
        };
        PhysicsContactListener.prototype.setPostSolve = function(cb) {
            this._PostSolve = cb;
        };
        PhysicsContactListener.prototype.BeginContact = function(contact) {
            if (!this._BeginContact) {
                return;
            }
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            var fixtures = this._contactFixtures;
            contact._shouldReport = false;
            if (fixtures.indexOf(fixtureA) !== -1 || fixtures.indexOf(fixtureB) !== -1) {
                contact._shouldReport = true;
                this._BeginContact(contact);
            }
        };
        PhysicsContactListener.prototype.EndContact = function(contact) {
            if (this._EndContact && contact._shouldReport) {
                contact._shouldReport = false;
                this._EndContact(contact);
            }
        };
        PhysicsContactListener.prototype.PreSolve = function(contact, oldManifold) {
            this._PreSolve && contact._shouldReport && this._PreSolve(contact, oldManifold);
        };
        PhysicsContactListener.prototype.PostSolve = function(contact, impulse) {
            this._PostSolve && contact._shouldReport && this._PostSolve(contact, impulse);
        };
        PhysicsContactListener.prototype.registerContactFixture = function(fixture) {
            this._contactFixtures.push(fixture);
        };
        PhysicsContactListener.prototype.unregisterContactFixture = function(fixture) {
            cc.js.array.remove(this._contactFixtures, fixture);
        };
        cc.PhysicsContactListener = module.exports = PhysicsContactListener;
    }), {} ],
    168: [ (function(require, module, exports) {
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var PhysicsDebugDraw = cc.Class({
            name: "cc.PhysicsDebugDraw",
            mixins: [ b2.Draw ],
            ctor: function() {
                this._drawer = new _ccsg.GraphicsNode();
                this._drawer.retain();
            },
            getDrawer: function() {
                return this._drawer;
            },
            AddDrawerToNode: function(node) {
                this._drawer.removeFromParent();
                node.addChild(this._drawer);
            },
            ClearDraw: function() {
                this._drawer.clear();
            },
            _DrawPolygon: function(vertices, vertexCount) {
                var drawer = this._drawer;
                for (var i = 0; i < vertexCount; i++) {
                    0 === i ? drawer.moveTo(vertices[i].x * PTM_RATIO, vertices[i].y * PTM_RATIO) : drawer.lineTo(vertices[i].x * PTM_RATIO, vertices[i].y * PTM_RATIO);
                }
                drawer.close();
            },
            DrawPolygon: function(vertices, vertexCount, color) {
                this._applyStrokeColor(color);
                this._DrawPolygon(vertices, vertexCount);
                this._drawer.stroke();
            },
            DrawSolidPolygon: function(vertices, vertexCount, color) {
                this._applyFillColor(color);
                this._DrawPolygon(vertices, vertexCount);
                this._drawer.fill();
            },
            _DrawCircle: function(center, radius) {
                this._drawer.circle(center.x * PTM_RATIO, center.y * PTM_RATIO, radius * PTM_RATIO);
            },
            DrawCircle: function(center, radius, color) {
                this._applyStrokeColor(color);
                this._DrawCircle(center, radius);
                this._drawer.stroke();
            },
            DrawSolidCircle: function(center, radius, axis, color) {
                this._applyFillColor(color);
                this._DrawCircle(center, radius);
                this._drawer.fill();
            },
            DrawSegment: function(p1, p2, color) {
                var drawer = this._drawer;
                if (p1.x === p2.x && p1.y === p2.y) {
                    this._applyFillColor(color);
                    this._DrawCircle(p1, 2 / PTM_RATIO);
                    drawer.fill();
                    return;
                }
                this._applyStrokeColor(color);
                drawer.moveTo(p1.x * PTM_RATIO, p1.y * PTM_RATIO);
                drawer.lineTo(p2.x * PTM_RATIO, p2.y * PTM_RATIO);
                drawer.stroke();
            },
            DrawPoint: function(center, radius, color) {},
            _applyStrokeColor: function(color) {
                this._drawer.setStrokeColor(cc.color(255 * color.r, 255 * color.g, 255 * color.b, 150));
            },
            _applyFillColor: function(color) {
                this._drawer.setFillColor(cc.color(255 * color.r, 255 * color.g, 255 * color.b, 150));
            }
        });
        cc.PhysicsDebugDraw = module.exports = PhysicsDebugDraw;
    }), {
        "../CCPhysicsTypes": 148
    } ],
    169: [ (function(require, module, exports) {
        function PhysicsRayCastCallback() {
            this._type = 0;
            this._fixtures = [];
            this._points = [];
            this._normals = [];
            this._fractions = [];
        }
        PhysicsRayCastCallback.prototype.init = function(type) {
            this._type = type;
            this._fixtures.length = 0;
            this._points.length = 0;
            this._normals.length = 0;
            this._fractions.length = 0;
        };
        PhysicsRayCastCallback.prototype.ReportFixture = function(fixture, point, normal, fraction) {
            if (0 === this._type) {
                this._fixtures[0] = fixture;
                this._points[0] = point;
                this._normals[0] = normal;
                this._fractions[0] = fraction;
                return fraction;
            }
            this._fixtures.push(fixture);
            this._points.push(point);
            this._normals.push(normal);
            this._fractions.push(fraction);
            if (1 === this._type) {
                return 0;
            }
            if (this._type >= 2) {
                return 1;
            }
            return fraction;
        };
        PhysicsRayCastCallback.prototype.getFixtures = function() {
            return this._fixtures;
        };
        PhysicsRayCastCallback.prototype.getPoints = function() {
            return this._points;
        };
        PhysicsRayCastCallback.prototype.getNormals = function() {
            return this._normals;
        };
        PhysicsRayCastCallback.prototype.getFractions = function() {
            return this._fractions;
        };
        cc.PhysicsRayCastCallback = module.exports = PhysicsRayCastCallback;
    }), {} ],
    170: [ (function(require, module, exports) {
        var PHYSICS_ANGLE_TO_ANGLE = require("../CCPhysicsTypes").PHYSICS_ANGLE_TO_ANGLE;
        var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
        var convertToNodeRotation = require("../utils").convertToNodeRotation;
        var tempPosition = cc.v2();
        function PhysicsUtils() {}
        PhysicsUtils.prototype.addB2Body = function(body) {};
        PhysicsUtils.prototype.removeB2Body = function(body) {};
        PhysicsUtils.prototype.syncNode = function() {
            var bodies = cc.director.getPhysicsManager()._bodies;
            for (var i = 0, l = bodies.length; i < l; i++) {
                var body = bodies[i];
                var node = body.node;
                var b2body = body._b2Body;
                var pos = b2body.GetPosition();
                tempPosition.x = pos.x * PTM_RATIO;
                tempPosition.y = pos.y * PTM_RATIO;
                var angle = b2body.GetAngle() * PHYSICS_ANGLE_TO_ANGLE;
                if (null !== node.parent.parent) {
                    tempPosition = node.parent.convertToNodeSpaceAR(tempPosition);
                    angle = convertToNodeRotation(node.parent, angle);
                }
                var sgNode = node._sgNode;
                var position = node._position;
                position.x = tempPosition.x;
                position.y = tempPosition.y;
                sgNode.setPosition(position);
                node._rotationX = node._rotationY = angle;
                sgNode.rotation = angle;
            }
        };
        cc.PhysicsUtils = module.exports = PhysicsUtils;
    }), {
        "../CCPhysicsTypes": 148,
        "../utils": 171
    } ],
    171: [ (function(require, module, exports) {
        function getWorldRotation(node) {
            var rot = node.rotationX;
            var parent = node.parent;
            while (parent.parent) {
                rot += parent.rotationX;
                parent = parent.parent;
            }
            return rot;
        }
        function getWorldScale(node) {
            var scaleX = node.scaleX;
            var scaleY = node.scaleY;
            var parent = node.parent;
            while (parent.parent) {
                scaleX *= parent.scaleX;
                scaleY *= parent.scaleY;
                parent = parent.parent;
            }
            return cc.v2(scaleX, scaleY);
        }
        function convertToNodeRotation(node, rotation) {
            rotation -= node.rotationX;
            var parent = node.parent;
            while (parent.parent) {
                rotation -= parent.rotationX;
                parent = parent.parent;
            }
            return rotation;
        }
        module.exports = {
            getWorldRotation: getWorldRotation,
            getWorldScale: getWorldScale,
            convertToNodeRotation: convertToNodeRotation
        };
    }), {} ],
    172: [ (function(require, module, exports) {
        var Asset = require("../assets/CCAsset");
        var callInNextTick = require("./utils").callInNextTick;
        var Loader = require("../load-pipeline/CCLoader");
        var PackDownloader = require("../load-pipeline/pack-downloader");
        var AutoReleaseUtils = require("../load-pipeline/auto-release-utils");
        var _libraryBase = "";
        var _rawAssetsBase = "";
        var _uuidToRawAsset = {};
        function isScene(asset) {
            return asset && (asset.constructor === cc.SceneAsset || asset instanceof cc.Scene);
        }
        var AssetLibrary = {
            loadAsset: function(uuid, callback, options) {
                if ("string" !== typeof uuid) {
                    return callInNextTick(callback, new Error("[AssetLibrary] uuid must be string"), null);
                }
                var item = {
                    uuid: uuid,
                    type: "uuid"
                };
                options && options.existingAsset && (item.existingAsset = options.existingAsset);
                Loader.load(item, (function(error, asset) {
                    if (error || !asset) {
                        error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + (error ? error.message : "Unknown error"));
                    } else {
                        if (asset.constructor === cc.SceneAsset) {
                            var key = cc.loader._getReferenceKey(uuid);
                            asset.scene.dependAssets = AutoReleaseUtils.getDependsRecursively(key);
                        }
                        if (isScene(asset)) {
                            var id = cc.loader._getReferenceKey(uuid);
                            Loader.removeItem(id);
                        }
                    }
                    callback && callback(error, asset);
                }));
            },
            getImportedDir: function(uuid) {
                return _libraryBase + uuid.slice(0, 2);
            },
            _queryAssetInfoInEditor: function(uuid, callback) {},
            _getAssetInfoInRuntime: function(uuid, result) {
                result || (result = {
                    url: null,
                    raw: false
                });
                var info = _uuidToRawAsset[uuid];
                if (info && !cc.isChildClassOf(info.type, cc.Asset)) {
                    result.url = _rawAssetsBase + info.url;
                    result.raw = true;
                } else {
                    result.url = this.getImportedDir(uuid) + "/" + uuid + ".json";
                }
                return result;
            },
            _getAssetUrl: function(uuid) {
                var info = _uuidToRawAsset[uuid];
                if (info) {
                    return _rawAssetsBase + info.url;
                }
                return null;
            },
            queryAssetInfo: function(uuid, callback) {
                var info = this._getAssetInfoInRuntime(uuid);
                callback(null, info.url, info.raw);
            },
            parseUuidInEditor: function(url) {
                var uuid;
                var isImported;
                var dir;
                var dirBasename;
                var isAssetUrl;
                var index;
            },
            loadJson: function(json, callback) {
                var randomUuid = "" + (new Date().getTime() + Math.random());
                var item = {
                    uuid: randomUuid,
                    type: "uuid",
                    content: json,
                    skips: [ Loader.assetLoader.id, Loader.downloader.id ]
                };
                Loader.load(item, (function(error, asset) {
                    if (error) {
                        error = new Error("[AssetLibrary] loading JSON or dependencies failed: " + error.message);
                    } else {
                        if (asset.constructor === cc.SceneAsset) {
                            var key = cc.loader._getReferenceKey(randomUuid);
                            asset.scene.dependAssets = AutoReleaseUtils.getDependsRecursively(key);
                        }
                        if (isScene(asset)) {
                            var id = cc.loader._getReferenceKey(randomUuid);
                            Loader.removeItem(id);
                        }
                    }
                    asset._uuid = "";
                    callback && callback(error, asset);
                }));
            },
            getAssetByUuid: function(uuid) {
                return AssetLibrary._uuidToAsset[uuid] || null;
            },
            init: function(options) {
                var libraryPath = options.libraryPath;
                libraryPath = libraryPath.replace(/\\/g, "/");
                _libraryBase = cc.path._setEndWithSep(libraryPath, "/");
                _rawAssetsBase = options.rawAssetsBase;
                var resources = Loader._resources;
                resources.reset();
                var rawAssets = options.rawAssets;
                if (rawAssets) {
                    var RES_DIR = "resources/";
                    for (var mountPoint in rawAssets) {
                        var assets = rawAssets[mountPoint];
                        for (var uuid in assets) {
                            var info = assets[uuid];
                            var url = info[0];
                            var typeId = info[1];
                            var type = cc.js._getClassById(typeId);
                            if (!type) {
                                cc.error("Cannot get", typeId);
                                continue;
                            }
                            _uuidToRawAsset[uuid] = {
                                url: mountPoint + "/" + url,
                                type: type
                            };
                            if ("assets" === mountPoint && url.startsWith(RES_DIR)) {
                                if (cc.isChildClassOf(type, Asset)) {
                                    var ext = cc.path.extname(url);
                                    url = ext ? url.slice(RES_DIR.length, -ext.length) : url.slice(RES_DIR.length);
                                } else {
                                    url = url.slice(RES_DIR.length);
                                }
                                var isSubAsset = 1 === info[2];
                                resources.add(url, uuid, type, !isSubAsset);
                            }
                        }
                    }
                }
                options.packedAssets && PackDownloader.initPacks(options.packedAssets);
                var mountPaths = options.mountPaths;
                mountPaths || (mountPaths = {
                    assets: _rawAssetsBase + "assets",
                    internal: _rawAssetsBase + "internal"
                });
                cc.url._init(mountPaths);
            }
        };
        AssetLibrary._uuidToAsset = {};
        module.exports = cc.AssetLibrary = AssetLibrary;
    }), {
        "../assets/CCAsset": 44,
        "../load-pipeline/CCLoader": 130,
        "../load-pipeline/auto-release-utils": 134,
        "../load-pipeline/pack-downloader": 140,
        "./utils": 198
    } ],
    173: [ (function(require, module, exports) {
        var JS = require("./js");
        var Enum = require("./CCEnum");
        var Utils = require("./utils");
        var _isPlainEmptyObj_DEV = Utils.isPlainEmptyObj_DEV;
        var _cloneable_DEV = Utils.cloneable_DEV;
        var Attr = require("./attribute");
        var DELIMETER = Attr.DELIMETER;
        var getTypeChecker = Attr.getTypeChecker;
        var preprocess = require("./preprocess-class");
        require("./requiring-frame");
        var BUILTIN_ENTRIES = [ "name", "extends", "mixins", "ctor", "__ctor__", "properties", "statics", "editor", "__ES6__" ];
        var INVALID_STATICS_DEV = [ "name", "__ctors__", "__props__", "arguments", "call", "apply", "caller", "length", "prototype" ];
        function pushUnique(array, item) {
            array.indexOf(item) < 0 && array.push(item);
        }
        var deferredInitializer = {
            datas: null,
            push: function(data) {
                if (this.datas) {
                    this.datas.push(data);
                } else {
                    this.datas = [ data ];
                    var self = this;
                    setTimeout((function() {
                        self.init();
                    }), 0);
                }
            },
            init: function() {
                var datas = this.datas;
                if (datas) {
                    for (var i = 0; i < datas.length; ++i) {
                        var data = datas[i];
                        var cls = data.cls;
                        var properties = data.props;
                        "function" === typeof properties && (properties = properties());
                        var name = JS.getClassName(cls);
                        properties ? declareProperties(cls, name, properties, cls.$super, data.mixins) : cc.errorID(3633, name);
                    }
                    this.datas = null;
                }
            }
        };
        function appendProp(cls, name) {
            if (name.indexOf(".") !== -1) {
                cc.errorID(3634);
                return;
            }
            pushUnique(cls.__props__, name);
        }
        var tmpArray = [];
        function defineProp(cls, className, propName, val, es6) {
            var defaultValue = val.default;
            if (!es6 && "object" === typeof defaultValue && defaultValue) {
                if (Array.isArray(defaultValue)) {
                    if (defaultValue.length > 0) {
                        cc.errorID(3635, className, propName, propName);
                        return;
                    }
                } else {
                    if (!_isPlainEmptyObj_DEV(defaultValue) && !_cloneable_DEV(defaultValue)) {
                        cc.errorID(3636, className, propName, propName);
                        return;
                    }
                }
            }
            if (CCClass.getInheritanceChain(cls).some((function(x) {
                return x.prototype.hasOwnProperty(propName);
            }))) {
                cc.errorID(3637, className, propName, className);
                return;
            }
            Attr.setClassAttr(cls, propName, "default", defaultValue);
            appendProp(cls, propName);
            var attrs = parseAttributes(cls, val, className, propName, false);
            if (attrs) {
                var onAfterProp = tmpArray;
                for (var i = 0; i < attrs.length; i++) {
                    var attr = attrs[i];
                    Attr.attr(cls, propName, attr);
                    attr._onAfterProp && onAfterProp.push(attr._onAfterProp);
                }
                for (var c = 0; c < onAfterProp.length; c++) {
                    onAfterProp[c](cls, propName);
                }
                tmpArray.length = 0;
                attrs.length = 0;
            }
        }
        function defineGetSet(cls, name, propName, val, es6) {
            var getter = val.get;
            var setter = val.set;
            var proto = cls.prototype;
            var d = Object.getOwnPropertyDescriptor(proto, propName);
            if (getter) {
                if (!es6 && d && d.get) {
                    cc.errorID(3638, name, propName);
                    return;
                }
                var attrs = parseAttributes(cls, val, name, propName, true);
                for (var i = 0; i < attrs.length; i++) {
                    Attr.attr(cls, propName, attrs[i]);
                }
                attrs.length = 0;
                var ForceSerializable = false;
                ForceSerializable || Attr.setClassAttr(cls, propName, "serializable", false);
                (ForceSerializable || true) && appendProp(cls, propName);
                if (!es6) {
                    var setterUndefined = !d;
                    JS.get(proto, propName, getter, setterUndefined, setterUndefined);
                }
                Attr.setClassAttr(cls, propName, "hasGetter", true);
            }
            if (setter) {
                if (!es6) {
                    if (d && d.set) {
                        return cc.errorID(3640, name, propName);
                    }
                    JS.set(proto, propName, setter, true, true);
                }
                Attr.setClassAttr(cls, propName, "hasSetter", true);
            }
        }
        function getDefault(defaultVal) {
            if ("function" === typeof defaultVal) {
                return defaultVal();
            }
            return defaultVal;
        }
        function mixinWithInherited(dest, src, filter) {
            for (var prop in src) {
                dest.hasOwnProperty(prop) || filter && !filter(prop) || Object.defineProperty(dest, prop, JS.getPropertyDescriptor(src, prop));
            }
        }
        function doDefine(className, baseClass, mixins, options) {
            var shouldAddProtoCtor;
            var __ctor__ = options.__ctor__;
            var ctor = options.ctor;
            var __es6__ = options.__ES6__;
            var ctorToUse = __ctor__ || ctor;
            if (ctorToUse) {
                if (CCClass._isCCClass(ctorToUse)) {
                    cc.errorID(3618, className);
                } else {
                    if ("function" !== typeof ctorToUse) {
                        cc.errorID(3619, className);
                    } else {
                        if (baseClass && /\bprototype.ctor\b/.test(ctorToUse)) {
                            if (__es6__) {
                                cc.errorID(3651, className || "");
                            } else {
                                cc.warnID(3600, className || "");
                                shouldAddProtoCtor = true;
                            }
                        }
                    }
                }
                ctor && (__ctor__ ? cc.errorID(3649, className) : ctor = options.ctor = _validateCtor_DEV(ctor, baseClass, className, options));
            }
            var ctors;
            var fireClass;
            if (__es6__) {
                ctors = [ ctor ];
                fireClass = ctor;
            } else {
                ctors = __ctor__ ? [ __ctor__ ] : _getAllCtors(baseClass, mixins, options);
                fireClass = _createCtor(ctors, baseClass, className, options);
                JS.value(fireClass, "extend", (function(options) {
                    options.extends = this;
                    return CCClass(options);
                }), true);
            }
            JS.value(fireClass, "__ctors__", ctors.length > 0 ? ctors : null, true);
            var prototype = fireClass.prototype;
            if (baseClass) {
                if (!__es6__) {
                    JS.extend(fireClass, baseClass);
                    prototype = fireClass.prototype;
                }
                JS.value(fireClass, "$super", baseClass);
                shouldAddProtoCtor && (prototype.ctor = function() {});
            }
            if (mixins) {
                for (var m = mixins.length - 1; m >= 0; m--) {
                    var mixin = mixins[m];
                    mixinWithInherited(prototype, mixin.prototype);
                    mixinWithInherited(fireClass, mixin, (function(prop) {
                        return mixin.hasOwnProperty(prop) && INVALID_STATICS_DEV.indexOf(prop) < 0;
                    }));
                    CCClass._isCCClass(mixin) && mixinWithInherited(Attr.getClassAttrs(fireClass).constructor.prototype, Attr.getClassAttrs(mixin).constructor.prototype);
                }
                prototype.constructor = fireClass;
            }
            __es6__ || (prototype.__initProps__ = compileProps);
            JS.setClassName(className, fireClass);
            return fireClass;
        }
        function define(className, baseClass, mixins, options) {
            var Component = cc.Component;
            var frame = cc._RF.peek();
            if (frame && cc.isChildClassOf(baseClass, Component)) {
                if (cc.isChildClassOf(frame.cls, Component)) {
                    cc.errorID(3615);
                    return null;
                }
                frame.uuid && className && cc.warnID(3616, className);
                className = className || frame.script;
            }
            var cls = doDefine(className, baseClass, mixins, options);
            if (frame) {
                if (cc.isChildClassOf(baseClass, Component)) {
                    var uuid = frame.uuid;
                    uuid && JS._setClassId(uuid, cls);
                    frame.cls = cls;
                } else {
                    cc.isChildClassOf(frame.cls, Component) || (frame.cls = cls);
                }
            }
            return cls;
        }
        function normalizeClassName_DEV(className) {
            var DefaultName = "CCClass";
            if (className) {
                className = Array.prototype.map.call(className, (function(x) {
                    return /^[a-zA-Z0-9_$]/.test(x) ? x : "_";
                })).join("");
                try {
                    Function("function " + className + "(){}")();
                    return className;
                } catch (e) {
                    className = DefaultName + "_" + className;
                }
                try {
                    Function("function " + className + "(){}")();
                    return className;
                } catch (e) {}
            }
            return DefaultName;
        }
        function getNewValueTypeCode(value) {
            var clsName = JS.getClassName(value);
            var type = value.constructor;
            var res = "new " + clsName + "(";
            var i;
            if (type === cc.Mat3 || type === cc.Mat4) {
                var data = value.data;
                for (i = 0; i < data.length; i++) {
                    res += data[i];
                    i < data.length - 1 && (res += ",");
                }
            } else {
                for (i = 0; i < type.__props__.length; i++) {
                    var prop = type.__props__[i];
                    var propVal = value[prop];
                    if ("object" === typeof propVal) {
                        cc.errorID(3641, clsName);
                        return "new " + clsName + "()";
                    }
                    res += propVal;
                    i < type.__props__.length - 1 && (res += ",");
                }
            }
            return res + ")";
        }
        function escapeForJS(s) {
            return JSON.stringify(s).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
        }
        var IDENTIFIER_RE = /^[$A-Za-z_][0-9A-Za-z_$]*$/;
        function compileProps(actualClass) {
            var attrs = Attr.getClassAttrs(actualClass);
            var propList = actualClass.__props__;
            if (null === propList) {
                deferredInitializer.init();
                propList = actualClass.__props__;
            }
            var F = [];
            var func = "";
            for (var i = 0; i < propList.length; i++) {
                var prop = propList[i];
                var attrKey = prop + DELIMETER + "default";
                if (attrKey in attrs) {
                    var statement;
                    statement = IDENTIFIER_RE.test(prop) ? "this." + prop + "=" : "this[" + escapeForJS(prop) + "]=";
                    var expression;
                    var def = attrs[attrKey];
                    if ("object" === typeof def && def) {
                        expression = def instanceof cc.ValueType ? getNewValueTypeCode(def) : Array.isArray(def) ? "[]" : "{}";
                    } else {
                        if ("function" === typeof def) {
                            var index = F.length;
                            F.push(def);
                            expression = "F[" + index + "]()";
                        } else {
                            expression = "string" === typeof def ? escapeForJS(def) : def;
                        }
                    }
                    statement = statement + expression + ";\n";
                    func += statement;
                }
            }
            var initProps;
            initProps = 0 === F.length ? Function(func) : Function("F", "return (function(){\n" + func + "})")(F);
            actualClass.prototype.__initProps__ = initProps;
            initProps.call(this);
        }
        function _createCtor(ctors, baseClass, className, options) {
            var superCallBounded = baseClass && boundSuperCalls(baseClass, options, className);
            var args = "";
            var ctorName = normalizeClassName_DEV(className);
            var body = "return function " + ctorName + "(" + args + "){\n";
            superCallBounded && (body += "this._super=null;\n");
            body += "this.__initProps__(" + ctorName + ");\n";
            var ctorLen = ctors.length;
            if (ctorLen > 0) {
                var useTryCatch = !(className && className.startsWith("cc."));
                useTryCatch && (body += "try{\n");
                var SNIPPET = "].apply(this,arguments);\n";
                if (1 === ctorLen) {
                    body += ctorName + ".__ctors__[0" + SNIPPET;
                } else {
                    body += "var cs=" + ctorName + ".__ctors__;\n";
                    for (var i = 0; i < ctorLen; i++) {
                        body += "cs[" + i + SNIPPET;
                    }
                }
                useTryCatch && (body += "}catch(e){\ncc._throw(e);\n}\n");
            }
            body += "}";
            return Function(body)();
        }
        function _validateCtor_DEV(ctor, baseClass, className, options) {
            var originCtor;
            !(ctor.length > 0) || className && className.startsWith("cc.") || cc.warnID(3617, className);
            return ctor;
        }
        function _getAllCtors(baseClass, mixins, options) {
            function getCtors(cls) {
                return CCClass._isCCClass(cls) ? cls.__ctors__ || [] : [ cls ];
            }
            var ctors = [];
            var baseOrMixins = [ baseClass ].concat(mixins);
            for (var b = 0; b < baseOrMixins.length; b++) {
                var baseOrMixin = baseOrMixins[b];
                if (baseOrMixin) {
                    var baseCtors = getCtors(baseOrMixin);
                    for (var c = 0; c < baseCtors.length; c++) {
                        pushUnique(ctors, baseCtors[c]);
                    }
                }
            }
            var ctor = options.ctor;
            ctor && ctors.push(ctor);
            return ctors;
        }
        var SuperCallReg = /xyz/.test((function() {
            xyz;
        })) ? /\b\._super\b/ : /.*/;
        var SuperCallRegStrict = /xyz/.test((function() {
            xyz;
        })) ? /this\._super\s*\(/ : /(NONE){99}/;
        function boundSuperCalls(baseClass, options, className) {
            var hasSuperCall = false;
            for (var funcName in options) {
                if (BUILTIN_ENTRIES.indexOf(funcName) >= 0) {
                    continue;
                }
                var func = options[funcName];
                if ("function" !== typeof func) {
                    continue;
                }
                var pd = JS.getPropertyDescriptor(baseClass.prototype, funcName);
                if (pd) {
                    var superFunc = pd.value;
                    if ("function" === typeof superFunc) {
                        if (SuperCallReg.test(func)) {
                            hasSuperCall = true;
                            options[funcName] = (function(superFunc, func) {
                                return function() {
                                    var tmp = this._super;
                                    this._super = superFunc;
                                    var ret = func.apply(this, arguments);
                                    this._super = tmp;
                                    return ret;
                                };
                            })(superFunc, func);
                        }
                        continue;
                    }
                }
                SuperCallRegStrict.test(func) && cc.warnID(3620, className, funcName);
            }
            return hasSuperCall;
        }
        function declareProperties(cls, className, properties, baseClass, mixins, es6) {
            cls.__props__ = [];
            baseClass && baseClass.__props__ && (cls.__props__ = baseClass.__props__.slice());
            if (mixins) {
                for (var m = 0; m < mixins.length; ++m) {
                    var mixin = mixins[m];
                    mixin.__props__ && (cls.__props__ = cls.__props__.concat(mixin.__props__.filter((function(x) {
                        return cls.__props__.indexOf(x) < 0;
                    }))));
                }
            }
            if (properties) {
                preprocess.preprocessAttrs(properties, className, cls, es6);
                for (var propName in properties) {
                    var val = properties[propName];
                    "default" in val ? defineProp(cls, className, propName, val, es6) : defineGetSet(cls, className, propName, val, es6);
                }
            }
        }
        function CCClass(options) {
            options = options || {};
            var name = options.name;
            var base = options.extends;
            var mixins = options.mixins;
            var cls = define(name, base, mixins, options);
            name || (name = cc.js.getClassName(cls));
            var properties = options.properties;
            if ("function" === typeof properties || base && null === base.__props__ || mixins && mixins.some((function(x) {
                return null === x.__props__;
            }))) {
                if (options.__ES6__) {
                    cc.error("not yet implement deferred properties for ES6 Classes");
                } else {
                    deferredInitializer.push({
                        cls: cls,
                        props: properties,
                        mixins: mixins
                    });
                    cls.__props__ = null;
                }
            } else {
                declareProperties(cls, name, properties, base, options.mixins, options.__ES6__);
            }
            var statics = options.statics;
            if (statics) {
                var staticPropName;
                for (staticPropName in statics) {
                    INVALID_STATICS_DEV.indexOf(staticPropName) !== -1 && cc.errorID(3642, name, staticPropName, staticPropName);
                }
                for (staticPropName in statics) {
                    cls[staticPropName] = statics[staticPropName];
                }
            }
            for (var funcName in options) {
                if (BUILTIN_ENTRIES.indexOf(funcName) >= 0) {
                    continue;
                }
                var func = options[funcName];
                if (!preprocess.validateMethod(func, funcName, name, cls, base)) {
                    continue;
                }
                JS.value(cls.prototype, funcName, func, true, true);
            }
            var editor = options.editor;
            editor && (cc.isChildClassOf(base, cc.Component) ? cc.Component._registerEditorProps(cls, editor) : cc.warnID(3623, name));
            return cls;
        }
        CCClass._isCCClass = function(constructor) {
            return constructor && constructor.hasOwnProperty("__ctors__");
        };
        CCClass._fastDefine = function(className, constructor, serializableFields) {
            JS.setClassName(className, constructor);
            var props = constructor.__props__ = Object.keys(serializableFields);
            var attrProtos = Attr.getClassAttrsProto(constructor);
            for (var i = 0; i < props.length; i++) {
                var key = props[i];
                attrProtos[key + DELIMETER + "visible"] = false;
                attrProtos[key + DELIMETER + "default"] = serializableFields[key];
            }
        };
        CCClass.Attr = Attr;
        CCClass.attr = Attr.attr;
        cc.isChildClassOf = function(subclass, superclass) {
            if (subclass && superclass) {
                if ("function" !== typeof subclass) {
                    return false;
                }
                if ("function" !== typeof superclass) {
                    cc.warnID(3625, superclass);
                    return false;
                }
                if (subclass === superclass) {
                    return true;
                }
                for (;;) {
                    subclass = JS.getSuper(subclass);
                    if (!subclass) {
                        return false;
                    }
                    if (subclass === superclass) {
                        return true;
                    }
                }
            }
            return false;
        };
        CCClass.getInheritanceChain = function(klass) {
            var chain = [];
            for (;;) {
                klass = JS.getSuper(klass);
                if (!klass) {
                    break;
                }
                klass !== Object && chain.push(klass);
            }
            return chain;
        };
        var PrimitiveTypes = {
            Integer: "Number",
            Float: "Number",
            Boolean: "Boolean",
            String: "String"
        };
        var tmpAttrs = [];
        function parseAttributes(cls, attrs, className, propName, usedInGetter) {
            var ERR_Type = "The %s of %s must be type %s";
            var attrsProto = null;
            var attrsProtoKey = "";
            function getAttrsProto() {
                attrsProtoKey = propName + DELIMETER;
                return attrsProto = Attr.getClassAttrsProto(cls);
            }
            tmpAttrs.length = 0;
            var result = tmpAttrs;
            var type = attrs.type;
            if (type) {
                var primitiveType = PrimitiveTypes[type];
                if (primitiveType) {
                    result.push({
                        type: type,
                        _onAfterProp: getTypeChecker(primitiveType, "cc." + type)
                    });
                } else {
                    if ("Object" === type) {
                        cc.errorID(3644, className, propName);
                    } else {
                        if (type === Attr.ScriptUuid) {
                            var attr = Attr.ObjectType(cc.ScriptAsset);
                            attr.type = "Script";
                            result.push(attr);
                        } else {
                            "object" === typeof type ? Enum.isEnum(type) ? result.push({
                                type: "Enum",
                                enumList: Enum.getList(type)
                            }) : cc.errorID(3645, className, propName, type) : "function" === typeof type ? attrs.url ? result.push({
                                type: "Object",
                                ctor: type,
                                _onAfterProp: getTypeChecker("String", "cc.String")
                            }) : result.push(attrs._short ? {
                                type: "Object",
                                ctor: type
                            } : Attr.ObjectType(type)) : cc.errorID(3646, className, propName, type);
                        }
                    }
                }
            }
            function parseSimpleAttr(attrName, expectType) {
                if (attrName in attrs) {
                    var val = attrs[attrName];
                    typeof val === expectType ? (attrsProto || getAttrsProto())[attrsProtoKey + attrName] = val : cc.error(ERR_Type, attrName, className, propName, expectType);
                }
            }
            attrs.editorOnly && (usedInGetter ? cc.errorID(3613, "editorOnly", name, propName) : (attrsProto || getAttrsProto())[attrsProtoKey + "editorOnly"] = true);
            parseSimpleAttr("displayName", "string");
            parseSimpleAttr("multiline", "boolean");
            attrs.readonly && ((attrsProto || getAttrsProto())[attrsProtoKey + "readonly"] = true);
            parseSimpleAttr("tooltip", "string");
            parseSimpleAttr("slide", "boolean");
            attrs.url && ((attrsProto || getAttrsProto())[attrsProtoKey + "saveUrlAsAsset"] = true);
            false === attrs.serializable && (usedInGetter ? cc.errorID(3613, "serializable", name, propName) : (attrsProto || getAttrsProto())[attrsProtoKey + "serializable"] = false);
            var visible = attrs.visible;
            if ("undefined" !== typeof visible) {
                visible ? "function" === typeof visible && ((attrsProto || getAttrsProto())[attrsProtoKey + "visible"] = visible) : (attrsProto || getAttrsProto())[attrsProtoKey + "visible"] = false;
            } else {
                var startsWithUS = 95 === propName.charCodeAt(0);
                startsWithUS && ((attrsProto || getAttrsProto())[attrsProtoKey + "visible"] = false);
            }
            var range = attrs.range;
            if (range) {
                if (Array.isArray(range)) {
                    if (range.length >= 2) {
                        (attrsProto || getAttrsProto())[attrsProtoKey + "min"] = range[0];
                        attrsProto[attrsProtoKey + "max"] = range[1];
                        attrsProto[attrsProtoKey + "step"] = range[2];
                    } else {
                        cc.errorID(3647);
                    }
                } else {
                    cc.error(ERR_Type, "range", className, propName, "array");
                }
            }
            parseSimpleAttr("min", "number");
            parseSimpleAttr("max", "number");
            parseSimpleAttr("step", "number");
            return result;
        }
        cc.Class = CCClass;
        module.exports = {
            isArray: function(defaultVal) {
                defaultVal = getDefault(defaultVal);
                return Array.isArray(defaultVal);
            },
            fastDefine: CCClass._fastDefine,
            getNewValueTypeCode: getNewValueTypeCode,
            IDENTIFIER_RE: IDENTIFIER_RE,
            escapeForJS: escapeForJS,
            getDefault: getDefault
        };
    }), {
        "./CCEnum": 175,
        "./attribute": 186,
        "./js": 193,
        "./preprocess-class": 195,
        "./requiring-frame": 196,
        "./utils": 198
    } ],
    174: [ (function(require, module, exports) {
        require("./CCClass");
        var Preprocess = require("./preprocess-class");
        var JS = require("./js");
        var isPlainEmptyObj_DEV = require("./utils").isPlainEmptyObj_DEV;
        function fNOP(ctor) {
            return ctor;
        }
        function getSubDict(obj, key) {
            var res = obj[key];
            res || (res = obj[key] = {});
            return res;
        }
        function checkCtorArgument(decorate) {
            return function(target) {
                if ("function" === typeof target) {
                    return decorate(target);
                }
                return function(ctor) {
                    return decorate(ctor, target);
                };
            };
        }
        function _checkNormalArgument(validator_DEV, decorate, decoratorName) {
            return function(target) {
                if (false === validator_DEV(target, decoratorName)) {
                    return function() {
                        return fNOP;
                    };
                }
                return function(ctor) {
                    return decorate(ctor, target);
                };
            };
        }
        var checkCompArgument = _checkNormalArgument.bind(null, (function(arg, decoratorName) {
            if (!cc.Class._isCCClass(arg)) {
                cc.error("The parameter for %s is missing.", decoratorName);
                return false;
            }
        }));
        function _argumentChecker(type) {
            return _checkNormalArgument.bind(null, (function(arg, decoratorName) {
                if (arg instanceof cc.Component || void 0 === arg) {
                    cc.error("The parameter for %s is missing.", decoratorName);
                    return false;
                }
                if (typeof arg !== type) {
                    cc.error("The parameter for %s must be type %s.", decoratorName, type);
                    return false;
                }
            }));
        }
        var checkStringArgument = _argumentChecker("string");
        var checkNumberArgument = _argumentChecker("number");
        function getClassProto(ctor, decoratorName) {
            if (cc.Class._isCCClass(ctor)) {
                cc.error('@%s should be used after @ccclass for class "%s"', decoratorName, JS.getClassName(ctor));
                return null;
            }
            return getSubDict(ctor, "__ccclassProto__");
        }
        function getDefaultFromInitializer(initializer) {
            var value;
            try {
                value = initializer();
            } catch (e) {
                return initializer;
            }
            return "object" !== typeof value || null === value ? value : initializer;
        }
        var ccclass = checkCtorArgument((function(ctor, name) {
            var base = JS.getSuper(ctor);
            base === Object && (base = null);
            var proto = {
                name: name,
                extends: base,
                ctor: ctor,
                __ES6__: true
            };
            var decoratedProto = ctor.__ccclassProto__;
            if (decoratedProto) {
                JS.mixin(proto, decoratedProto);
                ctor.__ccclassProto__ = void 0;
            }
            var res = cc.Class(proto);
            return res;
        }));
        function property(ctorProtoOrOptions, propName, desc) {
            var options = null;
            function normalized(ctorProto, propName, desc) {
                var ccclassProto = getClassProto(ctorProto.constructor);
                if (ccclassProto) {
                    var props = getSubDict(ccclassProto, "properties");
                    var prop = props[propName];
                    var fullOptions = options && (Preprocess.getFullFormOfProperty(options) || options);
                    prop = JS.mixin(prop || {}, fullOptions || {});
                    if (desc) {
                        if (desc.initializer) {
                            options && options.hasOwnProperty("default") && cc.warnID(3650, "default", propName, JS.getClassName(ctorProto.constructor));
                            prop.default = getDefaultFromInitializer(desc.initializer);
                        } else {
                            if (desc.get) {
                                options && options.get && cc.warnID(3650, "get", propName, JS.getClassName(ctorProto.constructor));
                                prop.get = desc.get;
                            }
                            if (desc.set) {
                                options && options.set && cc.warnID(3650, "set", propName, JS.getClassName(ctorProto.constructor));
                                prop.set = desc.set;
                            }
                        }
                    } else {
                        isPlainEmptyObj_DEV(prop) ? cc.error('Failed to get default value of "%s" in class "%s". If using TypeScript, you also need to pass in the "default" attribute required by the "property" decorator.', propName, JS.getClassName(ctorProto.constructor)) : (prop.get || prop.set) && cc.error('Can not define get set in decorator of "%s" in class "%s", please use:\n@decorator(...)\nget %s () {\n  ...\n}\n@decorator\nset %s () {\n  ...\n}', propName, JS.getClassName(ctorProto.constructor), propName, propName);
                    }
                    props[propName] = prop;
                }
            }
            if ("undefined" === typeof propName) {
                options = ctorProtoOrOptions;
                return normalized;
            }
            normalized(ctorProtoOrOptions, propName, desc);
        }
        function createEditorDecorator(argCheckFunc, editorPropName, staticValue) {
            return argCheckFunc((function(ctor, decoratedValue) {
                var proto = getClassProto(ctor, editorPropName);
                if (proto) {
                    var value = void 0 !== staticValue ? staticValue : decoratedValue;
                    getSubDict(proto, "editor")[editorPropName] = value;
                }
            }), editorPropName);
        }
        function createDummyDecorator(argCheckFunc) {
            return argCheckFunc(fNOP);
        }
        var executeInEditMode = createEditorDecorator(checkCtorArgument, "executeInEditMode", true);
        var requireComponent = createEditorDecorator(checkCompArgument, "requireComponent");
        var menu = createEditorDecorator(checkStringArgument, "menu");
        var executionOrder = createEditorDecorator(checkNumberArgument, "executionOrder");
        var disallowMultiple = createEditorDecorator(checkCtorArgument, "disallowMultiple");
        var playOnFocus = createEditorDecorator(checkCtorArgument, "playOnFocus");
        var inspector = createEditorDecorator(checkStringArgument, "inspector");
        var icon = createEditorDecorator(checkStringArgument, "icon");
        var help = createEditorDecorator(checkStringArgument, "help");
        function mixins() {
            var mixins = [];
            for (var i = 0; i < arguments.length; i++) {
                mixins[i] = arguments[i];
            }
            return function(ctor) {
                var proto = getClassProto(ctor, "mixins");
                proto && (proto.mixins = mixins);
            };
        }
        cc._decorator = module.exports = {
            ccclass: ccclass,
            property: property,
            executeInEditMode: executeInEditMode,
            requireComponent: requireComponent,
            menu: menu,
            executionOrder: executionOrder,
            disallowMultiple: disallowMultiple,
            playOnFocus: playOnFocus,
            inspector: inspector,
            icon: icon,
            help: help,
            mixins: mixins
        };
    }), {
        "./CCClass": 173,
        "./js": 193,
        "./preprocess-class": 195,
        "./utils": 198
    } ],
    175: [ (function(require, module, exports) {
        var JS = require("./js");
        function Enum(obj) {
            if ("__enums__" in obj) {
                return obj;
            }
            JS.value(obj, "__enums__", null, true);
            var lastIndex = -1;
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var val = obj[key];
                if (val === -1) {
                    val = ++lastIndex;
                    obj[key] = val;
                } else {
                    if ("number" === typeof val) {
                        lastIndex = val;
                    } else {
                        if ("string" === typeof val && Number.isInteger(parseFloat(key))) {
                            continue;
                        }
                    }
                }
                var reverseKey = "" + val;
                key !== reverseKey && JS.value(obj, reverseKey, key);
            }
            return obj;
        }
        Enum.isEnum = function(enumType) {
            return enumType && enumType.hasOwnProperty("__enums__");
        };
        Enum.getList = function(enumDef) {
            if (enumDef.__enums__) {
                return enumDef.__enums__;
            }
            var enums = enumDef.__enums__ = [];
            for (var name in enumDef) {
                var value = enumDef[name];
                Number.isInteger(value) && enums.push({
                    name: name,
                    value: value
                });
            }
            enums.sort((function(a, b) {
                return a.value - b.value;
            }));
            return enums;
        };
        var _TestEnum = Enum({
            ZERO: -1,
            ONE: -1,
            TWO: -1,
            THREE: -1
        });
        0 === _TestEnum.ZERO && 1 === _TestEnum.ONE && 3 === _TestEnum.THREE || cc.errorID(7101);
        module.exports = cc.Enum = Enum;
    }), {
        "./js": 193
    } ],
    176: [ (function(require, module, exports) {
        cc.ClassManager || require("./_CCClass");
        var inputManager = require("./CCInputManager");
        inputManager.__instanceId = cc.ClassManager.getNewInstanceId();
        inputManager.setAccelerometerEnabled = function(isEnable) {
            var _t = this;
            if (_t._accelEnabled === isEnable) {
                return;
            }
            _t._accelEnabled = isEnable;
            var scheduler = cc.director.getScheduler();
            if (_t._accelEnabled) {
                _t._accelCurTime = 0;
                scheduler.scheduleUpdate(_t);
            } else {
                _t._accelCurTime = 0;
                scheduler.scheduleUpdate(_t);
            }
        };
        inputManager.setAccelerometerInterval = function(interval) {
            this._accelInterval !== interval && (this._accelInterval = interval);
        };
        inputManager._registerKeyboardEvent = function() {
            cc.game.canvas.addEventListener("keydown", (function(e) {
                cc.eventManager.dispatchEvent(new cc.Event.EventKeyboard(e.keyCode, true));
                e.stopPropagation();
                e.preventDefault();
            }), false);
            cc.game.canvas.addEventListener("keyup", (function(e) {
                cc.eventManager.dispatchEvent(new cc.Event.EventKeyboard(e.keyCode, false));
                e.stopPropagation();
                e.preventDefault();
            }), false);
        };
        inputManager._registerAccelerometerEvent = function() {
            var w = window, _t = this;
            _t._acceleration = new cc.Acceleration();
            _t._accelDeviceEvent = w.DeviceMotionEvent || w.DeviceOrientationEvent;
            cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (_t._accelDeviceEvent = window.DeviceOrientationEvent);
            var _deviceEventType = _t._accelDeviceEvent === w.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
            var ua = navigator.userAgent;
            (/Android/.test(ua) || /Adr/.test(ua) && cc.sys.browserType === cc.BROWSER_TYPE_UC) && (_t._minus = -1);
            w.addEventListener(_deviceEventType, _t.didAccelerate.bind(_t), false);
        };
        inputManager.didAccelerate = function(eventData) {
            var _t = this, w = window;
            if (!_t._accelEnabled) {
                return;
            }
            var mAcceleration = _t._acceleration;
            var x, y, z;
            if (_t._accelDeviceEvent === window.DeviceMotionEvent) {
                var eventAcceleration = eventData["accelerationIncludingGravity"];
                x = _t._accelMinus * eventAcceleration.x * .1;
                y = _t._accelMinus * eventAcceleration.y * .1;
                z = .1 * eventAcceleration.z;
            } else {
                x = eventData["gamma"] / 90 * .981;
                y = .981 * -(eventData["beta"] / 90);
                z = eventData["alpha"] / 90 * .981;
            }
            mAcceleration.x = x;
            mAcceleration.y = y;
            mAcceleration.z = z;
            mAcceleration.timestamp = eventData.timeStamp || Date.now();
            var tmpX = mAcceleration.x;
            if (w.orientation === cc.macro.WEB_ORIENTATION_LANDSCAPE_RIGHT) {
                mAcceleration.x = -mAcceleration.y;
                mAcceleration.y = tmpX;
            } else {
                if (w.orientation === cc.macro.WEB_ORIENTATION_LANDSCAPE_LEFT) {
                    mAcceleration.x = mAcceleration.y;
                    mAcceleration.y = -tmpX;
                } else {
                    if (w.orientation === cc.macro.WEB_ORIENTATION_PORTRAIT_UPSIDE_DOWN) {
                        mAcceleration.x = -mAcceleration.x;
                        mAcceleration.y = -mAcceleration.y;
                    }
                }
            }
            if (cc.sys.os === cc.sys.OS_ANDROID && cc.sys.browserType !== cc.sys.BROWSER_TYPE_MOBILE_QQ) {
                mAcceleration.x = -mAcceleration.x;
                mAcceleration.y = -mAcceleration.y;
            }
        };
    }), {
        "./CCInputManager": 177,
        "./_CCClass": 185
    } ],
    177: [ (function(require, module, exports) {
        var macro = require("./CCMacro");
        var TOUCH_TIMEOUT = macro.TOUCH_TIMEOUT;
        var inputManager = {
            _mousePressed: false,
            _isRegisterEvent: false,
            _preTouchPoint: cc.p(0, 0),
            _prevMousePoint: cc.p(0, 0),
            _preTouchPool: [],
            _preTouchPoolPointer: 0,
            _touches: [],
            _touchesIntegerDict: {},
            _indexBitsUsed: 0,
            _maxTouches: 5,
            _accelEnabled: false,
            _accelInterval: 1 / 30,
            _accelMinus: 1,
            _accelCurTime: 0,
            _acceleration: null,
            _accelDeviceEvent: null,
            _getUnUsedIndex: function() {
                var temp = this._indexBitsUsed;
                var now = cc.sys.now();
                for (var i = 0; i < this._maxTouches; i++) {
                    if (!(1 & temp)) {
                        this._indexBitsUsed |= 1 << i;
                        return i;
                    }
                    var touch = this._touches[i];
                    if (now - touch._lastModified > TOUCH_TIMEOUT) {
                        this._removeUsedIndexBit(i);
                        delete this._touchesIntegerDict[touch.getID()];
                        return i;
                    }
                    temp >>= 1;
                }
                return -1;
            },
            _removeUsedIndexBit: function(index) {
                if (index < 0 || index >= this._maxTouches) {
                    return;
                }
                var temp = 1 << index;
                temp = ~temp;
                this._indexBitsUsed &= temp;
            },
            _glView: null,
            handleTouchesBegin: function(touches) {
                var selTouch, index, curTouch, touchID, handleTouches = [], locTouchIntDict = this._touchesIntegerDict, now = cc.sys.now();
                for (var i = 0, len = touches.length; i < len; i++) {
                    selTouch = touches[i];
                    touchID = selTouch.getID();
                    index = locTouchIntDict[touchID];
                    if (null == index) {
                        var unusedIndex = this._getUnUsedIndex();
                        if (unusedIndex === -1) {
                            cc.logID(2300, unusedIndex);
                            continue;
                        }
                        curTouch = this._touches[unusedIndex] = new cc.Touch(selTouch._point.x, selTouch._point.y, selTouch.getID());
                        curTouch._lastModified = now;
                        curTouch._setPrevPoint(selTouch._prevPoint);
                        locTouchIntDict[touchID] = unusedIndex;
                        handleTouches.push(curTouch);
                    }
                }
                if (handleTouches.length > 0) {
                    this._glView._convertTouchesWithScale(handleTouches);
                    var touchEvent = new cc.Event.EventTouch(handleTouches);
                    touchEvent._eventCode = cc.Event.EventTouch.BEGAN;
                    cc.eventManager.dispatchEvent(touchEvent);
                }
            },
            handleTouchesMove: function(touches) {
                var selTouch, index, touchID, handleTouches = [], locTouches = this._touches, now = cc.sys.now();
                for (var i = 0, len = touches.length; i < len; i++) {
                    selTouch = touches[i];
                    touchID = selTouch.getID();
                    index = this._touchesIntegerDict[touchID];
                    if (null == index) {
                        continue;
                    }
                    if (locTouches[index]) {
                        locTouches[index]._setPoint(selTouch._point);
                        locTouches[index]._setPrevPoint(selTouch._prevPoint);
                        locTouches[index]._lastModified = now;
                        handleTouches.push(locTouches[index]);
                    }
                }
                if (handleTouches.length > 0) {
                    this._glView._convertTouchesWithScale(handleTouches);
                    var touchEvent = new cc.Event.EventTouch(handleTouches);
                    touchEvent._eventCode = cc.Event.EventTouch.MOVED;
                    cc.eventManager.dispatchEvent(touchEvent);
                }
            },
            handleTouchesEnd: function(touches) {
                var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
                if (handleTouches.length > 0) {
                    this._glView._convertTouchesWithScale(handleTouches);
                    var touchEvent = new cc.Event.EventTouch(handleTouches);
                    touchEvent._eventCode = cc.Event.EventTouch.ENDED;
                    cc.eventManager.dispatchEvent(touchEvent);
                }
            },
            handleTouchesCancel: function(touches) {
                var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
                if (handleTouches.length > 0) {
                    this._glView._convertTouchesWithScale(handleTouches);
                    var touchEvent = new cc.Event.EventTouch(handleTouches);
                    touchEvent._eventCode = cc.Event.EventTouch.CANCELLED;
                    cc.eventManager.dispatchEvent(touchEvent);
                }
            },
            getSetOfTouchesEndOrCancel: function(touches) {
                var selTouch, index, touchID, handleTouches = [], locTouches = this._touches, locTouchesIntDict = this._touchesIntegerDict;
                for (var i = 0, len = touches.length; i < len; i++) {
                    selTouch = touches[i];
                    touchID = selTouch.getID();
                    index = locTouchesIntDict[touchID];
                    if (null == index) {
                        continue;
                    }
                    if (locTouches[index]) {
                        locTouches[index]._setPoint(selTouch._point);
                        locTouches[index]._setPrevPoint(selTouch._prevPoint);
                        handleTouches.push(locTouches[index]);
                        this._removeUsedIndexBit(index);
                        delete locTouchesIntDict[touchID];
                    }
                }
                return handleTouches;
            },
            getHTMLElementPosition: function(element) {
                var docElem = document.documentElement;
                var win = window;
                var box = null;
                box = "function" === typeof element.getBoundingClientRect ? element.getBoundingClientRect() : element instanceof HTMLCanvasElement ? {
                    left: 0,
                    top: 0,
                    width: element.width,
                    height: element.height
                } : {
                    left: 0,
                    top: 0,
                    width: parseInt(element.style.width),
                    height: parseInt(element.style.height)
                };
                return {
                    left: box.left + win.pageXOffset - docElem.clientLeft,
                    top: box.top + win.pageYOffset - docElem.clientTop,
                    width: box.width,
                    height: box.height
                };
            },
            getPreTouch: function(touch) {
                var preTouch = null;
                var locPreTouchPool = this._preTouchPool;
                var id = touch.getID();
                for (var i = locPreTouchPool.length - 1; i >= 0; i--) {
                    if (locPreTouchPool[i].getID() === id) {
                        preTouch = locPreTouchPool[i];
                        break;
                    }
                }
                preTouch || (preTouch = touch);
                return preTouch;
            },
            setPreTouch: function(touch) {
                var find = false;
                var locPreTouchPool = this._preTouchPool;
                var id = touch.getID();
                for (var i = locPreTouchPool.length - 1; i >= 0; i--) {
                    if (locPreTouchPool[i].getID() === id) {
                        locPreTouchPool[i] = touch;
                        find = true;
                        break;
                    }
                }
                if (!find) {
                    if (locPreTouchPool.length <= 50) {
                        locPreTouchPool.push(touch);
                    } else {
                        locPreTouchPool[this._preTouchPoolPointer] = touch;
                        this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50;
                    }
                }
            },
            getTouchByXY: function(tx, ty, pos) {
                var locPreTouch = this._preTouchPoint;
                var location = this._glView.convertToLocationInView(tx, ty, pos);
                var touch = new cc.Touch(location.x, location.y);
                touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
                locPreTouch.x = location.x;
                locPreTouch.y = location.y;
                return touch;
            },
            getMouseEvent: function(location, pos, eventType) {
                var locPreMouse = this._prevMousePoint;
                this._glView._convertMouseToLocationInView(location, pos);
                var mouseEvent = new cc.Event.EventMouse(eventType);
                mouseEvent.setLocation(location.x, location.y);
                mouseEvent._setPrevCursor(locPreMouse.x, locPreMouse.y);
                locPreMouse.x = location.x;
                locPreMouse.y = location.y;
                return mouseEvent;
            },
            getPointByEvent: function(event, pos) {
                if (null != event.pageX) {
                    return {
                        x: event.pageX,
                        y: event.pageY
                    };
                }
                pos.left -= document.body.scrollLeft;
                pos.top -= document.body.scrollTop;
                return {
                    x: event.clientX,
                    y: event.clientY
                };
            },
            getTouchesByEvent: function(event, pos) {
                var touchArr = [], locView = this._glView;
                var touch_event, touch, preLocation;
                var locPreTouch = this._preTouchPoint;
                var length = event.changedTouches.length;
                for (var i = 0; i < length; i++) {
                    touch_event = event.changedTouches[i];
                    if (touch_event) {
                        var location;
                        location = cc.sys.BROWSER_TYPE_FIREFOX === cc.sys.browserType ? locView.convertToLocationInView(touch_event.pageX, touch_event.pageY, pos) : locView.convertToLocationInView(touch_event.clientX, touch_event.clientY, pos);
                        if (null != touch_event.identifier) {
                            touch = new cc.Touch(location.x, location.y, touch_event.identifier);
                            preLocation = this.getPreTouch(touch).getLocation();
                            touch._setPrevPoint(preLocation.x, preLocation.y);
                            this.setPreTouch(touch);
                        } else {
                            touch = new cc.Touch(location.x, location.y);
                            touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
                        }
                        locPreTouch.x = location.x;
                        locPreTouch.y = location.y;
                        touchArr.push(touch);
                    }
                }
                return touchArr;
            },
            registerSystemEvent: function(element) {
                if (this._isRegisterEvent) {
                    return;
                }
                var locView = this._glView = cc.view;
                var selfPointer = this;
                var supportMouse = "mouse" in cc.sys.capabilities, supportTouches = "touches" in cc.sys.capabilities;
                var prohibition = false;
                cc.sys.isMobile && (prohibition = true);
                if (supportMouse) {
                    !prohibition && window.addEventListener("mousedown", (function() {
                        selfPointer._mousePressed = true;
                    }), false);
                    !prohibition && window.addEventListener("mouseup", (function(event) {
                        var savePressed = selfPointer._mousePressed;
                        selfPointer._mousePressed = false;
                        if (!savePressed) {
                            return;
                        }
                        var pos = selfPointer.getHTMLElementPosition(element);
                        var location = selfPointer.getPointByEvent(event, pos);
                        if (!cc.rectContainsPoint(new cc.Rect(pos.left, pos.top, pos.width, pos.height), location)) {
                            selfPointer.handleTouchesEnd([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
                            var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.UP);
                            mouseEvent.setButton(event.button);
                            cc.eventManager.dispatchEvent(mouseEvent);
                        }
                    }), false);
                    !prohibition && element.addEventListener("mousedown", (function(event) {
                        selfPointer._mousePressed = true;
                        var pos = selfPointer.getHTMLElementPosition(element);
                        var location = selfPointer.getPointByEvent(event, pos);
                        selfPointer.handleTouchesBegin([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
                        var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.DOWN);
                        mouseEvent.setButton(event.button);
                        cc.eventManager.dispatchEvent(mouseEvent);
                        event.stopPropagation();
                        event.preventDefault();
                        element.focus();
                    }), false);
                    !prohibition && element.addEventListener("mouseup", (function(event) {
                        selfPointer._mousePressed = false;
                        var pos = selfPointer.getHTMLElementPosition(element);
                        var location = selfPointer.getPointByEvent(event, pos);
                        selfPointer.handleTouchesEnd([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
                        var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.UP);
                        mouseEvent.setButton(event.button);
                        cc.eventManager.dispatchEvent(mouseEvent);
                        event.stopPropagation();
                        event.preventDefault();
                    }), false);
                    !prohibition && element.addEventListener("mousemove", (function(event) {
                        var pos = selfPointer.getHTMLElementPosition(element);
                        var location = selfPointer.getPointByEvent(event, pos);
                        selfPointer.handleTouchesMove([ selfPointer.getTouchByXY(location.x, location.y, pos) ]);
                        var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.MOVE);
                        selfPointer._mousePressed ? mouseEvent.setButton(event.button) : mouseEvent.setButton(null);
                        cc.eventManager.dispatchEvent(mouseEvent);
                        event.stopPropagation();
                        event.preventDefault();
                    }), false);
                    element.addEventListener("mousewheel", (function(event) {
                        var pos = selfPointer.getHTMLElementPosition(element);
                        var location = selfPointer.getPointByEvent(event, pos);
                        var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.SCROLL);
                        mouseEvent.setButton(event.button);
                        mouseEvent.setScrollData(0, event.wheelDelta);
                        cc.eventManager.dispatchEvent(mouseEvent);
                        event.stopPropagation();
                        event.preventDefault();
                    }), false);
                    element.addEventListener("DOMMouseScroll", (function(event) {
                        var pos = selfPointer.getHTMLElementPosition(element);
                        var location = selfPointer.getPointByEvent(event, pos);
                        var mouseEvent = selfPointer.getMouseEvent(location, pos, cc.Event.EventMouse.SCROLL);
                        mouseEvent.setButton(event.button);
                        mouseEvent.setScrollData(0, event.detail * -120);
                        cc.eventManager.dispatchEvent(mouseEvent);
                        event.stopPropagation();
                        event.preventDefault();
                    }), false);
                }
                if (window.navigator.msPointerEnabled) {
                    var _pointerEventsMap = {
                        MSPointerDown: selfPointer.handleTouchesBegin,
                        MSPointerMove: selfPointer.handleTouchesMove,
                        MSPointerUp: selfPointer.handleTouchesEnd,
                        MSPointerCancel: selfPointer.handleTouchesCancel
                    };
                    for (var eventName in _pointerEventsMap) {
                        (function(_pointerEvent, _touchEvent) {
                            element.addEventListener(_pointerEvent, (function(event) {
                                var pos = selfPointer.getHTMLElementPosition(element);
                                pos.left -= document.documentElement.scrollLeft;
                                pos.top -= document.documentElement.scrollTop;
                                _touchEvent.call(selfPointer, [ selfPointer.getTouchByXY(event.clientX, event.clientY, pos) ]);
                                event.stopPropagation();
                            }), false);
                        })(eventName, _pointerEventsMap[eventName]);
                    }
                }
                if (supportTouches) {
                    element.addEventListener("touchstart", (function(event) {
                        if (!event.changedTouches) {
                            return;
                        }
                        var pos = selfPointer.getHTMLElementPosition(element);
                        pos.left -= document.body.scrollLeft;
                        pos.top -= document.body.scrollTop;
                        selfPointer.handleTouchesBegin(selfPointer.getTouchesByEvent(event, pos));
                        event.stopPropagation();
                        event.preventDefault();
                        element.focus();
                    }), false);
                    element.addEventListener("touchmove", (function(event) {
                        if (!event.changedTouches) {
                            return;
                        }
                        var pos = selfPointer.getHTMLElementPosition(element);
                        pos.left -= document.body.scrollLeft;
                        pos.top -= document.body.scrollTop;
                        selfPointer.handleTouchesMove(selfPointer.getTouchesByEvent(event, pos));
                        event.stopPropagation();
                        event.preventDefault();
                    }), false);
                    element.addEventListener("touchend", (function(event) {
                        if (!event.changedTouches) {
                            return;
                        }
                        var pos = selfPointer.getHTMLElementPosition(element);
                        pos.left -= document.body.scrollLeft;
                        pos.top -= document.body.scrollTop;
                        selfPointer.handleTouchesEnd(selfPointer.getTouchesByEvent(event, pos));
                        event.stopPropagation();
                        event.preventDefault();
                    }), false);
                    element.addEventListener("touchcancel", (function(event) {
                        if (!event.changedTouches) {
                            return;
                        }
                        var pos = selfPointer.getHTMLElementPosition(element);
                        pos.left -= document.body.scrollLeft;
                        pos.top -= document.body.scrollTop;
                        selfPointer.handleTouchesCancel(selfPointer.getTouchesByEvent(event, pos));
                        event.stopPropagation();
                        event.preventDefault();
                    }), false);
                }
                this._registerKeyboardEvent();
                this._registerAccelerometerEvent();
                this._isRegisterEvent = true;
            },
            _registerKeyboardEvent: function() {},
            _registerAccelerometerEvent: function() {},
            update: function(dt) {
                if (this._accelCurTime > this._accelInterval) {
                    this._accelCurTime -= this._accelInterval;
                    cc.eventManager.dispatchEvent(new cc.Event.EventAcceleration(this._acceleration));
                }
                this._accelCurTime += dt;
            }
        };
        cc.inputManager = inputManager;
        module.exports = inputManager;
    }), {
        "./CCMacro": 178
    } ],
    178: [ (function(require, module, exports) {
        require("./_CCClass");
        cc._tmp = cc._tmp || {};
        cc.KEY = {
            none: 0,
            back: 6,
            menu: 18,
            backspace: 8,
            tab: 9,
            enter: 13,
            shift: 16,
            ctrl: 17,
            alt: 18,
            pause: 19,
            capslock: 20,
            escape: 27,
            space: 32,
            pageup: 33,
            pagedown: 34,
            end: 35,
            home: 36,
            left: 37,
            up: 38,
            right: 39,
            down: 40,
            select: 41,
            insert: 45,
            Delete: 46,
            0: 48,
            1: 49,
            2: 50,
            3: 51,
            4: 52,
            5: 53,
            6: 54,
            7: 55,
            8: 56,
            9: 57,
            a: 65,
            b: 66,
            c: 67,
            d: 68,
            e: 69,
            f: 70,
            g: 71,
            h: 72,
            i: 73,
            j: 74,
            k: 75,
            l: 76,
            m: 77,
            n: 78,
            o: 79,
            p: 80,
            q: 81,
            r: 82,
            s: 83,
            t: 84,
            u: 85,
            v: 86,
            w: 87,
            x: 88,
            y: 89,
            z: 90,
            num0: 96,
            num1: 97,
            num2: 98,
            num3: 99,
            num4: 100,
            num5: 101,
            num6: 102,
            num7: 103,
            num8: 104,
            num9: 105,
            "*": 106,
            "+": 107,
            "-": 109,
            numdel: 110,
            "/": 111,
            f1: 112,
            f2: 113,
            f3: 114,
            f4: 115,
            f5: 116,
            f6: 117,
            f7: 118,
            f8: 119,
            f9: 120,
            f10: 121,
            f11: 122,
            f12: 123,
            numlock: 144,
            scrolllock: 145,
            ";": 186,
            semicolon: 186,
            equal: 187,
            "=": 187,
            ",": 188,
            comma: 188,
            dash: 189,
            ".": 190,
            period: 190,
            forwardslash: 191,
            grave: 192,
            "[": 219,
            openbracket: 219,
            backslash: 220,
            "]": 221,
            closebracket: 221,
            quote: 222,
            dpadLeft: 1e3,
            dpadRight: 1001,
            dpadUp: 1003,
            dpadDown: 1004,
            dpadCenter: 1005
        };
        cc.ImageFormat = cc.Enum({
            JPG: 0,
            PNG: 1,
            TIFF: 2,
            WEBP: 3,
            PVR: 4,
            ETC: 5,
            S3TC: 6,
            ATITC: 7,
            TGA: 8,
            RAWDATA: 9,
            UNKNOWN: 10
        });
        cc.getImageFormatByData = function(imgData) {
            if (imgData.length > 8 && 137 === imgData[0] && 80 === imgData[1] && 78 === imgData[2] && 71 === imgData[3] && 13 === imgData[4] && 10 === imgData[5] && 26 === imgData[6] && 10 === imgData[7]) {
                return cc.ImageFormat.PNG;
            }
            if (imgData.length > 2 && (73 === imgData[0] && 73 === imgData[1] || 77 === imgData[0] && 77 === imgData[1] || 255 === imgData[0] && 216 === imgData[1])) {
                return cc.ImageFormat.TIFF;
            }
            return cc.ImageFormat.UNKNOWN;
        };
        cc.macro = {
            INVALID_INDEX: -1,
            NODE_TAG_INVALID: -1,
            PI: Math.PI,
            PI2: 2 * Math.PI,
            FLT_MAX: parseFloat("3.402823466e+38F"),
            FLT_MIN: parseFloat("1.175494351e-38F"),
            RAD: Math.PI / 180,
            DEG: 180 / Math.PI,
            UINT_MAX: 4294967295,
            REPEAT_FOREVER: Number.MAX_VALUE - 1,
            FLT_EPSILON: 1.192092896e-7,
            ONE: 1,
            ZERO: 0,
            SRC_ALPHA: 770,
            SRC_ALPHA_SATURATE: 776,
            SRC_COLOR: 768,
            DST_ALPHA: 772,
            DST_COLOR: 774,
            ONE_MINUS_SRC_ALPHA: 771,
            ONE_MINUS_SRC_COLOR: 769,
            ONE_MINUS_DST_ALPHA: 773,
            ONE_MINUS_DST_COLOR: 775,
            ONE_MINUS_CONSTANT_ALPHA: 32772,
            ONE_MINUS_CONSTANT_COLOR: 32770,
            LINEAR: 9729,
            BLEND_DST: 771,
            WEB_ORIENTATION_PORTRAIT: 0,
            WEB_ORIENTATION_LANDSCAPE_LEFT: -90,
            WEB_ORIENTATION_PORTRAIT_UPSIDE_DOWN: 180,
            WEB_ORIENTATION_LANDSCAPE_RIGHT: 90,
            ORIENTATION_PORTRAIT: 1,
            ORIENTATION_LANDSCAPE: 2,
            ORIENTATION_AUTO: 3,
            DENSITYDPI_DEVICE: "device-dpi",
            DENSITYDPI_HIGH: "high-dpi",
            DENSITYDPI_MEDIUM: "medium-dpi",
            DENSITYDPI_LOW: "low-dpi",
            VERTEX_ATTRIB_FLAG_NONE: 0,
            VERTEX_ATTRIB_FLAG_POSITION: 1,
            VERTEX_ATTRIB_FLAG_COLOR: 2,
            VERTEX_ATTRIB_FLAG_TEX_COORDS: 4,
            VERTEX_ATTRIB_FLAG_POS_COLOR_TEX: 7,
            GL_ALL: 0,
            VERTEX_ATTRIB_POSITION: 0,
            VERTEX_ATTRIB_COLOR: 1,
            VERTEX_ATTRIB_TEX_COORDS: 2,
            VERTEX_ATTRIB_MAX: 3,
            UNIFORM_PMATRIX: 0,
            UNIFORM_MVMATRIX: 1,
            UNIFORM_MVPMATRIX: 2,
            UNIFORM_TIME: 3,
            UNIFORM_SINTIME: 4,
            UNIFORM_COSTIME: 5,
            UNIFORM_RANDOM01: 6,
            UNIFORM_SAMPLER: 7,
            UNIFORM_MAX: 8,
            SHADER_POSITION_TEXTURECOLOR: "ShaderPositionTextureColor",
            SHADER_SPRITE_POSITION_TEXTURECOLOR: "ShaderSpritePositionTextureColor",
            SHADER_POSITION_TEXTURECOLORALPHATEST: "ShaderPositionTextureColorAlphaTest",
            SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST: "ShaderSpritePositionTextureColorAlphaTest",
            SHADER_POSITION_COLOR: "ShaderPositionColor",
            SHADER_SPRITE_POSITION_COLOR: "ShaderSpritePositionColor",
            SHADER_POSITION_TEXTURE: "ShaderPositionTexture",
            SHADER_POSITION_TEXTURE_UCOLOR: "ShaderPositionTexture_uColor",
            SHADER_POSITION_TEXTUREA8COLOR: "ShaderPositionTextureA8Color",
            SHADER_POSITION_UCOLOR: "ShaderPosition_uColor",
            SHADER_POSITION_LENGTHTEXTURECOLOR: "ShaderPositionLengthTextureColor",
            UNIFORM_PMATRIX_S: "CC_PMatrix",
            UNIFORM_MVMATRIX_S: "CC_MVMatrix",
            UNIFORM_MVPMATRIX_S: "CC_MVPMatrix",
            UNIFORM_TIME_S: "CC_Time",
            UNIFORM_SINTIME_S: "CC_SinTime",
            UNIFORM_COSTIME_S: "CC_CosTime",
            UNIFORM_RANDOM01_S: "CC_Random01",
            UNIFORM_SAMPLER_S: "CC_Texture0",
            UNIFORM_ALPHA_TEST_VALUE_S: "CC_alpha_value",
            ATTRIBUTE_NAME_COLOR: "a_color",
            ATTRIBUTE_NAME_POSITION: "a_position",
            ATTRIBUTE_NAME_TEX_COORD: "a_texCoord",
            ITEM_SIZE: 32,
            CURRENT_ITEM: 3233828865,
            ZOOM_ACTION_TAG: 3233828866,
            NORMAL_TAG: 8801,
            SELECTED_TAG: 8802,
            DISABLE_TAG: 8803,
            FIX_ARTIFACTS_BY_STRECHING_TEXEL: 0,
            DIRECTOR_STATS_POSITION: cc.p(0, 0),
            DIRECTOR_FPS_INTERVAL: .5,
            COCOSNODE_RENDER_SUBPIXEL: 1,
            SPRITEBATCHNODE_RENDER_SUBPIXEL: 1,
            AUTO_PREMULTIPLIED_ALPHA_FOR_PNG: 0,
            OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA: 0,
            TEXTURE_ATLAS_USE_TRIANGLE_STRIP: 0,
            TEXTURE_ATLAS_USE_VAO: 0,
            TEXTURE_NPOT_SUPPORT: 0,
            USE_LA88_LABELS: 1,
            SPRITE_DEBUG_DRAW: 0,
            LABELBMFONT_DEBUG_DRAW: 0,
            LABELATLAS_DEBUG_DRAW: 0,
            ENABLE_STACKABLE_ACTIONS: 1,
            ENABLE_GL_STATE_CACHE: 1,
            TOUCH_TIMEOUT: 5e3,
            BATCH_VERTEX_COUNT: 2e3,
            ENABLE_GC_FOR_NATIVE_OBJECTS: true,
            ENABLE_TILEDMAP_CULLING: true,
            DOWNLOAD_MAX_CONCURRENT: 64
        };
        cc.defineGetterSetter(cc.macro, "BLEND_SRC", (function() {
            return cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.macro.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA ? cc.macro.ONE : cc.macro.SRC_ALPHA;
        }));
        cc.lerp = function(a, b, r) {
            return a + (b - a) * r;
        };
        cc.rand = function() {
            return 16777215 * Math.random();
        };
        cc.randomMinus1To1 = function() {
            return 2 * (Math.random() - .5);
        };
        cc.random0To1 = Math.random;
        cc.degreesToRadians = function(angle) {
            return angle * cc.macro.RAD;
        };
        cc.radiansToDegrees = function(angle) {
            return angle * cc.macro.DEG;
        };
        cc.nodeDrawSetup = function(node) {
            if (node._shaderProgram) {
                node._shaderProgram.use();
                node._shaderProgram.setUniformForModelViewAndProjectionMatrixWithMat4();
            }
        };
        cc.incrementGLDraws = function(addNumber) {
            cc.g_NumberOfDraws += addNumber;
        };
        cc.checkGLErrorDebug = function() {
            if (cc.renderMode === cc.game.RENDER_TYPE_WEBGL) {
                var _error = cc._renderContext.getError();
                _error && cc.logID(2400, _error);
            }
        };
        module.exports = cc.macro;
    }), {
        "./_CCClass": 185
    } ],
    179: [ (function(require, module, exports) {
        var JS = require("./js");
        var CCClass = require("./CCClass");
        var Destroyed = 1;
        var RealDestroyed = 2;
        var ToDestroy = 4;
        var DontSave = 8;
        var EditorOnly = 16;
        var Dirty = 32;
        var DontDestroy = 64;
        var Destroying = 128;
        var Deactivating = 256;
        var IsOnEnableCalled = 2048;
        var IsEditorOnEnableCalled = 4096;
        var IsPreloadStarted = 8192;
        var IsOnLoadCalled = 16384;
        var IsOnLoadStarted = 32768;
        var IsStartCalled = 65536;
        var IsRotationLocked = 1 << 17;
        var IsScaleLocked = 1 << 18;
        var IsAnchorLocked = 1 << 19;
        var IsSizeLocked = 1 << 20;
        var IsPositionLocked = 1 << 21;
        var PersistentMask = ~(ToDestroy | Dirty | Destroying | DontDestroy | Deactivating | IsPreloadStarted | IsOnLoadStarted | IsOnLoadCalled | IsStartCalled | IsOnEnableCalled | IsEditorOnEnableCalled | IsRotationLocked | IsScaleLocked | IsAnchorLocked | IsSizeLocked | IsPositionLocked);
        function CCObject() {
            this._name = "";
            this._objFlags = 0;
        }
        CCClass.fastDefine("cc.Object", CCObject, {
            _name: "",
            _objFlags: 0
        });
        JS.value(CCObject, "Flags", {
            Destroyed: Destroyed,
            DontSave: DontSave,
            EditorOnly: EditorOnly,
            Dirty: Dirty,
            DontDestroy: DontDestroy,
            PersistentMask: PersistentMask,
            Destroying: Destroying,
            Deactivating: Deactivating,
            IsPreloadStarted: IsPreloadStarted,
            IsOnLoadStarted: IsOnLoadStarted,
            IsOnLoadCalled: IsOnLoadCalled,
            IsOnEnableCalled: IsOnEnableCalled,
            IsStartCalled: IsStartCalled,
            IsEditorOnEnableCalled: IsEditorOnEnableCalled,
            IsPositionLocked: IsPositionLocked,
            IsRotationLocked: IsRotationLocked,
            IsScaleLocked: IsScaleLocked,
            IsAnchorLocked: IsAnchorLocked,
            IsSizeLocked: IsSizeLocked
        });
        var objectsToDestroy = [];
        function deferredDestroy() {
            var deleteCount = objectsToDestroy.length;
            for (var i = 0; i < deleteCount; ++i) {
                var obj = objectsToDestroy[i];
                obj._objFlags & Destroyed || obj._destroyImmediate();
            }
            deleteCount === objectsToDestroy.length ? objectsToDestroy.length = 0 : objectsToDestroy.splice(0, deleteCount);
        }
        JS.value(CCObject, "_deferredDestroy", deferredDestroy);
        var prototype = CCObject.prototype;
        JS.getset(prototype, "name", (function() {
            return this._name;
        }), (function(value) {
            this._name = value;
        }));
        JS.get(prototype, "isValid", (function() {
            return !(this._objFlags & Destroyed);
        }));
        var deferredDestroyTimer = null;
        prototype.destroy = function() {
            if (this._objFlags & Destroyed) {
                cc.warnID(5e3);
                return false;
            }
            if (this._objFlags & ToDestroy) {
                return false;
            }
            this._objFlags |= ToDestroy;
            objectsToDestroy.push(this);
            return true;
        };
        function compileDestruct(obj, ctor) {
            var key, propsToReset = {};
            for (key in obj) {
                if (obj.hasOwnProperty(key)) {
                    switch (typeof obj[key]) {
                      case "string":
                        propsToReset[key] = "";
                        break;

                      case "object":
                      case "function":
                        propsToReset[key] = null;
                    }
                }
            }
            if (cc.Class._isCCClass(ctor)) {
                var attrs = cc.Class.Attr.getClassAttrs(ctor);
                var propList = ctor.__props__;
                for (var i = 0; i < propList.length; i++) {
                    key = propList[i];
                    var attrKey = key + cc.Class.Attr.DELIMETER + "default";
                    if (attrKey in attrs) {
                        switch (typeof attrs[attrKey]) {
                          case "string":
                            propsToReset[key] = "";
                            break;

                          case "object":
                          case "function":
                            propsToReset[key] = null;
                            break;

                          case "undefined":
                            propsToReset[key] = void 0;
                        }
                    }
                }
            }
            var skipId = obj instanceof cc._BaseNode || obj instanceof cc.Component;
            var func = "";
            for (key in propsToReset) {
                if (skipId && "_id" === key) {
                    continue;
                }
                var statement;
                statement = CCClass.IDENTIFIER_RE.test(key) ? "o." + key + "=" : "o[" + CCClass.escapeForJS(key) + "]=";
                var val = propsToReset[key];
                "" === val && (val = '""');
                func += statement + val + ";\n";
            }
            return Function("o", func);
        }
        prototype._destruct = function() {
            var ctor = this.constructor;
            var destruct = ctor.__destruct__;
            if (!destruct) {
                destruct = compileDestruct(this, ctor);
                JS.value(ctor, "__destruct__", destruct, true);
            }
            destruct(this);
        };
        prototype._onPreDestroy = null;
        prototype._destroyImmediate = function() {
            if (this._objFlags & Destroyed) {
                cc.errorID(5e3);
                return;
            }
            this._onPreDestroy && this._onPreDestroy();
            this._destruct();
            this._objFlags |= Destroyed;
        };
        prototype._deserialize = null;
        cc.isValid = function(value) {
            return "object" === typeof value ? !!value && !(value._objFlags & Destroyed) : "undefined" !== typeof value;
        };
        cc.Object = module.exports = CCObject;
    }), {
        "./CCClass": 173,
        "./js": 193
    } ],
    180: [ (function(require, module, exports) {
        cc.SAXParser = cc._Class.extend({
            ctor: function() {
                if (window.DOMParser) {
                    this._isSupportDOMParser = true;
                    this._parser = new DOMParser();
                } else {
                    this._isSupportDOMParser = false;
                    this._parser = null;
                }
            },
            parse: function(xmlTxt) {
                return this._parseXML(xmlTxt);
            },
            _parseXML: function(textxml) {
                var xmlDoc;
                if (this._isSupportDOMParser) {
                    xmlDoc = this._parser.parseFromString(textxml, "text/xml");
                } else {
                    xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                    xmlDoc.async = "false";
                    xmlDoc.loadXML(textxml);
                }
                return xmlDoc;
            }
        });
        cc.PlistParser = cc.SAXParser.extend({
            parse: function(xmlTxt) {
                var xmlDoc = this._parseXML(xmlTxt);
                var plist = xmlDoc.documentElement;
                if ("plist" !== plist.tagName) {
                    cc.warnID(5100);
                    return {};
                }
                var node = null;
                for (var i = 0, len = plist.childNodes.length; i < len; i++) {
                    node = plist.childNodes[i];
                    if (1 === node.nodeType) {
                        break;
                    }
                }
                xmlDoc = null;
                return this._parseNode(node);
            },
            _parseNode: function(node) {
                var data = null, tagName = node.tagName;
                if ("dict" === tagName) {
                    data = this._parseDict(node);
                } else {
                    if ("array" === tagName) {
                        data = this._parseArray(node);
                    } else {
                        if ("string" === tagName) {
                            if (1 === node.childNodes.length) {
                                data = node.firstChild.nodeValue;
                            } else {
                                data = "";
                                for (var i = 0; i < node.childNodes.length; i++) {
                                    data += node.childNodes[i].nodeValue;
                                }
                            }
                        } else {
                            "false" === tagName ? data = false : "true" === tagName ? data = true : "real" === tagName ? data = parseFloat(node.firstChild.nodeValue) : "integer" === tagName && (data = parseInt(node.firstChild.nodeValue, 10));
                        }
                    }
                }
                return data;
            },
            _parseArray: function(node) {
                var data = [];
                for (var i = 0, len = node.childNodes.length; i < len; i++) {
                    var child = node.childNodes[i];
                    if (1 !== child.nodeType) {
                        continue;
                    }
                    data.push(this._parseNode(child));
                }
                return data;
            },
            _parseDict: function(node) {
                var data = {};
                var key = null;
                for (var i = 0, len = node.childNodes.length; i < len; i++) {
                    var child = node.childNodes[i];
                    if (1 !== child.nodeType) {
                        continue;
                    }
                    "key" === child.tagName ? key = child.firstChild.nodeValue : data[key] = this._parseNode(child);
                }
                return data;
            }
        });
        cc.saxParser = new cc.SAXParser();
        cc.plistParser = new cc.PlistParser();
    }), {} ],
    181: [ (function(require, module, exports) {
        cc.screen = {
            _supportsFullScreen: false,
            _preOnFullScreenChange: null,
            _touchEvent: "",
            _fn: null,
            _fnMap: [ [ "requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement" ], [ "requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement" ], [ "webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement" ], [ "mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement" ], [ "msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement" ] ],
            init: function() {
                this._fn = {};
                var i, l, val, map = this._fnMap, valL;
                for (i = 0, l = map.length; i < l; i++) {
                    val = map[i];
                    if (val && val[1] in document) {
                        for (i = 0, valL = val.length; i < valL; i++) {
                            this._fn[map[0][i]] = val[i];
                        }
                        break;
                    }
                }
                this._supportsFullScreen = "undefined" !== typeof this._fn.requestFullscreen;
                this._touchEvent = "ontouchstart" in window ? "touchstart" : "mousedown";
            },
            fullScreen: function() {
                return !!this._supportsFullScreen && (void 0 !== document[this._fn.fullscreenElement] && null !== document[this._fn.fullscreenElement]);
            },
            requestFullScreen: function(element, onFullScreenChange) {
                if (!this._supportsFullScreen) {
                    return;
                }
                element = element || document.documentElement;
                if (onFullScreenChange) {
                    var eventName = this._fn.fullscreenchange;
                    this._preOnFullScreenChange && document.removeEventListener(eventName, this._preOnFullScreenChange);
                    this._preOnFullScreenChange = onFullScreenChange;
                    document.addEventListener(eventName, onFullScreenChange, false);
                }
                return element[this._fn.requestFullscreen]();
            },
            exitFullScreen: function() {
                return !this._supportsFullScreen || document[this._fn.exitFullscreen]();
            },
            autoFullScreen: function(element, onFullScreenChange) {
                element = element || document.body;
                var touchTarget = cc.game.canvas || element;
                var theScreen = this;
                function callback() {
                    touchTarget.removeEventListener(theScreen._touchEvent, callback);
                    theScreen.requestFullScreen(element, onFullScreenChange);
                }
                this.requestFullScreen(element, onFullScreenChange);
                touchTarget.addEventListener(this._touchEvent, callback);
            }
        };
        cc.screen.init();
    }), {} ],
    182: [ (function(require, module, exports) {
        if (cc.sys) {
            return;
        }
        cc.sys = {};
        var sys = cc.sys;
        sys.LANGUAGE_ENGLISH = "en";
        sys.LANGUAGE_CHINESE = "zh";
        sys.LANGUAGE_FRENCH = "fr";
        sys.LANGUAGE_ITALIAN = "it";
        sys.LANGUAGE_GERMAN = "de";
        sys.LANGUAGE_SPANISH = "es";
        sys.LANGUAGE_DUTCH = "du";
        sys.LANGUAGE_RUSSIAN = "ru";
        sys.LANGUAGE_KOREAN = "ko";
        sys.LANGUAGE_JAPANESE = "ja";
        sys.LANGUAGE_HUNGARIAN = "hu";
        sys.LANGUAGE_PORTUGUESE = "pt";
        sys.LANGUAGE_ARABIC = "ar";
        sys.LANGUAGE_NORWEGIAN = "no";
        sys.LANGUAGE_POLISH = "pl";
        sys.LANGUAGE_TURKISH = "tr";
        sys.LANGUAGE_UKRAINIAN = "uk";
        sys.LANGUAGE_ROMANIAN = "ro";
        sys.LANGUAGE_BULGARIAN = "bg";
        sys.LANGUAGE_UNKNOWN = "unknown";
        sys.OS_IOS = "iOS";
        sys.OS_ANDROID = "Android";
        sys.OS_WINDOWS = "Windows";
        sys.OS_MARMALADE = "Marmalade";
        sys.OS_LINUX = "Linux";
        sys.OS_BADA = "Bada";
        sys.OS_BLACKBERRY = "Blackberry";
        sys.OS_OSX = "OS X";
        sys.OS_WP8 = "WP8";
        sys.OS_WINRT = "WINRT";
        sys.OS_UNKNOWN = "Unknown";
        sys.UNKNOWN = -1;
        sys.WIN32 = 0;
        sys.LINUX = 1;
        sys.MACOS = 2;
        sys.ANDROID = 3;
        sys.IPHONE = 4;
        sys.IPAD = 5;
        sys.BLACKBERRY = 6;
        sys.NACL = 7;
        sys.EMSCRIPTEN = 8;
        sys.TIZEN = 9;
        sys.WINRT = 10;
        sys.WP8 = 11;
        sys.MOBILE_BROWSER = 100;
        sys.DESKTOP_BROWSER = 101;
        sys.EDITOR_PAGE = 102;
        sys.EDITOR_CORE = 103;
        sys.BROWSER_TYPE_WECHAT = "wechat";
        sys.BROWSER_TYPE_ANDROID = "androidbrowser";
        sys.BROWSER_TYPE_IE = "ie";
        sys.BROWSER_TYPE_QQ = "qqbrowser";
        sys.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
        sys.BROWSER_TYPE_UC = "ucbrowser";
        sys.BROWSER_TYPE_360 = "360browser";
        sys.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
        sys.BROWSER_TYPE_BAIDU = "baidubrowser";
        sys.BROWSER_TYPE_MAXTHON = "maxthon";
        sys.BROWSER_TYPE_OPERA = "opera";
        sys.BROWSER_TYPE_OUPENG = "oupeng";
        sys.BROWSER_TYPE_MIUI = "miuibrowser";
        sys.BROWSER_TYPE_FIREFOX = "firefox";
        sys.BROWSER_TYPE_SAFARI = "safari";
        sys.BROWSER_TYPE_CHROME = "chrome";
        sys.BROWSER_TYPE_LIEBAO = "liebao";
        sys.BROWSER_TYPE_QZONE = "qzone";
        sys.BROWSER_TYPE_SOUGOU = "sogou";
        sys.BROWSER_TYPE_UNKNOWN = "unknown";
        sys.isNative = false;
        sys.isBrowser = "object" === typeof window && "object" === typeof document;
        var win = window, nav = win.navigator, doc = document, docEle = doc.documentElement;
        var ua = nav.userAgent.toLowerCase();
        sys.isMobile = /mobile|android|iphone|ipad/.test(ua);
        sys.platform = sys.isMobile ? sys.MOBILE_BROWSER : sys.DESKTOP_BROWSER;
        var currLanguage = nav.language;
        currLanguage = currLanguage ? currLanguage : nav.browserLanguage;
        currLanguage = currLanguage ? currLanguage.split("-")[0] : sys.LANGUAGE_ENGLISH;
        sys.language = currLanguage;
        var isAndroid = false, iOS = false, osVersion = "", osMainVersion = 0;
        var uaResult = /android (\d+(?:\.\d+)+)/i.exec(ua) || /android (\d+(?:\.\d+)+)/i.exec(nav.platform);
        if (uaResult) {
            isAndroid = true;
            osVersion = uaResult[1] || "";
            osMainVersion = parseInt(osVersion) || 0;
        }
        uaResult = /(iPad|iPhone|iPod).*OS ((\d+_?){2,3})/i.exec(ua);
        if (uaResult) {
            iOS = true;
            osVersion = uaResult[2] || "";
            osMainVersion = parseInt(osVersion) || 0;
        } else {
            if (/(iPhone|iPad|iPod)/.exec(nav.platform)) {
                iOS = true;
                osVersion = "";
                osMainVersion = 0;
            }
        }
        var osName = sys.OS_UNKNOWN;
        nav.appVersion.indexOf("Win") !== -1 ? osName = sys.OS_WINDOWS : iOS ? osName = sys.OS_IOS : nav.appVersion.indexOf("Mac") !== -1 ? osName = sys.OS_OSX : nav.appVersion.indexOf("X11") !== -1 && nav.appVersion.indexOf("Linux") === -1 ? osName = sys.OS_UNIX : isAndroid ? osName = sys.OS_ANDROID : nav.appVersion.indexOf("Linux") !== -1 && (osName = sys.OS_LINUX);
        sys.os = osName;
        sys.osVersion = osVersion;
        sys.osMainVersion = osMainVersion;
        sys.browserType = sys.BROWSER_TYPE_UNKNOWN;
        (function() {
            var typeReg1 = /mqqbrowser|micromessenger|qq|sogou|qzone|liebao|maxthon|ucbrowser|360 aphone|360browser|baiduboxapp|baidubrowser|maxthon|mxbrowser|miuibrowser/i;
            var typeReg2 = /qqbrowser|chrome|safari|firefox|trident|opera|opr|oupeng/i;
            var browserTypes = typeReg1.exec(ua);
            browserTypes || (browserTypes = typeReg2.exec(ua));
            var browserType = browserTypes ? browserTypes[0].toLowerCase() : sys.BROWSER_TYPE_UNKNOWN;
            "micromessenger" === browserType ? browserType = sys.BROWSER_TYPE_WECHAT : "safari" === browserType && isAndroid ? browserType = sys.BROWSER_TYPE_ANDROID : "qq" === browserType && ua.match(/android.*applewebkit/i) ? brwoserType = sys.BROWSER_TYPE_ANDROID : "trident" === browserType ? browserType = sys.BROWSER_TYPE_IE : "360 aphone" === browserType ? browserType = sys.BROWSER_TYPE_360 : "mxbrowser" === browserType ? browserType = sys.BROWSER_TYPE_MAXTHON : "opr" === browserType && (browserType = sys.BROWSER_TYPE_OPERA);
            sys.browserType = browserType;
        })();
        sys.browserVersion = "";
        (function() {
            var versionReg1 = /(mqqbrowser|micromessenger|qq|sogou|qzone|liebao|maxthon|uc|360 aphone|360|baiduboxapp|baidu|maxthon|mxbrowser|miui)(mobile)?(browser)?\/?([\d.]+)/i;
            var versionReg2 = /(qqbrowser|chrome|safari|firefox|trident|opera|opr|oupeng)(mobile)?(browser)?\/?([\d.]+)/i;
            var tmp = ua.match(versionReg1);
            tmp || (tmp = ua.match(versionReg2));
            sys.browserVersion = tmp ? tmp[4] : "";
        })();
        var w = window.innerWidth || document.documentElement.clientWidth;
        var h = window.innerHeight || document.documentElement.clientHeight;
        var ratio = window.devicePixelRatio || 1;
        sys.windowPixelResolution = {
            width: ratio * w,
            height: ratio * h
        };
        sys._checkWebGLRenderMode = function() {
            if (cc._renderType !== cc.game.RENDER_TYPE_WEBGL) {
                throw new Error("This feature supports WebGL render mode only.");
            }
        };
        var _tmpCanvas1 = document.createElement("canvas"), _tmpCanvas2 = document.createElement("canvas");
        cc.create3DContext = function(canvas, opt_attribs, opt_contextType) {
            if (!opt_contextType) {
                return cc.create3DContext(canvas, opt_attribs, "webgl") || cc.create3DContext(canvas, opt_attribs, "experimental-webgl") || cc.create3DContext(canvas, opt_attribs, "webkit-3d") || cc.create3DContext(canvas, opt_attribs, "moz-webgl") || null;
            }
            try {
                return canvas.getContext(opt_contextType, opt_attribs);
            } catch (e) {
                return null;
            }
        };
        sys._supportCanvasNewBlendModes = (function() {
            var canvas = _tmpCanvas1;
            canvas.width = 1;
            canvas.height = 1;
            var context = canvas.getContext("2d");
            context.fillStyle = "#000";
            context.fillRect(0, 0, 1, 1);
            context.globalCompositeOperation = "multiply";
            var canvas2 = _tmpCanvas2;
            canvas2.width = 1;
            canvas2.height = 1;
            var context2 = canvas2.getContext("2d");
            context2.fillStyle = "#fff";
            context2.fillRect(0, 0, 1, 1);
            context.drawImage(canvas2, 0, 0, 1, 1);
            return 0 === context.getImageData(0, 0, 1, 1).data[0];
        })();
        if (cc.sys.isMobile) {
            var fontStyle = document.createElement("style");
            fontStyle.type = "text/css";
            document.body.appendChild(fontStyle);
            fontStyle.textContent = "body,canvas,div{ -moz-user-select: none;-webkit-user-select: none;-ms-user-select: none;-khtml-user-select: none;-webkit-tap-highlight-color:rgba(0,0,0,0);}";
        }
        try {
            var localStorage = sys.localStorage = win.localStorage;
            localStorage.setItem("storage", "");
            localStorage.removeItem("storage");
            localStorage = null;
        } catch (e) {
            var warn = function() {
                cc.warnID(5200);
            };
            sys.localStorage = {
                getItem: warn,
                setItem: warn,
                removeItem: warn,
                clear: warn
            };
        }
        var _supportWebp = _tmpCanvas1.toDataURL("image/webp").startsWith("data:image/webp");
        var _supportCanvas = !!_tmpCanvas1.getContext("2d");
        var _supportWebGL = false;
        if (win.WebGLRenderingContext) {
            cc.create3DContext(document.createElement("CANVAS")) && (_supportWebGL = true);
            _supportWebGL && sys.os === sys.OS_IOS && 9 === sys.osMainVersion && (win.indexedDB || (_supportWebGL = false));
            if (_supportWebGL && sys.os === sys.OS_ANDROID) {
                var browserVer = parseFloat(sys.browserVersion);
                switch (sys.browserType) {
                  case sys.BROWSER_TYPE_MOBILE_QQ:
                  case sys.BROWSER_TYPE_BAIDU:
                  case sys.BROWSER_TYPE_BAIDU_APP:
                    _supportWebGL = browserVer >= 6.2;
                    break;

                  case sys.BROWSER_TYPE_ANDROID:
                    sys.osMainVersion && sys.osMainVersion >= 5 && (_supportWebGL = true);
                    break;

                  case sys.BROWSER_TYPE_CHROME:
                    _supportWebGL = browserVer >= 30;
                    break;

                  case sys.BROWSER_TYPE_360:
                  case sys.BROWSER_TYPE_UC:
                    _supportWebGL = false;
                }
            }
        }
        var capabilities = sys.capabilities = {
            canvas: _supportCanvas,
            opengl: _supportWebGL,
            webp: _supportWebp
        };
        (void 0 !== docEle["ontouchstart"] || void 0 !== doc["ontouchstart"] || nav.msPointerEnabled) && (capabilities["touches"] = true);
        void 0 !== docEle["onmouseup"] && (capabilities["mouse"] = true);
        void 0 !== docEle["onkeyup"] && (capabilities["keyboard"] = true);
        (win.DeviceMotionEvent || win.DeviceOrientationEvent) && (capabilities["accelerometer"] = true);
        var __audioSupport;
        (function() {
            var DEBUG = false;
            var version = sys.browserVersion;
            var supportWebAudio = !!(window.AudioContext || window.webkitAudioContext || window.mozAudioContext);
            __audioSupport = {
                ONLY_ONE: false,
                WEB_AUDIO: supportWebAudio,
                DELAY_CREATE_CTX: false
            };
            sys.os === sys.OS_IOS && (__audioSupport.USE_LOADER_EVENT = "loadedmetadata");
            if (sys.browserType === sys.BROWSER_TYPE_FIREFOX) {
                __audioSupport.DELAY_CREATE_CTX = true;
                __audioSupport.USE_LOADER_EVENT = "canplay";
            }
            sys.os === sys.OS_ANDROID && sys.browserType === sys.BROWSER_TYPE_UC && (__audioSupport.ONE_SOURCE = true);
            DEBUG && setTimeout((function() {
                cc.log("browse type: " + sys.browserType);
                cc.log("browse version: " + version);
                cc.log("MULTI_CHANNEL: " + __audioSupport.MULTI_CHANNEL);
                cc.log("WEB_AUDIO: " + __audioSupport.WEB_AUDIO);
                cc.log("AUTOPLAY: " + __audioSupport.AUTOPLAY);
            }), 0);
        })();
        try {
            if (__audioSupport.WEB_AUDIO) {
                __audioSupport.context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
                __audioSupport.DELAY_CREATE_CTX && setTimeout((function() {
                    __audioSupport.context = new (window.AudioContext || window.webkitAudioContext || window.mozAudioContext)();
                }), 0);
            }
        } catch (error) {
            __audioSupport.WEB_AUDIO = false;
            cc.logID(5201);
        }
        var formatSupport = [];
        (function() {
            var audio = document.createElement("audio");
            if (audio.canPlayType) {
                var ogg = audio.canPlayType('audio/ogg; codecs="vorbis"');
                ogg && formatSupport.push(".ogg");
                var mp3 = audio.canPlayType("audio/mpeg");
                mp3 && formatSupport.push(".mp3");
                var wav = audio.canPlayType('audio/wav; codecs="1"');
                wav && formatSupport.push(".wav");
                var mp4 = audio.canPlayType("audio/mp4");
                mp4 && formatSupport.push(".mp4");
                var m4a = audio.canPlayType("audio/x-m4a");
                m4a && formatSupport.push(".m4a");
            }
        })();
        __audioSupport.format = formatSupport;
        sys.__audioSupport = __audioSupport;
        sys.garbageCollect = function() {};
        sys.dumpRoot = function() {};
        sys.restartVM = function() {};
        sys.cleanScript = function(jsfile) {};
        sys.isObjectValid = function(obj) {
            return !!obj;
        };
        sys.dump = function() {
            var self = this;
            var str = "";
            str += "isMobile : " + self.isMobile + "\r\n";
            str += "language : " + self.language + "\r\n";
            str += "browserType : " + self.browserType + "\r\n";
            str += "browserVersion : " + self.browserVersion + "\r\n";
            str += "capabilities : " + JSON.stringify(self.capabilities) + "\r\n";
            str += "os : " + self.os + "\r\n";
            str += "osVersion : " + self.osVersion + "\r\n";
            str += "platform : " + self.platform + "\r\n";
            str += "Using " + (cc._renderType === cc.game.RENDER_TYPE_WEBGL ? "WEBGL" : "CANVAS") + " renderer.\r\n";
            cc.log(str);
        };
        sys.openURL = function(url) {
            window.open(url);
        };
        sys.now = function() {
            return Date.now ? Date.now() : +new Date();
        };
        module.exports = sys;
    }), {} ],
    183: [ (function(require, module, exports) {
        var __BrowserGetter = {
            init: function() {
                this.html = document.getElementsByTagName("html")[0];
            },
            availWidth: function(frame) {
                return frame && frame !== this.html ? frame.clientWidth : window.innerWidth;
            },
            availHeight: function(frame) {
                return frame && frame !== this.html ? frame.clientHeight : window.innerHeight;
            },
            meta: {
                width: "device-width"
            },
            adaptationType: cc.sys.browserType
        };
        window.navigator.userAgent.indexOf("OS 8_1_") > -1 && (__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_MIUI);
        cc.sys.os === cc.sys.OS_IOS && (__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI);
        switch (__BrowserGetter.adaptationType) {
          case cc.sys.BROWSER_TYPE_SAFARI:
            __BrowserGetter.meta["minimal-ui"] = "true";
            __BrowserGetter.availWidth = function(frame) {
                return frame.clientWidth;
            };
            __BrowserGetter.availHeight = function(frame) {
                return frame.clientHeight;
            };
            break;

          case cc.sys.BROWSER_TYPE_CHROME:
            __BrowserGetter.__defineGetter__("target-densitydpi", (function() {
                return cc.view._targetDensityDPI;
            }));
            break;

          case cc.sys.BROWSER_TYPE_SOUGOU:
          case cc.sys.BROWSER_TYPE_UC:
            __BrowserGetter.availWidth = function(frame) {
                return frame.clientWidth;
            };
            __BrowserGetter.availHeight = function(frame) {
                return frame.clientHeight;
            };
            break;

          case cc.sys.BROWSER_TYPE_MIUI:
            __BrowserGetter.init = function(view) {
                if (view.__resizeWithBrowserSize) {
                    return;
                }
                var resize = function() {
                    view.setDesignResolutionSize(view._designResolutionSize.width, view._designResolutionSize.height, view._resolutionPolicy);
                    window.removeEventListener("resize", resize, false);
                };
                window.addEventListener("resize", resize, false);
            };
        }
        var _scissorRect = null;
        var View = cc._Class.extend({
            ctor: function() {
                var _t = this, _strategyer = cc.ContainerStrategy, _strategy = cc.ContentStrategy;
                __BrowserGetter.init(this);
                _t._frameSize = cc.size(0, 0);
                _t._initFrameSize();
                var w = cc.game.canvas.width, h = cc.game.canvas.height;
                _t._designResolutionSize = cc.size(w, h);
                _t._originalDesignResolutionSize = cc.size(w, h);
                _t._viewPortRect = cc.rect(0, 0, w, h);
                _t._visibleRect = cc.rect(0, 0, w, h);
                _t._contentTranslateLeftTop = {
                    left: 0,
                    top: 0
                };
                _t._autoFullScreen = false;
                _t._devicePixelRatio = 1;
                _t._viewName = "Cocos2dHTML5";
                _t._resizeCallback = null;
                _t._orientationChanging = true;
                _t._resizing = false;
                _t._scaleX = 1;
                _t._originalScaleX = 1;
                _t._scaleY = 1;
                _t._originalScaleY = 1;
                _t._isRotated = false;
                _t._orientation = 3;
                var sys = cc.sys;
                _t.enableRetina(sys.os === sys.OS_IOS || sys.os === sys.OS_OSX);
                cc.visibleRect && cc.visibleRect.init(_t._visibleRect);
                _t._resolutionPolicy = null;
                _t._rpExactFit = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
                _t._rpShowAll = new cc.ResolutionPolicy(_strategyer.PROPORTION_TO_FRAME, _strategy.SHOW_ALL);
                _t._rpNoBorder = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
                _t._rpFixedHeight = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
                _t._rpFixedWidth = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
                _t._initialized = false;
                _t._contentTranslateLeftTop = null;
                _t._frameZoomFactor = 1;
                _t.__resizeWithBrowserSize = false;
                _t._isAdjustViewPort = true;
                _t._targetDensityDPI = cc.macro.DENSITYDPI_HIGH;
                _t.enableAntiAlias(true);
            },
            _resizeEvent: function() {
                var view;
                view = this.setDesignResolutionSize ? this : cc.view;
                var prevFrameW = view._frameSize.width, prevFrameH = view._frameSize.height, prevRotated = view._isRotated;
                if (cc.sys.isMobile) {
                    var containerStyle = cc.game.container.style, margin = containerStyle.margin;
                    containerStyle.margin = "0";
                    containerStyle.display = "none";
                    view._initFrameSize();
                    containerStyle.margin = margin;
                    containerStyle.display = "block";
                } else {
                    view._initFrameSize();
                }
                if (view._isRotated === prevRotated && view._frameSize.width === prevFrameW && view._frameSize.height === prevFrameH) {
                    return;
                }
                var width = view._originalDesignResolutionSize.width;
                var height = view._originalDesignResolutionSize.height;
                view._resizing = true;
                width > 0 && view.setDesignResolutionSize(width, height, view._resolutionPolicy);
                view._resizing = false;
                cc.eventManager.dispatchCustomEvent("canvas-resize");
                view._resizeCallback && view._resizeCallback.call();
            },
            _orientationChange: function() {
                cc.view._orientationChanging = true;
                cc.view._resizeEvent();
            },
            setTargetDensityDPI: function(densityDPI) {
                this._targetDensityDPI = densityDPI;
                this._adjustViewportMeta();
            },
            getTargetDensityDPI: function() {
                return this._targetDensityDPI;
            },
            resizeWithBrowserSize: function(enabled) {
                if (enabled) {
                    if (!this.__resizeWithBrowserSize) {
                        this.__resizeWithBrowserSize = true;
                        window.addEventListener("resize", this._resizeEvent);
                        window.addEventListener("orientationchange", this._orientationChange);
                    }
                } else {
                    if (this.__resizeWithBrowserSize) {
                        this.__resizeWithBrowserSize = false;
                        window.removeEventListener("resize", this._resizeEvent);
                        window.removeEventListener("orientationchange", this._orientationChange);
                    }
                }
            },
            setResizeCallback: function(callback) {
                "function" !== typeof callback && null != callback || (this._resizeCallback = callback);
            },
            setOrientation: function(orientation) {
                orientation &= cc.macro.ORIENTATION_AUTO;
                if (orientation && this._orientation !== orientation) {
                    this._orientation = orientation;
                    var designWidth = this._originalDesignResolutionSize.width;
                    var designHeight = this._originalDesignResolutionSize.height;
                    this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
                }
            },
            _initFrameSize: function() {
                var locFrameSize = this._frameSize;
                var w = __BrowserGetter.availWidth(cc.game.frame);
                var h = __BrowserGetter.availHeight(cc.game.frame);
                var isLandscape = w >= h;
                if (!cc.sys.isMobile || isLandscape && this._orientation & cc.macro.ORIENTATION_LANDSCAPE || !isLandscape && this._orientation & cc.macro.ORIENTATION_PORTRAIT) {
                    locFrameSize.width = w;
                    locFrameSize.height = h;
                    cc.container.style["-webkit-transform"] = "rotate(0deg)";
                    cc.container.style.transform = "rotate(0deg)";
                    this._isRotated = false;
                } else {
                    locFrameSize.width = h;
                    locFrameSize.height = w;
                    cc.container.style["-webkit-transform"] = "rotate(90deg)";
                    cc.container.style.transform = "rotate(90deg)";
                    cc.container.style["-webkit-transform-origin"] = "0px 0px 0px";
                    cc.container.style.transformOrigin = "0px 0px 0px";
                    this._isRotated = true;
                }
                this._orientationChanging && setTimeout((function() {
                    cc.view._orientationChanging = false;
                }), 1e3);
            },
            _adjustSizeKeepCanvasSize: function() {
                var designWidth = this._originalDesignResolutionSize.width;
                var designHeight = this._originalDesignResolutionSize.height;
                designWidth > 0 && this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
            },
            _setViewportMeta: function(metas, overwrite) {
                var vp = document.getElementById("cocosMetaElement");
                vp && overwrite && document.head.removeChild(vp);
                var elems = document.getElementsByName("viewport"), currentVP = elems ? elems[0] : null, content, key, pattern;
                content = currentVP ? currentVP.content : "";
                vp = vp || document.createElement("meta");
                vp.id = "cocosMetaElement";
                vp.name = "viewport";
                vp.content = "";
                for (key in metas) {
                    if (content.indexOf(key) == -1) {
                        content += "," + key + "=" + metas[key];
                    } else {
                        if (overwrite) {
                            pattern = new RegExp(key + "s*=s*[^,]+");
                            content.replace(pattern, key + "=" + metas[key]);
                        }
                    }
                }
                /^,/.test(content) && (content = content.substr(1));
                vp.content = content;
                currentVP && (currentVP.content = content);
                document.head.appendChild(vp);
            },
            _adjustViewportMeta: function() {
                if (this._isAdjustViewPort) {
                    this._setViewportMeta(__BrowserGetter.meta, false);
                    this._isAdjustViewPort = false;
                }
            },
            _resetScale: function() {
                this._scaleX = this._originalScaleX;
                this._scaleY = this._originalScaleY;
            },
            _adjustSizeToBrowser: function() {},
            initialize: function() {
                this._initialized = true;
            },
            adjustViewPort: function(enabled) {
                this._isAdjustViewPort = enabled;
            },
            enableRetina: function(enabled) {
                this._retinaEnabled = !!enabled;
            },
            isRetinaEnabled: function() {
                return this._retinaEnabled;
            },
            enableAntiAlias: function(enabled) {
                if (this._antiAliasEnabled === enabled) {
                    return;
                }
                this._antiAliasEnabled = enabled;
                if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                    var cache = cc.loader._cache;
                    for (var key in cache) {
                        var item = cache[key];
                        var tex = item && item.content instanceof cc.Texture2D ? item.content : null;
                        tex && (enabled ? tex.setAntiAliasTexParameters() : tex.setAliasTexParameters());
                    }
                } else {
                    if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                        var ctx = cc._canvas.getContext("2d");
                        ctx.imageSmoothingEnabled = enabled;
                        ctx.mozImageSmoothingEnabled = enabled;
                        var dirtyRegion = cc.rendererCanvas._dirtyRegion;
                        if (dirtyRegion) {
                            var oldRegion = new cc.Region();
                            oldRegion.setTo(0, 0, cc.visibleRect.width, cc.visibleRect.height);
                            dirtyRegion.addRegion(oldRegion);
                        }
                    }
                }
            },
            isAntiAliasEnabled: function() {
                return this._antiAliasEnabled;
            },
            enableAutoFullScreen: function(enabled) {
                if (enabled && enabled !== this._autoFullScreen && cc.sys.isMobile && cc.sys.browserType !== cc.sys.BROWSER_TYPE_WECHAT) {
                    this._autoFullScreen = true;
                    cc.screen.autoFullScreen(cc.game.frame);
                } else {
                    this._autoFullScreen = false;
                }
            },
            isAutoFullScreenEnabled: function() {
                return this._autoFullScreen;
            },
            isViewReady: function() {
                return cc.game.canvas && cc._renderContext;
            },
            setFrameZoomFactor: function(zoomFactor) {
                this._frameZoomFactor = zoomFactor;
                cc.director.setProjection(cc.director.getProjection());
            },
            setContentTranslateLeftTop: function(offsetLeft, offsetTop) {
                this._contentTranslateLeftTop = {
                    left: offsetLeft,
                    top: offsetTop
                };
            },
            getContentTranslateLeftTop: function() {
                return this._contentTranslateLeftTop;
            },
            setCanvasSize: function(width, height) {
                var canvas = cc.game.canvas;
                var container = cc.game.container;
                canvas.width = width * this._devicePixelRatio;
                canvas.height = height * this._devicePixelRatio;
                canvas.style.width = width + "px";
                canvas.style.height = height + "px";
                container.style.width = width + "px";
                container.style.height = height + "px";
                this._resizeEvent();
            },
            getCanvasSize: function() {
                return cc.size(cc.game.canvas.width, cc.game.canvas.height);
            },
            getFrameSize: function() {
                return cc.size(this._frameSize.width, this._frameSize.height);
            },
            setFrameSize: function(width, height) {
                this._frameSize.width = width;
                this._frameSize.height = height;
                cc.game.frame.style.width = width + "px";
                cc.game.frame.style.height = height + "px";
                this._resizeEvent();
                cc.director.setProjection(cc.director.getProjection());
            },
            getVisibleSize: function() {
                return cc.size(this._visibleRect.width, this._visibleRect.height);
            },
            getVisibleSizeInPixel: function() {
                return cc.size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
            },
            getVisibleOrigin: function() {
                return cc.p(this._visibleRect.x, this._visibleRect.y);
            },
            getVisibleOriginInPixel: function() {
                return cc.p(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
            },
            canSetContentScaleFactor: function() {
                return true;
            },
            getResolutionPolicy: function() {
                return this._resolutionPolicy;
            },
            setResolutionPolicy: function(resolutionPolicy) {
                var _t = this;
                if (resolutionPolicy instanceof cc.ResolutionPolicy) {
                    _t._resolutionPolicy = resolutionPolicy;
                } else {
                    var _locPolicy = cc.ResolutionPolicy;
                    resolutionPolicy === _locPolicy.EXACT_FIT && (_t._resolutionPolicy = _t._rpExactFit);
                    resolutionPolicy === _locPolicy.SHOW_ALL && (_t._resolutionPolicy = _t._rpShowAll);
                    resolutionPolicy === _locPolicy.NO_BORDER && (_t._resolutionPolicy = _t._rpNoBorder);
                    resolutionPolicy === _locPolicy.FIXED_HEIGHT && (_t._resolutionPolicy = _t._rpFixedHeight);
                    resolutionPolicy === _locPolicy.FIXED_WIDTH && (_t._resolutionPolicy = _t._rpFixedWidth);
                }
            },
            setDesignResolutionSize: function(width, height, resolutionPolicy) {
                if (!(width > 0 || height > 0)) {
                    cc.logID(2200);
                    return;
                }
                this.setResolutionPolicy(resolutionPolicy);
                var policy = this._resolutionPolicy;
                policy && policy.preApply(this);
                cc.sys.isMobile && this._adjustViewportMeta();
                this._orientationChanging = true;
                this._resizing || this._initFrameSize();
                if (!policy) {
                    cc.logID(2201);
                    return;
                }
                this._originalDesignResolutionSize.width = this._designResolutionSize.width = width;
                this._originalDesignResolutionSize.height = this._designResolutionSize.height = height;
                var result = policy.apply(this, this._designResolutionSize);
                if (result.scale && 2 === result.scale.length) {
                    this._scaleX = result.scale[0];
                    this._scaleY = result.scale[1];
                }
                if (result.viewport) {
                    var vp = this._viewPortRect, vb = this._visibleRect, rv = result.viewport;
                    vp.x = rv.x;
                    vp.y = rv.y;
                    vp.width = rv.width;
                    vp.height = rv.height;
                    vb.x = -vp.x / this._scaleX;
                    vb.y = -vp.y / this._scaleY;
                    vb.width = cc.game.canvas.width / this._scaleX;
                    vb.height = cc.game.canvas.height / this._scaleY;
                    cc._renderContext.setOffset && cc._renderContext.setOffset(vp.x, -vp.y);
                }
                var director = cc.director;
                director._winSizeInPoints.width = this._designResolutionSize.width;
                director._winSizeInPoints.height = this._designResolutionSize.height;
                policy.postApply(this);
                cc.winSize.width = director._winSizeInPoints.width;
                cc.winSize.height = director._winSizeInPoints.height;
                cc._renderType === cc.game.RENDER_TYPE_WEBGL ? director.setGLDefaultValues() : cc._renderType === cc.game.RENDER_TYPE_CANVAS && (cc.renderer._allNeedDraw = true);
                this._originalScaleX = this._scaleX;
                this._originalScaleY = this._scaleY;
                cc.visibleRect && cc.visibleRect.init(this._visibleRect);
            },
            getDesignResolutionSize: function() {
                return cc.size(this._designResolutionSize.width, this._designResolutionSize.height);
            },
            setRealPixelResolution: function(width, height, resolutionPolicy) {
                this._setViewportMeta({
                    width: width
                }, true);
                document.documentElement.style.width = width + "px";
                document.body.style.width = width + "px";
                document.body.style.left = "0px";
                document.body.style.top = "0px";
                this.setDesignResolutionSize(width, height, resolutionPolicy);
            },
            setViewPortInPoints: function(x, y, w, h) {
                var locFrameZoomFactor = this._frameZoomFactor, locScaleX = this._scaleX, locScaleY = this._scaleY;
                cc._renderContext.viewport(x * locScaleX * locFrameZoomFactor + this._viewPortRect.x * locFrameZoomFactor, y * locScaleY * locFrameZoomFactor + this._viewPortRect.y * locFrameZoomFactor, w * locScaleX * locFrameZoomFactor, h * locScaleY * locFrameZoomFactor);
            },
            setScissorInPoints: function(x, y, w, h) {
                var zoomFactor = this._frameZoomFactor, scaleX = this._scaleX, scaleY = this._scaleY;
                var sx = Math.ceil(x * scaleX * zoomFactor + this._viewPortRect.x * zoomFactor);
                var sy = Math.ceil(y * scaleY * zoomFactor + this._viewPortRect.y * zoomFactor);
                var sw = Math.ceil(w * scaleX * zoomFactor);
                var sh = Math.ceil(h * scaleY * zoomFactor);
                if (!_scissorRect) {
                    var boxArr = gl.getParameter(gl.SCISSOR_BOX);
                    _scissorRect = cc.rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
                }
                if (_scissorRect.x !== sx || _scissorRect.y !== sy || _scissorRect.width !== sw || _scissorRect.height !== sh) {
                    _scissorRect.x = sx;
                    _scissorRect.y = sy;
                    _scissorRect.width = sw;
                    _scissorRect.height = sh;
                    cc._renderContext.scissor(sx, sy, sw, sh);
                }
            },
            isScissorEnabled: function() {
                return cc._renderContext.isEnabled(gl.SCISSOR_TEST);
            },
            getScissorRect: function() {
                if (!_scissorRect) {
                    var boxArr = gl.getParameter(gl.SCISSOR_BOX);
                    _scissorRect = cc.rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
                }
                var scaleXFactor = 1 / this._scaleX;
                var scaleYFactor = 1 / this._scaleY;
                return cc.rect((_scissorRect.x - this._viewPortRect.x) * scaleXFactor, (_scissorRect.y - this._viewPortRect.y) * scaleYFactor, _scissorRect.width * scaleXFactor, _scissorRect.height * scaleYFactor);
            },
            setViewName: function(viewName) {
                null != viewName && viewName.length > 0 && (this._viewName = viewName);
            },
            getViewName: function() {
                return this._viewName;
            },
            getViewPortRect: function() {
                return this._viewPortRect;
            },
            getScaleX: function() {
                return this._scaleX;
            },
            getScaleY: function() {
                return this._scaleY;
            },
            getDevicePixelRatio: function() {
                return this._devicePixelRatio;
            },
            convertToLocationInView: function(tx, ty, relatedPos) {
                var x = this._devicePixelRatio * (tx - relatedPos.left);
                var y = this._devicePixelRatio * (relatedPos.top + relatedPos.height - ty);
                return this._isRotated ? {
                    x: this._viewPortRect.width - y,
                    y: x
                } : {
                    x: x,
                    y: y
                };
            },
            _convertMouseToLocationInView: function(point, relatedPos) {
                var viewport = this._viewPortRect, _t = this;
                point.x = (_t._devicePixelRatio * (point.x - relatedPos.left) - viewport.x) / _t._scaleX;
                point.y = (_t._devicePixelRatio * (relatedPos.top + relatedPos.height - point.y) - viewport.y) / _t._scaleY;
            },
            _convertPointWithScale: function(point) {
                var viewport = this._viewPortRect;
                point.x = (point.x - viewport.x) / this._scaleX;
                point.y = (point.y - viewport.y) / this._scaleY;
            },
            _convertTouchesWithScale: function(touches) {
                var viewport = this._viewPortRect, scaleX = this._scaleX, scaleY = this._scaleY, selTouch, selPoint, selPrePoint;
                for (var i = 0; i < touches.length; i++) {
                    selTouch = touches[i];
                    selPoint = selTouch._point;
                    selPrePoint = selTouch._prevPoint;
                    selPoint.x = (selPoint.x - viewport.x) / scaleX;
                    selPoint.y = (selPoint.y - viewport.y) / scaleY;
                    selPrePoint.x = (selPrePoint.x - viewport.x) / scaleX;
                    selPrePoint.y = (selPrePoint.y - viewport.y) / scaleY;
                }
            }
        });
        View._getInstance = function() {
            if (!this._instance) {
                this._instance = this._instance || new View();
                this._instance.initialize();
            }
            return this._instance;
        };
        cc.ContainerStrategy = cc._Class.extend({
            preApply: function(view) {},
            apply: function(view, designedResolution) {},
            postApply: function(view) {},
            _setupContainer: function(view, w, h) {
                var locCanvas = cc.game.canvas, locContainer = cc.game.container;
                if (cc.sys.os === cc.sys.OS_ANDROID) {
                    document.body.style.width = (view._isRotated ? h : w) + "px";
                    document.body.style.height = (view._isRotated ? w : h) + "px";
                }
                locContainer.style.width = locCanvas.style.width = w + "px";
                locContainer.style.height = locCanvas.style.height = h + "px";
                var devicePixelRatio = view._devicePixelRatio = 1;
                view.isRetinaEnabled() && (devicePixelRatio = view._devicePixelRatio = Math.min(2, window.devicePixelRatio || 1));
                locCanvas.width = w * devicePixelRatio;
                locCanvas.height = h * devicePixelRatio;
                cc._renderContext.resetCache && cc._renderContext.resetCache();
            },
            _fixContainer: function() {
                document.body.insertBefore(cc.container, document.body.firstChild);
                var bs = document.body.style;
                bs.width = window.innerWidth + "px";
                bs.height = window.innerHeight + "px";
                bs.overflow = "hidden";
                var contStyle = cc.container.style;
                contStyle.position = "fixed";
                contStyle.left = contStyle.top = "0px";
                document.body.scrollTop = 0;
            }
        });
        cc.ContentStrategy = cc._Class.extend({
            _result: {
                scale: [ 1, 1 ],
                viewport: null
            },
            _buildResult: function(containerW, containerH, contentW, contentH, scaleX, scaleY) {
                Math.abs(containerW - contentW) < 2 && (contentW = containerW);
                Math.abs(containerH - contentH) < 2 && (contentH = containerH);
                var viewport = cc.rect(Math.round((containerW - contentW) / 2), Math.round((containerH - contentH) / 2), contentW, contentH);
                cc._renderType === cc.game.RENDER_TYPE_CANVAS;
                this._result.scale = [ scaleX, scaleY ];
                this._result.viewport = viewport;
                return this._result;
            },
            preApply: function(view) {},
            apply: function(view, designedResolution) {
                return {
                    scale: [ 1, 1 ]
                };
            },
            postApply: function(view) {}
        });
        (function() {
            var EqualToFrame = cc.ContainerStrategy.extend({
                apply: function(view) {
                    var frameH = view._frameSize.height, containerStyle = cc.container.style;
                    this._setupContainer(view, view._frameSize.width, view._frameSize.height);
                    view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px";
                }
            });
            var ProportionalToFrame = cc.ContainerStrategy.extend({
                apply: function(view, designedResolution) {
                    var frameW = view._frameSize.width, frameH = view._frameSize.height, containerStyle = cc.container.style, designW = designedResolution.width, designH = designedResolution.height, scaleX = frameW / designW, scaleY = frameH / designH, containerW, containerH;
                    scaleX < scaleY ? (containerW = frameW, containerH = designH * scaleX) : (containerW = designW * scaleY, 
                    containerH = frameH);
                    var offx = Math.round((frameW - containerW) / 2);
                    var offy = Math.round((frameH - containerH) / 2);
                    containerW = frameW - 2 * offx;
                    containerH = frameH - 2 * offy;
                    this._setupContainer(view, containerW, containerH);
                    view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px";
                    containerStyle.paddingLeft = offx + "px";
                    containerStyle.paddingRight = offx + "px";
                    containerStyle.paddingTop = offy + "px";
                    containerStyle.paddingBottom = offy + "px";
                }
            });
            var EqualToWindow = EqualToFrame.extend({
                preApply: function(view) {
                    this._super(view);
                    cc.game.frame = document.documentElement;
                },
                apply: function(view) {
                    this._super(view);
                    this._fixContainer();
                }
            });
            var ProportionalToWindow = ProportionalToFrame.extend({
                preApply: function(view) {
                    this._super(view);
                    cc.game.frame = document.documentElement;
                },
                apply: function(view, designedResolution) {
                    this._super(view, designedResolution);
                    this._fixContainer();
                }
            });
            var OriginalContainer = cc.ContainerStrategy.extend({
                apply: function(view) {
                    this._setupContainer(view, cc.game.canvas.width, cc.game.canvas.height);
                }
            });
            cc.ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
            cc.ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();
            cc.ContainerStrategy.ORIGINAL_CONTAINER = new OriginalContainer();
            var ExactFit = cc.ContentStrategy.extend({
                apply: function(view, designedResolution) {
                    var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scaleX = containerW / designedResolution.width, scaleY = containerH / designedResolution.height;
                    return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
                }
            });
            var ShowAll = cc.ContentStrategy.extend({
                apply: function(view, designedResolution) {
                    var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale = 0, contentW, contentH;
                    scaleX < scaleY ? (scale = scaleX, contentW = containerW, contentH = designH * scale) : (scale = scaleY, 
                    contentW = designW * scale, contentH = containerH);
                    return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }
            });
            var NoBorder = cc.ContentStrategy.extend({
                apply: function(view, designedResolution) {
                    var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale, contentW, contentH;
                    scaleX < scaleY ? (scale = scaleY, contentW = designW * scale, contentH = containerH) : (scale = scaleX, 
                    contentW = containerW, contentH = designH * scale);
                    return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                }
            });
            var FixedHeight = cc.ContentStrategy.extend({
                apply: function(view, designedResolution) {
                    var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designH = designedResolution.height, scale = containerH / designH, contentW = containerW, contentH = containerH;
                    return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                },
                postApply: function(view) {
                    cc.director._winSizeInPoints = view.getVisibleSize();
                }
            });
            var FixedWidth = cc.ContentStrategy.extend({
                apply: function(view, designedResolution) {
                    var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, scale = containerW / designW, contentW = containerW, contentH = containerH;
                    return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
                },
                postApply: function(view) {
                    cc.director._winSizeInPoints = view.getVisibleSize();
                }
            });
            cc.ContentStrategy.EXACT_FIT = new ExactFit();
            cc.ContentStrategy.SHOW_ALL = new ShowAll();
            cc.ContentStrategy.NO_BORDER = new NoBorder();
            cc.ContentStrategy.FIXED_HEIGHT = new FixedHeight();
            cc.ContentStrategy.FIXED_WIDTH = new FixedWidth();
        })();
        cc.ResolutionPolicy = cc._Class.extend({
            _containerStrategy: null,
            _contentStrategy: null,
            ctor: function(containerStg, contentStg) {
                this.setContainerStrategy(containerStg);
                this.setContentStrategy(contentStg);
            },
            preApply: function(view) {
                this._containerStrategy.preApply(view);
                this._contentStrategy.preApply(view);
            },
            apply: function(view, designedResolution) {
                this._containerStrategy.apply(view, designedResolution);
                return this._contentStrategy.apply(view, designedResolution);
            },
            postApply: function(view) {
                this._containerStrategy.postApply(view);
                this._contentStrategy.postApply(view);
            },
            setContainerStrategy: function(containerStg) {
                containerStg instanceof cc.ContainerStrategy && (this._containerStrategy = containerStg);
            },
            setContentStrategy: function(contentStg) {
                contentStg instanceof cc.ContentStrategy && (this._contentStrategy = contentStg);
            }
        });
        cc.js.get(cc.ResolutionPolicy.prototype, "canvasSize", (function() {
            return cc.v2(cc.game.canvas.width, cc.game.canvas.height);
        }));
        cc.ResolutionPolicy.EXACT_FIT = 0;
        cc.ResolutionPolicy.NO_BORDER = 1;
        cc.ResolutionPolicy.SHOW_ALL = 2;
        cc.ResolutionPolicy.FIXED_HEIGHT = 3;
        cc.ResolutionPolicy.FIXED_WIDTH = 4;
        cc.ResolutionPolicy.UNKNOWN = 5;
        module.exports = View;
    }), {} ],
    184: [ (function(require, module, exports) {
        cc.visibleRect = {
            topLeft: cc.p(0, 0),
            topRight: cc.p(0, 0),
            top: cc.p(0, 0),
            bottomLeft: cc.p(0, 0),
            bottomRight: cc.p(0, 0),
            bottom: cc.p(0, 0),
            center: cc.p(0, 0),
            left: cc.p(0, 0),
            right: cc.p(0, 0),
            width: 0,
            height: 0,
            init: function(visibleRect) {
                var w = this.width = visibleRect.width;
                var h = this.height = visibleRect.height;
                var l = visibleRect.x, b = visibleRect.y, t = b + h, r = l + w;
                this.topLeft.x = l;
                this.topLeft.y = t;
                this.topRight.x = r;
                this.topRight.y = t;
                this.top.x = l + w / 2;
                this.top.y = t;
                this.bottomLeft.x = l;
                this.bottomLeft.y = b;
                this.bottomRight.x = r;
                this.bottomRight.y = b;
                this.bottom.x = l + w / 2;
                this.bottom.y = b;
                this.center.x = l + w / 2;
                this.center.y = b + h / 2;
                this.left.x = l;
                this.left.y = b + h / 2;
                this.right.x = r;
                this.right.y = b + h / 2;
            }
        };
    }), {} ],
    185: [ (function(require, module, exports) {
        var ClassManager = cc.ClassManager = {
            id: 0 | 998 * Math.random(),
            instanceId: 0 | 998 * Math.random(),
            getNewID: function() {
                return this.id++;
            },
            getNewInstanceId: function() {
                return this.instanceId++;
            }
        };
        var fnTest = /\b_super\b/;
        var Class = function() {};
        Class.extend = function(props) {
            var _super = this.prototype;
            var proto = Object.create(_super);
            var desc = {
                writable: true,
                enumerable: false,
                configurable: true
            };
            var TheClass;
            if (cc.game && cc.game.config && cc.game.config[cc.game.CONFIG_KEY.exposeClassName]) {
                var ctor = "return (function " + (props._className || "Class") + "(arg0,arg1,arg2,arg3,arg4) {\nthis.__instanceId = cc.ClassManager.getNewInstanceId();\nif (this.ctor) {\nswitch (arguments.length) {\ncase 0: this.ctor(); break;\ncase 1: this.ctor(arg0); break;\ncase 2: this.ctor(arg0,arg1); break;\ncase 3: this.ctor(arg0,arg1,arg2); break;\ncase 4: this.ctor(arg0,arg1,arg2,arg3); break;\ncase 5: this.ctor(arg0,arg1,arg2,arg3,arg4); break;\ndefault: this.ctor.apply(this, arguments);\n}\n}\n});";
                TheClass = Function(ctor)();
            } else {
                TheClass = function(arg0, arg1, arg2, arg3, arg4) {
                    this.__instanceId = ClassManager.getNewInstanceId();
                    if (this.ctor) {
                        switch (arguments.length) {
                          case 0:
                            this.ctor();
                            break;

                          case 1:
                            this.ctor(arg0);
                            break;

                          case 2:
                            this.ctor(arg0, arg1);
                            break;

                          case 3:
                            this.ctor(arg0, arg1, arg2);
                            break;

                          case 4:
                            this.ctor(arg0, arg1, arg2, arg3);
                            break;

                          case 5:
                            this.ctor(arg0, arg1, arg2, arg3, arg4);
                            break;

                          default:
                            this.ctor.apply(this, arguments);
                        }
                    }
                };
            }
            desc.value = ClassManager.getNewID();
            Object.defineProperty(proto, "__pid", desc);
            TheClass.prototype = proto;
            desc.value = TheClass;
            Object.defineProperty(proto, "constructor", desc);
            for (var name in props) {
                var isFunc = "function" === typeof props[name];
                var override = isFunc && "function" === typeof _super[name];
                var hasSuperCall = override && fnTest.test(props[name]);
                if (hasSuperCall) {
                    desc.value = (function(name, fn) {
                        return function() {
                            var tmp = this._super;
                            this._super = _super[name];
                            var ret = fn.apply(this, arguments);
                            this._super = tmp;
                            return ret;
                        };
                    })(name, props[name]);
                    Object.defineProperty(proto, name, desc);
                } else {
                    if (isFunc) {
                        desc.value = props[name];
                        Object.defineProperty(proto, name, desc);
                    } else {
                        proto[name] = props[name];
                    }
                }
            }
            TheClass.extend = Class.extend;
            TheClass.implement = function(prop) {
                for (var name in prop) {
                    proto[name] = prop[name];
                }
            };
            return TheClass;
        };
        cc.defineGetterSetter = function(proto, prop, getter, setter, getterName, setterName) {
            if (proto.__defineGetter__) {
                getter && proto.__defineGetter__(prop, getter);
                setter && proto.__defineSetter__(prop, setter);
            } else {
                if (!Object.defineProperty) {
                    throw new Error("browser does not support getters");
                }
                var desc = {
                    configurable: true
                };
                getter && (desc.get = getter);
                setter && (desc.set = setter);
                Object.defineProperty(proto, prop, desc);
            }
        };
        cc.clone = function(obj) {
            var newObj = obj.constructor ? new obj.constructor() : {};
            for (var key in obj) {
                var copy = obj[key];
                "object" !== typeof copy || !copy || copy instanceof _ccsg.Node || copy instanceof HTMLElement ? newObj[key] = copy : newObj[key] = cc.clone(copy);
            }
            return newObj;
        };
        cc._Class = module.exports = Class;
    }), {} ],
    186: [ (function(require, module, exports) {
        var JS = require("./js");
        var isPlainEmptyObj = require("./utils").isPlainEmptyObj_DEV;
        var DELIMETER = "$_$";
        function createAttrsSingle(owner, ownerCtor, superAttrs) {
            var AttrsCtor;
            var ctorName = ownerCtor.name;
            ctorName += owner === ownerCtor ? "_ATTRS" : "_ATTRS_INSTANCE";
            AttrsCtor = Function("return (function " + ctorName + "(){});")();
            superAttrs && JS.extend(AttrsCtor, superAttrs.constructor);
            var attrs = new AttrsCtor();
            JS.value(owner, "__attrs__", attrs);
            return attrs;
        }
        function createAttrs(subclass) {
            var superClass;
            var chains = cc.Class.getInheritanceChain(subclass);
            for (var i = chains.length - 1; i >= 0; i--) {
                var cls = chains[i];
                var attrs = cls.hasOwnProperty("__attrs__") && cls.__attrs__;
                if (!attrs) {
                    superClass = chains[i + 1];
                    createAttrsSingle(cls, cls, superClass && superClass.__attrs__);
                }
            }
            superClass = chains[0];
            createAttrsSingle(subclass, subclass, superClass && superClass.__attrs__);
            return subclass.__attrs__;
        }
        function attr(ctor, propName, newAttrs) {
            var attrs, setter, key;
            if ("function" === typeof ctor) {
                attrs = getClassAttrs(ctor);
                setter = attrs.constructor.prototype;
            } else {
                var instance = ctor;
                attrs = instance.__attrs__;
                if (!attrs) {
                    ctor = instance.constructor;
                    var clsAttrs = getClassAttrs(ctor);
                    attrs = createAttrsSingle(instance, ctor, clsAttrs);
                }
                setter = attrs;
            }
            if ("undefined" === typeof newAttrs) {
                var prefix = propName + DELIMETER;
                var ret = {};
                for (key in attrs) {
                    key.startsWith(prefix) && (ret[key.slice(prefix.length)] = attrs[key]);
                }
                return ret;
            }
            if ("object" === typeof newAttrs) {
                for (key in newAttrs) {
                    95 !== key.charCodeAt(0) && (setter[propName + DELIMETER + key] = newAttrs[key]);
                }
            } else {
                cc.errorID(3629);
            }
        }
        function getClassAttrs(ctor) {
            return ctor.hasOwnProperty("__attrs__") && ctor.__attrs__ || createAttrs(ctor);
        }
        function getClassAttrsProto(ctor) {
            return getClassAttrs(ctor).constructor.prototype;
        }
        function setClassAttr(ctor, propName, key, value) {
            var proto = getClassAttrsProto(ctor);
            proto[propName + DELIMETER + key] = value;
        }
        cc.Integer = "Integer";
        cc.Float = "Float";
        cc.Boolean = "Boolean";
        cc.String = "String";
        function getTypeChecker(type, attrName) {
            return function(constructor, mainPropName) {
                var propInfo = '"' + JS.getClassName(constructor) + "." + mainPropName + '"';
                var mainPropAttrs = attr(constructor, mainPropName);
                if (!mainPropAttrs.saveUrlAsAsset) {
                    var mainPropAttrsType = mainPropAttrs.type;
                    mainPropAttrsType !== cc.Integer && mainPropAttrsType !== cc.Float || (mainPropAttrsType = "Number");
                    if (mainPropAttrsType !== type) {
                        cc.warnID(3604, propInfo);
                        return;
                    }
                }
                if (!mainPropAttrs.hasOwnProperty("default")) {
                    return;
                }
                var defaultVal = mainPropAttrs.default;
                if ("undefined" === typeof defaultVal) {
                    return;
                }
                var isContainer = Array.isArray(defaultVal) || isPlainEmptyObj(defaultVal);
                if (isContainer) {
                    return;
                }
                var defaultType = typeof defaultVal;
                var type_lowerCase = type.toLowerCase();
                if (defaultType === type_lowerCase) {
                    if (!mainPropAttrs.saveUrlAsAsset) {
                        if ("object" === type_lowerCase) {
                            if (!defaultVal || defaultVal instanceof mainPropAttrs.ctor) {
                                return;
                            }
                            cc.warnID(3605, propInfo, JS.getClassName(mainPropAttrs.ctor));
                        } else {
                            "Number" !== type && cc.warnID(3606, attrName, propInfo, type);
                        }
                    }
                } else {
                    if ("function" === defaultType) {
                        return;
                    }
                    if (type === cc.String && null == defaultVal) {
                        cc.isChildClassOf(mainPropAttrs.ctor, cc.RawAsset) || cc.warnID(3607, propInfo);
                    } else {
                        if (mainPropAttrs.ctor !== String || "string" !== defaultType && null != defaultVal) {
                            if (mainPropAttrs.ctor === Boolean && "boolean" === defaultType) {
                                mainPropAttrs.type = cc.Boolean;
                                cc.warnID(3609, propInfo);
                            } else {
                                if (mainPropAttrs.ctor === Number && "number" === defaultType) {
                                    mainPropAttrs.type = cc.Float;
                                    cc.warnID(3610, propInfo);
                                } else {
                                    cc.warnID(3611, attrName, propInfo, defaultType);
                                }
                            }
                        } else {
                            mainPropAttrs.type = cc.String;
                            cc.warnID(3608, propInfo);
                        }
                    }
                }
                delete mainPropAttrs.type;
            };
        }
        function ObjectType(typeCtor) {
            return {
                type: "Object",
                ctor: typeCtor,
                _onAfterProp: function(classCtor, mainPropName) {
                    getTypeChecker("Object", "type")(classCtor, mainPropName);
                    var defaultDef = getClassAttrs(classCtor)[mainPropName + DELIMETER + "default"];
                    var defaultVal = require("./CCClass").getDefault(defaultDef);
                    if (!Array.isArray(defaultVal) && cc.isChildClassOf(typeCtor, cc.ValueType)) {
                        var typename = JS.getClassName(typeCtor);
                        var info = cc.js.formatStr('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', JS.getClassName(classCtor), mainPropName, typename);
                        defaultDef ? cc.log(info) : cc.warnID(3612, info, typename, JS.getClassName(classCtor), mainPropName, typename);
                    }
                }
            };
        }
        module.exports = {
            attr: attr,
            getClassAttrs: getClassAttrs,
            getClassAttrsProto: getClassAttrsProto,
            setClassAttr: setClassAttr,
            DELIMETER: DELIMETER,
            getTypeChecker: getTypeChecker,
            ObjectType: ObjectType,
            ScriptUuid: {}
        };
    }), {
        "./CCClass": 173,
        "./js": 193,
        "./utils": 198
    } ],
    187: [ (function(require, module, exports) {
        var JS = require("./js");
        var CallbacksHandler = function() {
            this._callbackTable = {};
            this._invoking = {};
            this._toRemove = {};
            this._toRemoveAll = null;
        };
        var REMOVE_PLACEHOLDER = {};
        CallbacksHandler.REMOVE_PLACEHOLDER = REMOVE_PLACEHOLDER;
        CallbacksHandler.prototype._clearToRemove = function(key) {
            var list = this._callbackTable[key];
            if (this._toRemove[key] && list) {
                var firstRemovedIndex = list.indexOf(REMOVE_PLACEHOLDER);
                var nextIndex = firstRemovedIndex;
                for (var i = firstRemovedIndex + 1; i < list.length; ++i) {
                    var item = list[i];
                    if (item !== REMOVE_PLACEHOLDER) {
                        list[nextIndex] = item;
                        ++nextIndex;
                    }
                }
                list.length = nextIndex;
                this._toRemove[key] = false;
            }
            if (this._toRemoveAll) {
                this.removeAll(this._toRemoveAll);
                this._toRemoveAll = null;
            }
        };
        CallbacksHandler.prototype.add = function(key, callback, target) {
            var list = this._callbackTable[key];
            if ("undefined" !== typeof list) {
                "object" === typeof target ? list.push(callback, target) : list.push(callback);
                return false;
            }
            list = "object" === typeof target ? [ callback, target ] : [ callback ];
            this._callbackTable[key] = list;
            return true;
        };
        CallbacksHandler.prototype.has = function(key, callback, target) {
            if (this._toRemoveAll === key) {
                return false;
            }
            var list = this._callbackTable[key], callbackTarget, index;
            if (!list) {
                return false;
            }
            if (!callback) {
                if (this._toRemove[key]) {
                    for (index = 0; index < list.length; index++) {
                        if (list[index] !== REMOVE_PLACEHOLDER) {
                            return true;
                        }
                    }
                    return false;
                }
                return list.length > 0;
            }
            if ("function" !== typeof callback) {
                return false;
            }
            index = list.indexOf(callback);
            while (index !== -1) {
                callbackTarget = list[index + 1];
                "object" !== typeof callbackTarget && (callbackTarget = void 0);
                if (callbackTarget === target) {
                    return true;
                }
                index = cc.js.array.indexOf.call(list, callback, index + 1);
            }
            return false;
        };
        CallbacksHandler.prototype.removeAll = function(key) {
            if (this._invoking[key]) {
                this._toRemoveAll = key;
                return;
            }
            if ("object" === typeof key) {
                var target = key, list, index, callback;
                for (key in this._callbackTable) {
                    list = this._callbackTable[key];
                    index = list.lastIndexOf(target);
                    while (index !== -1) {
                        callback = list[index - 1];
                        "function" === typeof callback ? list.splice(index - 1, 2) : list.splice(index, 1);
                        index = list.lastIndexOf(target);
                    }
                }
            } else {
                delete this._callbackTable[key];
                delete this._toRemove[key];
            }
        };
        CallbacksHandler.prototype.remove = function(key, callback, target) {
            var list = this._callbackTable[key], index, callbackTarget;
            if (list) {
                index = list.indexOf(callback);
                while (index !== -1) {
                    callbackTarget = list[index + 1];
                    "object" !== typeof callbackTarget && (callbackTarget = void 0);
                    if (callbackTarget === target) {
                        if (this._invoking[key]) {
                            list[index] = REMOVE_PLACEHOLDER;
                            callbackTarget && (list[index + 1] = REMOVE_PLACEHOLDER);
                            this._toRemove[key] = true;
                        } else {
                            list.splice(index, callbackTarget ? 2 : 1);
                        }
                        break;
                    }
                    index = cc.js.array.indexOf.call(list, callback, index + 1);
                }
                return true;
            }
            return false;
        };
        var CallbacksInvoker = function() {
            CallbacksHandler.call(this);
        };
        JS.extend(CallbacksInvoker, CallbacksHandler);
        CallbacksInvoker.prototype.invoke = function(key, p1, p2, p3, p4, p5) {
            this._invoking[key] = true;
            var list = this._callbackTable[key];
            if (list) {
                var i, endIndex = list.length - 1;
                for (i = 0; i <= endIndex; ) {
                    var callingFunc = list[i];
                    var increment = 1;
                    if (callingFunc !== REMOVE_PLACEHOLDER) {
                        var target = list[i + 1];
                        var hasTarget = target && "object" === typeof target;
                        if (hasTarget) {
                            callingFunc.call(target, p1, p2, p3, p4, p5);
                            increment = 2;
                        } else {
                            callingFunc(p1, p2, p3, p4, p5);
                        }
                    }
                    i += increment;
                }
            }
            this._invoking[key] = false;
            this._clearToRemove(key);
        };
        CallbacksInvoker.prototype.invokeAndRemove = function(key, p1, p2, p3, p4, p5) {
            this._invoking[key] = true;
            var list = this._callbackTable[key], i, l, increment, callingFunc, target;
            if (list) {
                for (i = 0, l = list.length; i < l; ) {
                    callingFunc = list[i];
                    increment = 1;
                    if (callingFunc !== REMOVE_PLACEHOLDER) {
                        target = list[i + 1];
                        if (target && "object" === typeof target) {
                            callingFunc.call(target, p1, p2, p3, p4, p5);
                            increment = 2;
                        } else {
                            callingFunc(p1, p2, p3, p4, p5);
                        }
                    }
                    i += increment;
                }
            }
            this._invoking[key] = false;
            this._toRemove[key] = false;
            this.removeAll(key);
        };
        CallbacksInvoker.prototype.bindKey = function(key, remove) {
            var self = this;
            return function bindedInvocation(p1, p2, p3, p4, p5) {
                var list = self._callbackTable[key], i, l, target;
                if (list) {
                    for (i = 0, l = list.length; i < l; ) {
                        target = list[i + 1];
                        if (target && "object" === typeof target) {
                            list[i].call(target, p1, p2, p3, p4, p5);
                            i += 2;
                        } else {
                            list[i](p1, p2, p3, p4, p5);
                            ++i;
                        }
                    }
                }
                remove && self.removeAll(key);
            };
        };
        CallbacksInvoker.CallbacksHandler = CallbacksHandler;
        module.exports = CallbacksInvoker;
    }), {
        "./js": 193
    } ],
    188: [ (function(require, module, exports) {
        var JS = require("./js");
        var CCObject = require("./CCObject");
        var Attr = require("./attribute");
        var CCClass = require("./CCClass");
        var Details = function() {
            this.uuidList = [];
            this.uuidObjList = [];
            this.uuidPropList = [];
            this.rawProp = "";
        };
        Details.prototype.reset = function() {
            this.uuidList.length = 0;
            this.uuidObjList.length = 0;
            this.uuidPropList.length = 0;
            this.rawProp = "";
        };
        Details.prototype.assignAssetsBy = function(getter) {
            for (var i = 0, len = this.uuidList.length; i < len; i++) {
                var uuid = this.uuidList[i];
                var obj = this.uuidObjList[i];
                var prop = this.uuidPropList[i];
                obj[prop] = getter(uuid);
            }
        };
        Details.prototype.getUuidOf = function(obj, propName) {
            for (var i = 0; i < this.uuidObjList.length; i++) {
                if (this.uuidObjList[i] === obj && this.uuidPropList[i] === propName) {
                    return this.uuidList[i];
                }
            }
            return "";
        };
        Details.prototype.push = function(obj, propName, uuid) {
            this.uuidList.push(uuid);
            this.uuidObjList.push(obj);
            this.uuidPropList.push(propName);
        };
        Details.pool = new JS.Pool(function(obj) {
            obj.reset();
        }, 10);
        Details.pool.get = function() {
            return this._get() || new Details();
        };
        var _Deserializer = (function() {
            function _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly) {
                this.result = result;
                this.customEnv = customEnv;
                this.deserializedList = [];
                this.deserializedData = null;
                this._classFinder = classFinder;
                this._target = target;
                this._ignoreEditorOnly = ignoreEditorOnly;
                this._idList = [];
                this._idObjList = [];
                this._idPropList = [];
            }
            function _dereference(self) {
                var deserializedList = self.deserializedList;
                var idPropList = self._idPropList;
                var idList = self._idList;
                var idObjList = self._idObjList;
                var onDereferenced = self._classFinder && self._classFinder.onDereferenced;
                var i, propName, id;
                for (i = 0; i < idList.length; i++) {
                    propName = idPropList[i];
                    id = idList[i];
                    idObjList[i][propName] = deserializedList[id];
                }
            }
            var prototype = _Deserializer.prototype;
            prototype.deserialize = function(jsonObj) {
                if (Array.isArray(jsonObj)) {
                    var jsonArray = jsonObj;
                    var refCount = jsonArray.length;
                    this.deserializedList.length = refCount;
                    for (var i = 0; i < refCount; i++) {
                        if (jsonArray[i]) {
                            var mainTarget;
                            this.deserializedList[i] = this._deserializeObject(jsonArray[i]);
                        }
                    }
                    this.deserializedData = refCount > 0 ? this.deserializedList[0] : [];
                } else {
                    this.deserializedList.length = 1;
                    this.deserializedData = jsonObj ? this._deserializeObject(jsonObj) : null;
                    this.deserializedList[0] = this.deserializedData;
                }
                _dereference(this);
                return this.deserializedData;
            };
            prototype._deserializeObject = function(serialized, target, owner, propName) {
                var prop;
                var obj = null;
                var klass = null;
                if (serialized.__type__) {
                    var type = serialized.__type__;
                    klass = this._classFinder(type, serialized, owner, propName);
                    if (!klass) {
                        var notReported = this._classFinder === JS._getClassById;
                        notReported && cc.deserialize.reportMissingClass(type);
                        return null;
                    }
                    obj = new klass();
                    if (obj._deserialize) {
                        obj._deserialize(serialized.content, this);
                        return obj;
                    }
                    cc.Class._isCCClass(klass) ? _deserializeFireClass(this, obj, serialized, klass, target) : this._deserializeTypedObject(obj, serialized, klass);
                } else {
                    if (Array.isArray(serialized)) {
                        obj = new Array(serialized.length);
                        for (var i = 0; i < serialized.length; i++) {
                            prop = serialized[i];
                            "object" === typeof prop && prop ? this._deserializeObjField(obj, prop, "" + i) : obj[i] = prop;
                        }
                    } else {
                        obj = {};
                        this._deserializePrimitiveObject(obj, serialized);
                    }
                }
                return obj;
            };
            prototype._deserializeObjField = function(obj, jsonObj, propName, target) {
                var id = jsonObj.__id__;
                if ("undefined" === typeof id) {
                    var uuid = jsonObj.__uuid__;
                    if (uuid) {
                        this.result.uuidList.push(uuid);
                        this.result.uuidObjList.push(obj);
                        this.result.uuidPropList.push(propName);
                    } else {
                        obj[propName] = this._deserializeObject(jsonObj);
                    }
                } else {
                    var dObj = this.deserializedList[id];
                    if (dObj) {
                        obj[propName] = dObj;
                    } else {
                        this._idList.push(id);
                        this._idObjList.push(obj);
                        this._idPropList.push(propName);
                    }
                }
            };
            prototype._deserializePrimitiveObject = function(instance, serialized) {
                var self = this;
                for (var propName in serialized) {
                    if (serialized.hasOwnProperty(propName)) {
                        var prop = serialized[propName];
                        "object" !== typeof prop ? "__type__" !== propName && (instance[propName] = prop) : prop ? self._deserializeObjField(instance, prop, propName) : instance[propName] = null;
                    }
                }
            };
            prototype._deserializeTypedObject = function(instance, serialized, klass) {
                if (klass === cc.Vec2) {
                    instance.x = serialized.x || 0;
                    instance.y = serialized.y || 0;
                    return;
                }
                if (klass === cc.Color) {
                    instance.r = serialized.r || 0;
                    instance.g = serialized.g || 0;
                    instance.b = serialized.b || 0;
                    var a = serialized.a;
                    instance.a = void 0 === a ? 255 : a;
                    return;
                }
                var fastDefinedProps = klass.__props__;
                fastDefinedProps || (fastDefinedProps = Object.keys(instance));
                for (var i = 0; i < fastDefinedProps.length; i++) {
                    var propName = fastDefinedProps[i];
                    var prop = serialized[propName];
                    "undefined" !== typeof prop && serialized.hasOwnProperty(propName) && ("object" !== typeof prop ? instance[propName] = prop : prop ? this._deserializeObjField(instance, prop, propName) : instance[propName] = null);
                }
            };
            function compileDeserialize(self, klass) {
                var RAW_TYPE = Attr.DELIMETER + "rawType";
                var EDITOR_ONLY = Attr.DELIMETER + "editorOnly";
                var SERIALIZABLE = Attr.DELIMETER + "serializable";
                var DEFAULT = Attr.DELIMETER + "default";
                var attrs = Attr.getClassAttrs(klass);
                var props = klass.__props__;
                var sources = [ "var prop;" ];
                for (var p = 0; p < props.length; p++) {
                    var propName = props[p];
                    var propNameLiteral;
                    var rawType = attrs[propName + RAW_TYPE];
                    if (rawType) {
                        propNameLiteral = CCClass.IDENTIFIER_RE.test(propName) ? '"' + propName + '"' : CCClass.escapeForJS(propName);
                        sources.push('if(s.result.rawProp)\ncc.error("not support multi raw object in a file");');
                        sources.push("s.result.rawProp=" + propNameLiteral + ";");
                    } else {
                        if (attrs[propName + EDITOR_ONLY]) {
                            var mayUsedInPersistRoot = "_id" === propName && cc.isChildClassOf(klass, cc.Node);
                            if (!mayUsedInPersistRoot) {
                                continue;
                            }
                        }
                        if (false === attrs[propName + SERIALIZABLE]) {
                            continue;
                        }
                        var accessor;
                        if (CCClass.IDENTIFIER_RE.test(propName)) {
                            propNameLiteral = '"' + propName + '"';
                            accessor = "." + propName;
                        } else {
                            propNameLiteral = CCClass.escapeForJS(propName);
                            accessor = "[" + propNameLiteral + "]";
                        }
                        sources.push("prop=d" + accessor + ";");
                        sources.push('if(typeof prop!=="undefined"){');
                        sources.push('if(typeof prop!=="object"){o' + accessor + "=prop;");
                        sources.push("}else{if(prop){");
                        var defaultValue = CCClass.getDefault(attrs[propName + DEFAULT]);
                        if (defaultValue instanceof cc.ValueType) {
                            var ctorCode = JS.getClassName(defaultValue);
                            sources.push("s._deserializeTypedObject(o" + accessor + ",prop," + ctorCode + ");");
                        } else {
                            sources.push("s._deserializeObjField(o,prop," + propNameLiteral + ");");
                        }
                        sources.push("}else o" + accessor + "=null;}}");
                    }
                }
                if ("_$erialized" === props[props.length - 1]) {
                    sources.push("o._$erialized=JSON.parse(JSON.stringify(d));");
                    sources.push("s._deserializePrimitiveObject(o._$erialized,d);");
                }
                return Function("s", "o", "d", "k", "t", sources.join(""));
            }
            function unlinkUnusedPrefab(self, serialized, obj) {
                var uuid = serialized["asset"] && serialized["asset"].__uuid__;
                if (uuid) {
                    var last = self.result.uuidList.length - 1;
                    if (self.result.uuidList[last] === uuid && self.result.uuidObjList[last] === obj && "asset" === self.result.uuidPropList[last]) {
                        self.result.uuidList.pop();
                        self.result.uuidObjList.pop();
                        self.result.uuidPropList.pop();
                    } else {
                        var debugEnvOnlyInfo = "Failed to skip prefab asset while deserializing PrefabInfo";
                        cc.warn(debugEnvOnlyInfo);
                    }
                }
            }
            function _deserializeFireClass(self, obj, serialized, klass, target) {
                var deserialize = klass.__deserialize__;
                if (!deserialize) {
                    deserialize = compileDeserialize(self, klass);
                    JS.value(klass, "__deserialize__", deserialize, true);
                }
                deserialize(self, obj, serialized, klass, target);
                klass !== cc._PrefabInfo || obj.sync || unlinkUnusedPrefab(self, serialized, obj);
            }
            _Deserializer.pool = new JS.Pool(function(obj) {
                obj.result = null;
                obj.customEnv = null;
                obj.deserializedList.length = 0;
                obj.deserializedData = null;
                obj._classFinder = null;
                obj._target = null;
                obj._idList.length = 0;
                obj._idObjList.length = 0;
                obj._idPropList.length = 0;
            }, 1);
            _Deserializer.pool.get = function(result, target, classFinder, customEnv, ignoreEditorOnly) {
                var cache = this._get();
                if (cache) {
                    cache.result = result;
                    cache.customEnv = customEnv;
                    cache._classFinder = classFinder;
                    cache._target = target;
                    cache._ignoreEditorOnly = ignoreEditorOnly;
                    return cache;
                }
                return new _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly);
            };
            return _Deserializer;
        })();
        cc.deserialize = function(data, details, options) {
            options = options || {};
            var classFinder = options.classFinder || JS._getClassById;
            var createAssetRefs = options.createAssetRefs || cc.sys.platform === cc.sys.EDITOR_CORE;
            var target = false;
            var customEnv = options.customEnv;
            var ignoreEditorOnly = options.ignoreEditorOnly;
            "string" === typeof data && (data = JSON.parse(data));
            var tempDetails = !details;
            details = details || Details.pool.get();
            var deserializer = _Deserializer.pool.get(details, target, classFinder, customEnv, ignoreEditorOnly);
            cc.game._isCloning = true;
            var res = deserializer.deserialize(data);
            cc.game._isCloning = false;
            _Deserializer.pool.put(deserializer);
            createAssetRefs && details.assignAssetsBy(Editor.serialize.asAsset);
            tempDetails && Details.pool.put(details);
            return res;
        };
        cc.deserialize.Details = Details;
        cc.deserialize.reportMissingClass = function(id) {
            cc.warnID(5302, id);
        };
    }), {
        "./CCClass": 173,
        "./CCObject": 179,
        "./attribute": 186,
        "./js": 193
    } ],
    189: [ (function(require, module, exports) {
        var NonUuidMark = ".";
        function IdGenerater(category) {
            this.id = 0 | 998 * Math.random();
            this.prefix = category ? category + NonUuidMark : "";
        }
        IdGenerater.prototype.getNewId = function() {
            return this.prefix + ++this.id;
        };
        IdGenerater.global = new IdGenerater("global");
        module.exports = IdGenerater;
    }), {} ],
    190: [ (function(require, module, exports) {
        require("./js");
        require("./CCClass");
        require("./CCClassDecorator");
        require("./CCEnum");
        require("./CCObject");
        require("./callbacks-invoker");
        require("./url");
        require("./deserialize");
        require("./instantiate");
        require("./instantiate-jit");
        require("./requiring-frame");
        require("./CCSys");
        require("./CCMacro");
        cc.sys.isBrowser && require("./CCAssetLibrary");
        require("./miniFramework");
        require("./CCVisibleRect");
    }), {
        "./CCAssetLibrary": 172,
        "./CCClass": 173,
        "./CCClassDecorator": 174,
        "./CCEnum": 175,
        "./CCMacro": 178,
        "./CCObject": 179,
        "./CCSys": 182,
        "./CCVisibleRect": 184,
        "./callbacks-invoker": 187,
        "./deserialize": 188,
        "./instantiate": 192,
        "./instantiate-jit": 191,
        "./js": 193,
        "./miniFramework": 194,
        "./requiring-frame": 196,
        "./url": 197
    } ],
    191: [ (function(require, module, exports) {
        var CCObject = require("./CCObject");
        var Destroyed = CCObject.Flags.Destroyed;
        var PersistentMask = CCObject.Flags.PersistentMask;
        var Attr = require("./attribute");
        var JS = require("./js");
        var CCClass = require("./CCClass");
        var SERIALIZABLE = Attr.DELIMETER + "serializable";
        var DEFAULT = Attr.DELIMETER + "default";
        var IDENTIFIER_RE = CCClass.IDENTIFIER_RE;
        var escapeForJS = CCClass.escapeForJS;
        var VAR = "var ";
        var LOCAL_OBJ = "o";
        var LOCAL_TEMP_OBJ = "t";
        var LOCAL_ARRAY = "a";
        var LINE_INDEX_OF_NEW_OBJ = 0;
        function Declaration(varName, expression) {
            this.varName = varName;
            this.expression = expression;
        }
        Declaration.prototype.toString = function() {
            return VAR + this.varName + "=" + this.expression + ";";
        };
        function mergeDeclaration(statement, expression) {
            return expression instanceof Declaration ? new Declaration(expression.varName, statement + expression.expression) : statement + expression;
        }
        function writeAssignment(codeArray, statement, expression) {
            if (Array.isArray(expression)) {
                expression[0] = mergeDeclaration(statement, expression[0]);
                codeArray.push(expression);
            } else {
                codeArray.push(mergeDeclaration(statement, expression) + ";");
            }
        }
        function Assignments(targetExpression) {
            this._exps = [];
            this._targetExp = targetExpression;
        }
        Assignments.prototype.append = function(key, expression) {
            this._exps.push([ key, expression ]);
        };
        Assignments.prototype.writeCode = function(codeArray) {
            var targetVar;
            if (this._exps.length > 1) {
                codeArray.push(LOCAL_TEMP_OBJ + "=" + this._targetExp + ";");
                targetVar = LOCAL_TEMP_OBJ;
            } else {
                if (1 !== this._exps.length) {
                    return;
                }
                targetVar = this._targetExp;
            }
            for (var i = 0; i < this._exps.length; i++) {
                var pair = this._exps[i];
                writeAssignment(codeArray, targetVar + getPropAccessor(pair[0]) + "=", pair[1]);
            }
        };
        Assignments.pool = new JS.Pool(function(obj) {
            obj._exps.length = 0;
            obj._targetExp = null;
        }, 1);
        Assignments.pool.get = function(targetExpression) {
            var cache = this._get() || new Assignments();
            cache._targetExp = targetExpression;
            return cache;
        };
        function equalsToDefault(def, value) {
            if ("function" === typeof def) {
                try {
                    def = def();
                } catch (e) {
                    return false;
                }
            }
            if (def === value) {
                return true;
            }
            if (def && value) {
                if (def instanceof cc.ValueType && def.equals(value)) {
                    return true;
                }
                if (Array.isArray(def) && Array.isArray(value) || def.constructor === Object && value.constructor === Object) {
                    try {
                        return JSON.stringify(def) === JSON.stringify(value);
                    } catch (e) {}
                }
            }
            return false;
        }
        function flattenCodeArray(array, separator) {
            var strList = [];
            (function deepFlatten(array) {
                for (var i = 0; i < array.length; i++) {
                    var item = array[i];
                    Array.isArray(item) ? deepFlatten(item) : strList.push(item);
                }
            })(array);
            return strList.join(separator);
        }
        function getPropAccessor(key) {
            return IDENTIFIER_RE.test(key) ? "." + key : "[" + escapeForJS(key) + "]";
        }
        function Parser(obj, parent) {
            this.parent = parent;
            this.objsToClear_iN$t = [];
            this.codeArray = [];
            this.objs = [];
            this.funcs = [];
            this.globalVariables = [];
            this.globalVariableId = 0;
            this.localVariableId = 0;
            this.codeArray.push(VAR + LOCAL_OBJ + "," + LOCAL_TEMP_OBJ + ";", "if(R){", LOCAL_OBJ + "=R;", "}else{", LOCAL_OBJ + "=R=new " + this.getFuncModule(obj.constructor, true) + "();", "}");
            obj._iN$t = {
                globalVar: "R"
            };
            this.objsToClear_iN$t.push(obj);
            this.enumerateObject(this.codeArray, obj);
            var globalVariablesDeclaration;
            this.globalVariables.length > 0 && (globalVariablesDeclaration = VAR + this.globalVariables.join(",") + ";");
            var code = flattenCodeArray([ "return (function(R){", globalVariablesDeclaration || [], this.codeArray, "return o;", "})" ], "\n");
            this.result = Function("O", "F", code)(this.objs, this.funcs);
            for (var i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) {
                this.objsToClear_iN$t[i]._iN$t = null;
            }
            this.objsToClear_iN$t.length = 0;
        }
        var proto = Parser.prototype;
        proto.getFuncModule = function(func, usedInNew) {
            var clsName = JS.getClassName(func);
            var clsNameIsModule = clsName.indexOf(".") !== -1;
            if (clsNameIsModule) {
                try {
                    clsNameIsModule = func === Function("return " + clsName)();
                    if (clsNameIsModule) {
                        return clsName;
                    }
                } catch (e) {}
            }
            var index = this.funcs.indexOf(func);
            if (index < 0) {
                index = this.funcs.length;
                this.funcs.push(func);
            }
            var res = "F[" + index + "]";
            return usedInNew ? "(" + res + ")" : res;
        };
        proto.getObjRef = function(obj) {
            var index = this.objs.indexOf(obj);
            if (index < 0) {
                index = this.objs.length;
                this.objs.push(obj);
            }
            return "O[" + index + "]";
        };
        proto.setValueType = function(codeArray, defaultValue, srcValue, targetExpression) {
            var assignments = Assignments.pool.get(targetExpression);
            var fastDefinedProps = defaultValue.constructor.__props__;
            fastDefinedProps || (fastDefinedProps = Object.keys(defaultValue));
            for (var i = 0; i < fastDefinedProps.length; i++) {
                var propName = fastDefinedProps[i];
                var prop = srcValue[propName];
                if (defaultValue[propName] === prop) {
                    continue;
                }
                var expression = this.enumerateField(srcValue, propName, prop);
                assignments.append(propName, expression);
            }
            assignments.writeCode(codeArray);
            Assignments.pool.put(assignments);
        };
        proto.enumerateCCClass = function(codeArray, obj, klass) {
            var props = klass.__props__;
            var attrs = Attr.getClassAttrs(klass);
            for (var p = 0; p < props.length; p++) {
                var key = props[p];
                if (false !== attrs[key + SERIALIZABLE]) {
                    var val = obj[key];
                    var defaultValue = attrs[key + DEFAULT];
                    if (equalsToDefault(defaultValue, val)) {
                        continue;
                    }
                    if ("object" === typeof val && val instanceof cc.ValueType) {
                        var defaultValue = CCClass.getDefault(defaultValue);
                        if ((defaultValue && defaultValue.constructor) === val.constructor) {
                            var targetExpression = LOCAL_OBJ + getPropAccessor(key);
                            this.setValueType(codeArray, defaultValue, val, targetExpression);
                            continue;
                        }
                    }
                    this.setObjProp(codeArray, obj, key, val);
                }
            }
        };
        proto.instantiateArray = function(value) {
            if (0 === value.length) {
                return "[]";
            }
            var arrayVar = LOCAL_ARRAY + ++this.localVariableId;
            var declaration = new Declaration(arrayVar, "new Array(" + value.length + ")");
            var codeArray = [ declaration ];
            value._iN$t = {
                globalVar: "",
                source: codeArray
            };
            this.objsToClear_iN$t.push(value);
            for (var i = 0; i < value.length; ++i) {
                var statement = arrayVar + "[" + i + "]=";
                var expression = this.enumerateField(value, i, value[i]);
                writeAssignment(codeArray, statement, expression);
            }
            return codeArray;
        };
        proto.enumerateField = function(obj, key, value) {
            if ("object" === typeof value && value) {
                var _iN$t = value._iN$t;
                if (_iN$t) {
                    var globalVar = _iN$t.globalVar;
                    if (!globalVar) {
                        globalVar = _iN$t.globalVar = "v" + ++this.globalVariableId;
                        this.globalVariables.push(globalVar);
                        var line = _iN$t.source[LINE_INDEX_OF_NEW_OBJ];
                        _iN$t.source[LINE_INDEX_OF_NEW_OBJ] = mergeDeclaration(globalVar + "=", line);
                    }
                    return globalVar;
                }
                return Array.isArray(value) ? this.instantiateArray(value) : this.instantiateObj(value);
            }
            if ("function" === typeof value) {
                return this.getFuncModule(value);
            }
            if ("string" === typeof value) {
                return escapeForJS(value);
            }
            "_objFlags" === key && obj instanceof CCObject && (value &= PersistentMask);
            return value;
        };
        proto.setObjProp = function(codeArray, obj, key, value) {
            var statement = LOCAL_OBJ + getPropAccessor(key) + "=";
            var expression = this.enumerateField(obj, key, value);
            writeAssignment(codeArray, statement, expression);
        };
        proto.enumerateObject = function(codeArray, obj) {
            var klass = obj.constructor;
            if (cc.Class._isCCClass(klass)) {
                this.enumerateCCClass(codeArray, obj, klass);
            } else {
                for (var key in obj) {
                    if (!obj.hasOwnProperty(key) || 95 === key.charCodeAt(0) && 95 === key.charCodeAt(1) && "__type__" !== key) {
                        continue;
                    }
                    var value = obj[key];
                    if ("object" === typeof value && value && value === obj._iN$t) {
                        continue;
                    }
                    this.setObjProp(codeArray, obj, key, value);
                }
            }
        };
        proto.instantiateObj = function(obj) {
            if (obj instanceof cc.ValueType) {
                return CCClass.getNewValueTypeCode(obj);
            }
            if (obj instanceof cc.Asset) {
                return this.getObjRef(obj);
            }
            if (obj._objFlags & Destroyed) {
                return null;
            }
            var createCode;
            var ctor = obj.constructor;
            if (cc.Class._isCCClass(ctor)) {
                if (this.parent) {
                    if (this.parent instanceof cc.Component) {
                        if (obj instanceof cc._BaseNode || obj instanceof cc.Component) {
                            return this.getObjRef(obj);
                        }
                    } else {
                        if (this.parent instanceof cc._BaseNode) {
                            if (obj instanceof cc._BaseNode) {
                                if (!obj.isChildOf(this.parent)) {
                                    return this.getObjRef(obj);
                                }
                            } else {
                                if (obj instanceof cc.Component && !obj.node.isChildOf(this.parent)) {
                                    return this.getObjRef(obj);
                                }
                            }
                        }
                    }
                }
                createCode = new Declaration(LOCAL_OBJ, "new " + this.getFuncModule(ctor, true) + "()");
            } else {
                if (ctor !== Object) {
                    return this.getObjRef(obj);
                }
                createCode = new Declaration(LOCAL_OBJ, "{}");
            }
            var codeArray = [ createCode ];
            obj._iN$t = {
                globalVar: "",
                source: codeArray
            };
            this.objsToClear_iN$t.push(obj);
            this.enumerateObject(codeArray, obj);
            return [ "(function(){", codeArray, "return o;})();" ];
        };
        function compile(node) {
            var root = node instanceof cc._BaseNode && node;
            var parser = new Parser(node, root);
            return parser.result;
        }
        module.exports = {
            compile: compile,
            equalsToDefault: equalsToDefault
        };
    }), {
        "./CCClass": 173,
        "./CCObject": 179,
        "./attribute": 186,
        "./js": 193
    } ],
    192: [ (function(require, module, exports) {
        var CCObject = require("./CCObject");
        var Destroyed = CCObject.Flags.Destroyed;
        var PersistentMask = CCObject.Flags.PersistentMask;
        var Attr = require("./attribute");
        var _isDomNode = require("./utils").isDomNode;
        function instantiate(original, internal_force) {
            if (!internal_force) {
                if ("object" !== typeof original || Array.isArray(original)) {
                    cc.errorID(6900);
                    return null;
                }
                if (!original) {
                    cc.errorID(6901);
                    return null;
                }
                if (!cc.isValid(original)) {
                    cc.errorID(6902);
                    return null;
                }
                original instanceof cc.Component && cc.warn("Should not instantiate a single cc.Component directly, you must instantiate the entire node.");
            }
            var clone;
            if (original instanceof CCObject) {
                if (original._instantiate) {
                    cc.game._isCloning = true;
                    clone = original._instantiate();
                    cc.game._isCloning = false;
                    return clone;
                }
                if (original instanceof cc.Asset) {
                    cc.errorID(6903);
                    return null;
                }
            }
            cc.game._isCloning = true;
            clone = doInstantiate(original);
            cc.game._isCloning = false;
            return clone;
        }
        var objsToClearTmpVar = [];
        function doInstantiate(obj, parent) {
            if (Array.isArray(obj)) {
                cc.errorID(6904);
                return null;
            }
            if (_isDomNode && _isDomNode(obj)) {
                cc.errorID(6905);
                return null;
            }
            var clone;
            if (obj._iN$t) {
                clone = obj._iN$t;
            } else {
                var klass = obj.constructor;
                clone = new klass();
            }
            enumerateObject(obj, clone, parent);
            for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) {
                objsToClearTmpVar[i]._iN$t = null;
            }
            objsToClearTmpVar.length = 0;
            return clone;
        }
        var SERIALIZABLE = Attr.DELIMETER + "serializable";
        function enumerateCCClass(klass, obj, clone, parent) {
            var props = klass.__props__;
            var attrs = Attr.getClassAttrs(klass);
            for (var p = 0; p < props.length; p++) {
                var key = props[p];
                if (false !== attrs[key + SERIALIZABLE]) {
                    var value = obj[key];
                    "object" === typeof value && value ? clone[key] = value._iN$t || instantiateObj(value, parent) : clone[key] = value;
                }
            }
        }
        function enumerateObject(obj, clone, parent) {
            obj._iN$t = clone;
            objsToClearTmpVar.push(obj);
            var klass = obj.constructor;
            if (cc.Class._isCCClass(klass)) {
                enumerateCCClass(klass, obj, clone, parent);
            } else {
                for (var key in obj) {
                    if (!obj.hasOwnProperty(key) || 95 === key.charCodeAt(0) && 95 === key.charCodeAt(1) && "__type__" !== key) {
                        continue;
                    }
                    var value = obj[key];
                    if ("object" === typeof value && value) {
                        if (value === clone) {
                            continue;
                        }
                        clone[key] = value._iN$t || instantiateObj(value, parent);
                    } else {
                        clone[key] = value;
                    }
                }
            }
            obj instanceof CCObject && (clone._objFlags &= PersistentMask);
        }
        function instantiateObj(obj, parent) {
            if (obj instanceof cc.ValueType) {
                return obj.clone();
            }
            if (obj instanceof cc.Asset) {
                return obj;
            }
            var clone;
            if (Array.isArray(obj)) {
                var len = obj.length;
                clone = new Array(len);
                obj._iN$t = clone;
                for (var i = 0; i < len; ++i) {
                    var value = obj[i];
                    "object" === typeof value && value ? clone[i] = value._iN$t || instantiateObj(value, parent) : clone[i] = value;
                }
                objsToClearTmpVar.push(obj);
                return clone;
            }
            if (obj._objFlags & Destroyed) {
                return null;
            }
            var ctor = obj.constructor;
            if (cc.Class._isCCClass(ctor)) {
                if (parent) {
                    if (parent instanceof cc.Component) {
                        if (obj instanceof cc._BaseNode || obj instanceof cc.Component) {
                            return obj;
                        }
                    } else {
                        if (parent instanceof cc._BaseNode) {
                            if (obj instanceof cc._BaseNode) {
                                if (!obj.isChildOf(parent)) {
                                    return obj;
                                }
                            } else {
                                if (obj instanceof cc.Component && !obj.node.isChildOf(parent)) {
                                    return obj;
                                }
                            }
                        }
                    }
                }
            } else {
                if (ctor !== Object) {
                    return obj;
                }
            }
            clone = new ctor();
            enumerateObject(obj, clone, parent);
            return clone;
        }
        instantiate._clone = doInstantiate;
        cc.instantiate = instantiate;
        module.exports = instantiate;
    }), {
        "./CCObject": 179,
        "./attribute": 186,
        "./utils": 198
    } ],
    193: [ (function(require, module, exports) {
        var tempCIDGenerater = new (require("./id-generater"))("TmpCId.");
        function _getPropertyDescriptor(obj, name) {
            while (obj) {
                var pd = Object.getOwnPropertyDescriptor(obj, name);
                if (pd) {
                    return pd;
                }
                obj = Object.getPrototypeOf(obj);
            }
            return null;
        }
        function _copyprop(name, source, target) {
            var pd = _getPropertyDescriptor(source, name);
            Object.defineProperty(target, name, pd);
        }
        var js = {
            isNumber: function(obj) {
                return "number" === typeof obj || obj instanceof Number;
            },
            isString: function(obj) {
                return "string" === typeof obj || obj instanceof String;
            },
            addon: function(obj) {
                "use strict";
                obj = obj || {};
                for (var i = 1, length = arguments.length; i < length; i++) {
                    var source = arguments[i];
                    if (source) {
                        if ("object" !== typeof source) {
                            cc.errorID(5402, source);
                            continue;
                        }
                        for (var name in source) {
                            name in obj || _copyprop(name, source, obj);
                        }
                    }
                }
                return obj;
            },
            mixin: function(obj) {
                "use strict";
                obj = obj || {};
                for (var i = 1, length = arguments.length; i < length; i++) {
                    var source = arguments[i];
                    if (source) {
                        if ("object" !== typeof source) {
                            cc.errorID(5403, source);
                            continue;
                        }
                        for (var name in source) {
                            _copyprop(name, source, obj);
                        }
                    }
                }
                return obj;
            },
            extend: function(cls, base) {
                if (!base) {
                    cc.errorID(5404);
                    return;
                }
                if (!cls) {
                    cc.errorID(5405);
                    return;
                }
                Object.keys(cls.prototype).length > 0 && cc.errorID(5406);
                for (var p in base) {
                    base.hasOwnProperty(p) && (cls[p] = base[p]);
                }
                cls.prototype = Object.create(base.prototype, {
                    constructor: {
                        value: cls,
                        writable: true,
                        configurable: true
                    }
                });
                return cls;
            },
            getSuper: function(ctor) {
                var proto = ctor.prototype;
                var dunderProto = proto && Object.getPrototypeOf(proto);
                return dunderProto && dunderProto.constructor;
            },
            clear: function(obj) {
                var keys = Object.keys(obj);
                for (var i = 0; i < keys.length; i++) {
                    delete obj[keys[i]];
                }
            },
            getPropertyDescriptor: _getPropertyDescriptor
        };
        var tmpValueDesc = {
            value: void 0,
            enumerable: false,
            writable: false,
            configurable: true
        };
        js.value = function(obj, prop, value, writable, enumerable) {
            tmpValueDesc.value = value;
            tmpValueDesc.writable = writable;
            tmpValueDesc.enumerable = enumerable;
            Object.defineProperty(obj, prop, tmpValueDesc);
            tmpValueDesc.value = void 0;
        };
        var tmpGetSetDesc = {
            get: null,
            set: null,
            enumerable: false
        };
        js.getset = function(obj, prop, getter, setter, enumerable) {
            if ("function" !== typeof setter) {
                enumerable = setter;
                setter = void 0;
            }
            tmpGetSetDesc.get = getter;
            tmpGetSetDesc.set = setter;
            tmpGetSetDesc.enumerable = enumerable;
            Object.defineProperty(obj, prop, tmpGetSetDesc);
            tmpGetSetDesc.get = null;
            tmpGetSetDesc.set = null;
        };
        var tmpGetDesc = {
            get: null,
            enumerable: false,
            configurable: false
        };
        js.get = function(obj, prop, getter, enumerable, configurable) {
            tmpGetDesc.get = getter;
            tmpGetDesc.enumerable = enumerable;
            tmpGetDesc.configurable = configurable;
            Object.defineProperty(obj, prop, tmpGetDesc);
            tmpGetDesc.get = null;
        };
        var tmpSetDesc = {
            set: null,
            enumerable: false,
            configurable: false
        };
        js.set = function(obj, prop, setter, enumerable, configurable) {
            tmpSetDesc.set = setter;
            tmpSetDesc.enumerable = enumerable;
            tmpSetDesc.configurable = configurable;
            Object.defineProperty(obj, prop, tmpSetDesc);
            tmpSetDesc.set = null;
        };
        js.getClassName = function(objOrCtor) {
            if ("function" === typeof objOrCtor) {
                var prototype = objOrCtor.prototype;
                if (prototype && prototype.hasOwnProperty("__classname__") && prototype.__classname__) {
                    return prototype.__classname__;
                }
                var retval = "";
                objOrCtor.name && (retval = objOrCtor.name);
                if (objOrCtor.toString) {
                    var arr, str = objOrCtor.toString();
                    arr = "[" === str.charAt(0) ? str.match(/\[\w+\s*(\w+)\]/) : str.match(/function\s*(\w+)/);
                    arr && 2 === arr.length && (retval = arr[1]);
                }
                return "Object" !== retval ? retval : "";
            }
            if (objOrCtor && objOrCtor.constructor) {
                return js.getClassName(objOrCtor.constructor);
            }
            return "";
        };
        function isTempClassId_DEV(id) {
            return "string" !== typeof id || id.startsWith(tempCIDGenerater.prefix);
        }
        (function() {
            var _idToClass = {};
            var _nameToClass = {};
            function getRegister(key, table) {
                return function(id, constructor) {
                    constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]];
                    js.value(constructor.prototype, key, id);
                    if (id) {
                        var registered = table[id];
                        if (registered && registered !== constructor) {
                            var error = "A Class already exists with the same " + key + ' : "' + id + '".';
                            cc.error(error);
                        } else {
                            table[id] = constructor;
                        }
                    }
                };
            }
            js._setClassId = getRegister("__cid__", _idToClass);
            var doSetClassName = getRegister("__classname__", _nameToClass);
            js.setClassName = function(className, constructor) {
                doSetClassName(className, constructor);
                if (!constructor.prototype.hasOwnProperty("__cid__")) {
                    var id = className || tempCIDGenerater.getNewId();
                    id && js._setClassId(id, constructor);
                }
            };
            js.unregisterClass = function() {
                for (var i = 0; i < arguments.length; i++) {
                    var p = arguments[i].prototype;
                    var classId = p.__cid__;
                    classId && delete _idToClass[classId];
                    var classname = p.__classname__;
                    classname && delete _nameToClass[classname];
                }
            };
            js._getClassById = function(classId) {
                return _idToClass[classId];
            };
            js.getClassByName = function(classname) {
                return _nameToClass[classname];
            };
            js._getClassId = function(obj, allowTempId) {
                allowTempId = "undefined" === typeof allowTempId || allowTempId;
                var res;
                if ("function" === typeof obj && obj.prototype.hasOwnProperty("__cid__")) {
                    res = obj.prototype.__cid__;
                    if (!allowTempId && true && isTempClassId_DEV(res)) {
                        return "";
                    }
                    return res;
                }
                if (obj && obj.constructor) {
                    var prototype = obj.constructor.prototype;
                    if (prototype && prototype.hasOwnProperty("__cid__")) {
                        res = obj.__cid__;
                        if (!allowTempId && true && isTempClassId_DEV(res)) {
                            return "";
                        }
                        return res;
                    }
                }
                return "";
            };
            js.getset(js, "_registeredClassIds", (function() {
                var dump = {};
                for (var id in _idToClass) {
                    dump[id] = _idToClass[id];
                }
                return dump;
            }), (function(value) {
                js.clear(_idToClass);
                for (var id in value) {
                    _idToClass[id] = value[id];
                }
            }));
            js.getset(js, "_registeredClassNames", (function() {
                var dump = {};
                for (var id in _nameToClass) {
                    dump[id] = _nameToClass[id];
                }
                return dump;
            }), (function(value) {
                js.clear(_nameToClass);
                for (var id in value) {
                    _nameToClass[id] = value[id];
                }
            }));
        })();
        js.obsolete = function(obj, obsoleted, newPropName, writable) {
            var oldName = obsoleted.split(".").slice(-1);
            function get() {
                cc.warnID(5400, obsoleted, newPropName);
                return this[newPropName];
            }
            writable ? js.getset(obj, oldName, get, (function(value) {
                cc.warnID(5401, obsoleted, newPropName);
                this[newPropName] = value;
            })) : js.get(obj, oldName, get);
        };
        js.obsoletes = function(obj, objName, props, writable) {
            for (var obsoleted in props) {
                var newName = props[obsoleted];
                js.obsolete(obj, objName + "." + obsoleted, newName, writable);
            }
        };
        js.formatStr = function() {
            var args = arguments;
            var l = args.length;
            if (l < 1) {
                return "";
            }
            var REGEXP_NUM_OR_STR = /(%d)|(%s)/;
            var i = 1;
            var str = args[0];
            var hasSubstitution = "string" === typeof str && REGEXP_NUM_OR_STR.test(str);
            if (hasSubstitution) {
                var REGEXP_STR = /%s/;
                for (;i < l; ++i) {
                    var arg = args[i];
                    var regExpToTest = "number" === typeof arg ? REGEXP_NUM_OR_STR : REGEXP_STR;
                    regExpToTest.test(str) ? str = str.replace(regExpToTest, arg) : str += " " + arg;
                }
            } else {
                if (l > 1) {
                    for (;i < l; ++i) {
                        str += " " + args[i];
                    }
                } else {
                    str = "" + str;
                }
            }
            return str;
        };
        js.shiftArguments = function() {
            var len = arguments.length - 1;
            var args = new Array(len);
            for (var i = 0; i < len; ++i) {
                args[i] = arguments[i + i];
            }
            return args;
        };
        function removeAt(array, index) {
            array.splice(index, 1);
        }
        function fastRemoveAt(array, index) {
            var length = array.length;
            if (index < 0 || index >= length) {
                return;
            }
            array[index] = array[length - 1];
            array.length = length - 1;
        }
        function remove(array, value) {
            var index = array.indexOf(value);
            if (index >= 0) {
                removeAt(array, index);
                return true;
            }
            return false;
        }
        function fastRemove(array, value) {
            var index = array.indexOf(value);
            if (index >= 0) {
                array[index] = array[array.length - 1];
                --array.length;
            }
        }
        function verifyType(array, type) {
            if (array && array.length > 0) {
                for (var i = 0; i < array.length; i++) {
                    if (!(array[i] instanceof type)) {
                        cc.logID(1300);
                        return false;
                    }
                }
            }
            return true;
        }
        function removeArray(array, minusArr) {
            for (var i = 0, l = minusArr.length; i < l; i++) {
                remove(array, minusArr[i]);
            }
        }
        function appendObjectsAt(array, addObjs, index) {
            array.splice.apply(array, [ index, 0 ].concat(addObjs));
            return array;
        }
        var indexOf = Array.prototype.indexOf;
        function contains(array, value) {
            return indexOf.call(array, value) >= 0;
        }
        function copy(array) {
            var i, len = array.length, arr_clone = new Array(len);
            for (i = 0; i < len; i += 1) {
                arr_clone[i] = array[i];
            }
            return arr_clone;
        }
        js.array = {
            remove: remove,
            fastRemove: fastRemove,
            removeAt: removeAt,
            fastRemoveAt: fastRemoveAt,
            contains: contains,
            verifyType: verifyType,
            removeArray: removeArray,
            appendObjectsAt: appendObjectsAt,
            copy: copy,
            indexOf: indexOf,
            MutableForwardIterator: require("../utils/mutable-forward-iterator")
        };
        function Pool(cleanupFunc, size) {
            if ("number" === typeof cleanupFunc) {
                size = cleanupFunc;
                cleanupFunc = null;
            }
            this.get = null;
            this.count = 0;
            this._pool = new Array(size);
            this._cleanup = cleanupFunc;
        }
        Pool.prototype._get = function() {
            if (this.count > 0) {
                --this.count;
                var cache = this._pool[this.count];
                this._pool[this.count] = null;
                return cache;
            }
            return null;
        };
        Pool.prototype.put = function(obj) {
            var pool = this._pool;
            if (this.count < pool.length) {
                if (this._cleanup && false === this._cleanup(obj)) {
                    return;
                }
                pool[this.count] = obj;
                ++this.count;
            }
        };
        js.Pool = Pool;
        cc.js = js;
        module.exports = js;
    }), {
        "../utils/mutable-forward-iterator": 224,
        "./id-generater": 189
    } ],
    194: [ (function(require, module, exports) {
        cc.$ = function(x) {
            var parent = this === cc ? document : this;
            var el = x instanceof HTMLElement ? x : parent.querySelector(x);
            if (el) {
                el.find = el.find || cc.$;
                el.hasClass = el.hasClass || function(cls) {
                    return this.className.match(new RegExp("(\\s|^)" + cls + "(\\s|$)"));
                };
                el.addClass = el.addClass || function(cls) {
                    if (!this.hasClass(cls)) {
                        this.className && (this.className += " ");
                        this.className += cls;
                    }
                    return this;
                };
                el.removeClass = el.removeClass || function(cls) {
                    this.hasClass(cls) && (this.className = this.className.replace(cls, ""));
                    return this;
                };
                el.remove = el.remove || function() {
                    this.parentNode && this.parentNode.removeChild(this);
                    return this;
                };
                el.appendTo = el.appendTo || function(x) {
                    x.appendChild(this);
                    return this;
                };
                el.prependTo = el.prependTo || function(x) {
                    x.childNodes[0] ? x.insertBefore(this, x.childNodes[0]) : x.appendChild(this);
                    return this;
                };
                el.transforms = el.transforms || function() {
                    this.style[cc.$.trans] = cc.$.translate(this.position) + cc.$.rotate(this.rotation) + cc.$.scale(this.scale) + cc.$.skew(this.skew);
                    return this;
                };
                el.position = el.position || {
                    x: 0,
                    y: 0
                };
                el.rotation = el.rotation || 0;
                el.scale = el.scale || {
                    x: 1,
                    y: 1
                };
                el.skew = el.skew || {
                    x: 0,
                    y: 0
                };
                el.translates = function(x, y) {
                    this.position.x = x;
                    this.position.y = y;
                    this.transforms();
                    return this;
                };
                el.rotate = function(x) {
                    this.rotation = x;
                    this.transforms();
                    return this;
                };
                el.resize = function(x, y) {
                    this.scale.x = x;
                    this.scale.y = y;
                    this.transforms();
                    return this;
                };
                el.setSkew = function(x, y) {
                    this.skew.x = x;
                    this.skew.y = y;
                    this.transforms();
                    return this;
                };
            }
            return el;
        };
        switch (cc.sys.browserType) {
          case cc.sys.BROWSER_TYPE_FIREFOX:
            cc.$.pfx = "Moz";
            cc.$.hd = true;
            break;

          case cc.sys.BROWSER_TYPE_CHROME:
          case cc.sys.BROWSER_TYPE_SAFARI:
            cc.$.pfx = "webkit";
            cc.$.hd = true;
            break;

          case cc.sys.BROWSER_TYPE_OPERA:
            cc.$.pfx = "O";
            cc.$.hd = false;
            break;

          case cc.sys.BROWSER_TYPE_IE:
            cc.$.pfx = "ms";
            cc.$.hd = false;
            break;

          default:
            cc.$.pfx = "webkit";
            cc.$.hd = true;
        }
        cc.$.trans = cc.$.pfx + "Transform";
        cc.$.translate = cc.$.hd ? function(a) {
            return "translate3d(" + a.x + "px, " + a.y + "px, 0) ";
        } : function(a) {
            return "translate(" + a.x + "px, " + a.y + "px) ";
        };
        cc.$.rotate = cc.$.hd ? function(a) {
            return "rotateZ(" + a + "deg) ";
        } : function(a) {
            return "rotate(" + a + "deg) ";
        };
        cc.$.scale = function(a) {
            return "scale(" + a.x + ", " + a.y + ") ";
        };
        cc.$.skew = function(a) {
            return "skewX(" + -a.x + "deg) skewY(" + a.y + "deg)";
        };
        cc.$new = function(x) {
            return cc.$(document.createElement(x));
        };
        cc.$.findpos = function(obj) {
            var curleft = 0;
            var curtop = 0;
            do {
                curleft += obj.offsetLeft;
                curtop += obj.offsetTop;
            } while (obj = obj.offsetParent);
            return {
                x: curleft,
                y: curtop
            };
        };
    }), {} ],
    195: [ (function(require, module, exports) {
        var SerializableAttrs = {
            url: {
                canUsedInGet: true
            },
            default: {},
            serializable: {},
            editorOnly: {},
            rawType: {}
        };
        var TYPO_TO_CORRECT_DEV = {
            extend: "extends",
            property: "properties",
            static: "statics",
            constructor: "ctor"
        };
        function parseNotify(val, propName, notify, properties) {
            if (val.get || val.set) {
                cc.warnID(5500);
                return;
            }
            if (val.hasOwnProperty("default")) {
                var newKey = "_N$" + propName;
                val.get = function() {
                    return this[newKey];
                };
                val.set = function(value) {
                    var oldValue = this[newKey];
                    this[newKey] = value;
                    notify.call(this, oldValue);
                };
                var newValue = {};
                properties[newKey] = newValue;
                for (var attr in SerializableAttrs) {
                    var v = SerializableAttrs[attr];
                    if (val.hasOwnProperty(attr)) {
                        newValue[attr] = val[attr];
                        v.canUsedInGet || delete val[attr];
                    }
                }
            } else {
                cc.warnID(5501);
            }
        }
        function checkUrl(val, className, propName, url) {
            Array.isArray(url) && url.length > 0 && (url = url[0]);
            val.type = url;
        }
        function parseType(val, type, className, propName) {
            if (Array.isArray(type)) {
                var isArray;
                if (!(type.length > 0)) {
                    return cc.errorID(5508, className, propName);
                }
                if (cc.RawAsset.isRawAssetType(type[0])) {
                    val.url = type[0];
                    delete val.type;
                    return;
                }
                val.type = type = type[0];
            }
        }
        function postCheckType(val, type, className, propName) {}
        function getBaseClassWherePropertyDefined_DEV(propName, cls) {
            var res;
            for (;cls && cls.__props__ && cls.__props__.indexOf(propName) !== -1; cls = cls.$super) {
                res = cls;
            }
            res || cc.error("unknown error");
            return res;
        }
        exports.getFullFormOfProperty = function(options) {
            var isLiteral = options && options.constructor === Object;
            if (!isLiteral) {
                if (Array.isArray(options) && options.length > 0) {
                    return {
                        default: [],
                        type: options,
                        _short: true
                    };
                }
                if ("function" === typeof options) {
                    var type = options;
                    return cc.RawAsset.isRawAssetType(type) ? {
                        default: "",
                        url: type,
                        _short: true
                    } : {
                        default: cc.isChildClassOf(type, cc.ValueType) ? new type() : null,
                        type: type,
                        _short: true
                    };
                }
                return {
                    default: options,
                    _short: true
                };
            }
            return null;
        };
        exports.preprocessAttrs = function(properties, className, cls, es6) {
            for (var propName in properties) {
                var val = properties[propName];
                var fullForm = exports.getFullFormOfProperty(val);
                fullForm && (val = properties[propName] = fullForm);
                if (val) {
                    var maybeTypeScript;
                    if (!val.override && cls.__props__.indexOf(propName) !== -1) {
                        var baseClass = cc.js.getClassName(getBaseClassWherePropertyDefined_DEV(propName, cls));
                        cc.warnID(5517, className, propName, baseClass, propName);
                    }
                    var notify = val.notify;
                    notify && (es6 ? cc.error("not yet support notify attribute for ES6 Classes") : parseNotify(val, propName, notify, properties));
                    "type" in val && parseType(val, val.type, className, propName);
                    "url" in val && checkUrl(val, className, propName, val.url);
                    "type" in val && postCheckType(val, val.type, className, propName);
                }
            }
        };
        module.exports.validateMethod = function(func, funcName, className, cls, base) {
            if ("constructor" === funcName) {
                cc.errorID(3643, className);
                return false;
            }
            if ("function" !== typeof func && null !== func) {
                if (false === func && base && base.prototype) {
                    var overrided = base.prototype[funcName];
                    if ("function" === typeof overrided) {
                        var baseFuc = cc.js.getClassName(base) + "." + funcName;
                        var subFuc = className + "." + funcName;
                        cc.warnID(3624, subFuc, baseFuc, subFuc, subFuc);
                    }
                }
                var correct = TYPO_TO_CORRECT_DEV[funcName];
                correct ? cc.warnID(3621, className, funcName, correct) : func && cc.errorID(3622, className, funcName);
                return false;
            }
            if (cls.__props__ && cls.__props__.indexOf(funcName) >= 0) {
                var baseClassName = cc.js.getClassName(getBaseClassWherePropertyDefined_DEV(funcName, cls));
                cc.errorID(3648, className, funcName, baseClassName);
                return false;
            }
            return true;
        };
    }), {
        "./CCClass": 173
    } ],
    196: [ (function(require, module, exports) {
        var requiringFrames = [];
        cc._RF = {
            push: function(module, uuid, script) {
                if (void 0 === script) {
                    script = uuid;
                    uuid = "";
                }
                requiringFrames.push({
                    uuid: uuid,
                    script: script,
                    module: module,
                    exports: module.exports,
                    beh: null
                });
            },
            pop: function() {
                var frameInfo = requiringFrames.pop();
                var module = frameInfo.module;
                var exports = module.exports;
                if (exports === frameInfo.exports) {
                    for (var anyKey in exports) {
                        return;
                    }
                    module.exports = exports = frameInfo.cls;
                }
            },
            peek: function() {
                return requiringFrames[requiringFrames.length - 1];
            }
        };
        cc._RFpush = cc._RF.push;
        cc._RFpop = cc._RF.pop;
        cc._RFpeek = cc._RF.peek;
    }), {} ],
    197: [ (function(require, module, exports) {
        var _mounts = {};
        cc.url = {
            _rawAssets: "",
            _builtinRawAssets: "",
            normalize: function(url) {
                46 === url.charCodeAt(0) && 47 === url.charCodeAt(1) ? url = url.slice(2) : 47 === url.charCodeAt(0) && (url = url.slice(1));
                return url;
            },
            raw: function(url) {
                url = this.normalize(url);
                url.startsWith("resources/") || cc.errorID(7002, url);
                return this._rawAssets + url;
            },
            builtinRaw: false,
            _init: function(mountPaths) {
                for (var dir in mountPaths) {
                    var path = mountPaths[dir];
                    path = cc.path._setEndWithSep(path, "/");
                    _mounts[dir] = path;
                }
                this._rawAssets = _mounts.assets;
                this._builtinRawAssets = _mounts.internal;
            }
        };
        module.exports = cc.url;
    }), {} ],
    198: [ (function(require, module, exports) {
        module.exports = {
            contains: function(refNode, otherNode) {
                if ("function" == typeof refNode.contains) {
                    return refNode.contains(otherNode);
                }
                if ("function" == typeof refNode.compareDocumentPosition) {
                    return !!(16 & refNode.compareDocumentPosition(otherNode));
                }
                var node = otherNode.parentNode;
                do {
                    if (node === refNode) {
                        return true;
                    }
                    node = node.parentNode;
                } while (null !== node);
                return false;
            },
            isDomNode: "object" === typeof window && ("function" === typeof Node ? function(obj) {
                return obj instanceof Node;
            } : function(obj) {
                return obj && "object" === typeof obj && "number" === typeof obj.nodeType && "string" === typeof obj.nodeName;
            }),
            callInNextTick: function(callback, p1, p2) {
                callback && setTimeout((function() {
                    callback(p1, p2);
                }), 0);
            }
        };
        module.exports.isPlainEmptyObj_DEV = function(obj) {
            if (!obj || obj.constructor !== Object) {
                return false;
            }
            for (var k in obj) {
                return false;
            }
            return true;
        };
        module.exports.cloneable_DEV = function(obj) {
            return obj && "function" === typeof obj.clone && (obj.constructor.prototype.hasOwnProperty("clone") || obj.hasOwnProperty("clone"));
        };
    }), {} ],
    199: [ (function(require, module, exports) {
        var Region = function() {
            this._minX = 0;
            this._minY = 0;
            this._maxX = 0;
            this._maxY = 0;
            this._width = 0;
            this._height = 0;
            this._area = 0;
        };
        var regionProto = Region.prototype;
        var regionPool = [];
        function regionCreate() {
            var region = regionPool.pop();
            region || (region = new Region());
            return region;
        }
        function regionRelease(region) {
            regionPool.push(region);
        }
        regionProto.setTo = function(minX, minY, maxX, maxY) {
            this._minX = minX;
            this._minY = minY;
            this._maxX = maxX;
            this._maxY = maxY;
            this.updateArea();
            return this;
        };
        regionProto.intValues = function() {
            this._minX = Math.floor(this._minX);
            this._minY = Math.floor(this._minY);
            this._maxX = Math.ceil(this._maxX);
            this._maxY = Math.ceil(this._maxY);
            this.updateArea();
        };
        regionProto.updateArea = function() {
            this._width = this._maxX - this._minX;
            this._height = this._maxY - this._minY;
            this._area = this._width * this._height;
        };
        regionProto.union = function(target) {
            if (this.isEmpty()) {
                this.setTo(target._minX, target._minY, target._maxX, target._maxY);
                return;
            }
            this._minX > target._minX && (this._minX = target._minX);
            this._minY > target._minY && (this._minY = target._minY);
            this._maxX < target._maxX && (this._maxX = target._maxX);
            this._maxY < target._maxY && (this._maxY = target._maxY);
            this.updateArea();
        };
        regionProto.setEmpty = function() {
            this._minX = 0;
            this._minY = 0;
            this._maxX = 0;
            this._maxY = 0;
            this._width = 0;
            this._height = 0;
            this._area = 0;
        };
        regionProto.isEmpty = function() {
            return this._width <= 0 || this._height <= 0;
        };
        regionProto.intersects = function(target) {
            if (this.isEmpty() || target.isEmpty()) {
                return false;
            }
            var max = this._minX > target._minX ? this._minX : target._minX;
            var min = this._maxX < target._maxX ? this._maxX : target._maxX;
            if (max > min) {
                return false;
            }
            max = this._minY > target._minY ? this._minY : target._minY;
            min = this._maxY < target._maxY ? this._maxY : target._maxY;
            return max <= min;
        };
        regionProto.updateRegion = function(bounds, matrix) {
            if (0 === bounds.width || 0 === bounds.height) {
                this.setEmpty();
                return;
            }
            var m = matrix;
            var a = m.a;
            var b = m.b;
            var c = m.c;
            var d = m.d;
            var tx = m.tx;
            var ty = m.ty;
            var x = bounds.x;
            var y = bounds.y;
            var xMax = x + bounds.width;
            var yMax = y + bounds.height;
            var minX, minY, maxX, maxY;
            if (1 === a && 0 === b && 0 === c && 1 === d) {
                minX = x + tx - 1;
                minY = y + ty - 1;
                maxX = xMax + tx + 1;
                maxY = yMax + ty + 1;
            } else {
                var x0 = a * x + c * y + tx;
                var y0 = b * x + d * y + ty;
                var x1 = a * xMax + c * y + tx;
                var y1 = b * xMax + d * y + ty;
                var x2 = a * xMax + c * yMax + tx;
                var y2 = b * xMax + d * yMax + ty;
                var x3 = a * x + c * yMax + tx;
                var y3 = b * x + d * yMax + ty;
                var tmp = 0;
                if (x0 > x1) {
                    tmp = x0;
                    x0 = x1;
                    x1 = tmp;
                }
                if (x2 > x3) {
                    tmp = x2;
                    x2 = x3;
                    x3 = tmp;
                }
                minX = (x0 < x2 ? x0 : x2) - 1;
                maxX = (x1 > x3 ? x1 : x3) + 1;
                if (y0 > y1) {
                    tmp = y0;
                    y0 = y1;
                    y1 = tmp;
                }
                if (y2 > y3) {
                    tmp = y2;
                    y2 = y3;
                    y3 = tmp;
                }
                minY = (y0 < y2 ? y0 : y2) - 1;
                maxY = (y1 > y3 ? y1 : y3) + 1;
            }
            this._minX = minX;
            this._minY = minY;
            this._maxX = maxX;
            this._maxY = maxY;
            this._width = maxX - minX;
            this._height = maxY - minY;
            this._area = this._width * this._height;
        };
        function unionArea(r1, r2) {
            var minX = r1._minX < r2._minX ? r1._minX : r2._minX;
            var minY = r1._minY < r2._minY ? r1._minY : r2._minY;
            var maxX = r1._maxX > r2._maxX ? r1._maxX : r2._maxX;
            var maxY = r1._maxY > r2._maxY ? r1._maxY : r2._maxY;
            return (maxX - minX) * (maxY - minY);
        }
        var DirtyRegion = function() {
            this.dirtyList = [];
            this.hasClipRect = false;
            this.clipWidth = 0;
            this.clipHeight = 0;
            this.clipArea = 0;
            this.clipRectChanged = false;
        };
        var dirtyRegionProto = DirtyRegion.prototype;
        dirtyRegionProto.setClipRect = function(width, height) {
            this.hasClipRect = true;
            this.clipRectChanged = true;
            this.clipWidth = Math.ceil(width);
            this.clipHeight = Math.ceil(height);
            this.clipArea = this.clipWidth * this.clipHeight;
        };
        dirtyRegionProto.addRegion = function(target) {
            var minX = target._minX, minY = target._minY, maxX = target._maxX, maxY = target._maxY;
            if (this.hasClipRect) {
                minX < 0 && (minX = 0);
                minY < 0 && (minY = 0);
                maxX > this.clipWidth && (maxX = this.clipWidth);
                maxY > this.clipHeight && (maxY = this.clipHeight);
            }
            if (minX >= maxX || minY >= maxY) {
                return false;
            }
            if (this.clipRectChanged) {
                return true;
            }
            var dirtyList = this.dirtyList;
            var region = regionCreate();
            dirtyList.push(region.setTo(minX, minY, maxX, maxY));
            this.mergeDirtyList(dirtyList);
            return true;
        };
        dirtyRegionProto.clear = function() {
            var dirtyList = this.dirtyList;
            var length = dirtyList.length;
            for (var i = 0; i < length; i++) {
                regionRelease(dirtyList[i]);
            }
            dirtyList.length = 0;
        };
        dirtyRegionProto.getDirtyRegions = function() {
            var dirtyList = this.dirtyList;
            if (this.clipRectChanged) {
                this.clipRectChanged = false;
                this.clear();
                var region = regionCreate();
                dirtyList.push(region.setTo(0, 0, this.clipWidth, this.clipHeight));
            } else {
                while (this.mergeDirtyList(dirtyList)) {}
            }
            var numDirty = this.dirtyList.length;
            if (numDirty > 0) {
                for (var i = 0; i < numDirty; i++) {
                    this.dirtyList[i].intValues();
                }
            }
            return this.dirtyList;
        };
        dirtyRegionProto.mergeDirtyList = function(dirtyList) {
            var length = dirtyList.length;
            if (length < 2) {
                return false;
            }
            var hasClipRect = this.hasClipRect;
            var bestDelta = length > 3 ? Number.POSITIVE_INFINITY : 0;
            var mergeA = 0;
            var mergeB = 0;
            var totalArea = 0;
            for (var i = 0; i < length - 1; i++) {
                var regionA = dirtyList[i];
                hasClipRect && (totalArea += regionA.area);
                for (var j = i + 1; j < length; j++) {
                    var regionB = dirtyList[j];
                    var delta = unionArea(regionA, regionB) - regionA.area - regionB.area;
                    if (bestDelta > delta) {
                        mergeA = i;
                        mergeB = j;
                        bestDelta = delta;
                    }
                }
            }
            hasClipRect && totalArea / this.clipArea > .95 && (this.clipRectChanged = true);
            if (mergeA !== mergeB) {
                var region = dirtyList[mergeB];
                dirtyList[mergeA].union(region);
                regionRelease(region);
                dirtyList.splice(mergeB, 1);
                return true;
            }
            return false;
        };
        cc.Region = Region;
        cc.DirtyRegion = DirtyRegion;
    }), {} ],
    200: [ (function(require, module, exports) {
        cc.rendererCanvas = {
            childrenOrderDirty: true,
            assignedZ: 0,
            assignedZStep: 1e-4,
            _transformNodePool: [],
            _renderCmds: [],
            _isCacheToCanvasOn: false,
            _cacheToCanvasCmds: {},
            _cacheInstanceIds: [],
            _currentID: 0,
            _clearColor: cc.color(),
            _clearFillStyle: "rgb(0, 0, 0)",
            _dirtyRegion: null,
            _allNeedDraw: true,
            _enableDirtyRegion: true,
            _debugDirtyRegion: false,
            _dirtyRegionCountThreshold: 10,
            init: function() {
                cc.sys.browserType !== cc.sys.BROWSER_TYPE_IE && cc.sys.browserType !== cc.sys.BROWSER_TYPE_UC || this.enableDirtyRegion(false);
            },
            getRenderCmd: function(renderableObject) {
                return renderableObject._createRenderCmd();
            },
            enableDirtyRegion: function(enabled) {
                this._enableDirtyRegion = enabled;
            },
            isDirtyRegionEnabled: function() {
                return this._enableDirtyRegion;
            },
            setDirtyRegionCountThreshold: function(threshold) {
                this._dirtyRegionCountThreshold = threshold;
            },
            _collectDirtyRegion: function() {
                var locCmds = this._renderCmds, i, len;
                var dirtyRegion = this._dirtyRegion;
                var localStatus = _ccsg.Node.CanvasRenderCmd.RegionStatus;
                var dirtryRegionCount = 0;
                var result = true;
                for (i = 0, len = locCmds.length; i < len; i++) {
                    var cmd = locCmds[i];
                    var regionFlag = cmd._regionFlag;
                    var oldRegion = cmd._oldRegion;
                    var currentRegion = cmd._currentRegion;
                    if (regionFlag > localStatus.NotDirty) {
                        ++dirtryRegionCount;
                        dirtryRegionCount > this._dirtyRegionCountThreshold && (result = false);
                        if (result) {
                            !currentRegion.isEmpty() && dirtyRegion.addRegion(currentRegion);
                            cmd._regionFlag > localStatus.Dirty && !oldRegion.isEmpty() && dirtyRegion.addRegion(oldRegion);
                        }
                        cmd._regionFlag = localStatus.NotDirty;
                    }
                }
                return result;
            },
            _beginDrawDirtyRegion: function(ctxWrapper) {
                var ctx = ctxWrapper.getContext();
                var dirtyList = this._dirtyRegion.getDirtyRegions();
                ctx.save();
                ctxWrapper.setTransform({
                    a: 1,
                    b: 0,
                    c: 0,
                    d: 1,
                    tx: 0,
                    ty: 0
                }, 1, 1);
                ctx.beginPath();
                var x = 0, y = 0, width = 0, height = 0, scaleX = ctxWrapper._scaleX, scaleY = ctxWrapper._scaleY;
                for (var index = 0, count = dirtyList.length; index < count; ++index) {
                    var region = dirtyList[index];
                    x = (region._minX * scaleX | 0) - 1;
                    y = (-region._maxY * scaleX | 0) - 1;
                    width = (region._width * scaleX | 0) + 2;
                    height = (region._height * scaleY | 0) + 2;
                    ctx.rect(x, y, width, height);
                }
                ctx.clip();
            },
            _endDrawDirtyRegion: function(ctx) {
                ctx.restore();
            },
            _debugDrawDirtyRegion: function(ctxWrapper) {
                if (!this._debugDirtyRegion) {
                    return;
                }
                var ctx = ctxWrapper.getContext();
                var dirtyList = this._dirtyRegion.getDirtyRegions();
                ctxWrapper.setTransform({
                    a: 1,
                    b: 0,
                    c: 0,
                    d: 1,
                    tx: 0,
                    ty: 0
                }, 1, 1);
                ctx.beginPath();
                var x = 0, y = 0, width = 0, height = 0, scaleX = ctxWrapper._scaleX, scaleY = ctxWrapper._scaleY;
                for (var index = 0, count = dirtyList.length; index < count; ++index) {
                    var region = dirtyList[index];
                    x = (region._minX * scaleX | 0) - 1;
                    y = (-region._maxY * scaleX | 0) - 1;
                    width = (region._width * scaleX | 0) + 2;
                    height = (region._height * scaleY | 0) + 2;
                    ctx.rect(x, y, width, height);
                }
                var oldstyle = ctx.fillStyle;
                ctx.fillStyle = "green";
                ctx.fill();
                ctx.fillStyle = oldstyle;
            },
            rendering: function(ctxWrapper) {
                var dirtyRegion = this._dirtyRegion = this._dirtyRegion || new cc.DirtyRegion();
                var viewport = cc._canvas;
                var wrapper = ctxWrapper || cc._renderContext;
                var ctx = wrapper.getContext();
                var scaleX = cc.view.getScaleX(), scaleY = cc.view.getScaleY();
                wrapper.setViewScale(scaleX, scaleY);
                wrapper.computeRealOffsetY();
                var dirtyList = this._dirtyRegion.getDirtyRegions();
                var locCmds = this._renderCmds, i, len;
                var allNeedDraw = this._allNeedDraw || !this._enableDirtyRegion;
                allNeedDraw || (allNeedDraw = allNeedDraw || !this._collectDirtyRegion());
                allNeedDraw || this._beginDrawDirtyRegion(wrapper);
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, viewport.width, viewport.height);
                if (0 !== this._clearColor.r || 0 !== this._clearColor.g || 0 !== this._clearColor.b) {
                    wrapper.setFillStyle(this._clearFillStyle);
                    wrapper.setGlobalAlpha(this._clearColor.a);
                    ctx.fillRect(0, 0, viewport.width, viewport.height);
                }
                for (i = 0, len = locCmds.length; i < len; i++) {
                    var cmd = locCmds[i];
                    if (!cmd._needDraw) {
                        continue;
                    }
                    var needRendering = false;
                    var cmdRegion = cmd._currentRegion;
                    if (!cmdRegion || allNeedDraw) {
                        needRendering = true;
                    } else {
                        for (var index = 0, count = dirtyList.length; index < count; ++index) {
                            if (dirtyList[index].intersects(cmdRegion)) {
                                needRendering = true;
                                break;
                            }
                        }
                    }
                    needRendering && cmd.rendering(wrapper, scaleX, scaleY);
                }
                if (!allNeedDraw) {
                    this._debugDrawDirtyRegion(wrapper);
                    this._endDrawDirtyRegion(ctx);
                }
                dirtyRegion.clear();
                this._allNeedDraw = false;
            },
            _renderingToCacheCanvas: function(ctx, instanceID, scaleX, scaleY) {
                ctx || cc.logID(7600);
                scaleX = void 0 === scaleX ? 1 : scaleX;
                scaleY = void 0 === scaleY ? 1 : scaleY;
                instanceID = instanceID || this._currentID;
                var locCmds = this._cacheToCanvasCmds[instanceID], i, len;
                ctx.computeRealOffsetY();
                for (i = 0, len = locCmds.length; i < len; i++) {
                    locCmds[i].rendering(ctx, scaleX, scaleY);
                }
                this._removeCache(instanceID);
                var locIDs = this._cacheInstanceIds;
                0 === locIDs.length ? this._isCacheToCanvasOn = false : this._currentID = locIDs[locIDs.length - 1];
            },
            _turnToCacheMode: function(renderTextureID) {
                this._isCacheToCanvasOn = true;
                renderTextureID = renderTextureID || 0;
                this._cacheToCanvasCmds[renderTextureID] = [];
                this._cacheInstanceIds.indexOf(renderTextureID) === -1 && this._cacheInstanceIds.push(renderTextureID);
                this._currentID = renderTextureID;
            },
            _turnToNormalMode: function() {
                this._isCacheToCanvasOn = false;
            },
            _removeCache: function(instanceID) {
                instanceID = instanceID || this._currentID;
                var cmds = this._cacheToCanvasCmds[instanceID];
                if (cmds) {
                    cmds.length = 0;
                    delete this._cacheToCanvasCmds[instanceID];
                }
                var locIDs = this._cacheInstanceIds;
                cc.js.array.remove(locIDs, instanceID);
            },
            resetFlag: function() {
                this.childrenOrderDirty = false;
                this._transformNodePool.length = 0;
            },
            transform: function() {
                var locPool = this._transformNodePool;
                locPool.sort(this._sortNodeByLevelAsc);
                for (var i = 0, len = locPool.length; i < len; i++) {
                    locPool[i].updateStatus();
                }
                locPool.length = 0;
            },
            transformDirty: function() {
                return this._transformNodePool.length > 0;
            },
            _sortNodeByLevelAsc: function(n1, n2) {
                return n1._curLevel - n2._curLevel;
            },
            pushDirtyNode: function(node) {
                this._transformNodePool.push(node);
            },
            clear: function() {},
            clearRenderCommands: function() {
                this._renderCmds.length = 0;
                this._cacheInstanceIds.length = 0;
                this._isCacheToCanvasOn = false;
                this._allNeedDraw = true;
            },
            pushRenderCommand: function(cmd) {
                if (!cmd.rendering) {
                    return;
                }
                if (this._isCacheToCanvasOn) {
                    var currentId = this._currentID, locCmdBuffer = this._cacheToCanvasCmds;
                    var cmdList = locCmdBuffer[currentId];
                    cmdList.indexOf(cmd) === -1 && cmdList.push(cmd);
                } else {
                    this._renderCmds.indexOf(cmd) === -1 && this._renderCmds.push(cmd);
                }
            }
        };
        (function() {
            cc.CanvasContextWrapper = function(context) {
                this._context = context;
                this._saveCount = 0;
                this._currentAlpha = context.globalAlpha;
                this._currentCompositeOperation = context.globalCompositeOperation;
                this._currentFillStyle = context.fillStyle;
                this._currentStrokeStyle = context.strokeStyle;
                this._offsetX = 0;
                this._offsetY = 0;
                this._realOffsetY = this.height;
                this._armatureMode = 0;
            };
            var proto = cc.CanvasContextWrapper.prototype;
            proto.resetCache = function() {
                var context = this._context;
                this._currentAlpha = context.globalAlpha;
                this._currentCompositeOperation = context.globalCompositeOperation;
                this._currentFillStyle = context.fillStyle;
                this._currentStrokeStyle = context.strokeStyle;
                this._realOffsetY = this._context.canvas.height + this._offsetY;
            };
            proto.setOffset = function(x, y) {
                this._offsetX = x;
                this._offsetY = y;
                this._realOffsetY = this._context.canvas.height + this._offsetY;
            };
            proto.computeRealOffsetY = function() {
                this._realOffsetY = this._context.canvas.height + this._offsetY;
            };
            proto.setViewScale = function(scaleX, scaleY) {
                this._scaleX = scaleX;
                this._scaleY = scaleY;
            };
            proto.getContext = function() {
                return this._context;
            };
            proto.save = function() {
                this._context.save();
                this._saveCount++;
            };
            proto.restore = function() {
                this._context.restore();
                this._currentAlpha = this._context.globalAlpha;
                this._saveCount--;
            };
            proto.setGlobalAlpha = function(alpha) {
                if (this._saveCount > 0) {
                    this._context.globalAlpha = alpha;
                } else {
                    if (this._currentAlpha !== alpha) {
                        this._currentAlpha = alpha;
                        this._context.globalAlpha = alpha;
                    }
                }
            };
            proto.setCompositeOperation = function(compositionOperation) {
                if (this._saveCount > 0) {
                    this._context.globalCompositeOperation = compositionOperation;
                } else {
                    if (this._currentCompositeOperation !== compositionOperation) {
                        this._currentCompositeOperation = compositionOperation;
                        this._context.globalCompositeOperation = compositionOperation;
                    }
                }
            };
            proto.setFillStyle = function(fillStyle) {
                this._context.fillStyle = fillStyle;
            };
            proto.setStrokeStyle = function(strokeStyle) {
                if (this._saveCount > 0) {
                    this._context.strokeStyle = strokeStyle;
                } else {
                    if (this._currentStrokeStyle !== strokeStyle) {
                        this._currentStrokeStyle = strokeStyle;
                        this._context.strokeStyle = strokeStyle;
                    }
                }
            };
            proto.setTransform = function(t, scaleX, scaleY) {
                if (this._armatureMode > 0) {
                    this.restore();
                    this.save();
                    this._context.transform(t.a, -t.b, -t.c, t.d, t.tx * scaleX, -(t.ty * scaleY));
                } else {
                    this._context.setTransform(t.a * scaleX, -t.b * scaleY, -t.c * scaleX, t.d * scaleY, this._offsetX + t.tx * scaleX, this._realOffsetY - t.ty * scaleY);
                }
            };
            proto._switchToArmatureMode = function(enable, t, scaleX, scaleY) {
                if (enable) {
                    this._armatureMode++;
                    this._context.setTransform(t.a, t.c, t.b, t.d, this._offsetX + t.tx * scaleX, this._realOffsetY - t.ty * scaleY);
                    this.save();
                } else {
                    this._armatureMode--;
                    this.restore();
                }
            };
        })();
    }), {} ],
    201: [ (function(require, module, exports) {
        var _batchedInfo = {
            texture: null,
            blendSrc: null,
            blendDst: null,
            shader: null
        }, _batchBroken = false, _indexBuffer = null, _vertexBuffer = null, _maxVertexSize = 0, _batchingSize = 0, _indexSize = 0, _sizePerVertex = 6, _vertexData = null, _vertexDataSize = 0, _vertexDataF32 = null, _vertexDataUI32 = null, _indexData = null, _prevIndexSize = 0, _pureQuad = true, _IS_IOS = false;
        function updateBuffer(numVertex) {
            var gl = cc._renderContext;
            if (_indexBuffer) {
                var indexCount = 6 * Math.ceil(numVertex / 4);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _indexBuffer);
                _indexData = new Uint16Array(indexCount);
                var currentQuad = 0;
                for (var i = 0, len = indexCount; i < len; i += 6) {
                    _indexData[i] = currentQuad + 0;
                    _indexData[i + 1] = currentQuad + 1;
                    _indexData[i + 2] = currentQuad + 2;
                    _indexData[i + 3] = currentQuad + 1;
                    _indexData[i + 4] = currentQuad + 2;
                    _indexData[i + 5] = currentQuad + 3;
                    currentQuad += 4;
                }
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, _indexData, gl.DYNAMIC_DRAW);
            }
            if (_vertexBuffer) {
                _vertexDataSize = numVertex * _sizePerVertex;
                var byteLength = 4 * _vertexDataSize;
                _vertexData = new ArrayBuffer(byteLength);
                _vertexDataF32 = new Float32Array(_vertexData);
                _vertexDataUI32 = new Uint32Array(_vertexData);
                gl.bindBuffer(gl.ARRAY_BUFFER, _vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, _vertexDataF32, gl.DYNAMIC_DRAW);
            }
            _maxVertexSize = numVertex - 200;
        }
        function initQuadBuffer(numVertex) {
            var gl = cc._renderContext;
            if (null === _indexBuffer) {
                _vertexBuffer = gl.createBuffer();
                _indexBuffer = gl.createBuffer();
            }
            updateBuffer(numVertex);
        }
        var VertexType = cc.Enum({
            QUAD: 0,
            TRIANGLE: 1,
            CUSTOM: 2
        });
        cc.rendererWebGL = {
            mat4Identity: null,
            childrenOrderDirty: true,
            assignedZ: 0,
            assignedZStep: .01,
            VertexType: VertexType,
            _transformNodePool: [],
            _renderCmds: [],
            _isCacheToBufferOn: false,
            _cacheToBufferCmds: {},
            _cacheInstanceIds: [],
            _currentID: 0,
            _clearColor: {
                r: 0,
                g: 0,
                b: 0,
                a: 255
            },
            init: function() {
                var gl = cc._renderContext;
                gl.disable(gl.CULL_FACE);
                gl.disable(gl.DEPTH_TEST);
                this.mat4Identity = new cc.math.Matrix4();
                this.mat4Identity.identity();
                initQuadBuffer(cc.macro.BATCH_VERTEX_COUNT);
                cc.sys.os === cc.sys.OS_IOS && (_IS_IOS = true);
            },
            getVertexSize: function() {
                return _maxVertexSize;
            },
            getRenderCmd: function(renderableObject) {
                return renderableObject._createRenderCmd();
            },
            _turnToCacheMode: function(renderTextureID) {
                this._isCacheToBufferOn = true;
                renderTextureID = renderTextureID || 0;
                this._cacheToBufferCmds[renderTextureID] ? this._cacheToBufferCmds[renderTextureID].length = 0 : this._cacheToBufferCmds[renderTextureID] = [];
                this._cacheInstanceIds.indexOf(renderTextureID) === -1 && this._cacheInstanceIds.push(renderTextureID);
                this._currentID = renderTextureID;
            },
            _turnToNormalMode: function() {
                this._isCacheToBufferOn = false;
            },
            _removeCache: function(instanceID) {
                instanceID = instanceID || this._currentID;
                var cmds = this._cacheToBufferCmds[instanceID];
                if (cmds) {
                    cmds.length = 0;
                    delete this._cacheToBufferCmds[instanceID];
                }
                var locIDs = this._cacheInstanceIds;
                cc.js.array.remove(locIDs, instanceID);
            },
            _renderingToBuffer: function(renderTextureId) {
                renderTextureId = renderTextureId || this._currentID;
                var locCmds = this._cacheToBufferCmds[renderTextureId];
                var ctx = cc._renderContext;
                this.rendering(ctx, locCmds);
                this._removeCache(renderTextureId);
                var locIDs = this._cacheInstanceIds;
                0 === locIDs.length ? this._isCacheToBufferOn = false : this._currentID = locIDs[locIDs.length - 1];
            },
            resetFlag: function() {
                this.childrenOrderDirty && (this.childrenOrderDirty = false);
                this._transformNodePool.length = 0;
            },
            transform: function() {
                var locPool = this._transformNodePool;
                locPool.sort(this._sortNodeByLevelAsc);
                var i, len, cmd;
                for (i = 0, len = locPool.length; i < len; i++) {
                    cmd = locPool[i];
                    cmd.updateStatus();
                }
                locPool.length = 0;
            },
            transformDirty: function() {
                return this._transformNodePool.length > 0;
            },
            _sortNodeByLevelAsc: function(n1, n2) {
                return n1._curLevel - n2._curLevel;
            },
            pushDirtyNode: function(node) {
                this._transformNodePool.push(node);
            },
            clearRenderCommands: function() {
                this._renderCmds.length = 0;
            },
            clear: function() {
                var gl = cc._renderContext;
                gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearColor.a);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            },
            setDepthTest: function(enable) {
                var gl = cc._renderContext;
                if (enable) {
                    gl.clearDepth(1);
                    gl.enable(gl.DEPTH_TEST);
                    gl.depthFunc(gl.LEQUAL);
                } else {
                    gl.disable(gl.DEPTH_TEST);
                }
            },
            pushRenderCommand: function(cmd) {
                if (!cmd.rendering && !cmd.uploadData) {
                    return;
                }
                if (this._isCacheToBufferOn) {
                    var currentId = this._currentID, locCmdBuffer = this._cacheToBufferCmds;
                    var cmdList = locCmdBuffer[currentId];
                    cmdList.indexOf(cmd) === -1 && cmdList.push(cmd);
                } else {
                    this._renderCmds.push(cmd);
                }
            },
            _increaseBatchingSize: function(increment, vertexType, indices) {
                vertexType = vertexType || VertexType.QUAD;
                var i, curr;
                switch (vertexType) {
                  case VertexType.QUAD:
                    for (i = 0; i < increment; i += 4) {
                        curr = _batchingSize + i;
                        _indexData[_indexSize++] = curr + 0;
                        _indexData[_indexSize++] = curr + 1;
                        _indexData[_indexSize++] = curr + 2;
                        _indexData[_indexSize++] = curr + 1;
                        _indexData[_indexSize++] = curr + 2;
                        _indexData[_indexSize++] = curr + 3;
                    }
                    break;

                  case VertexType.TRIANGLE:
                    _pureQuad = false;
                    for (i = 0; i < increment; i += 3) {
                        curr = _batchingSize + i;
                        _indexData[_indexSize++] = curr + 0;
                        _indexData[_indexSize++] = curr + 1;
                        _indexData[_indexSize++] = curr + 2;
                    }
                    break;

                  case VertexType.CUSTOM:
                    _pureQuad = false;
                    var len = indices.length;
                    for (i = 0; i < len; i++) {
                        _indexData[_indexSize++] = _batchingSize + indices[i];
                    }
                    break;

                  default:
                    return;
                }
                _batchingSize += increment;
            },
            _updateBatchedInfo: function(texture, blendFunc, shaderProgram) {
                texture && (_batchedInfo.texture = texture);
                if (blendFunc) {
                    _batchedInfo.blendSrc = blendFunc.src;
                    _batchedInfo.blendDst = blendFunc.dst;
                }
                shaderProgram && (_batchedInfo.shader = shaderProgram);
            },
            _breakBatch: function() {
                _batchBroken = true;
            },
            _uploadBufferData: function(cmd) {
                _batchingSize >= _maxVertexSize && this._batchRendering();
                var node = cmd._node;
                var texture = cmd._texture || node._texture || node._spriteFrame && node._spriteFrame._texture;
                var blendSrc = node._blendFunc.src;
                var blendDst = node._blendFunc.dst;
                var shader = cmd._shaderProgram;
                if (_batchBroken || _batchedInfo.texture !== texture || _batchedInfo.blendSrc !== blendSrc || _batchedInfo.blendDst !== blendDst || _batchedInfo.shader !== shader) {
                    this._batchRendering();
                    _batchedInfo.texture = texture;
                    _batchedInfo.blendSrc = blendSrc;
                    _batchedInfo.blendDst = blendDst;
                    _batchedInfo.shader = shader;
                    _batchBroken = false;
                }
                var len = cmd.uploadData(_vertexDataF32, _vertexDataUI32, _batchingSize * _sizePerVertex);
                if (len > 0) {
                    var i, curr, type = cmd.vertexType || VertexType.QUAD;
                    switch (type) {
                      case VertexType.QUAD:
                        for (i = 0; i < len; i += 4) {
                            curr = _batchingSize + i;
                            _indexData[_indexSize++] = curr + 0;
                            _indexData[_indexSize++] = curr + 1;
                            _indexData[_indexSize++] = curr + 2;
                            _indexData[_indexSize++] = curr + 1;
                            _indexData[_indexSize++] = curr + 2;
                            _indexData[_indexSize++] = curr + 3;
                        }
                        break;

                      case VertexType.TRIANGLE:
                        _pureQuad = false;
                        for (i = 0; i < len; i += 3) {
                            curr = _batchingSize + i;
                            _indexData[_indexSize++] = curr + 0;
                            _indexData[_indexSize++] = curr + 1;
                            _indexData[_indexSize++] = curr + 2;
                        }
                        break;

                      case VertexType.CUSTOM:
                        _pureQuad = false;
                        cmd.uploadIndexData && (_indexSize += cmd.uploadIndexData(_indexData, _indexSize, _batchingSize));
                        break;

                      default:
                        return;
                    }
                    _batchingSize += len;
                }
            },
            _batchRendering: function() {
                if (0 === _batchingSize || !_batchedInfo.texture) {
                    return;
                }
                var gl = cc._renderContext;
                var texture = _batchedInfo.texture;
                var shader = _batchedInfo.shader;
                var uploadAll = _batchingSize > .5 * _maxVertexSize;
                if (shader) {
                    shader.use();
                    shader._updateProjectionUniform();
                }
                cc.gl.blendFunc(_batchedInfo.blendSrc, _batchedInfo.blendDst);
                cc.gl.bindTexture2DN(0, texture);
                gl.bindBuffer(gl.ARRAY_BUFFER, _vertexBuffer);
                if (uploadAll) {
                    gl.bufferData(gl.ARRAY_BUFFER, _vertexDataF32, gl.DYNAMIC_DRAW);
                } else {
                    var view = _vertexDataF32.subarray(0, _batchingSize * _sizePerVertex);
                    gl.bufferData(gl.ARRAY_BUFFER, view, gl.DYNAMIC_DRAW);
                }
                gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_POSITION);
                gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_COLOR);
                gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_TEX_COORDS);
                gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 24, 0);
                gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, 24, 12);
                gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 24, 16);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _indexBuffer);
                (!_prevIndexSize || !_pureQuad || _indexSize > _prevIndexSize) && (uploadAll ? gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, _indexData, gl.DYNAMIC_DRAW) : gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, _indexData.subarray(0, _indexSize), gl.DYNAMIC_DRAW));
                gl.drawElements(gl.TRIANGLES, _indexSize, gl.UNSIGNED_SHORT, 0);
                cc.g_NumberOfDraws++;
                if (_pureQuad) {
                    _prevIndexSize = _indexSize;
                } else {
                    _prevIndexSize = 0;
                    _pureQuad = true;
                }
                _batchingSize = 0;
                _indexSize = 0;
            },
            rendering: function(ctx, cmds) {
                var locCmds = cmds || this._renderCmds, i, len, cmd, context = ctx || cc._renderContext;
                context.bindBuffer(context.ARRAY_BUFFER, null);
                for (i = 0, len = locCmds.length; i < len; ++i) {
                    cmd = locCmds[i];
                    if (!cmd._needDraw) {
                        continue;
                    }
                    if (cmd.uploadData) {
                        this._uploadBufferData(cmd);
                    } else {
                        _batchingSize > 0 && this._batchRendering();
                        cmd.rendering(context);
                    }
                }
                this._batchRendering();
                _batchedInfo.texture = null;
            }
        };
    }), {} ],
    202: [ (function(require, module, exports) {
        require("./RendererCanvas");
        require("./RendererWebGL");
        require("./DirtyRegion");
    }), {
        "./DirtyRegion": 199,
        "./RendererCanvas": 200,
        "./RendererWebGL": 201
    } ],
    203: [ (function(require, module, exports) {
        _ccsg.Scene = _ccsg.Node.extend({
            _className: "Scene",
            ctor: function() {
                _ccsg.Node.prototype.ctor.call(this);
                this._ignoreAnchorPointForPosition = true;
                this.setAnchorPoint(.5, .5);
                this.setContentSize(cc.director.getWinSize());
            }
        });
    }), {} ],
    204: [ (function(require, module, exports) {
        var EventTarget = require("../event/event-target");
        _ccsg.Sprite = _ccsg.Node.extend({
            dirty: false,
            atlasIndex: 0,
            textureAtlas: null,
            _recursiveDirty: null,
            _shouldBeHidden: false,
            _transformToBatch: null,
            _blendFunc: null,
            _texture: null,
            _rect: null,
            _rectRotated: false,
            _offsetPosition: null,
            _unflippedOffsetPositionFromCenter: null,
            _opacityModifyRGB: false,
            _flippedX: false,
            _flippedY: false,
            _textureLoaded: false,
            _className: "Sprite",
            ctor: function(fileName, rect, rotated) {
                var self = this;
                _ccsg.Node.prototype.ctor.call(self);
                EventTarget.call(self);
                self._shouldBeHidden = false;
                self._offsetPosition = cc.p(0, 0);
                self._unflippedOffsetPositionFromCenter = cc.p(0, 0);
                self._blendFunc = {
                    src: cc.macro.BLEND_SRC,
                    dst: cc.macro.BLEND_DST
                };
                self._rect = cc.rect(0, 0, 0, 0);
                self._softInit(fileName, rect, rotated);
            },
            textureLoaded: function() {
                return this._textureLoaded;
            },
            addLoadedEventListener: function(callback, target) {
                this.once("load", callback, target);
            },
            isDirty: function() {
                return this.dirty;
            },
            setDirty: function(bDirty) {
                this.dirty = bDirty;
            },
            isTextureRectRotated: function() {
                return this._rectRotated;
            },
            getAtlasIndex: function() {
                return this.atlasIndex;
            },
            setAtlasIndex: function(atlasIndex) {
                this.atlasIndex = atlasIndex;
            },
            getTextureRect: function() {
                return cc.rect(this._rect);
            },
            getTextureAtlas: function() {
                return this.textureAtlas;
            },
            setTextureAtlas: function(textureAtlas) {
                this.textureAtlas = textureAtlas;
            },
            getOffsetPosition: function() {
                return cc.p(this._offsetPosition);
            },
            _getOffsetX: function() {
                return this._offsetPosition.x;
            },
            _getOffsetY: function() {
                return this._offsetPosition.y;
            },
            getBlendFunc: function() {
                return this._blendFunc;
            },
            initWithSpriteFrame: function(spriteFrame) {
                cc.assertID(spriteFrame, 2606);
                if (!spriteFrame.textureLoaded()) {
                    this._textureLoaded = false;
                    spriteFrame.once("load", this._renderCmd._spriteFrameLoadedCallback, this._renderCmd);
                }
                var rotated = cc._renderType !== cc.game.RENDER_TYPE_CANVAS && spriteFrame._rotated;
                var ret = this.initWithTexture(spriteFrame.getTexture(), spriteFrame.getRect(), rotated);
                this.setSpriteFrame(spriteFrame);
                return ret;
            },
            initWithSpriteFrameName: function() {
                cc.warnID(2608);
                return;
            },
            useBatchNode: function(batchNode) {
                this.textureAtlas = batchNode.getTextureAtlas();
                this._batchNode = batchNode;
            },
            setVertexRect: function(rect) {
                var locRect = this._rect;
                locRect.x = rect.x;
                locRect.y = rect.y;
                locRect.width = rect.width;
                locRect.height = rect.height;
            },
            setFlippedX: function(flippedX) {
                if (this._flippedX !== flippedX) {
                    this._flippedX = flippedX;
                    this.setTextureRect(this._rect, this._rectRotated, this._contentSize);
                    this.setNodeDirty(true);
                }
            },
            setFlippedY: function(flippedY) {
                if (this._flippedY !== flippedY) {
                    this._flippedY = flippedY;
                    this.setTextureRect(this._rect, this._rectRotated, this._contentSize);
                    this.setNodeDirty(true);
                }
            },
            isFlippedX: function() {
                return this._flippedX;
            },
            isFlippedY: function() {
                return this._flippedY;
            },
            setOpacityModifyRGB: function(modify) {
                if (this._opacityModifyRGB !== modify) {
                    this._opacityModifyRGB = modify;
                    this._renderCmd._setColorDirty();
                }
            },
            isOpacityModifyRGB: function() {
                return this._opacityModifyRGB;
            },
            setDisplayFrameWithAnimationName: function(animationName, frameIndex) {
                cc.assertID(animationName, 2610);
                var cache = cc.spriteFrameAnimationCache.getAnimation(animationName);
                if (!cache) {
                    cc.logID(2602);
                    return;
                }
                var animFrame = cache.getFrames()[frameIndex];
                if (!animFrame) {
                    cc.logID(2603);
                    return;
                }
                this.setSpriteFrame(animFrame.getSpriteFrame());
            },
            getTexture: function() {
                return this._texture;
            },
            _softInit: function(fileName, rect, rotated) {
                if (void 0 === fileName) {
                    _ccsg.Sprite.prototype.init.call(this);
                } else {
                    if (cc.js.isString(fileName)) {
                        "#" === fileName[0] ? cc.logID(2728, fileName) : _ccsg.Sprite.prototype.init.call(this, fileName, rect);
                    } else {
                        if ("object" === typeof fileName) {
                            if (fileName instanceof cc.Texture2D) {
                                this.initWithTexture(fileName, rect, rotated);
                            } else {
                                if (fileName instanceof cc.SpriteFrame) {
                                    this.initWithSpriteFrame(fileName);
                                } else {
                                    if (fileName instanceof HTMLImageElement || fileName instanceof HTMLCanvasElement) {
                                        var texture2d = new cc.Texture2D();
                                        texture2d.initWithElement(fileName);
                                        texture2d.handleLoadedTexture();
                                        this.initWithTexture(texture2d);
                                    }
                                }
                            }
                        }
                    }
                }
            },
            getQuad: function() {
                return null;
            },
            setBlendFunc: function(src, dst) {
                var locBlendFunc = this._blendFunc;
                if (void 0 === dst) {
                    locBlendFunc.src = src.src;
                    locBlendFunc.dst = src.dst;
                } else {
                    locBlendFunc.src = src;
                    locBlendFunc.dst = dst;
                }
                this._renderCmd.updateBlendFunc(locBlendFunc);
            },
            init: function() {
                var _t = this;
                if (arguments.length > 0) {
                    return _t.initWithFile(arguments[0], arguments[1]);
                }
                _t.dirty = _t._recursiveDirty = false;
                _t._blendFunc.src = cc.macro.BLEND_SRC;
                _t._blendFunc.dst = cc.macro.BLEND_DST;
                _t.texture = null;
                _t._flippedX = _t._flippedY = false;
                _t.anchorX = .5;
                _t.anchorY = .5;
                _t._offsetPosition.x = 0;
                _t._offsetPosition.y = 0;
                _t.setTextureRect(cc.rect(0, 0, 0, 0), false, cc.size(0, 0));
                return true;
            },
            initWithFile: function(filename, rect) {
                cc.assertID(filename, 2609);
                var tex = cc.textureCache.getTextureForKey(filename);
                if (tex) {
                    if (!rect) {
                        var size = tex.getContentSize();
                        rect = cc.rect(0, 0, size.width, size.height);
                    }
                    return this.initWithTexture(tex, rect);
                }
                tex = cc.textureCache.addImage(filename);
                return this.initWithTexture(tex, rect || cc.rect(0, 0, tex._contentSize.width, tex._contentSize.height));
            },
            initWithTexture: function(texture, rect, rotated, counterclockwise) {
                var _t = this;
                cc.assertID(0 !== arguments.length, 2710);
                rotated = rotated || false;
                texture = this._renderCmd._handleTextureForRotatedTexture(texture, rect, rotated, counterclockwise);
                _t._recursiveDirty = false;
                _t.dirty = false;
                _t._opacityModifyRGB = true;
                _t._blendFunc.src = cc.macro.BLEND_SRC;
                _t._blendFunc.dst = cc.macro.BLEND_DST;
                _t._flippedX = _t._flippedY = false;
                _t.setAnchorPoint(.5, .5);
                _t._offsetPosition.x = 0;
                _t._offsetPosition.y = 0;
                var locTextureLoaded = texture.isLoaded();
                _t._textureLoaded = locTextureLoaded;
                if (!locTextureLoaded) {
                    _t._rectRotated = rotated;
                    if (rect) {
                        _t._rect.x = rect.x;
                        _t._rect.y = rect.y;
                        _t._rect.width = rect.width;
                        _t._rect.height = rect.height;
                    }
                    _t.texture && _t.texture.off("load", _t._renderCmd._textureLoadedCallback, _t._renderCmd);
                    texture.once("load", _t._renderCmd._textureLoadedCallback, _t._renderCmd);
                    _t.setTexture(texture);
                    return true;
                }
                rect || (rect = cc.rect(0, 0, texture.width, texture.height));
                this._renderCmd._checkTextureBoundary(texture, rect, rotated);
                _t.setTexture(texture);
                _t.setTextureRect(rect, rotated);
                this.emit("load");
                return true;
            },
            setTextureRect: function(rect, rotated, untrimmedSize, needConvert) {
                var _t = this;
                _t._rectRotated = rotated || false;
                _t.setContentSize(untrimmedSize || rect);
                _t.setVertexRect(rect);
                _t._renderCmd._setTextureCoords(rect, needConvert);
                var relativeOffsetX = _t._unflippedOffsetPositionFromCenter.x, relativeOffsetY = _t._unflippedOffsetPositionFromCenter.y;
                _t._flippedX && (relativeOffsetX = -relativeOffsetX);
                _t._flippedY && (relativeOffsetY = -relativeOffsetY);
                var locRect = _t._rect;
                _t._offsetPosition.x = relativeOffsetX + (_t._contentSize.width - locRect.width) / 2;
                _t._offsetPosition.y = relativeOffsetY + (_t._contentSize.height - locRect.height) / 2;
            },
            setSpriteFrame: function(newFrame) {
                var _t = this;
                cc.assertID(newFrame, 2712);
                this.setNodeDirty(true);
                var frameOffset = newFrame.getOffset();
                _t._unflippedOffsetPositionFromCenter.x = frameOffset.x;
                _t._unflippedOffsetPositionFromCenter.y = frameOffset.y;
                var pNewTexture = newFrame.getTexture();
                var locTextureLoaded = newFrame.textureLoaded();
                if (locTextureLoaded) {
                    _t._textureLoaded = true;
                    if (pNewTexture !== _t._texture) {
                        _t._setTexture(pNewTexture);
                        _t.setColor(_t._realColor);
                    }
                    _t.setTextureRect(newFrame.getRect(), newFrame.isRotated(), newFrame.getOriginalSize());
                } else {
                    _t._textureLoaded = false;
                    newFrame.once("load", (function(event) {
                        var sender = event.currentTarget;
                        _t._textureLoaded = true;
                        var locNewTexture = sender.getTexture();
                        locNewTexture !== _t._texture && _t._setTexture(locNewTexture);
                        _t.setTextureRect(sender.getRect(), sender.isRotated(), sender.getOriginalSize());
                        _t.emit("load");
                        _t.setColor(_t._realColor);
                    }), _t);
                }
                this._renderCmd._updateForSetSpriteFrame(pNewTexture);
            },
            setDisplayFrame: function(newFrame) {
                cc.logID(2604);
                this.setSpriteFrame(newFrame);
            },
            isFrameDisplayed: function(frame) {
                return this._renderCmd.isFrameDisplayed(frame);
            },
            displayFrame: function() {
                return this.getSpriteFrame();
            },
            getSpriteFrame: function() {
                return new cc.SpriteFrame(this._texture, this._rect, this._rectRotated, this._unflippedOffsetPositionFromCenter, this._contentSize);
            },
            setTexture: function(texture) {
                if (!texture) {
                    return this._renderCmd._setTexture(null);
                }
                var isFileName = cc.js.isString(texture);
                isFileName && (texture = cc.textureCache.addImage(texture));
                if (texture._textureLoaded) {
                    this._setTexture(texture, isFileName);
                    this.setColor(this._realColor);
                    this._textureLoaded = true;
                    this.emit("load");
                } else {
                    this._renderCmd._setTexture(texture);
                    texture.once("load", (function(event) {
                        this._setTexture(texture, isFileName);
                        this.setColor(this._realColor);
                        this._textureLoaded = true;
                        this.emit("load");
                    }), this);
                }
            },
            _setTexture: function(texture, change) {
                this._renderCmd._setTexture(texture);
                change && this._changeRectWithTexture(texture);
            },
            _changeRectWithTexture: function(texture) {
                var contentSize = texture._contentSize;
                var rect = cc.rect(0, 0, contentSize.width, contentSize.height);
                this.setTextureRect(rect);
            },
            _createRenderCmd: function() {
                return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new _ccsg.Sprite.CanvasRenderCmd(this) : new _ccsg.Sprite.WebGLRenderCmd(this);
            }
        });
        cc.js.addon(_ccsg.Sprite.prototype, EventTarget.prototype);
        cc.assertID("function" === typeof cc._tmp.PrototypeSprite, 3200, "SpritesPropertyDefine.js");
        cc._tmp.PrototypeSprite();
        delete cc._tmp.PrototypeSprite;
    }), {
        "../event/event-target": 112
    } ],
    205: [ (function(require, module, exports) {
        _ccsg.Sprite.CanvasRenderCmd = function(renderable) {
            this._rootCtor(renderable);
            this._needDraw = true;
            this._textureCoord = {
                renderX: 0,
                renderY: 0,
                x: 0,
                y: 0,
                width: 0,
                height: 0,
                validRect: false
            };
            this._blendFuncStr = "source-over";
            this._colorized = false;
            this._textureToRender = null;
        };
        var proto = _ccsg.Sprite.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
        proto.constructor = _ccsg.Sprite.CanvasRenderCmd;
        proto.setDirtyRecursively = function(value) {};
        proto._setTexture = function(texture) {
            var node = this._node;
            if (node._texture !== texture) {
                node._textureLoaded = !!texture && texture._textureLoaded;
                node._texture = texture;
                var texSize = texture._contentSize;
                var rect = cc.rect(0, 0, texSize.width, texSize.height);
                node.setTextureRect(rect);
                this._updateColor();
            }
        };
        proto._setColorDirty = function() {
            this.setDirtyFlag(_ccsg.Node._dirtyFlags.colorDirty | _ccsg.Node._dirtyFlags.opacityDirty);
        };
        proto.isFrameDisplayed = function(frame) {
            var node = this._node;
            if (frame.getTexture() !== node._texture) {
                return false;
            }
            return cc.rectEqualToRect(frame.getRect(), node._rect);
        };
        proto.updateBlendFunc = function(blendFunc) {
            this._blendFuncStr = _ccsg.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(blendFunc);
        };
        proto._handleTextureForRotatedTexture = function(texture, rect, rotated, counterclockwise) {
            if (rotated && texture.isLoaded()) {
                var tempElement = texture.getHtmlElementObj();
                tempElement = _ccsg.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(tempElement, rect, counterclockwise);
                var tempTexture = new cc.Texture2D();
                tempTexture.initWithElement(tempElement);
                tempTexture.handleLoadedTexture();
                texture = tempTexture;
                rect.x = rect.y = 0;
                this._node._rect = cc.rect(0, 0, rect.width, rect.height);
            }
            return texture;
        };
        proto._checkTextureBoundary = function(texture, rect, rotated) {
            if (texture && texture.url) {
                var _x = rect.x + rect.width, _y = rect.y + rect.height;
                _x > texture.width && cc.errorID(3300, texture.url);
                _y > texture.height && cc.errorID(3400, texture.url);
            }
        };
        proto.rendering = function(ctx, scaleX, scaleY) {
            var node = this._node;
            var locTextureCoord = this._textureCoord, alpha = this._displayedOpacity / 255;
            var texture = this._textureToRender || node._texture;
            if (texture && (0 === locTextureCoord.width || 0 === locTextureCoord.height || !texture._textureLoaded) || 0 === alpha) {
                return;
            }
            var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
            var locX = node._offsetPosition.x, locHeight = node._rect.height, locWidth = node._rect.width, locY = -node._offsetPosition.y - locHeight, image;
            wrapper.setTransform(this._worldTransform, scaleX, scaleY);
            wrapper.setCompositeOperation(this._blendFuncStr);
            wrapper.setGlobalAlpha(alpha);
            (node._flippedX || node._flippedY) && wrapper.save();
            if (node._flippedX) {
                locX = -locX - locWidth;
                context.scale(-1, 1);
            }
            if (node._flippedY) {
                locY = node._offsetPosition.y;
                context.scale(1, -1);
            }
            var sx, sy, sw, sh, x, y, w, h;
            if (this._colorized) {
                sx = 0;
                sy = 0;
            } else {
                sx = locTextureCoord.renderX;
                sy = locTextureCoord.renderY;
            }
            sw = locTextureCoord.width;
            sh = locTextureCoord.height;
            x = locX;
            y = locY;
            w = locWidth;
            h = locHeight;
            if (texture && texture._htmlElementObj) {
                image = texture._htmlElementObj;
                if ("" !== texture._pattern) {
                    wrapper.setFillStyle(context.createPattern(image, texture._pattern));
                    context.fillRect(x, y, w, h);
                } else {
                    context.drawImage(image, sx, sy, sw, sh, x, y, w, h);
                }
            } else {
                var contentSize = node._contentSize;
                if (locTextureCoord.validRect) {
                    var curColor = this._displayedColor;
                    wrapper.setFillStyle("rgba(" + curColor.r + "," + curColor.g + "," + curColor.b + ",1)");
                    context.fillRect(x, y, contentSize.width, contentSize.height);
                }
            }
            (node._flippedX || node._flippedY) && wrapper.restore();
            cc.g_NumberOfDraws++;
        };
        proto._updateColor = function() {
            var node = this._node;
            var texture = node._texture, rect = this._textureCoord;
            var dColor = this._displayedColor;
            if (texture) {
                if (255 !== dColor.r || 255 !== dColor.g || 255 !== dColor.b) {
                    this._textureToRender = texture._generateColorTexture(dColor.r, dColor.g, dColor.b, rect);
                    this._colorized = true;
                } else {
                    if (texture) {
                        this._textureToRender = texture;
                        this._colorized = false;
                    }
                }
            }
        };
        proto._updateForSetSpriteFrame = function(pNewTexture, textureLoaded) {
            this._colorized = false;
            this._textureCoord.renderX = this._textureCoord.x;
            this._textureCoord.renderY = this._textureCoord.y;
            textureLoaded = textureLoaded || pNewTexture._textureLoaded;
            if (textureLoaded) {
                var curColor = this._node.getColor();
                255 === curColor.r && 255 === curColor.g && 255 === curColor.b || this._updateColor();
            }
        };
        proto._spriteFrameLoadedCallback = function(event) {
            var node = this._node, spriteFrame = event.currentTarget;
            node.setTextureRect(spriteFrame.getRect(), spriteFrame.isRotated(), spriteFrame.getOriginalSize());
            this._updateColor();
            node.emit("load");
        };
        proto._textureLoadedCallback = function(event) {
            var node = this._node, sender = event.currentTarget;
            if (node._textureLoaded) {
                return;
            }
            node._textureLoaded = true;
            var locRect = node._rect;
            if (locRect) {
                if (cc._rectEqualToZero(locRect)) {
                    locRect.width = sender.width;
                    locRect.height = sender.height;
                }
            } else {
                locRect = cc.rect(0, 0, sender.width, sender.height);
            }
            node.texture = sender;
            node.setTextureRect(locRect, node._rectRotated);
            var locColor = this._displayedColor;
            255 === locColor.r && 255 === locColor.g && 255 === locColor.b || this._updateColor();
            node.emit("load");
        };
        proto._setTextureCoords = function(rect) {
            var locTextureRect = this._textureCoord;
            locTextureRect.renderX = locTextureRect.x = 0 | rect.x;
            locTextureRect.renderY = locTextureRect.y = 0 | rect.y;
            locTextureRect.width = 0 | rect.width;
            locTextureRect.height = 0 | rect.height;
            locTextureRect.validRect = !(0 === locTextureRect.width || 0 === locTextureRect.height || locTextureRect.x < 0 || locTextureRect.y < 0);
        };
        _ccsg.Sprite.CanvasRenderCmd._cutRotateImageToCanvas = function(texture, rect, counterclockwise) {
            if (!texture) {
                return null;
            }
            if (!rect) {
                return texture;
            }
            counterclockwise = null == counterclockwise || counterclockwise;
            var nCanvas = document.createElement("canvas");
            nCanvas.width = rect.width;
            nCanvas.height = rect.height;
            var ctx = nCanvas.getContext("2d");
            ctx.translate(nCanvas.width / 2, nCanvas.height / 2);
            counterclockwise ? ctx.rotate(-1.5707963267948966) : ctx.rotate(1.5707963267948966);
            ctx.drawImage(texture, rect.x, rect.y, rect.height, rect.width, -rect.height / 2, -rect.width / 2, rect.height, rect.width);
            return nCanvas;
        };
    }), {} ],
    206: [ (function(require, module, exports) {
        var macro = cc.macro;
        _ccsg.Sprite.WebGLRenderCmd = function(renderable) {
            this._rootCtor(renderable);
            this._needDraw = true;
            this._vertices = [ {
                x: 0,
                y: 0,
                u: 0,
                v: 0
            }, {
                x: 0,
                y: 0,
                u: 0,
                v: 0
            }, {
                x: 0,
                y: 0,
                u: 0,
                v: 0
            }, {
                x: 0,
                y: 0,
                u: 0,
                v: 0
            } ];
            this._dirty = false;
            this._recursiveDirty = false;
            this._shaderProgram = cc.shaderCache.programForKey(macro.SHADER_SPRITE_POSITION_TEXTURECOLOR);
        };
        var proto = _ccsg.Sprite.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
        proto.constructor = _ccsg.Sprite.WebGLRenderCmd;
        proto.updateBlendFunc = function(blendFunc) {};
        proto.setDirtyFlag = function(dirtyFlag) {
            _ccsg.Node.WebGLRenderCmd.prototype.setDirtyFlag.call(this, dirtyFlag);
            this._dirty = true;
        };
        proto.setDirtyRecursively = function(value) {
            this._recursiveDirty = value;
            this._dirty = value;
            var locChildren = this._node._children, child, l = locChildren ? locChildren.length : 0;
            for (var i = 0; i < l; i++) {
                child = locChildren[i];
                child instanceof _ccsg.Sprite && child._renderCmd.setDirtyRecursively(value);
            }
        };
        proto._handleTextureForRotatedTexture = function(texture) {
            return texture;
        };
        proto.isFrameDisplayed = function(frame) {
            var node = this._node;
            return cc.rectEqualToRect(frame.getRect(), node._rect) && frame.getTexture().getName() === node._texture.getName() && cc.pointEqualToPoint(frame.getOffset(), node._unflippedOffsetPositionFromCenter);
        };
        proto._updateForSetSpriteFrame = function() {};
        proto._spriteFrameLoadedCallback = function(event) {
            var spriteFrame = event.currentTarget;
            this._node.setTextureRect(spriteFrame.getRect(), spriteFrame.isRotated(), spriteFrame.getOriginalSize());
            this._node.emit("load");
        };
        proto._textureLoadedCallback = function(event) {
            var node = this._node, sender = event.currentTarget;
            if (node._textureLoaded) {
                return;
            }
            node._textureLoaded = true;
            var locRect = node._rect;
            if (locRect) {
                if (cc._rectEqualToZero(locRect)) {
                    locRect.width = sender.width;
                    locRect.height = sender.height;
                }
            } else {
                locRect = cc.rect(0, 0, sender.width, sender.height);
            }
            node.texture = sender;
            node.setTextureRect(locRect, node._rectRotated);
            node.emit("load");
            cc.renderer.childrenOrderDirty = true;
        };
        proto._setTextureCoords = function(rect) {
            var node = this._node;
            var tex = node._texture;
            var uvs = this._vertices;
            if (!tex) {
                return;
            }
            var atlasWidth = tex.pixelWidth;
            var atlasHeight = tex.pixelHeight;
            var left, right, top, bottom, tempSwap;
            if (node._rectRotated) {
                if (macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                    left = (2 * rect.x + 1) / (2 * atlasWidth);
                    right = left + (2 * rect.height - 2) / (2 * atlasWidth);
                    top = (2 * rect.y + 1) / (2 * atlasHeight);
                    bottom = top + (2 * rect.width - 2) / (2 * atlasHeight);
                } else {
                    left = rect.x / atlasWidth;
                    right = (rect.x + rect.height) / atlasWidth;
                    top = rect.y / atlasHeight;
                    bottom = (rect.y + rect.width) / atlasHeight;
                }
                if (node._flippedX) {
                    tempSwap = top;
                    top = bottom;
                    bottom = tempSwap;
                }
                if (node._flippedY) {
                    tempSwap = left;
                    left = right;
                    right = tempSwap;
                }
                uvs[0].u = right;
                uvs[0].v = top;
                uvs[1].u = left;
                uvs[1].v = top;
                uvs[2].u = right;
                uvs[2].v = bottom;
                uvs[3].u = left;
                uvs[3].v = bottom;
            } else {
                if (macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                    left = (2 * rect.x + 1) / (2 * atlasWidth);
                    right = left + (2 * rect.width - 2) / (2 * atlasWidth);
                    top = (2 * rect.y + 1) / (2 * atlasHeight);
                    bottom = top + (2 * rect.height - 2) / (2 * atlasHeight);
                } else {
                    left = rect.x / atlasWidth;
                    right = (rect.x + rect.width) / atlasWidth;
                    top = rect.y / atlasHeight;
                    bottom = (rect.y + rect.height) / atlasHeight;
                }
                if (node._flippedX) {
                    tempSwap = left;
                    left = right;
                    right = tempSwap;
                }
                if (node._flippedY) {
                    tempSwap = top;
                    top = bottom;
                    bottom = tempSwap;
                }
                uvs[0].u = left;
                uvs[0].v = top;
                uvs[1].u = left;
                uvs[1].v = bottom;
                uvs[2].u = right;
                uvs[2].v = top;
                uvs[3].u = right;
                uvs[3].v = bottom;
            }
        };
        proto._setColorDirty = function() {};
        proto._updateBlendFunc = function() {
            var node = this._node;
            if (node._texture && node._texture.hasPremultipliedAlpha()) {
                node._blendFunc.src = macro.BLEND_SRC;
                node._blendFunc.dst = macro.BLEND_DST;
                node.opacityModifyRGB = true;
            } else {
                node._blendFunc.src = macro.SRC_ALPHA;
                node._blendFunc.dst = macro.ONE_MINUS_SRC_ALPHA;
                node.opacityModifyRGB = false;
            }
        };
        proto._setTexture = function(texture) {
            var node = this._node;
            if (node._texture !== texture) {
                node._textureLoaded = !!texture && texture._textureLoaded;
                node._texture = texture;
                this._updateBlendFunc();
                node._textureLoaded && (cc.renderer.childrenOrderDirty = true);
            }
        };
        proto._checkTextureBoundary = function(texture, rect, rotated) {
            if (texture && texture.url) {
                var _x, _y;
                if (rotated) {
                    _x = rect.x + rect.height;
                    _y = rect.y + rect.width;
                } else {
                    _x = rect.x + rect.width;
                    _y = rect.y + rect.height;
                }
                _x > texture.width && cc.errorID(3300, texture.url);
                _y > texture.height && cc.errorID(3400, texture.url);
            }
        };
        proto.transform = function(parentCmd, recursive) {
            this.originTransform(parentCmd, recursive);
            var node = this._node, lx = node._offsetPosition.x, rx = lx + node._rect.width, by = node._offsetPosition.y, ty = by + node._rect.height, wt = this._worldTransform;
            var vertices = this._vertices;
            vertices[0].x = lx * wt.a + ty * wt.c + wt.tx;
            vertices[0].y = lx * wt.b + ty * wt.d + wt.ty;
            vertices[1].x = lx * wt.a + by * wt.c + wt.tx;
            vertices[1].y = lx * wt.b + by * wt.d + wt.ty;
            vertices[2].x = rx * wt.a + ty * wt.c + wt.tx;
            vertices[2].y = rx * wt.b + ty * wt.d + wt.ty;
            vertices[3].x = rx * wt.a + by * wt.c + wt.tx;
            vertices[3].y = rx * wt.b + by * wt.d + wt.ty;
        };
        proto.needDraw = function() {
            var node = this._node, locTexture = node._texture;
            return this._needDraw && locTexture;
        };
        proto.uploadData = function(f32buffer, ui32buffer, vertexDataOffset) {
            var node = this._node, locTexture = node._texture;
            if (!(locTexture && locTexture._textureLoaded && node._rect.width && node._rect.height) || !this._displayedOpacity) {
                return 0;
            }
            var opacity = this._displayedOpacity;
            var color, colorVal = this._displayedColor._val;
            if (node._opacityModifyRGB) {
                var a = opacity / 255, r = this._displayedColor.r * a, g = this._displayedColor.g * a, b = this._displayedColor.b * a;
                color = (opacity << 24 >>> 0) + (b << 16) + (g << 8) + r;
            } else {
                color = (opacity << 24 >>> 0) + ((65280 & colorVal) << 8) + ((16711680 & colorVal) >> 8) + (colorVal >>> 24);
            }
            var z = node._vertexZ;
            var vertices = this._vertices;
            var i, len = vertices.length, vertex, offset = vertexDataOffset;
            for (i = 0; i < len; ++i) {
                vertex = vertices[i];
                f32buffer[offset] = vertex.x;
                f32buffer[offset + 1] = vertex.y;
                f32buffer[offset + 2] = z;
                ui32buffer[offset + 3] = color;
                f32buffer[offset + 4] = vertex.u;
                f32buffer[offset + 5] = vertex.v;
                offset += 6;
            }
            return len;
        };
    }), {} ],
    207: [ (function(require, module, exports) {
        var EventTarget = require("../event/event-target");
        var dataPool = {
            _pool: {},
            _lengths: [],
            put: function(data) {
                var length = data.length;
                if (this._pool[length]) {
                    this._pool[length].push(data);
                } else {
                    this._pool[length] = [ data ];
                    this._lengths.push(length);
                    this._lengths.sort();
                }
            },
            get: function(length) {
                var id;
                for (var i = 0; i < this._lengths.length; i++) {
                    if (this._lengths[i] >= length) {
                        id = this._lengths[i];
                        break;
                    }
                }
                return id ? this._pool[id].pop() : void 0;
            }
        };
        var macro = cc.macro, webgl, vl, vb, vt, vr, cornerId = [];
        var simpleQuadGenerator = {
            _rebuildQuads_base: function(sprite, spriteFrame, contentSize, isTrimmedContentSize) {
                var vertices = sprite._vertices, wt = sprite._renderCmd._worldTransform, l, b, r, t;
                if (isTrimmedContentSize) {
                    l = 0;
                    b = 0;
                    r = contentSize.width;
                    t = contentSize.height;
                } else {
                    var originalSize = spriteFrame._originalSize;
                    var rect = spriteFrame._rect;
                    var offset = spriteFrame._offset;
                    var scaleX = contentSize.width / originalSize.width;
                    var scaleY = contentSize.height / originalSize.height;
                    var trimmLeft = offset.x + (originalSize.width - rect.width) / 2;
                    var trimmRight = offset.x - (originalSize.width - rect.width) / 2;
                    var trimmedBottom = offset.y + (originalSize.height - rect.height) / 2;
                    var trimmedTop = offset.y - (originalSize.height - rect.height) / 2;
                    l = trimmLeft * scaleX;
                    b = trimmedBottom * scaleY;
                    r = contentSize.width + trimmRight * scaleX;
                    t = contentSize.height + trimmedTop * scaleY;
                }
                if (vertices.length < 8) {
                    dataPool.put(vertices);
                    vertices = dataPool.get(8) || new Float32Array(8);
                    sprite._vertices = vertices;
                }
                if (webgl) {
                    var la = l * wt.a, lb = l * wt.b, ra = r * wt.a, rb = r * wt.b, tcx = t * wt.c + wt.tx, tdy = t * wt.d + wt.ty, bcx = b * wt.c + wt.tx, bdy = b * wt.d + wt.ty;
                    vertices[0] = la + bcx;
                    vertices[1] = lb + bdy;
                    vertices[2] = ra + bcx;
                    vertices[3] = rb + bdy;
                    vertices[4] = la + tcx;
                    vertices[5] = lb + tdy;
                    vertices[6] = ra + tcx;
                    vertices[7] = rb + tdy;
                } else {
                    vertices[0] = l;
                    vertices[1] = b;
                    vertices[2] = r;
                    vertices[3] = b;
                    vertices[4] = l;
                    vertices[5] = t;
                    vertices[6] = r;
                    vertices[7] = t;
                }
                cornerId[0] = 0;
                cornerId[1] = 2;
                cornerId[2] = 4;
                cornerId[3] = 6;
                sprite._uvsDirty && this._calculateUVs(sprite, spriteFrame);
                sprite._vertCount = 4;
            },
            _calculateUVs: function(sprite, spriteFrame) {
                var uvs = sprite._uvs;
                var atlasWidth = spriteFrame._texture._pixelWidth;
                var atlasHeight = spriteFrame._texture._pixelHeight;
                var textureRect = spriteFrame._rect;
                if (uvs.length < 8) {
                    dataPool.put(uvs);
                    uvs = dataPool.get(8) || new Float32Array(8);
                    sprite._uvs = uvs;
                }
                var l, b, r, t;
                var texelCorrect = macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? .5 : 0;
                if (spriteFrame._rotated) {
                    l = (textureRect.x + texelCorrect) / atlasWidth;
                    b = (textureRect.y + textureRect.width - texelCorrect) / atlasHeight;
                    r = (textureRect.x + textureRect.height - texelCorrect) / atlasWidth;
                    t = (textureRect.y + texelCorrect) / atlasHeight;
                    uvs[0] = l;
                    uvs[1] = t;
                    uvs[2] = l;
                    uvs[3] = b;
                    uvs[4] = r;
                    uvs[5] = t;
                    uvs[6] = r;
                    uvs[7] = b;
                } else {
                    l = (textureRect.x + texelCorrect) / atlasWidth;
                    b = (textureRect.y + textureRect.height - texelCorrect) / atlasHeight;
                    r = (textureRect.x + textureRect.width - texelCorrect) / atlasWidth;
                    t = (textureRect.y + texelCorrect) / atlasHeight;
                    uvs[0] = l;
                    uvs[1] = b;
                    uvs[2] = r;
                    uvs[3] = b;
                    uvs[4] = l;
                    uvs[5] = t;
                    uvs[6] = r;
                    uvs[7] = t;
                }
            }
        };
        var scale9QuadGenerator = {
            x: new Array(4),
            y: new Array(4),
            _rebuildQuads_base: function(sprite, spriteFrame, contentSize, insetLeft, insetRight, insetTop, insetBottom) {
                var vertices = sprite._vertices;
                var wt = sprite._renderCmd._worldTransform;
                var leftWidth, centerWidth, rightWidth;
                var topHeight, centerHeight, bottomHeight;
                var rect = spriteFrame._rect;
                leftWidth = insetLeft;
                rightWidth = insetRight;
                centerWidth = rect.width - leftWidth - rightWidth;
                topHeight = insetTop;
                bottomHeight = insetBottom;
                centerHeight = rect.height - topHeight - bottomHeight;
                var preferSize = contentSize;
                var sizableWidth = preferSize.width - leftWidth - rightWidth;
                var sizableHeight = preferSize.height - topHeight - bottomHeight;
                var xScale = preferSize.width / (leftWidth + rightWidth);
                var yScale = preferSize.height / (topHeight + bottomHeight);
                xScale = isNaN(xScale) || xScale > 1 ? 1 : xScale;
                yScale = isNaN(yScale) || yScale > 1 ? 1 : yScale;
                sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
                sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
                var x = this.x;
                var y = this.y;
                x[0] = 0;
                x[1] = leftWidth * xScale;
                x[2] = x[1] + sizableWidth;
                x[3] = preferSize.width;
                y[0] = 0;
                y[1] = bottomHeight * yScale;
                y[2] = y[1] + sizableHeight;
                y[3] = preferSize.height;
                if (vertices.length < 32) {
                    dataPool.put(vertices);
                    vertices = dataPool.get(32) || new Float32Array(32);
                    sprite._vertices = vertices;
                }
                var offset = 0, row, col;
                if (webgl) {
                    for (row = 0; row < 4; row++) {
                        for (col = 0; col < 4; col++) {
                            vertices[offset] = x[col] * wt.a + y[row] * wt.c + wt.tx;
                            vertices[offset + 1] = x[col] * wt.b + y[row] * wt.d + wt.ty;
                            offset += 2;
                        }
                    }
                } else {
                    for (row = 0; row < 4; row++) {
                        for (col = 0; col < 4; col++) {
                            vertices[offset] = x[col];
                            vertices[offset + 1] = y[row];
                            offset += 2;
                        }
                    }
                }
                cornerId[0] = 0;
                cornerId[1] = 6;
                cornerId[2] = 24;
                cornerId[3] = 30;
                sprite._uvsDirty && this._calculateUVs(sprite, spriteFrame, insetLeft, insetRight, insetTop, insetBottom);
            },
            _calculateUVs: function(sprite, spriteFrame, insetLeft, insetRight, insetTop, insetBottom) {
                var uvs = sprite._uvs;
                var rect = spriteFrame._rect;
                var atlasWidth = spriteFrame._texture._pixelWidth;
                var atlasHeight = spriteFrame._texture._pixelHeight;
                var leftWidth, centerWidth, rightWidth;
                var topHeight, centerHeight, bottomHeight;
                var textureRect = spriteFrame._rect;
                leftWidth = insetLeft;
                rightWidth = insetRight;
                centerWidth = rect.width - leftWidth - rightWidth;
                topHeight = insetTop;
                bottomHeight = insetBottom;
                centerHeight = rect.height - topHeight - bottomHeight;
                if (uvs.length < 32) {
                    dataPool.put(uvs);
                    uvs = dataPool.get(32) || new Float32Array(32);
                    sprite._uvs = uvs;
                }
                var u = this.x;
                var v = this.y;
                var texelCorrect = macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? .5 : 0;
                var offset = 0, row, col;
                if (spriteFrame._rotated) {
                    u[0] = (textureRect.x + texelCorrect) / atlasWidth;
                    u[1] = (bottomHeight + textureRect.x) / atlasWidth;
                    u[2] = (bottomHeight + centerHeight + textureRect.x) / atlasWidth;
                    u[3] = (textureRect.x + textureRect.height - texelCorrect) / atlasWidth;
                    v[3] = (textureRect.y + texelCorrect) / atlasHeight;
                    v[2] = (leftWidth + textureRect.y) / atlasHeight;
                    v[1] = (leftWidth + centerWidth + textureRect.y) / atlasHeight;
                    v[0] = (textureRect.y + textureRect.width - texelCorrect) / atlasHeight;
                    for (row = 0; row < 4; row++) {
                        for (col = 0; col < 4; col++) {
                            uvs[offset] = u[row];
                            uvs[offset + 1] = v[3 - col];
                            offset += 2;
                        }
                    }
                } else {
                    u[0] = (textureRect.x + texelCorrect) / atlasWidth;
                    u[1] = (leftWidth + textureRect.x) / atlasWidth;
                    u[2] = (leftWidth + centerWidth + textureRect.x) / atlasWidth;
                    u[3] = (textureRect.x + textureRect.width - texelCorrect) / atlasWidth;
                    v[3] = (textureRect.y + texelCorrect) / atlasHeight;
                    v[2] = (topHeight + textureRect.y) / atlasHeight;
                    v[1] = (topHeight + centerHeight + textureRect.y) / atlasHeight;
                    v[0] = (textureRect.y + textureRect.height - texelCorrect) / atlasHeight;
                    for (row = 0; row < 4; row++) {
                        for (col = 0; col < 4; col++) {
                            uvs[offset] = u[col];
                            uvs[offset + 1] = v[row];
                            offset += 2;
                        }
                    }
                }
            }
        };
        var tiledQuadGenerator = {
            _rebuildQuads_base: function(sprite, spriteFrame, contentSize) {
                var vertices = sprite._vertices, wt = sprite._renderCmd._worldTransform, uvs = sprite._uvs;
                var atlasWidth = spriteFrame._texture._pixelWidth;
                var atlasHeight = spriteFrame._texture._pixelHeight;
                var textureRect = spriteFrame._rect;
                var u0, v0, u1, v1;
                var texelCorrect = macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? .5 : 0;
                if (spriteFrame._rotated) {
                    u0 = (textureRect.x + texelCorrect) / atlasWidth;
                    u1 = (textureRect.x + textureRect.height - texelCorrect) / atlasWidth;
                    v0 = (textureRect.y + textureRect.width - texelCorrect) / atlasHeight;
                    v1 = (textureRect.y + texelCorrect) / atlasHeight;
                } else {
                    u0 = (textureRect.x + texelCorrect) / atlasWidth;
                    u1 = (textureRect.x + textureRect.width - texelCorrect) / atlasWidth;
                    v0 = (textureRect.y + textureRect.height - texelCorrect) / atlasHeight;
                    v1 = (textureRect.y + texelCorrect) / atlasHeight;
                }
                var rectWidth = textureRect.width;
                var rectHeight = textureRect.height;
                var hRepeat = contentSize.width / rectWidth;
                var vRepeat = contentSize.height / rectHeight;
                var row = Math.ceil(vRepeat), col = Math.ceil(hRepeat);
                row * col > 16384 && cc.errorID(2625);
                var dataLength = row * col * 4 * 2;
                if (vertices.length < dataLength) {
                    dataPool.put(vertices);
                    vertices = dataPool.get(dataLength) || new Float32Array(dataLength);
                    sprite._vertices = vertices;
                }
                if (uvs.length < dataLength) {
                    dataPool.put(uvs);
                    uvs = dataPool.get(dataLength) || new Float32Array(dataLength);
                    sprite._uvs = uvs;
                }
                var offset = 0, l, b, r, t;
                sprite._vertCount = 0;
                for (var vindex = 0; vindex < row; ++vindex) {
                    for (var hindex = 0; hindex < col; ++hindex) {
                        l = rectWidth * hindex;
                        b = rectHeight * vindex;
                        r = rectWidth * Math.min(hindex + 1, hRepeat);
                        t = rectHeight * Math.min(vindex + 1, vRepeat);
                        if (webgl) {
                            var la = l * wt.a, lb = l * wt.b, ra = r * wt.a, rb = r * wt.b, tcx = t * wt.c + wt.tx, tdy = t * wt.d + wt.ty, bcx = b * wt.c + wt.tx, bdy = b * wt.d + wt.ty;
                            vertices[offset] = la + bcx;
                            vertices[offset + 1] = lb + bdy;
                            vertices[offset + 2] = ra + bcx;
                            vertices[offset + 3] = rb + bdy;
                            vertices[offset + 4] = la + tcx;
                            vertices[offset + 5] = lb + tdy;
                            vertices[offset + 6] = ra + tcx;
                            vertices[offset + 7] = rb + tdy;
                        } else {
                            vertices[offset] = l;
                            vertices[offset + 1] = b;
                            vertices[offset + 2] = r;
                            vertices[offset + 3] = b;
                            vertices[offset + 4] = l;
                            vertices[offset + 5] = t;
                            vertices[offset + 6] = r;
                            vertices[offset + 7] = t;
                        }
                        if (spriteFrame._rotated) {
                            uvs[offset] = u0;
                            uvs[offset + 1] = v1;
                            uvs[offset + 2] = u0;
                            uvs[offset + 3] = t = v1 + (v0 - v1) * Math.min(1, hRepeat - hindex);
                            uvs[offset + 4] = r = u0 + (u1 - u0) * Math.min(1, vRepeat - vindex);
                            uvs[offset + 5] = v1;
                            uvs[offset + 6] = r;
                            uvs[offset + 7] = t;
                        } else {
                            uvs[offset] = u0;
                            uvs[offset + 1] = v0;
                            uvs[offset + 2] = r = u0 + (u1 - u0) * Math.min(1, hRepeat - hindex);
                            uvs[offset + 3] = v0;
                            uvs[offset + 4] = u0;
                            uvs[offset + 5] = t = v0 + (v1 - v0) * Math.min(1, vRepeat - vindex);
                            uvs[offset + 6] = r;
                            uvs[offset + 7] = t;
                        }
                        offset += 8;
                        sprite._vertCount += 4;
                        if (offset > dataLength) {
                            return;
                        }
                    }
                }
                cornerId[0] = 0;
                cornerId[1] = 8 * (col - 1) + 2;
                cornerId[2] = (row - 1) * col * 8 + 4;
                cornerId[3] = dataLength - 2;
            }
        };
        var fillQuadGeneratorBar = {
            _rebuildQuads_base: function(sprite, spriteFrame, contentSize, fillType, fillStart, fillRange) {
                var vertices = sprite._vertices, wt = sprite._renderCmd._worldTransform, uvs = sprite._uvs;
                var fillEnd;
                var l = 0, b = 0, r = contentSize.width, t = contentSize.height;
                var atlasWidth = spriteFrame._texture._pixelWidth;
                var atlasHeight = spriteFrame._texture._pixelHeight;
                var textureRect = spriteFrame._rect;
                var ul, vb, ur, vt;
                var texelCorrect = macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? .5 : 0;
                if (spriteFrame._rotated) {
                    ul = (textureRect.x + texelCorrect) / atlasWidth;
                    vb = (textureRect.y + textureRect.width - texelCorrect) / atlasHeight;
                    ur = (textureRect.x + textureRect.height - texelCorrect) / atlasWidth;
                    vt = (textureRect.y + texelCorrect) / atlasHeight;
                } else {
                    ul = (textureRect.x + texelCorrect) / atlasWidth;
                    vb = (textureRect.y + textureRect.height - texelCorrect) / atlasHeight;
                    ur = (textureRect.x + textureRect.width - texelCorrect) / atlasWidth;
                    vt = (textureRect.y + texelCorrect) / atlasHeight;
                }
                if (vertices.length < 8) {
                    dataPool.put(vertices);
                    vertices = dataPool.get(8) || new Float32Array(8);
                    sprite._vertices = vertices;
                }
                if (uvs.length < 8) {
                    dataPool.put(uvs);
                    uvs = dataPool.get(8) || new Float32Array(8);
                    sprite._uvs = uvs;
                }
                var quadUV = new Array(8);
                if (spriteFrame._rotated) {
                    quadUV[0] = quadUV[2] = ul;
                    quadUV[4] = quadUV[6] = ur;
                    quadUV[3] = quadUV[7] = vb;
                    quadUV[1] = quadUV[5] = vt;
                } else {
                    quadUV[0] = quadUV[4] = ul;
                    quadUV[2] = quadUV[6] = ur;
                    quadUV[1] = quadUV[3] = vb;
                    quadUV[5] = quadUV[7] = vt;
                }
                fillStart = fillStart > 1 ? 1 : fillStart;
                fillStart = fillStart < 0 ? 0 : fillStart;
                fillRange = fillRange < 0 ? 0 : fillRange;
                fillEnd = fillStart + fillRange;
                fillEnd = fillEnd > 1 ? 1 : fillEnd;
                var progressStart, progressEnd;
                switch (fillType) {
                  case FillType.HORIZONTAL:
                    progressStart = l + (r - l) * fillStart;
                    progressEnd = l + (r - l) * fillEnd;
                    l = progressStart;
                    r = progressEnd;
                    uvs[0] = quadUV[0] + (quadUV[2] - quadUV[0]) * fillStart;
                    uvs[1] = quadUV[1];
                    uvs[2] = quadUV[0] + (quadUV[2] - quadUV[0]) * fillEnd;
                    uvs[3] = quadUV[3];
                    uvs[4] = quadUV[4] + (quadUV[6] - quadUV[4]) * fillStart;
                    uvs[5] = quadUV[5];
                    uvs[6] = quadUV[4] + (quadUV[6] - quadUV[4]) * fillEnd;
                    uvs[7] = quadUV[7];
                    break;

                  case FillType.VERTICAL:
                    progressStart = b + (t - b) * fillStart;
                    progressEnd = b + (t - b) * fillEnd;
                    b = progressStart;
                    t = progressEnd;
                    uvs[0] = quadUV[0];
                    uvs[1] = quadUV[1] + (quadUV[5] - quadUV[1]) * fillStart;
                    uvs[2] = quadUV[2];
                    uvs[3] = quadUV[3] + (quadUV[7] - quadUV[3]) * fillStart;
                    uvs[4] = quadUV[4];
                    uvs[5] = quadUV[1] + (quadUV[5] - quadUV[1]) * fillEnd;
                    uvs[6] = quadUV[6];
                    uvs[7] = quadUV[3] + (quadUV[7] - quadUV[3]) * fillEnd;
                    break;

                  default:
                    cc.errorID(2626);
                }
                if (webgl) {
                    var la = l * wt.a, lb = l * wt.b, ra = r * wt.a, rb = r * wt.b, tcx = t * wt.c + wt.tx, tdy = t * wt.d + wt.ty, bcx = b * wt.c + wt.tx, bdy = b * wt.d + wt.ty;
                    vertices[0] = la + bcx;
                    vertices[1] = lb + bdy;
                    vertices[2] = ra + bcx;
                    vertices[3] = rb + bdy;
                    vertices[4] = la + tcx;
                    vertices[5] = lb + tdy;
                    vertices[6] = ra + tcx;
                    vertices[7] = rb + tdy;
                } else {
                    vertices[0] = l;
                    vertices[1] = b;
                    vertices[2] = r;
                    vertices[3] = b;
                    vertices[4] = l;
                    vertices[5] = t;
                    vertices[6] = r;
                    vertices[7] = t;
                }
                sprite._vertCount = 4;
                cornerId[0] = 0;
                cornerId[1] = 2;
                cornerId[2] = 4;
                cornerId[3] = 6;
            }
        };
        var fillQuadGeneratorRadial = {
            _vertPos: [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ],
            _vertices: [ cc.v2(0, 0), cc.v2(0, 0) ],
            _uvs: [ cc.v2(0, 0), cc.v2(0, 0) ],
            _intersectPoint_1: [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ],
            _intersectPoint_2: [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ],
            outVerts: null,
            outUvs: null,
            rawVerts: null,
            rawUvs: null,
            _rebuildQuads_base: function(sprite, spriteFrame, contentSize, fillCenter, fillStart, fillRange) {
                var vertices = sprite._vertices, uvs = sprite._uvs, rawVerts = sprite._rawVerts, rawUvs = sprite._rawUvs, wt = sprite._renderCmd._worldTransform;
                while (fillStart >= 1) {
                    fillStart -= 1;
                }
                while (fillStart < 0) {
                    fillStart += 1;
                }
                var cx = fillCenter.x * contentSize.width, cy = fillCenter.y * contentSize.height;
                var center = cc.v2(cx, cy);
                fillStart *= 2 * Math.PI;
                fillRange *= 2 * Math.PI;
                var fillEnd = fillStart + fillRange;
                this.outVerts = vertices;
                this.outUvs = uvs;
                this.rawVerts = rawVerts;
                this.rawUvs = rawUvs;
                this._calculateVertices(wt, spriteFrame, contentSize);
                this._calculateUVs(spriteFrame);
                var _vertPos = this._vertPos, _vertices = this._vertices;
                _vertPos[0].x = _vertPos[3].x = _vertices[0].x;
                _vertPos[1].x = _vertPos[2].x = _vertices[1].x;
                _vertPos[0].y = _vertPos[1].y = _vertices[0].y;
                _vertPos[2].y = _vertPos[3].y = _vertices[1].y;
                center.x > _vertices[1].x && (center.x = _vertices[1].x);
                center.x < _vertices[0].x && (center.x = _vertices[0].x);
                center.y < _vertices[0].y && (center.y = _vertices[0].y);
                center.y > _vertices[1].y && (center.y = _vertices[1].y);
                rawVerts[0] = rawVerts[4] = this._vertices[0].x;
                rawVerts[2] = rawVerts[6] = this._vertices[1].x;
                rawVerts[1] = rawVerts[3] = this._vertices[0].y;
                rawVerts[5] = rawVerts[7] = this._vertices[1].y;
                if (spriteFrame._rotated) {
                    rawUvs[0] = rawUvs[2] = this._uvs[0].x;
                    rawUvs[4] = rawUvs[6] = this._uvs[1].x;
                    rawUvs[3] = rawUvs[7] = this._uvs[0].y;
                    rawUvs[1] = rawUvs[5] = this._uvs[1].y;
                } else {
                    rawUvs[0] = rawUvs[4] = this._uvs[0].x;
                    rawUvs[2] = rawUvs[6] = this._uvs[1].x;
                    rawUvs[1] = rawUvs[3] = this._uvs[0].y;
                    rawUvs[5] = rawUvs[7] = this._uvs[1].y;
                }
                var triangles = [ null, null, null, null ];
                center.x !== this._vertices[0].x && (triangles[0] = [ 3, 0 ]);
                center.x !== this._vertices[1].x && (triangles[2] = [ 1, 2 ]);
                center.y !== this._vertices[0].y && (triangles[1] = [ 0, 1 ]);
                center.y !== this._vertices[1].y && (triangles[3] = [ 2, 3 ]);
                this._getInsectedPoints(this._vertices[0].x, this._vertices[1].x, this._vertices[0].y, this._vertices[1].y, center, fillStart, this._intersectPoint_1);
                this._getInsectedPoints(this._vertices[0].x, this._vertices[1].x, this._vertices[0].y, this._vertices[1].y, center, fillStart + fillRange, this._intersectPoint_2);
                var dataLength = 30;
                if (vertices.length < dataLength) {
                    dataPool.put(vertices);
                    vertices = dataPool.get(dataLength) || new Float32Array(dataLength);
                    this.outVerts = sprite._vertices = vertices;
                }
                if (uvs.length < dataLength) {
                    dataPool.put(uvs);
                    uvs = dataPool.get(dataLength) || new Float32Array(dataLength);
                    this.outUvs = sprite._uvs = uvs;
                }
                var offset = 0, count = 0;
                for (var triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
                    var triangle = triangles[triangleIndex];
                    if (null === triangle) {
                        continue;
                    }
                    if (fillRange >= 2 * Math.PI) {
                        this._generateTriangle(wt, offset, center, this._vertPos[triangle[0]], this._vertPos[triangle[1]]);
                        offset += 6;
                        count += 3;
                        continue;
                    }
                    var startAngle = this._getVertAngle(center, this._vertPos[triangle[0]]);
                    var endAngle = this._getVertAngle(center, this._vertPos[triangle[1]]);
                    endAngle < startAngle && (endAngle += 2 * Math.PI);
                    startAngle -= 2 * Math.PI;
                    endAngle -= 2 * Math.PI;
                    for (var testIndex = 0; testIndex < 3; ++testIndex) {
                        if (startAngle >= fillEnd) {
                            ;
                        } else {
                            if (startAngle >= fillStart) {
                                endAngle >= fillEnd ? this._generateTriangle(wt, offset, center, this._vertPos[triangle[0]], this._intersectPoint_2[triangleIndex]) : this._generateTriangle(wt, offset, center, this._vertPos[triangle[0]], this._vertPos[triangle[1]]);
                                offset += 6;
                                count += 3;
                            } else {
                                if (endAngle <= fillStart) {
                                    ;
                                } else {
                                    if (endAngle <= fillEnd) {
                                        this._generateTriangle(wt, offset, center, this._intersectPoint_1[triangleIndex], this._vertPos[triangle[1]]);
                                        offset += 6;
                                        count += 3;
                                    } else {
                                        this._generateTriangle(wt, offset, center, this._intersectPoint_1[triangleIndex], this._intersectPoint_2[triangleIndex]);
                                        offset += 6;
                                        count += 3;
                                    }
                                }
                            }
                        }
                        startAngle += 2 * Math.PI;
                        endAngle += 2 * Math.PI;
                    }
                }
                sprite._vertCount = count;
                cornerId[0] = 0;
                cornerId[1] = 2;
                cornerId[2] = 4;
                cornerId[3] = 6;
            },
            _generateTriangle: function(wt, offset, vert0, vert1, vert2) {
                var rawVerts = this.rawVerts;
                var rawUvs = this.rawUvs;
                var vertices = this.outVerts;
                var v0x = rawVerts[0];
                var v0y = rawVerts[1];
                var v1x = rawVerts[6];
                var v1y = rawVerts[7];
                var progressX, progressY;
                if (webgl) {
                    vertices[offset] = vert0.x * wt.a + vert0.y * wt.c + wt.tx;
                    vertices[offset + 1] = vert0.x * wt.b + vert0.y * wt.d + wt.ty;
                    vertices[offset + 2] = vert1.x * wt.a + vert1.y * wt.c + wt.tx;
                    vertices[offset + 3] = vert1.x * wt.b + vert1.y * wt.d + wt.ty;
                    vertices[offset + 4] = vert2.x * wt.a + vert2.y * wt.c + wt.tx;
                    vertices[offset + 5] = vert2.x * wt.b + vert2.y * wt.d + wt.ty;
                } else {
                    vertices[offset] = vert0.x;
                    vertices[offset + 1] = vert0.y;
                    vertices[offset + 2] = vert1.x;
                    vertices[offset + 3] = vert1.y;
                    vertices[offset + 4] = vert2.x;
                    vertices[offset + 5] = vert2.y;
                }
                progressX = (vert0.x - v0x) / (v1x - v0x);
                progressY = (vert0.y - v0y) / (v1y - v0y);
                this._generateUV(progressX, progressY, rawUvs, offset);
                progressX = (vert1.x - v0x) / (v1x - v0x);
                progressY = (vert1.y - v0y) / (v1y - v0y);
                this._generateUV(progressX, progressY, rawUvs, offset + 2);
                progressX = (vert2.x - v0x) / (v1x - v0x);
                progressY = (vert2.y - v0y) / (v1y - v0y);
                this._generateUV(progressX, progressY, rawUvs, offset + 4);
            },
            _generateUV: function(progressX, progressY, uvs, offset) {
                var out = this.outUvs;
                var px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX;
                var px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX;
                var py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX;
                var py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX;
                out[offset] = px1 + (px2 - px1) * progressY;
                out[offset + 1] = py1 + (py2 - py1) * progressY;
            },
            _isAngleIn: function(angle, start, rangeAngle) {
                var pi_2 = 2 * Math.PI;
                while (angle < start || angle >= start + pi_2) {
                    angle < start && (angle += pi_2);
                    angle >= start + pi_2 && (angle -= pi_2);
                }
                return angle <= start + rangeAngle;
            },
            _getVertAngle: function(start, end) {
                var placementX, placementY;
                placementX = end.x - start.x;
                placementY = end.y - start.y;
                if (0 === placementX && 0 === placementY) {
                    return;
                }
                if (0 === placementX) {
                    return placementY > 0 ? .5 * Math.PI : 1.5 * Math.PI;
                }
                var angle = Math.atan(placementY / placementX);
                placementX < 0 && (angle += Math.PI);
                return angle;
            },
            _getInsectedPoints: function(left, right, bottom, top, center, angle, intersectPoints) {
                var result = [ null, null, null, null ];
                var sinAngle = Math.sin(angle);
                var cosAngle = Math.cos(angle);
                var tanAngle, cotAngle;
                if (0 !== Math.cos(angle)) {
                    tanAngle = sinAngle / cosAngle;
                    if ((left - center.x) * cosAngle > 0) {
                        var yleft = center.y + tanAngle * (left - center.x);
                        intersectPoints[0].x = left;
                        intersectPoints[0].y = yleft;
                    }
                    if ((right - center.x) * cosAngle > 0) {
                        var yright = center.y + tanAngle * (right - center.x);
                        intersectPoints[2].x = right;
                        intersectPoints[2].y = yright;
                    }
                }
                if (0 !== Math.sin(angle)) {
                    cotAngle = cosAngle / sinAngle;
                    if ((top - center.y) * sinAngle > 0) {
                        var xtop = center.x + cotAngle * (top - center.y);
                        intersectPoints[3].x = xtop;
                        intersectPoints[3].y = top;
                    }
                    if ((bottom - center.y) * sinAngle > 0) {
                        var xbottom = center.x + cotAngle * (bottom - center.y);
                        intersectPoints[1].x = xbottom;
                        intersectPoints[1].y = bottom;
                    }
                }
                return result;
            },
            _calculateVertices: function(wt, spriteFrame, contentSize) {
                var x0, x3, y0, y3;
                x0 = 0;
                y0 = 0;
                x3 = contentSize.width;
                y3 = contentSize.height;
                this._vertices[0].x = x0;
                this._vertices[0].y = y0;
                this._vertices[1].x = x3;
                this._vertices[1].y = y3;
            },
            _calculateUVs: function(spriteFrame) {
                var atlasWidth = spriteFrame._texture._pixelWidth;
                var atlasHeight = spriteFrame._texture._pixelHeight;
                var textureRect = spriteFrame._rect;
                var u0, u3, v0, v3;
                var texelCorrect = macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? .5 : 0;
                if (spriteFrame._rotated) {
                    u0 = (textureRect.x + texelCorrect) / atlasWidth;
                    u3 = (textureRect.x + textureRect.height - texelCorrect) / atlasWidth;
                    v0 = (textureRect.y + texelCorrect) / atlasHeight;
                    v3 = (textureRect.y + textureRect.width - texelCorrect) / atlasHeight;
                } else {
                    u0 = (textureRect.x + texelCorrect) / atlasWidth;
                    u3 = (textureRect.x + textureRect.width - texelCorrect) / atlasWidth;
                    v0 = (textureRect.y + texelCorrect) / atlasHeight;
                    v3 = (textureRect.y + textureRect.height - texelCorrect) / atlasHeight;
                }
                this._uvs[0].x = u0;
                this._uvs[0].y = v3;
                this._uvs[1].x = u3;
                this._uvs[1].y = v0;
            }
        };
        var meshQuadGenerator = {
            _rebuildQuads_base: function(sprite, spriteFrame, polygonInfo) {
                if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                    return;
                }
                if (!polygonInfo) {
                    return;
                }
                var wt = sprite._renderCmd._worldTransform;
                var srcVerts = polygonInfo.triangles.verts;
                var vertices = sprite._vertices;
                var uvs = sprite._uvs;
                var count = srcVerts.length;
                var dataLength = 2 * count;
                if (vertices.length < dataLength) {
                    dataPool.put(vertices);
                    vertices = dataPool.get(dataLength) || new Float32Array(dataLength);
                    sprite._vertices = vertices;
                }
                if (uvs.length < dataLength) {
                    dataPool.put(uvs);
                    uvs = dataPool.get(dataLength) || new Float32Array(dataLength);
                    sprite._uvs = uvs;
                }
                var l = 1 / 0, b = 1 / 0, r = -(1 / 0), t = -(1 / 0);
                for (var i = 0; i < count; i++) {
                    var x = srcVerts[i].x * wt.a + srcVerts[i].y * wt.c + wt.tx;
                    var y = srcVerts[i].x * wt.b + srcVerts[i].y * wt.d + wt.ty;
                    vertices[2 * i] = x;
                    vertices[2 * i + 1] = y;
                    uvs[2 * i] = srcVerts[i].u;
                    uvs[2 * i + 1] = srcVerts[i].v;
                    if (x < l) {
                        l = x;
                        cornerId[0] = 2 * i;
                    }
                    if (x > r) {
                        r = x;
                        cornerId[1] = 2 * i;
                    }
                    if (y < b) {
                        b = y;
                        cornerId[2] = 2 * i;
                    }
                    if (y > t) {
                        t = y;
                        cornerId[3] = 2 * i;
                    }
                }
                sprite._vertCount = count;
            }
        };
        cc.Scale9Sprite = _ccsg.Node.extend({
            _spriteFrame: null,
            _insetLeft: 0,
            _insetRight: 0,
            _insetTop: 0,
            _insetBottom: 0,
            _blendFunc: null,
            _renderingType: 1,
            _brightState: 0,
            _rawVerts: null,
            _rawUvs: null,
            _vertices: null,
            _uvs: null,
            _vertCount: 0,
            _quadsDirty: true,
            _uvsDirty: true,
            _isTriangle: false,
            _isTrimmedContentSize: true,
            _fillType: 0,
            _fillCenter: null,
            _fillStart: 0,
            _fillRange: 2 * Math.PI,
            _distortionOffset: null,
            _distortionTiling: null,
            _meshPolygonInfo: null,
            ctor: function(textureOrSpriteFrame) {
                _ccsg.Node.prototype.ctor.call(this);
                this._renderCmd.setState(this._brightState);
                this._blendFunc = cc.BlendFunc._alphaNonPremultiplied();
                this._fillCenter = cc.v2(0, 0);
                this.setAnchorPoint(cc.p(.5, .5));
                this._rawVerts = null;
                this._rawUvs = null;
                this._vertices = dataPool.get(8) || new Float32Array(8);
                this._uvs = dataPool.get(8) || new Float32Array(8);
                "string" === typeof textureOrSpriteFrame || textureOrSpriteFrame instanceof cc.Texture2D ? this.initWithTexture(textureOrSpriteFrame) : textureOrSpriteFrame instanceof cc.SpriteFrame && this.initWithSpriteFrame(textureOrSpriteFrame);
                if (void 0 === webgl) {
                    webgl = cc._renderType === cc.game.RENDER_TYPE_WEBGL;
                    vl = cc.visibleRect.left;
                    vr = cc.visibleRect.right;
                    vt = cc.visibleRect.top;
                    vb = cc.visibleRect.bottom;
                }
            },
            loaded: function() {
                return null !== this._spriteFrame && this._spriteFrame.textureLoaded();
            },
            initWithTexture: function(textureOrTextureFile) {
                this.setTexture(textureOrTextureFile);
            },
            initWithSpriteFrame: function(spriteFrameOrSFName) {
                this.setSpriteFrame(spriteFrameOrSFName);
            },
            setTexture: function(textureOrTextureFile) {
                var spriteFrame = new cc.SpriteFrame(textureOrTextureFile);
                this.setSpriteFrame(spriteFrame);
            },
            setSpriteFrame: function(spriteFrame) {
                if (spriteFrame) {
                    this._spriteFrame = spriteFrame;
                    this._quadsDirty = true;
                    this._uvsDirty = true;
                    this._renderCmd._needDraw = false;
                    var self = this;
                    var onResourceDataLoaded = function() {
                        cc.sizeEqualToSize(self._contentSize, cc.size(0, 0)) && self.setContentSize(self._spriteFrame._rect);
                        self._renderCmd._needDraw = true;
                        self._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
                    };
                    spriteFrame.textureLoaded() ? onResourceDataLoaded() : spriteFrame.once("load", onResourceDataLoaded, this);
                }
            },
            setBlendFunc: function(blendFunc, dst) {
                if (void 0 === dst) {
                    this._blendFunc.src = blendFunc.src || cc.macro.BLEND_SRC;
                    this._blendFunc.dst = blendFunc.dst || cc.macro.BLEND_DST;
                } else {
                    this._blendFunc.src = blendFunc || cc.macro.BLEND_SRC;
                    this._blendFunc.dst = dst || cc.macro.BLEND_DST;
                }
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
            },
            getBlendFunc: function() {
                return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
            },
            setContentSize: function(width, height) {
                if (void 0 === height) {
                    height = width.height;
                    width = width.width;
                }
                if (width === this._contentSize.width && height === this._contentSize.height) {
                    return;
                }
                _ccsg.Node.prototype.setContentSize.call(this, width, height);
                this._quadsDirty = true;
            },
            enableTrimmedContentSize: function(isTrimmed) {
                if (this._isTrimmedContentSize !== isTrimmed) {
                    this._isTrimmedContentSize = isTrimmed;
                    this._quadsDirty = true;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
                }
            },
            isTrimmedContentSizeEnabled: function() {
                return this._isTrimmedContentSize;
            },
            setState: function(state) {
                this._brightState = state;
                this._renderCmd.setState(state);
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
            },
            getState: function() {
                return this._brightState;
            },
            setRenderingType: function(type) {
                if (this._renderingType === type) {
                    return;
                }
                this._renderingType = type;
                this._quadsDirty = true;
                this._uvsDirty = true;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
            },
            getRenderingType: function() {
                return this._renderingType;
            },
            setInsetLeft: function(insetLeft) {
                this._insetLeft = insetLeft;
                this._quadsDirty = true;
                this._uvsDirty = true;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
            },
            getInsetLeft: function() {
                return this._insetLeft;
            },
            setInsetTop: function(insetTop) {
                this._insetTop = insetTop;
                this._quadsDirty = true;
                this._uvsDirty = true;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
            },
            getInsetTop: function() {
                return this._insetTop;
            },
            setInsetRight: function(insetRight) {
                this._insetRight = insetRight;
                this._quadsDirty = true;
                this._uvsDirty = true;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
            },
            getInsetRight: function() {
                return this._insetRight;
            },
            setInsetBottom: function(insetBottom) {
                this._insetBottom = insetBottom;
                this._quadsDirty = true;
                this._uvsDirty = true;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
            },
            getInsetBottom: function() {
                return this._insetBottom;
            },
            setFillType: function(value) {
                if (this._fillType === value) {
                    return;
                }
                this._fillType = value;
                if (this._renderingType === RenderingType.FILLED) {
                    this._quadsDirty = true;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
                }
            },
            getFillType: function() {
                return this._fillType;
            },
            setFillCenter: function(value, y) {
                this._fillCenter = cc.v2(value, y);
                if (this._renderingType === RenderingType.FILLED && this._fillType === FillType.RADIAL) {
                    this._quadsDirty = true;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
                }
            },
            setDistortionTiling: function(valueOrX, y) {
                if (void 0 === y) {
                    y = valueOrX.y;
                    valueOrX = valueOrX.x;
                }
                this._distortionTiling = this._distortionTiling || cc.v2(0, 0);
                this._distortionTiling.x = valueOrX;
                this._distortionTiling.y = y;
            },
            setDistortionOffset: function(valueOrX, y) {
                if (void 0 === y) {
                    y = valueOrX.y;
                    valueOrX = valueOrX.x;
                }
                this._distortionOffset = this._distortionOffset || cc.v2(0, 0);
                this._distortionOffset.x = valueOrX;
                this._distortionOffset.y = y;
            },
            getFillCenter: function() {
                return cc.v2(this._fillCenter);
            },
            setFillStart: function(value) {
                if (this._fillStart === value) {
                    return;
                }
                this._fillStart = value;
                if (this._renderingType === RenderingType.FILLED) {
                    this._quadsDirty = true;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
                }
            },
            getFillStart: function() {
                return this._fillStart;
            },
            setFillRange: function(value) {
                if (this._fillRange === value) {
                    return;
                }
                this._fillRange = value;
                if (this._renderingType === RenderingType.FILLED) {
                    this._quadsDirty = true;
                    this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
                }
            },
            getFillRange: function() {
                return this._fillRange;
            },
            _rebuildQuads: function() {
                if (!this._spriteFrame || !this._spriteFrame._textureLoaded) {
                    this._renderCmd._needDraw = false;
                    return;
                }
                this._isTriangle = false;
                switch (this._renderingType) {
                  case RenderingType.SIMPLE:
                    simpleQuadGenerator._rebuildQuads_base(this, this._spriteFrame, this._contentSize, this._isTrimmedContentSize);
                    break;

                  case RenderingType.SLICED:
                    scale9QuadGenerator._rebuildQuads_base(this, this._spriteFrame, this._contentSize, this._insetLeft, this._insetRight, this._insetTop, this._insetBottom);
                    break;

                  case RenderingType.TILED:
                    tiledQuadGenerator._rebuildQuads_base(this, this._spriteFrame, this._contentSize);
                    break;

                  case RenderingType.FILLED:
                    var fillstart = this._fillStart;
                    var fillRange = this._fillRange;
                    if (fillRange < 0) {
                        fillstart += fillRange;
                        fillRange = -fillRange;
                    }
                    if (this._fillType !== FillType.RADIAL) {
                        fillRange = fillstart + fillRange;
                        fillstart = fillstart > 1 ? 1 : fillstart;
                        fillstart = fillstart < 0 ? 0 : fillstart;
                        fillRange = fillRange > 1 ? 1 : fillRange;
                        fillRange = fillRange < 0 ? 0 : fillRange;
                        fillRange -= fillstart;
                        fillQuadGeneratorBar._rebuildQuads_base(this, this._spriteFrame, this._contentSize, this._fillType, fillstart, fillRange);
                    } else {
                        this._isTriangle = true;
                        if (!this._rawVerts) {
                            this._rawVerts = dataPool.get(8) || new Float32Array(8);
                            this._rawUvs = dataPool.get(8) || new Float32Array(8);
                        }
                        fillQuadGeneratorRadial._rebuildQuads_base(this, this._spriteFrame, this._contentSize, this._fillCenter, fillstart, fillRange);
                    }
                    break;

                  case RenderingType.MESH:
                    meshQuadGenerator._rebuildQuads_base(this, this._spriteFrame, this._meshPolygonInfo);
                    break;

                  default:
                    this._quadsDirty = false;
                    this._uvsDirty = false;
                    this._renderCmd._needDraw = false;
                    cc.errorID(2627);
                    return;
                }
                if (webgl) {
                    ;
                } else {
                    var bb = this._renderCmd._currentRegion, l = bb._minX, r = bb._maxX, b = bb._minY, t = bb._maxY;
                    r < vl.x || l > vr.x || t < vb.y || b > vt.y ? this._renderCmd._needDraw = false : this._renderCmd._needDraw = true;
                }
                this._quadsDirty = false;
                this._uvsDirty = false;
            },
            _createRenderCmd: function() {
                return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.Scale9Sprite.CanvasRenderCmd(this) : new cc.Scale9Sprite.WebGLRenderCmd(this);
            },
            setMeshPolygonInfo: function(polygonInfo) {
                this.setRenderingType(RenderingType.MESH);
                this._meshPolygonInfo = polygonInfo;
                this._quadsDirty = true;
                this._uvsDirty = true;
            },
            getMeshPolygonInfo: function() {
                return this._meshPolygonInfo;
            }
        });
        var _p = cc.Scale9Sprite.prototype;
        cc.js.addon(_p, EventTarget.prototype);
        cc.defineGetterSetter(_p, "insetLeft", _p.getInsetLeft, _p.setInsetLeft);
        cc.defineGetterSetter(_p, "insetTop", _p.getInsetTop, _p.setInsetTop);
        cc.defineGetterSetter(_p, "insetRight", _p.getInsetRight, _p.setInsetRight);
        cc.defineGetterSetter(_p, "insetBottom", _p.getInsetBottom, _p.setInsetBottom);
        cc.Scale9Sprite.state = {
            NORMAL: 0,
            GRAY: 1,
            DISTORTION: 2
        };
        var RenderingType = cc.Scale9Sprite.RenderingType = cc.Enum({
            SIMPLE: 0,
            SLICED: 1,
            TILED: 2,
            FILLED: 3,
            MESH: 4
        });
        var FillType = cc.Scale9Sprite.FillType = cc.Enum({
            HORIZONTAL: 0,
            VERTICAL: 1,
            RADIAL: 2
        });
    }), {
        "../event/event-target": 112
    } ],
    208: [ (function(require, module, exports) {
        cc.Scale9Sprite.CanvasRenderCmd = function(renderable) {
            this._rootCtor(renderable);
            this._node.loaded() ? this._needDraw = true : this._needDraw = false;
            this._state = cc.Scale9Sprite.state.NORMAL;
            this._originalTexture = this._textureToRender = null;
        };
        var proto = cc.Scale9Sprite.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
        proto.constructor = cc.Scale9Sprite.CanvasRenderCmd;
        proto.transform = function(parentCmd, recursive) {
            this.originTransform(parentCmd, recursive);
            this._node._rebuildQuads();
        };
        proto._updateDisplayColor = function(parentColor) {
            _ccsg.Node.WebGLRenderCmd.prototype._updateDisplayColor.call(this, parentColor);
            this._originalTexture = this._textureToRender = null;
        };
        proto.setState = function(state) {
            if (this._state === state) {
                return;
            }
            this._state = state;
            this._originalTexture = this._textureToRender = null;
        };
        proto.rendering = function(ctx, scaleX, scaleY) {
            var node = this._node;
            var locDisplayOpacity = this._displayedOpacity;
            var alpha = locDisplayOpacity / 255;
            var locTexture = null;
            node._spriteFrame && (locTexture = node._spriteFrame._texture);
            if (!node.loaded() || 0 === locDisplayOpacity) {
                return;
            }
            if (null === this._textureToRender || this._originalTexture !== locTexture) {
                this._textureToRender = this._originalTexture = locTexture;
                cc.Scale9Sprite.state.GRAY === this._state && (this._textureToRender = this._textureToRender._generateGrayTexture());
                var color = node.getDisplayedColor();
                !locTexture || 255 === color.r && 255 === color.g && 255 === color.b || (this._textureToRender = this._textureToRender._generateColorTexture(color.r, color.g, color.b));
            }
            var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
            wrapper.setTransform(this._worldTransform, scaleX, scaleY);
            wrapper.setCompositeOperation(_ccsg.Node.CanvasRenderCmd._getCompositeOperationByBlendFunc(node._blendFunc));
            wrapper.setGlobalAlpha(alpha);
            if (this._textureToRender) {
                node._quadsDirty && node._rebuildQuads();
                var sx, sy, sw, sh;
                var x, y, w, h;
                var textureWidth = this._textureToRender._pixelWidth;
                var textureHeight = this._textureToRender._pixelHeight;
                var image = this._textureToRender._htmlElementObj;
                var vertices = node._vertices;
                var uvs = node._uvs;
                var i = 0, off = 0;
                if (node._isTriangle) {
                    var rawVerts = node._rawVerts, rawUvs = node._rawUvs;
                    x = rawVerts[0];
                    y = rawVerts[1];
                    w = rawVerts[6] - x;
                    h = rawVerts[7] - y;
                    y = -y - h;
                    sx = rawUvs[4] * textureWidth;
                    sy = rawUvs[5] * textureHeight;
                    sw = (rawUvs[6] - rawUvs[0]) * textureWidth;
                    sh = (rawUvs[1] - rawUvs[7]) * textureHeight;
                    wrapper.save();
                    context.beginPath();
                    var triangleCount = Math.floor(node._vertCount / 3);
                    for (i = 0, off = 0; i < triangleCount; i++) {
                        context.moveTo(vertices[off++], -vertices[off++]);
                        context.lineTo(vertices[off++], -vertices[off++]);
                        context.lineTo(vertices[off++], -vertices[off++]);
                    }
                    context.clip();
                    if ("" !== this._textureToRender._pattern) {
                        wrapper.setFillStyle(context.createPattern(image, this._textureToRender._pattern));
                        context.fillRect(x, y, w, h);
                    } else {
                        sw > 0 && sh > 0 && w > 0 && h > 0 && context.drawImage(image, sx, sy, sw, sh, x, y, w, h);
                    }
                    wrapper.restore();
                    cc.g_NumberOfDraws += triangleCount;
                } else {
                    if (node._renderingType === cc.Scale9Sprite.RenderingType.SLICED) {
                        for (var r = 0; r < 3; ++r) {
                            for (var c = 0; c < 3; ++c) {
                                off = 8 * r + 2 * c;
                                x = vertices[off];
                                y = vertices[off + 1];
                                w = vertices[off + 10] - x;
                                h = vertices[off + 11] - y;
                                y = -y - h;
                                sx = uvs[off] * textureWidth;
                                sy = uvs[off + 11] * textureHeight;
                                sw = (uvs[off + 10] - uvs[off]) * textureWidth;
                                sh = (uvs[off + 1] - uvs[off + 11]) * textureHeight;
                                sw > 0 && sh > 0 && w > 0 && h > 0 && context.drawImage(image, sx, sy, sw, sh, x, y, w, h);
                            }
                        }
                        cc.g_NumberOfDraws += 9;
                    } else {
                        var quadCount = Math.floor(node._vertCount / 4);
                        for (i = 0, off = 0; i < quadCount; i++) {
                            x = vertices[off];
                            y = vertices[off + 1];
                            w = vertices[off + 6] - x;
                            h = vertices[off + 7] - y;
                            y = -y - h;
                            sx = uvs[off] * textureWidth;
                            sy = uvs[off + 7] * textureHeight;
                            sw = (uvs[off + 6] - uvs[off]) * textureWidth;
                            sh = (uvs[off + 1] - uvs[off + 7]) * textureHeight;
                            if ("" !== this._textureToRender._pattern) {
                                wrapper.setFillStyle(context.createPattern(image, this._textureToRender._pattern));
                                context.fillRect(x, y, w, h);
                            } else {
                                sw > 0 && sh > 0 && w > 0 && h > 0 && context.drawImage(image, sx, sy, sw, sh, x, y, w, h);
                            }
                            off += 8;
                        }
                        cc.g_NumberOfDraws += quadCount;
                    }
                }
            }
        };
    }), {} ],
    209: [ (function(require, module, exports) {
        var ccgl = cc.gl;
        cc.Scale9Sprite.WebGLRenderCmd = function(renderable) {
            this._rootCtor(renderable);
            this._node.loaded() ? this._needDraw = true : this._needDraw = false;
            this.vertexType = cc.renderer.VertexType.QUAD;
            this._dirty = false;
            this._shaderProgram = cc.shaderCache.programForKey(cc.macro.SHADER_SPRITE_POSITION_TEXTURECOLOR);
        };
        var Scale9Sprite = cc.Scale9Sprite;
        var proto = Scale9Sprite.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
        proto.constructor = Scale9Sprite.WebGLRenderCmd;
        proto._uploadSliced = function(vertices, uvs, color, z, f32buffer, ui32buffer, offset) {
            var off;
            for (var r = 0; r < 3; ++r) {
                for (var c = 0; c < 3; ++c) {
                    off = 8 * r + 2 * c;
                    f32buffer[offset] = vertices[off];
                    f32buffer[offset + 1] = vertices[off + 1];
                    f32buffer[offset + 2] = z;
                    ui32buffer[offset + 3] = color;
                    f32buffer[offset + 4] = uvs[off];
                    f32buffer[offset + 5] = uvs[off + 1];
                    offset += 6;
                    f32buffer[offset] = vertices[off + 2];
                    f32buffer[offset + 1] = vertices[off + 3];
                    f32buffer[offset + 2] = z;
                    ui32buffer[offset + 3] = color;
                    f32buffer[offset + 4] = uvs[off + 2];
                    f32buffer[offset + 5] = uvs[off + 3];
                    offset += 6;
                    f32buffer[offset] = vertices[off + 8];
                    f32buffer[offset + 1] = vertices[off + 9];
                    f32buffer[offset + 2] = z;
                    ui32buffer[offset + 3] = color;
                    f32buffer[offset + 4] = uvs[off + 8];
                    f32buffer[offset + 5] = uvs[off + 9];
                    offset += 6;
                    f32buffer[offset] = vertices[off + 10];
                    f32buffer[offset + 1] = vertices[off + 11];
                    f32buffer[offset + 2] = z;
                    ui32buffer[offset + 3] = color;
                    f32buffer[offset + 4] = uvs[off + 10];
                    f32buffer[offset + 5] = uvs[off + 11];
                    offset += 6;
                }
            }
            return 36;
        };
        proto.transform = function(parentCmd, recursive) {
            this.originTransform(parentCmd, recursive);
            this._node._rebuildQuads();
        };
        proto.uploadData = function(f32buffer, ui32buffer, vertexDataOffset) {
            var node = this._node;
            if (0 === this._displayedOpacity) {
                return 0;
            }
            node._quadsDirty && node._rebuildQuads();
            if (node._distortionOffset && this._shaderProgram === Scale9Sprite.WebGLRenderCmd._distortionProgram) {
                this._shaderProgram.use();
                this._shaderProgram.setUniformLocationWith2f(Scale9Sprite.WebGLRenderCmd._distortionOffset, node._distortionOffset.x, node._distortionOffset.y);
                this._shaderProgram.setUniformLocationWith2f(Scale9Sprite.WebGLRenderCmd._distortionTiling, node._distortionTiling.x, node._distortionTiling.y);
                cc.renderer._breakBatch();
            }
            var opacity = this._displayedOpacity;
            var color, colorVal = this._displayedColor._val;
            if (node._opacityModifyRGB) {
                var a = opacity / 255, r = this._displayedColor.r * a, g = this._displayedColor.g * a, b = this._displayedColor.b * a;
                color = (opacity << 24 >>> 0) + (b << 16) + (g << 8) + r;
            } else {
                color = (opacity << 24 >>> 0) + ((65280 & colorVal) << 8) + ((16711680 & colorVal) >> 8) + (colorVal >>> 24);
            }
            var z = node._vertexZ;
            var vertices = node._vertices;
            var uvs = node._uvs;
            var types = Scale9Sprite.RenderingType;
            var offset = vertexDataOffset;
            var len = 0;
            switch (node._renderingType) {
              case types.SIMPLE:
              case types.TILED:
              case types.FILLED:
              case types.MESH:
                len = this._node._vertCount;
                for (var i = 0, srcOff = 0; i < len; i++, srcOff += 2) {
                    f32buffer[offset] = vertices[srcOff];
                    f32buffer[offset + 1] = vertices[srcOff + 1];
                    f32buffer[offset + 2] = z;
                    ui32buffer[offset + 3] = color;
                    f32buffer[offset + 4] = uvs[srcOff];
                    f32buffer[offset + 5] = uvs[srcOff + 1];
                    offset += 6;
                }
                break;

              case types.SLICED:
                len = this._uploadSliced(vertices, uvs, color, z, f32buffer, ui32buffer, offset);
            }
            node._renderingType === types.MESH ? this.vertexType = cc.renderer.VertexType.CUSTOM : node._renderingType === types.FILLED && node._fillType === Scale9Sprite.FillType.RADIAL ? this.vertexType = cc.renderer.VertexType.TRIANGLE : this.vertexType = cc.renderer.VertexType.QUAD;
            return len;
        };
        proto.uploadIndexData = function(indexData, indexSize, batchingSize) {
            var polygonInfo = this._node._meshPolygonInfo;
            if (!polygonInfo) {
                return 0;
            }
            var indices = polygonInfo.triangles.indices;
            var len = indices.length;
            for (var i = 0; i < len; i++) {
                indexData[indexSize + i] = batchingSize + indices[i];
            }
            return len;
        };
        proto.setState = function(state) {
            state === Scale9Sprite.state.NORMAL ? this._shaderProgram = cc.shaderCache.programForKey(cc.macro.SHADER_SPRITE_POSITION_TEXTURECOLOR) : state === Scale9Sprite.state.GRAY ? this._shaderProgram = cc.Scale9Sprite.WebGLRenderCmd._getGrayShaderProgram() : state === Scale9Sprite.state.DISTORTION && (this._shaderProgram = cc.Scale9Sprite.WebGLRenderCmd._getDistortionProgram());
        };
        Scale9Sprite.WebGLRenderCmd._grayShaderProgram = null;
        Scale9Sprite.WebGLRenderCmd._getGrayShaderProgram = function() {
            var grayShader = Scale9Sprite.WebGLRenderCmd._grayShaderProgram;
            if (grayShader) {
                return grayShader;
            }
            grayShader = new cc.GLProgram();
            grayShader.initWithVertexShaderByteArray(cc.PresetShaders.SPRITE_POSITION_TEXTURE_COLOR_VERT, cc.Scale9Sprite.WebGLRenderCmd._grayShaderFragment);
            grayShader.addAttribute(cc.macro.ATTRIBUTE_NAME_POSITION, cc.macro.VERTEX_ATTRIB_POSITION);
            grayShader.addAttribute(cc.macro.ATTRIBUTE_NAME_COLOR, cc.macro.VERTEX_ATTRIB_COLOR);
            grayShader.addAttribute(cc.macro.ATTRIBUTE_NAME_TEX_COORD, cc.macro.VERTEX_ATTRIB_TEX_COORDS);
            grayShader.link();
            grayShader.updateUniforms();
            Scale9Sprite.WebGLRenderCmd._grayShaderProgram = grayShader;
            return grayShader;
        };
        Scale9Sprite.WebGLRenderCmd._grayShaderFragment = "precision lowp float;\nvarying vec4 v_fragmentColor;\nvarying vec2 v_texCoord;\nvoid main()\n{\nvec4 c = texture2D(CC_Texture0, v_texCoord);\ngl_FragColor.xyz = vec3(0.2126*c.r + 0.7152*c.g + 0.0722*c.b);\ngl_FragColor.w = c.w ;\n}";
        Scale9Sprite.WebGLRenderCmd._distortionProgram = null;
        Scale9Sprite.WebGLRenderCmd._getDistortionProgram = function() {
            var shader = Scale9Sprite.WebGLRenderCmd._distortionProgram;
            if (shader) {
                return shader;
            }
            shader = new cc.GLProgram();
            shader.initWithVertexShaderByteArray(cc.PresetShaders.SPRITE_POSITION_TEXTURE_COLOR_VERT, distortionSpriteShader.fShader);
            shader.addAttribute(cc.macro.ATTRIBUTE_NAME_POSITION, cc.macro.VERTEX_ATTRIB_POSITION);
            shader.addAttribute(cc.macro.ATTRIBUTE_NAME_COLOR, cc.macro.VERTEX_ATTRIB_COLOR);
            shader.addAttribute(cc.macro.ATTRIBUTE_NAME_TEX_COORD, cc.macro.VERTEX_ATTRIB_TEX_COORDS);
            shader.link();
            shader.updateUniforms();
            Scale9Sprite.WebGLRenderCmd._distortionProgram = shader;
            Scale9Sprite.WebGLRenderCmd._distortionOffset = shader.getUniformLocationForName("u_offset");
            Scale9Sprite.WebGLRenderCmd._distortionTiling = shader.getUniformLocationForName("u_offset_tiling");
            return shader;
        };
        var distortionSpriteShader = {
            shaderKey: "cc.Sprite.Shader.Distortion",
            fShader: "precision lowp float;\nvarying vec4 v_fragmentColor;\nvarying vec2 v_texCoord;\nuniform vec2 u_offset;\nuniform vec2 u_offset_tiling;\nconst float PI = 3.14159265359;\nvoid main()\n{\nfloat halfPI = 0.5 * PI;\nfloat maxFactor = sin(halfPI);\nvec2 uv = v_texCoord;\nvec2 xy = 2.0 * uv.xy - 1.0;\nfloat d = length(xy);\nif (d < (2.0-maxFactor)) {\nd = length(xy * maxFactor);\nfloat z = sqrt(1.0 - d * d);\nfloat r = atan(d, z) / PI;\nfloat phi = atan(xy.y, xy.x);\nuv.x = r * cos(phi) + 0.5;\nuv.y = r * sin(phi) + 0.5;\n} else {\ndiscard;\n}\nuv = uv * u_offset_tiling + u_offset;\nuv = fract(uv);\ngl_FragColor = v_fragmentColor * texture2D(CC_Texture0, uv);\n}"
        };
    }), {} ],
    210: [ (function(require, module, exports) {
        cc.SpriteBatchNode = _ccsg.Node.extend({
            _blendFunc: null,
            _texture: null,
            _className: "SpriteBatchNode",
            ctor: function(fileImage) {
                _ccsg.Node.prototype.ctor.call(this);
                this._blendFunc = new cc.BlendFunc(cc.macro.BLEND_SRC, cc.macro.BLEND_DST);
                var texture2D;
                if (cc.js.isString(fileImage)) {
                    texture2D = cc.textureCache.getTextureForKey(fileImage);
                    texture2D || (texture2D = cc.textureCache.addImage(fileImage));
                } else {
                    fileImage instanceof cc.Texture2D && (texture2D = fileImage);
                }
                texture2D && this.initWithTexture(texture2D);
            },
            addSpriteWithoutQuad: function(child, z, aTag) {
                this.addChild(child, z, aTag);
                return this;
            },
            getTextureAtlas: function() {
                return null;
            },
            setTextureAtlas: function(textureAtlas) {},
            getDescendants: function() {
                return this._children;
            },
            initWithFile: function(fileImage, capacity) {
                var texture2D = cc.textureCache.getTextureForKey(fileImage);
                texture2D || (texture2D = cc.textureCache.addImage(fileImage));
                return this.initWithTexture(texture2D, capacity);
            },
            init: function(fileImage, capacity) {
                var texture2D = cc.textureCache.getTextureForKey(fileImage);
                texture2D || (texture2D = cc.textureCache.addImage(fileImage));
                return this.initWithTexture(texture2D, capacity);
            },
            increaseAtlasCapacity: function() {},
            removeChildAtIndex: function(index, doCleanup) {
                this.removeChild(this._children[index], doCleanup);
            },
            rebuildIndexInOrder: function(pobParent, index) {
                return index;
            },
            highestAtlasIndexInChild: function(sprite) {
                var children = sprite.children;
                return children && 0 !== children.length ? this.highestAtlasIndexInChild(children[children.length - 1]) : sprite.zIndex;
            },
            lowestAtlasIndexInChild: function(sprite) {
                var children = sprite.children;
                return children && 0 !== children.length ? this.lowestAtlasIndexInChild(children[children.length - 1]) : sprite.zIndex;
            },
            atlasIndexForChild: function(sprite) {
                return sprite.zIndex;
            },
            reorderBatch: function(reorder) {
                this._reorderChildDirty = reorder;
            },
            setBlendFunc: function(src, dst) {
                void 0 === dst ? this._blendFunc = src : this._blendFunc = {
                    src: src,
                    dst: dst
                };
            },
            getBlendFunc: function() {
                return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
            },
            updateQuadFromSprite: function(sprite, index) {
                cc.assertID(sprite, 2623);
                if (!(sprite instanceof _ccsg.Sprite)) {
                    cc.log(2616);
                    return;
                }
                sprite.dirty = true;
                sprite._renderCmd.transform(this._renderCmd, true);
            },
            insertQuadFromSprite: function(sprite, index) {
                this.addChild(sprite, index);
            },
            insertChild: function(sprite, index) {
                this.addChild(sprite, index);
            },
            appendChild: function(sprite) {
                this.sortAllChildren();
                var lastLocalZOrder = this._children[this._children.length - 1]._localZOrder;
                this.addChild(sprite.lastLocalZOrder + 1);
            },
            removeSpriteFromAtlas: function(sprite, cleanup) {
                this.removeChild(sprite, cleanup);
            },
            initWithTexture: function(tex) {
                this.setTexture(tex);
                return true;
            },
            getTexture: function() {
                return this._texture;
            },
            setTexture: function(texture) {
                this._texture = texture;
                if (texture._textureLoaded) {
                    var children = this._children, i, len = children.length;
                    for (i = 0; i < len; ++i) {
                        children[i].setTexture(texture);
                    }
                } else {
                    texture.addEventListener("load", (function() {
                        var children = this._children, i, len = children.length;
                        for (i = 0; i < len; ++i) {
                            children[i].setTexture(texture);
                        }
                    }), this);
                }
            },
            setShaderProgram: function(newShaderProgram) {
                this._renderCmd.setShaderProgram(newShaderProgram);
                var children = this._children, i, len = children.length;
                for (i = 0; i < len; ++i) {
                    children[i].setShaderProgram(newShaderProgram);
                }
            },
            addChild: function(child, zOrder, tag) {
                cc.assertID(void 0 !== child, 2614);
                if (!this._isValidChild(child)) {
                    return;
                }
                zOrder = void 0 === zOrder ? child.zIndex : zOrder;
                tag = void 0 === tag ? child.tag : tag;
                _ccsg.Node.prototype.addChild.call(this, child, zOrder, tag);
                this._renderCmd._shaderProgram && (child.shaderProgram = this._renderCmd._shaderProgram);
            },
            _isValidChild: function(child) {
                if (!(child instanceof _ccsg.Sprite)) {
                    cc.logID(2618);
                    return false;
                }
                if (child.texture !== this._texture) {
                    cc.logID(2619);
                    return false;
                }
                return true;
            }
        });
        var _p = cc.SpriteBatchNode.prototype;
        cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
        cc.defineGetterSetter(_p, "shaderProgram", _p.getShaderProgram, _p.setShaderProgram);
    }), {} ],
    211: [ (function(require, module, exports) {
        var EventTarget = require("../event/event-target");
        cc.SpriteFrame = cc.Class({
            name: "cc.SpriteFrame",
            extends: require("../assets/CCAsset"),
            mixins: [ EventTarget ],
            properties: {
                _textureFilenameSetter: {
                    set: function(url) {
                        this._textureFilename = url;
                        url && this._loadTexture();
                    }
                }
            },
            ctor: function() {
                var filename = arguments[0];
                var rect = arguments[1];
                var rotated = arguments[2];
                var offset = arguments[3];
                var originalSize = arguments[4];
                this._rect = null;
                this._offset = null;
                this._originalSize = null;
                this._rotated = false;
                this.insetTop = 0;
                this.insetBottom = 0;
                this.insetLeft = 0;
                this.insetRight = 0;
                this._texture = null;
                this._textureFilename = "";
                this._textureLoaded = false;
                void 0 !== filename && this.initWithTexture(filename, rect, rotated, offset, originalSize);
            },
            textureLoaded: function() {
                return this._textureLoaded;
            },
            addLoadedEventListener: function(callback, target) {
                this.once("load", callback, target);
            },
            isRotated: function() {
                return this._rotated;
            },
            setRotated: function(bRotated) {
                this._rotated = bRotated;
            },
            getRect: function() {
                return cc.rect(this._rect);
            },
            setRect: function(rect) {
                this._rect = rect;
            },
            getOriginalSize: function() {
                return cc.size(this._originalSize);
            },
            setOriginalSize: function(size) {
                if (this._originalSize) {
                    this._originalSize.width = size.width;
                    this._originalSize.height = size.height;
                } else {
                    this._originalSize = cc.size(size);
                }
            },
            getTexture: function() {
                return this._texture;
            },
            _refreshTexture: function(texture) {
                var self = this;
                if (self._texture !== texture) {
                    var locLoaded = texture.isLoaded();
                    this._textureLoaded = locLoaded;
                    this._texture = texture;
                    function textureLoadedCallback() {
                        if (!self._texture) {
                            return;
                        }
                        self._textureLoaded = true;
                        var w = texture.width, h = texture.height;
                        if (self._rotated && cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                            var tempElement = texture.getHtmlElementObj();
                            tempElement = _ccsg.Sprite.CanvasRenderCmd._cutRotateImageToCanvas(tempElement, self.getRect());
                            var tempTexture = new cc.Texture2D();
                            tempTexture.initWithElement(tempElement);
                            tempTexture.handleLoadedTexture();
                            self._texture = tempTexture;
                            self._rotated = false;
                            w = self._texture.width;
                            h = self._texture.height;
                            self.setRect(cc.rect(0, 0, w, h));
                        }
                        self._rect ? self._checkRect(self._texture) : self.setRect(cc.rect(0, 0, w, h));
                        self._originalSize || self.setOriginalSize(cc.size(w, h));
                        self._offset || self.setOffset(cc.v2(0, 0));
                        self.emit("load");
                    }
                    locLoaded ? textureLoadedCallback() : texture.once("load", textureLoadedCallback);
                }
            },
            getOffset: function() {
                return cc.v2(this._offset);
            },
            setOffset: function(offsets) {
                this._offset = cc.v2(offsets);
            },
            clone: function() {
                return new cc.SpriteFrame(this._texture || this._textureFilename, this._rect, this._rotated, this._offset, this._originalSize);
            },
            setTexture: function(textureOrTextureFile, rect, rotated, offset, originalSize) {
                rect ? this.setRect(rect) : this._rect = null;
                offset ? this.setOffset(offset) : this._offset = null;
                originalSize ? this.setOriginalSize(originalSize) : this._originalSize = null;
                this._rotated = rotated || false;
                var texture = textureOrTextureFile;
                if (cc.js.isString(texture)) {
                    this._textureFilename = texture;
                    this._loadTexture();
                } else {
                    texture instanceof cc.Texture2D && this._refreshTexture(texture);
                }
                return true;
            },
            _loadTexture: function() {
                if (this._textureFilename) {
                    var texture = cc.textureCache.addImage(this._textureFilename);
                    this._refreshTexture(texture);
                }
            },
            ensureLoadTexture: function() {
                this._texture || this._loadTexture();
            },
            clearTexture: function() {
                this._textureLoaded = false;
                this._texture = null;
            },
            _checkRect: function(texture) {
                var rect = this._rect;
                var maxX = rect.x, maxY = rect.y;
                if (this._rotated) {
                    maxX += rect.height;
                    maxY += rect.width;
                } else {
                    maxX += rect.width;
                    maxY += rect.height;
                }
                maxX > texture.getPixelWidth() && cc.errorID(3300, texture.url + "/" + this.name);
                maxY > texture.getPixelHeight() && cc.errorID(3400, texture.url + "/" + this.name);
            },
            _serialize: false,
            _deserialize: function(data, handle) {
                var rect = data.rect;
                rect && this.setRect(new cc.Rect(rect[0], rect[1], rect[2], rect[3]));
                data.offset && this.setOffset(new cc.Vec2(data.offset[0], data.offset[1]));
                data.originalSize && this.setOriginalSize(new cc.Size(data.originalSize[0], data.originalSize[1]));
                this._rotated = 1 === data.rotated;
                this._name = data.name;
                var capInsets = data.capInsets;
                if (capInsets) {
                    this.insetLeft = capInsets[0];
                    this.insetTop = capInsets[1];
                    this.insetRight = capInsets[2];
                    this.insetBottom = capInsets[3];
                }
                var textureUuid = data.texture;
                if (textureUuid) {
                    var dontLoadTexture = handle.customEnv && handle.customEnv.deferredLoadRaw;
                    var receiver = dontLoadTexture ? "_textureFilename" : "_textureFilenameSetter";
                    handle.result.push(this, receiver, textureUuid);
                }
            }
        });
        var proto = cc.SpriteFrame.prototype;
        proto.copyWithZone = proto.clone;
        proto.copy = proto.clone;
        proto.initWithTexture = proto.setTexture;
    }), {
        "../assets/CCAsset": 44,
        "../event/event-target": 112
    } ],
    212: [ (function(require, module, exports) {
        cc._tmp.PrototypeSprite = function() {
            var _p = _ccsg.Sprite.prototype;
            cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
            cc.defineGetterSetter(_p, "opacity", _p.getOpacity, _p.setOpacity);
            cc.defineGetterSetter(_p, "color", _p.getColor, _p.setColor);
            _p.dirty;
            _p.flippedX;
            cc.defineGetterSetter(_p, "flippedX", _p.isFlippedX, _p.setFlippedX);
            _p.flippedY;
            cc.defineGetterSetter(_p, "flippedY", _p.isFlippedY, _p.setFlippedY);
            _p.offsetX;
            cc.defineGetterSetter(_p, "offsetX", _p._getOffsetX);
            _p.offsetY;
            cc.defineGetterSetter(_p, "offsetY", _p._getOffsetY);
            _p.atlasIndex;
            _p.texture;
            cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
            _p.textureRectRotated;
            cc.defineGetterSetter(_p, "textureRectRotated", _p.isTextureRectRotated);
            _p.textureAtlas;
            _p.batchNode;
            cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
            _p.quad;
            cc.defineGetterSetter(_p, "quad", _p.getQuad);
        };
    }), {} ],
    213: [ (function(require, module, exports) {
        var EventTarget = require("../event/event-target");
        var sys = require("../platform/CCSys");
        var JS = require("../platform/js");
        var misc = require("../utils/misc");
        var game = require("../CCGame");
        require("../platform/_CCClass");
        require("../platform/CCClass");
        var WrapMode = cc.Enum({
            REPEAT: 10497,
            CLAMP_TO_EDGE: 33071,
            MIRRORED_REPEAT: 33648
        });
        var Texture2D = cc.Class({
            name: "cc.Texture2D",
            extends: require("../assets/CCRawAsset"),
            mixins: [ EventTarget ],
            statics: {
                WrapMode: WrapMode
            },
            ctor: function() {
                this.url = null;
                this._textureLoaded = false;
                this._htmlElementObj = null;
                this._contentSize = cc.size(0, 0);
                this._pixelWidth = 0;
                this._pixelHeight = 0;
                if (cc._renderType === game.RENDER_TYPE_CANVAS) {
                    this._pattern = "";
                    this._grayElementObj = null;
                    this._backupElement = null;
                    this._isGray = false;
                } else {
                    if (cc._renderType === game.RENDER_TYPE_WEBGL) {
                        this._pixelFormat = Texture2D.defaultPixelFormat;
                        this._hasPremultipliedAlpha = false;
                        this._hasMipmaps = false;
                        this._webTextureObj = null;
                    }
                }
            },
            getPixelWidth: function() {
                return this._pixelWidth;
            },
            getPixelHeight: function() {
                return this._pixelHeight;
            },
            getContentSize: function() {
                return cc.size(this._contentSize.width, this._contentSize.height);
            },
            _getWidth: function() {
                return this._contentSize.width;
            },
            _getHeight: function() {
                return this._contentSize.height;
            },
            getContentSizeInPixels: function() {
                return this._contentSize;
            },
            initWithElement: function(element) {
                if (!element) {
                    return;
                }
                this._htmlElementObj = element;
                this._pixelWidth = this._contentSize.width = element.width;
                this._pixelHeight = this._contentSize.height = element.height;
                this._textureLoaded = true;
            },
            initWithData: function(data, pixelFormat, pixelsWide, pixelsHigh, contentSize) {
                return false;
            },
            initWithImage: function(uiImage) {
                return false;
            },
            getHtmlElementObj: function() {
                return this._htmlElementObj;
            },
            isLoaded: function() {
                return this._textureLoaded;
            },
            handleLoadedTexture: function() {
                var self = this;
                if (!self._htmlElementObj || !self._htmlElementObj.width || !self._htmlElementObj.height) {
                    return;
                }
                var locElement = self._htmlElementObj;
                self._pixelWidth = self._contentSize.width = locElement.width;
                self._pixelHeight = self._contentSize.height = locElement.height;
                self._textureLoaded = true;
                self.emit("load");
            },
            description: function() {
                return "<cc.Texture2D | Name = " + this.getName() + " | Dimensions = " + this.getPixelWidth() + " x " + this.getPixelHeight() + ">";
            },
            releaseTexture: function() {
                this._webTextureObj && cc._renderContext.deleteTexture(this._webTextureObj);
            },
            getName: function() {
                return this._webTextureObj || null;
            },
            getPixelFormat: function() {
                return this._pixelFormat || null;
            },
            hasPremultipliedAlpha: function() {
                return this._hasPremultipliedAlpha || false;
            },
            hasMipmaps: function() {
                return this._hasMipmaps || false;
            },
            setTexParameters: function(texParams, magFilter, wrapS, wrapT) {
                void 0 !== magFilter && (texParams = {
                    minFilter: texParams,
                    magFilter: magFilter,
                    wrapS: wrapS,
                    wrapT: wrapT
                });
                if (texParams.wrapS === WrapMode.REPEAT && texParams.wrapT === WrapMode.REPEAT) {
                    this._pattern = "repeat";
                    return;
                }
                if (texParams.wrapS === WrapMode.REPEAT) {
                    this._pattern = "repeat-x";
                    return;
                }
                if (texParams.wrapT === WrapMode.REPEAT) {
                    this._pattern = "repeat-y";
                    return;
                }
                this._pattern = "";
            },
            setAntiAliasTexParameters: function() {},
            setAliasTexParameters: function() {},
            generateMipmap: function() {},
            stringForFormat: function() {
                return "";
            },
            bitsPerPixelForFormat: function(format) {
                return -1;
            }
        });
        Texture2D.WrapMode = WrapMode;
        var _c = Texture2D;
        _c.PIXEL_FORMAT_RGBA8888 = 2;
        _c.PIXEL_FORMAT_RGB888 = 3;
        _c.PIXEL_FORMAT_RGB565 = 4;
        _c.PIXEL_FORMAT_A8 = 5;
        _c.PIXEL_FORMAT_I8 = 6;
        _c.PIXEL_FORMAT_AI88 = 7;
        _c.PIXEL_FORMAT_RGBA4444 = 8;
        _c.PIXEL_FORMAT_RGB5A1 = 7;
        _c.PIXEL_FORMAT_PVRTC4 = 9;
        _c.PIXEL_FORMAT_PVRTC2 = 10;
        _c.PIXEL_FORMAT_DEFAULT = _c.PIXEL_FORMAT_RGBA8888;
        _c.defaultPixelFormat = _c.PIXEL_FORMAT_DEFAULT;
        var _M = Texture2D._M = {};
        _M[_c.PIXEL_FORMAT_RGBA8888] = "RGBA8888";
        _M[_c.PIXEL_FORMAT_RGB888] = "RGB888";
        _M[_c.PIXEL_FORMAT_RGB565] = "RGB565";
        _M[_c.PIXEL_FORMAT_A8] = "A8";
        _M[_c.PIXEL_FORMAT_I8] = "I8";
        _M[_c.PIXEL_FORMAT_AI88] = "AI88";
        _M[_c.PIXEL_FORMAT_RGBA4444] = "RGBA4444";
        _M[_c.PIXEL_FORMAT_RGB5A1] = "RGB5A1";
        _M[_c.PIXEL_FORMAT_PVRTC4] = "PVRTC4";
        _M[_c.PIXEL_FORMAT_PVRTC2] = "PVRTC2";
        var _B = Texture2D._B = {};
        _B[_c.PIXEL_FORMAT_RGBA8888] = 32;
        _B[_c.PIXEL_FORMAT_RGB888] = 24;
        _B[_c.PIXEL_FORMAT_RGB565] = 16;
        _B[_c.PIXEL_FORMAT_A8] = 8;
        _B[_c.PIXEL_FORMAT_I8] = 8;
        _B[_c.PIXEL_FORMAT_AI88] = 16;
        _B[_c.PIXEL_FORMAT_RGBA4444] = 16;
        _B[_c.PIXEL_FORMAT_RGB5A1] = 16;
        _B[_c.PIXEL_FORMAT_PVRTC4] = 4;
        _B[_c.PIXEL_FORMAT_PVRTC2] = 3;
        var _p = Texture2D.prototype;
        _p.name;
        cc.defineGetterSetter(_p, "name", _p.getName);
        _p.pixelFormat;
        cc.defineGetterSetter(_p, "pixelFormat", _p.getPixelFormat);
        _p.pixelWidth;
        cc.defineGetterSetter(_p, "pixelWidth", _p.getPixelWidth);
        _p.pixelHeight;
        cc.defineGetterSetter(_p, "pixelHeight", _p.getPixelHeight);
        _p.width;
        cc.defineGetterSetter(_p, "width", _p._getWidth);
        _p.height;
        cc.defineGetterSetter(_p, "height", _p._getHeight);
        game.once(game.EVENT_RENDERER_INITED, (function() {
            if (cc._renderType === game.RENDER_TYPE_CANVAS) {
                var renderToCache = function(image, cache) {
                    var w = image.width;
                    var h = image.height;
                    cache[0].width = w;
                    cache[0].height = h;
                    cache[1].width = w;
                    cache[1].height = h;
                    cache[2].width = w;
                    cache[2].height = h;
                    cache[3].width = w;
                    cache[3].height = h;
                    var cacheCtx = cache[3].getContext("2d");
                    cacheCtx.drawImage(image, 0, 0);
                    var pixels = cacheCtx.getImageData(0, 0, w, h).data;
                    var ctx;
                    for (var rgbI = 0; rgbI < 4; rgbI++) {
                        ctx = cache[rgbI].getContext("2d");
                        var to = ctx.getImageData(0, 0, w, h);
                        var data = to.data;
                        for (var i = 0; i < pixels.length; i += 4) {
                            data[i] = 0 === rgbI ? pixels[i] : 0;
                            data[i + 1] = 1 === rgbI ? pixels[i + 1] : 0;
                            data[i + 2] = 2 === rgbI ? pixels[i + 2] : 0;
                            data[i + 3] = pixels[i + 3];
                        }
                        ctx.putImageData(to, 0, 0);
                    }
                    image.onload = null;
                };
                var generateGrayTexture = function(texture, rect, renderCanvas) {
                    if (null === texture) {
                        return null;
                    }
                    renderCanvas = renderCanvas || document.createElement("canvas");
                    rect = rect || cc.rect(0, 0, texture.width, texture.height);
                    renderCanvas.width = rect.width;
                    renderCanvas.height = rect.height;
                    var context = renderCanvas.getContext("2d");
                    context.drawImage(texture, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
                    var imgData = context.getImageData(0, 0, rect.width, rect.height);
                    var data = imgData.data;
                    for (var i = 0, len = data.length; i < len; i += 4) {
                        data[i] = data[i + 1] = data[i + 2] = .34 * data[i] + .5 * data[i + 1] + .16 * data[i + 2];
                    }
                    context.putImageData(imgData, 0, 0);
                    return renderCanvas;
                };
                _p._generateTextureCacheForColor = function() {
                    if (this.channelCache) {
                        return this.channelCache;
                    }
                    var textureCache = [ document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas"), document.createElement("canvas") ];
                    renderToCache(this._htmlElementObj, textureCache);
                    return this.channelCache = textureCache;
                };
                _p._switchToGray = function(toGray) {
                    if (!this._textureLoaded || this._isGray === toGray) {
                        return;
                    }
                    this._isGray = toGray;
                    if (this._isGray) {
                        this._backupElement = this._htmlElementObj;
                        this._grayElementObj || (this._grayElementObj = generateGrayTexture(this._htmlElementObj));
                        this._htmlElementObj = this._grayElementObj;
                    } else {
                        null !== this._backupElement && (this._htmlElementObj = this._backupElement);
                    }
                };
                _p._generateGrayTexture = function() {
                    if (!this._textureLoaded) {
                        return null;
                    }
                    var grayElement = generateGrayTexture(this._htmlElementObj);
                    var newTexture = new Texture2D();
                    newTexture.initWithElement(grayElement);
                    newTexture.handleLoadedTexture();
                    return newTexture;
                };
                _p._generateColorTexture = sys._supportCanvasNewBlendModes ? function(r, g, b, rect, canvas) {
                    var onlyCanvas = false;
                    canvas ? onlyCanvas = true : canvas = document.createElement("canvas");
                    var textureImage = this._htmlElementObj;
                    rect || (rect = cc.rect(0, 0, textureImage.width, textureImage.height));
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                    if (rect.width && rect.height) {
                        var context = canvas.getContext("2d");
                        context.globalCompositeOperation = "source-over";
                        context.fillStyle = "rgb(" + (0 | r) + "," + (0 | g) + "," + (0 | b) + ")";
                        context.fillRect(0, 0, rect.width, rect.height);
                        context.globalCompositeOperation = "multiply";
                        context.drawImage(textureImage, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
                        context.globalCompositeOperation = "destination-atop";
                        context.drawImage(textureImage, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
                    }
                    if (onlyCanvas) {
                        return canvas;
                    }
                    var newTexture = new Texture2D();
                    newTexture.initWithElement(canvas);
                    newTexture.handleLoadedTexture();
                    return newTexture;
                } : function(r, g, b, rect, canvas) {
                    var onlyCanvas = false;
                    canvas ? onlyCanvas = true : canvas = document.createElement("canvas");
                    var textureImage = this._htmlElementObj;
                    rect || (rect = cc.rect(0, 0, textureImage.width, textureImage.height));
                    canvas.width = rect.width;
                    canvas.height = rect.height;
                    if (rect.width && rect.height) {
                        var context = canvas.getContext("2d");
                        context.drawImage(textureImage, rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
                        var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                        var data = imageData.data;
                        r /= 255;
                        g /= 255;
                        b /= 255;
                        for (var i = 0; i < data.length; i += 4) {
                            data[i] = data[i] * r;
                            data[i + 1] = data[i + 1] * g;
                            data[i + 2] = data[i + 2] * b;
                        }
                        context.putImageData(imageData, 0, 0);
                    }
                    if (onlyCanvas) {
                        return canvas;
                    }
                    var newTexture = new Texture2D();
                    newTexture.initWithElement(canvas);
                    newTexture.handleLoadedTexture();
                    return newTexture;
                };
            } else {
                if (cc._renderType === game.RENDER_TYPE_WEBGL) {
                    _p.initWithData = function(data, pixelFormat, pixelsWide, pixelsHigh, contentSize) {
                        var self = this, tex2d = Texture2D;
                        var gl = cc._renderContext;
                        var format = gl.RGBA, type = gl.UNSIGNED_BYTE;
                        var bitsPerPixel = Texture2D._B[pixelFormat];
                        var bytesPerRow = pixelsWide * bitsPerPixel / 8;
                        bytesPerRow % 8 === 0 ? gl.pixelStorei(gl.UNPACK_ALIGNMENT, 8) : bytesPerRow % 4 === 0 ? gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4) : bytesPerRow % 2 === 0 ? gl.pixelStorei(gl.UNPACK_ALIGNMENT, 2) : gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
                        self._webTextureObj = gl.createTexture();
                        cc.gl.bindTexture2D(self);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        switch (pixelFormat) {
                          case tex2d.PIXEL_FORMAT_RGBA8888:
                            format = gl.RGBA;
                            break;

                          case tex2d.PIXEL_FORMAT_RGB888:
                            format = gl.RGB;
                            break;

                          case tex2d.PIXEL_FORMAT_RGBA4444:
                            type = gl.UNSIGNED_SHORT_4_4_4_4;
                            break;

                          case tex2d.PIXEL_FORMAT_RGB5A1:
                            type = gl.UNSIGNED_SHORT_5_5_5_1;
                            break;

                          case tex2d.PIXEL_FORMAT_RGB565:
                            type = gl.UNSIGNED_SHORT_5_6_5;
                            break;

                          case tex2d.PIXEL_FORMAT_AI88:
                            format = gl.LUMINANCE_ALPHA;
                            break;

                          case tex2d.PIXEL_FORMAT_A8:
                            format = gl.ALPHA;
                            break;

                          case tex2d.PIXEL_FORMAT_I8:
                            format = gl.LUMINANCE;
                            break;

                          default:
                            cc.assertID(0, 3113);
                        }
                        gl.texImage2D(gl.TEXTURE_2D, 0, format, pixelsWide, pixelsHigh, 0, format, type, data);
                        self._contentSize.width = contentSize.width;
                        self._contentSize.height = contentSize.height;
                        self._pixelWidth = pixelsWide;
                        self._pixelHeight = pixelsHigh;
                        self._pixelFormat = pixelFormat;
                        self._hasPremultipliedAlpha = false;
                        self._hasMipmaps = false;
                        self._textureLoaded = true;
                        return true;
                    };
                    _p.initWithImage = function(uiImage) {
                        if (null == uiImage) {
                            cc.logID(3104);
                            return false;
                        }
                        var imageWidth = uiImage.getWidth();
                        var imageHeight = uiImage.getHeight();
                        var maxTextureSize = cc.configuration.getMaxTextureSize();
                        if (imageWidth > maxTextureSize || imageHeight > maxTextureSize) {
                            cc.logID(3105, imageWidth, imageHeight, maxTextureSize, maxTextureSize);
                            return false;
                        }
                        this._textureLoaded = true;
                        return this._initPremultipliedATextureWithImage(uiImage, imageWidth, imageHeight);
                    };
                    _p.initWithElement = function(element) {
                        if (!element) {
                            return;
                        }
                        this._webTextureObj = cc._renderContext.createTexture();
                        this._htmlElementObj = element;
                        this._textureLoaded = true;
                    };
                    _p.handleLoadedTexture = function(premultiplied) {
                        premultiplied = !!premultiplied;
                        var self = this;
                        if (!game._rendererInitialized) {
                            return;
                        }
                        if (!self._htmlElementObj || !self._htmlElementObj.width || !self._htmlElementObj.height) {
                            return;
                        }
                        var gl = cc._renderContext;
                        cc.gl.bindTexture2D(self);
                        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 4);
                        premultiplied && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, self._htmlElementObj);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        cc.gl.bindTexture2D(null);
                        premultiplied && gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
                        var pixelsWide = self._htmlElementObj.width;
                        var pixelsHigh = self._htmlElementObj.height;
                        self._pixelWidth = self._contentSize.width = pixelsWide;
                        self._pixelHeight = self._contentSize.height = pixelsHigh;
                        self._pixelFormat = Texture2D.PIXEL_FORMAT_RGBA8888;
                        self._hasPremultipliedAlpha = premultiplied;
                        self._hasMipmaps = false;
                        self._textureLoaded = true;
                        cc.view._antiAliasEnabled ? self.setAntiAliasTexParameters() : self.setAliasTexParameters();
                        self._htmlElementObj = null;
                        self.emit("load");
                    };
                    _p.setTexParameters = function(texParams, magFilter, wrapS, wrapT) {
                        var _t = this;
                        var gl = cc._renderContext;
                        void 0 !== magFilter && (texParams = {
                            minFilter: texParams,
                            magFilter: magFilter,
                            wrapS: wrapS,
                            wrapT: wrapT
                        });
                        cc.assertID(_t._pixelWidth === misc.NextPOT(_t._pixelWidth) && _t._pixelHeight === misc.NextPOT(_t._pixelHeight) || texParams.wrapS === gl.CLAMP_TO_EDGE && texParams.wrapT === gl.CLAMP_TO_EDGE, 3116);
                        cc.gl.bindTexture2D(_t);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texParams.minFilter);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texParams.magFilter);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, texParams.wrapS);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, texParams.wrapT);
                    };
                    _p.setAntiAliasTexParameters = function() {
                        var gl = cc._renderContext;
                        cc.gl.bindTexture2D(this);
                        this._hasMipmaps ? gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST) : gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    };
                    _p.setAliasTexParameters = function() {
                        var gl = cc._renderContext;
                        cc.gl.bindTexture2D(this);
                        this._hasMipmaps ? gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST) : gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    };
                    _p.generateMipmap = function() {
                        var _t = this;
                        cc.assertID(_t._pixelWidth === misc.NextPOT(_t._pixelWidth) && _t._pixelHeight === misc.NextPOT(_t._pixelHeight), 3117);
                        cc.gl.bindTexture2D(_t);
                        cc._renderContext.generateMipmap(cc._renderContext.TEXTURE_2D);
                        _t._hasMipmaps = true;
                    };
                    _p.stringForFormat = function() {
                        return Texture2D._M[this._pixelFormat];
                    };
                    _p.bitsPerPixelForFormat = function(format) {
                        format = format || this._pixelFormat;
                        var value = Texture2D._B[format];
                        if (null != value) {
                            return value;
                        }
                        cc.logID(3110, format);
                        return -1;
                    };
                    _p._initPremultipliedATextureWithImage = function(uiImage, width, height) {
                        var tex2d = Texture2D;
                        var tempData = uiImage.getData();
                        var inPixel32 = null;
                        var inPixel8 = null;
                        var outPixel16 = null;
                        var hasAlpha = uiImage.hasAlpha();
                        var imageSize = cc.size(uiImage.getWidth(), uiImage.getHeight());
                        var pixelFormat = tex2d.defaultPixelFormat;
                        var bpp = uiImage.getBitsPerComponent();
                        var i;
                        if (!hasAlpha) {
                            if (bpp >= 8) {
                                pixelFormat = tex2d.PIXEL_FORMAT_RGB888;
                            } else {
                                cc.logID(3111);
                                pixelFormat = tex2d.PIXEL_FORMAT_RGB565;
                            }
                        }
                        var length = width * height;
                        if (pixelFormat === tex2d.PIXEL_FORMAT_RGB565) {
                            if (hasAlpha) {
                                tempData = new Uint16Array(width * height);
                                inPixel32 = uiImage.getData();
                                for (i = 0; i < length; ++i) {
                                    tempData[i] = (inPixel32[i] >> 0 & 255) >> 3 << 11 | (inPixel32[i] >> 8 & 255) >> 2 << 5 | (inPixel32[i] >> 16 & 255) >> 3 << 0;
                                }
                            } else {
                                tempData = new Uint16Array(width * height);
                                inPixel8 = uiImage.getData();
                                for (i = 0; i < length; ++i) {
                                    tempData[i] = (255 & inPixel8[i]) >> 3 << 11 | (255 & inPixel8[i]) >> 2 << 5 | (255 & inPixel8[i]) >> 3 << 0;
                                }
                            }
                        } else {
                            if (pixelFormat === tex2d.PIXEL_FORMAT_RGBA4444) {
                                tempData = new Uint16Array(width * height);
                                inPixel32 = uiImage.getData();
                                for (i = 0; i < length; ++i) {
                                    tempData[i] = (inPixel32[i] >> 0 & 255) >> 4 << 12 | (inPixel32[i] >> 8 & 255) >> 4 << 8 | (inPixel32[i] >> 16 & 255) >> 4 << 4 | (inPixel32[i] >> 24 & 255) >> 4 << 0;
                                }
                            } else {
                                if (pixelFormat === tex2d.PIXEL_FORMAT_RGB5A1) {
                                    tempData = new Uint16Array(width * height);
                                    inPixel32 = uiImage.getData();
                                    for (i = 0; i < length; ++i) {
                                        tempData[i] = (inPixel32[i] >> 0 & 255) >> 3 << 11 | (inPixel32[i] >> 8 & 255) >> 3 << 6 | (inPixel32[i] >> 16 & 255) >> 3 << 1 | (inPixel32[i] >> 24 & 255) >> 7 << 0;
                                    }
                                } else {
                                    if (pixelFormat === tex2d.PIXEL_FORMAT_A8) {
                                        tempData = new Uint8Array(width * height);
                                        inPixel32 = uiImage.getData();
                                        for (i = 0; i < length; ++i) {
                                            tempData[i] = inPixel32 >> 24 & 255;
                                        }
                                    }
                                }
                            }
                        }
                        if (hasAlpha && pixelFormat === tex2d.PIXEL_FORMAT_RGB888) {
                            inPixel32 = uiImage.getData();
                            tempData = new Uint8Array(width * height * 3);
                            for (i = 0; i < length; ++i) {
                                tempData[3 * i] = inPixel32 >> 0 & 255;
                                tempData[3 * i + 1] = inPixel32 >> 8 & 255;
                                tempData[3 * i + 2] = inPixel32 >> 16 & 255;
                            }
                        }
                        this.initWithData(tempData, pixelFormat, width, height, imageSize);
                        tempData != uiImage.getData() && (tempData = null);
                        this._hasPremultipliedAlpha = uiImage.isPremultipliedAlpha();
                        return true;
                    };
                }
            }
        }));
        cc.Texture2D = module.exports = Texture2D;
    }), {
        "../CCGame": 40,
        "../assets/CCRawAsset": 50,
        "../event/event-target": 112,
        "../platform/CCClass": 173,
        "../platform/CCSys": 182,
        "../platform/_CCClass": 185,
        "../platform/js": 193,
        "../utils/misc": 223
    } ],
    214: [ (function(require, module, exports) {
        var Class = require("../platform/_CCClass");
        var JS = require("../platform/js");
        var game = require("../CCGame");
        var TextureAtlas = Class.extend({
            ctor: function(fileName, capacity) {
                this.dirty = false;
                this.texture = null;
                this._indices = null;
                this._buffersVBO = [];
                this._capacity = 0;
                this._quads = null;
                this._quadsArrayBuffer = null;
                this._quadsWebBuffer = null;
                this._quadsReader = null;
                cc.js.isString(fileName) ? this.initWithFile(fileName, capacity) : fileName instanceof cc.Texture2D && this.initWithTexture(fileName, capacity);
            },
            getTotalQuads: function() {
                return this._totalQuads;
            },
            getCapacity: function() {
                return this._capacity;
            },
            getTexture: function() {
                return this.texture;
            },
            setTexture: function(texture) {
                this.texture = texture;
            },
            setDirty: function(dirty) {
                this.dirty = dirty;
            },
            isDirty: function() {
                return this.dirty;
            },
            getQuads: function() {
                return this._quads;
            },
            setQuads: function(quads) {
                this._quads = quads;
            },
            _copyQuadsToTextureAtlas: function(quads, index) {
                if (!quads) {
                    return;
                }
                for (var i = 0; i < quads.length; i++) {
                    this._setQuadToArray(quads[i], index + i);
                }
            },
            _setQuadToArray: function(quad, index) {
                var locQuads = this._quads;
                if (!locQuads[index]) {
                    locQuads[index] = new cc.V3F_C4B_T2F_Quad(quad.tl, quad.bl, quad.tr, quad.br, this._quadsArrayBuffer, index * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
                    return;
                }
                locQuads[index].bl = quad.bl;
                locQuads[index].br = quad.br;
                locQuads[index].tl = quad.tl;
                locQuads[index].tr = quad.tr;
            },
            description: function() {
                return "<cc.TextureAtlas | totalQuads =" + this._totalQuads + ">";
            },
            _setupIndices: function() {
                if (0 === this._capacity) {
                    return;
                }
                var locIndices = this._indices, locCapacity = this._capacity;
                for (var i = 0; i < locCapacity; i++) {
                    if (cc.macro.TEXTURE_ATLAS_USE_TRIANGLE_STRIP) {
                        locIndices[6 * i + 0] = 4 * i + 0;
                        locIndices[6 * i + 1] = 4 * i + 0;
                        locIndices[6 * i + 2] = 4 * i + 2;
                        locIndices[6 * i + 3] = 4 * i + 1;
                        locIndices[6 * i + 4] = 4 * i + 3;
                        locIndices[6 * i + 5] = 4 * i + 3;
                    } else {
                        locIndices[6 * i + 0] = 4 * i + 0;
                        locIndices[6 * i + 1] = 4 * i + 1;
                        locIndices[6 * i + 2] = 4 * i + 2;
                        locIndices[6 * i + 3] = 4 * i + 3;
                        locIndices[6 * i + 4] = 4 * i + 2;
                        locIndices[6 * i + 5] = 4 * i + 1;
                    }
                }
            },
            initWithFile: function(file, capacity) {
                var texture = cc.textureCache.addImage(file);
                if (texture) {
                    return this.initWithTexture(texture, capacity);
                }
                cc.logID(2900, file);
                return false;
            },
            initWithTexture: function(texture, capacity) {
                cc.assertID(texture, 2902);
                capacity |= 0;
                this._capacity = capacity;
                this._totalQuads = 0;
                this.texture = texture;
                this._quads = [];
                this._indices = new Uint16Array(6 * capacity);
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                this._quadsArrayBuffer = new ArrayBuffer(quadSize * capacity);
                this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
                if (!(this._quads && this._indices) && capacity > 0) {
                    return false;
                }
                var locQuads = this._quads;
                for (var i = 0; i < capacity; i++) {
                    locQuads[i] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, i * quadSize);
                }
                this._setupIndices();
                this._setupVBO();
                this.dirty = true;
                return true;
            },
            updateQuad: function(quad, index) {
                cc.assertID(quad, 2903);
                cc.assertID(index >= 0 && index < this._capacity, 2904);
                this._totalQuads = Math.max(index + 1, this._totalQuads);
                this._setQuadToArray(quad, index);
                this.dirty = true;
            },
            insertQuad: function(quad, index) {
                cc.assertID(index < this._capacity, 2905);
                this._totalQuads++;
                if (this._totalQuads > this._capacity) {
                    cc.logID(2901);
                    return;
                }
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                var remaining = this._totalQuads - 1 - index;
                var startOffset = index * quadSize;
                var moveLength = remaining * quadSize;
                this._quads[this._totalQuads - 1] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * quadSize);
                this._quadsReader.set(this._quadsReader.subarray(startOffset, startOffset + moveLength), startOffset + quadSize);
                this._setQuadToArray(quad, index);
                this.dirty = true;
            },
            insertQuads: function(quads, index, amount) {
                amount = amount || quads.length;
                cc.assertID(index + amount <= this._capacity, 2906);
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                this._totalQuads += amount;
                if (this._totalQuads > this._capacity) {
                    cc.logID(2901);
                    return;
                }
                var remaining = this._totalQuads - 1 - index - amount;
                var startOffset = index * quadSize;
                var moveLength = remaining * quadSize;
                var lastIndex = this._totalQuads - 1 - amount;
                var i;
                for (i = 0; i < amount; i++) {
                    this._quads[lastIndex + i] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, (this._totalQuads - 1) * quadSize);
                }
                this._quadsReader.set(this._quadsReader.subarray(startOffset, startOffset + moveLength), startOffset + quadSize * amount);
                for (i = 0; i < amount; i++) {
                    this._setQuadToArray(quads[i], index + i);
                }
                this.dirty = true;
            },
            insertQuadFromIndex: function(fromIndex, newIndex) {
                if (fromIndex === newIndex) {
                    return;
                }
                cc.assertID(newIndex >= 0 || newIndex < this._totalQuads, 2907);
                cc.assertID(fromIndex >= 0 || fromIndex < this._totalQuads, 2908);
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                var locQuadsReader = this._quadsReader;
                var sourceArr = locQuadsReader.subarray(fromIndex * quadSize, quadSize);
                var startOffset, moveLength;
                if (fromIndex > newIndex) {
                    startOffset = newIndex * quadSize;
                    moveLength = (fromIndex - newIndex) * quadSize;
                    locQuadsReader.set(locQuadsReader.subarray(startOffset, startOffset + moveLength), startOffset + quadSize);
                    locQuadsReader.set(sourceArr, startOffset);
                } else {
                    startOffset = (fromIndex + 1) * quadSize;
                    moveLength = (newIndex - fromIndex) * quadSize;
                    locQuadsReader.set(locQuadsReader.subarray(startOffset, startOffset + moveLength), startOffset - quadSize);
                    locQuadsReader.set(sourceArr, newIndex * quadSize);
                }
                this.dirty = true;
            },
            removeQuadAtIndex: function(index) {
                cc.assertID(index < this._totalQuads, 2909);
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                this._totalQuads--;
                this._quads.length = this._totalQuads;
                if (index !== this._totalQuads) {
                    var startOffset = (index + 1) * quadSize;
                    var moveLength = (this._totalQuads - index) * quadSize;
                    this._quadsReader.set(this._quadsReader.subarray(startOffset, startOffset + moveLength), startOffset - quadSize);
                }
                this.dirty = true;
            },
            removeQuadsAtIndex: function(index, amount) {
                cc.assertID(index + amount <= this._totalQuads, 2910);
                this._totalQuads -= amount;
                if (index !== this._totalQuads) {
                    var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                    var srcOffset = (index + amount) * quadSize;
                    var moveLength = (this._totalQuads - index) * quadSize;
                    var dstOffset = index * quadSize;
                    this._quadsReader.set(this._quadsReader.subarray(srcOffset, srcOffset + moveLength), dstOffset);
                }
                this.dirty = true;
            },
            removeAllQuads: function() {
                this._quads.length = 0;
                this._totalQuads = 0;
            },
            _setDirty: function(dirty) {
                this.dirty = dirty;
            },
            resizeCapacity: function(newCapacity) {
                if (newCapacity === this._capacity) {
                    return true;
                }
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                var oldCapacity = this._capacity;
                this._totalQuads = Math.min(this._totalQuads, newCapacity);
                this._capacity = 0 | newCapacity;
                var i, capacity = this._capacity, locTotalQuads = this._totalQuads;
                if (null === this._quads) {
                    this._quads = [];
                    this._quadsArrayBuffer = new ArrayBuffer(quadSize * capacity);
                    this._quadsReader = new Uint8Array(this._quadsArrayBuffer);
                    for (i = 0; i < capacity; i++) {
                        this._quads = new cc.V3F_C4B_T2F_Quad(null, null, null, null, this._quadsArrayBuffer, i * quadSize);
                    }
                } else {
                    var newQuads, newArrayBuffer, quads = this._quads;
                    if (capacity > oldCapacity) {
                        newQuads = [];
                        newArrayBuffer = new ArrayBuffer(quadSize * capacity);
                        for (i = 0; i < locTotalQuads; i++) {
                            newQuads[i] = new cc.V3F_C4B_T2F_Quad(quads[i].tl, quads[i].bl, quads[i].tr, quads[i].br, newArrayBuffer, i * quadSize);
                        }
                        for (;i < capacity; i++) {
                            newQuads[i] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, newArrayBuffer, i * quadSize);
                        }
                        this._quadsReader = new Uint8Array(newArrayBuffer);
                        this._quads = newQuads;
                        this._quadsArrayBuffer = newArrayBuffer;
                    } else {
                        var count = Math.max(locTotalQuads, capacity);
                        newQuads = [];
                        newArrayBuffer = new ArrayBuffer(quadSize * capacity);
                        for (i = 0; i < count; i++) {
                            newQuads[i] = new cc.V3F_C4B_T2F_Quad(quads[i].tl, quads[i].bl, quads[i].tr, quads[i].br, newArrayBuffer, i * quadSize);
                        }
                        this._quadsReader = new Uint8Array(newArrayBuffer);
                        this._quads = newQuads;
                        this._quadsArrayBuffer = newArrayBuffer;
                    }
                }
                if (null === this._indices) {
                    this._indices = new Uint16Array(6 * capacity);
                } else {
                    if (capacity > oldCapacity) {
                        var tempIndices = new Uint16Array(6 * capacity);
                        tempIndices.set(this._indices, 0);
                        this._indices = tempIndices;
                    } else {
                        this._indices = this._indices.subarray(0, 6 * capacity);
                    }
                }
                this._setupIndices();
                this._mapBuffers();
                this.dirty = true;
                return true;
            },
            increaseTotalQuadsWith: function(amount) {
                this._totalQuads += amount;
            },
            moveQuadsFromIndex: function(oldIndex, amount, newIndex) {
                if (void 0 === newIndex) {
                    newIndex = amount;
                    amount = this._totalQuads - oldIndex;
                    cc.assertID(newIndex + (this._totalQuads - oldIndex) <= this._capacity, 2911);
                    if (0 === amount) {
                        return;
                    }
                } else {
                    cc.assertID(newIndex + amount <= this._totalQuads, 2912);
                    cc.assertID(oldIndex < this._totalQuads, 2913);
                    if (oldIndex === newIndex) {
                        return;
                    }
                }
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                var srcOffset = oldIndex * quadSize;
                var srcLength = amount * quadSize;
                var locQuadsReader = this._quadsReader;
                var sourceArr = locQuadsReader.subarray(srcOffset, srcOffset + srcLength);
                var dstOffset = newIndex * quadSize;
                var moveLength, moveStart;
                if (newIndex < oldIndex) {
                    moveLength = (oldIndex - newIndex) * quadSize;
                    moveStart = newIndex * quadSize;
                    locQuadsReader.set(locQuadsReader.subarray(moveStart, moveStart + moveLength), moveStart + srcLength);
                } else {
                    moveLength = (newIndex - oldIndex) * quadSize;
                    moveStart = (oldIndex + amount) * quadSize;
                    locQuadsReader.set(locQuadsReader.subarray(moveStart, moveStart + moveLength), srcOffset);
                }
                locQuadsReader.set(sourceArr, dstOffset);
                this.dirty = true;
            },
            fillWithEmptyQuadsFromIndex: function(index, amount) {
                var count = amount * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                var clearReader = new Uint8Array(this._quadsArrayBuffer, index * cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT, count);
                for (var i = 0; i < count; i++) {
                    clearReader[i] = 0;
                }
            },
            _setupVBO: function() {},
            _mapBuffers: function() {},
            drawQuads: function() {},
            drawNumberOfQuads: null,
            _releaseBuffer: function() {
                var gl = cc._renderContext;
                if (this._buffersVBO) {
                    this._buffersVBO[0] && gl.deleteBuffer(this._buffersVBO[0]);
                    this._buffersVBO[1] && gl.deleteBuffer(this._buffersVBO[1]);
                }
                this._quadsWebBuffer && gl.deleteBuffer(this._quadsWebBuffer);
            }
        });
        var _p = TextureAtlas.prototype;
        _p.totalQuads;
        cc.defineGetterSetter(_p, "totalQuads", _p.getTotalQuads);
        _p.capacity;
        cc.defineGetterSetter(_p, "capacity", _p.getCapacity);
        _p.quads;
        cc.defineGetterSetter(_p, "quads", _p.getQuads, _p.setQuads);
        game.once(game.EVENT_RENDERER_INITED, (function() {
            if (cc._renderType === game.RENDER_TYPE_WEBGL) {
                TextureAtlas.prototype._setupVBO = function() {
                    var _t = this;
                    var gl = cc._renderContext;
                    _t._buffersVBO[0] = gl.createBuffer();
                    _t._buffersVBO[1] = gl.createBuffer();
                    _t._quadsWebBuffer = gl.createBuffer();
                    _t._mapBuffers();
                };
                TextureAtlas.prototype._mapBuffers = function() {
                    var _t = this;
                    var gl = cc._renderContext;
                    gl.bindBuffer(gl.ARRAY_BUFFER, _t._quadsWebBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, _t._quadsArrayBuffer, gl.DYNAMIC_DRAW);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _t._buffersVBO[1]);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, _t._indices, gl.STATIC_DRAW);
                };
                TextureAtlas.prototype.drawQuads = function() {
                    this.drawNumberOfQuads(this._totalQuads, 0);
                };
                TextureAtlas.prototype.drawNumberOfQuads = function(n, start) {
                    var _t = this;
                    start = start || 0;
                    if (0 === n || !_t.texture || !_t.texture.isLoaded()) {
                        return;
                    }
                    var gl = cc._renderContext;
                    cc.gl.bindTexture2D(_t.texture);
                    gl.bindBuffer(gl.ARRAY_BUFFER, _t._quadsWebBuffer);
                    gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_POSITION);
                    gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_COLOR);
                    gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_TEX_COORDS);
                    if (_t.dirty) {
                        gl.bufferData(gl.ARRAY_BUFFER, _t._quadsArrayBuffer, gl.DYNAMIC_DRAW);
                        _t.dirty = false;
                    }
                    gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 24, 0);
                    gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, 24, 12);
                    gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 24, 16);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _t._buffersVBO[1]);
                    cc.macro.TEXTURE_ATLAS_USE_TRIANGLE_STRIP ? gl.drawElements(gl.TRIANGLE_STRIP, 6 * n, gl.UNSIGNED_SHORT, 6 * start * _t._indices.BYTES_PER_ELEMENT) : gl.drawElements(gl.TRIANGLES, 6 * n, gl.UNSIGNED_SHORT, 6 * start * _t._indices.BYTES_PER_ELEMENT);
                    cc.g_NumberOfDraws++;
                };
            }
        }));
        cc.TextureAtlas = module.exports = TextureAtlas;
    }), {
        "../CCGame": 40,
        "../platform/_CCClass": 185,
        "../platform/js": 193
    } ],
    215: [ (function(require, module, exports) {
        var game = require("../CCGame");
        var Texture2D = require("./CCTexture2D");
        var textureCache = {
            _textures: {},
            _textureColorsCache: {},
            _textureKeySeq: 0 | 1e3 * Math.random(),
            _loadedTexturesBefore: {},
            handleLoadedTexture: null,
            _initializingRenderer: function() {
                var selPath;
                var locLoadedTexturesBefore = this._loadedTexturesBefore, locTextures = this._textures;
                for (selPath in locLoadedTexturesBefore) {
                    var tex2d = locLoadedTexturesBefore[selPath];
                    tex2d.handleLoadedTexture();
                    locTextures[selPath] = tex2d;
                }
                this._loadedTexturesBefore = {};
            },
            description: function() {
                return "<TextureCache | Number of textures = " + this._textures.length + ">";
            },
            textureForKey: function(textureKeyName) {
                cc.logID(3002);
                return this.getTextureForKey(textureKeyName);
            },
            getTextureForKey: function(textureKeyName) {
                return this._textures[textureKeyName];
            },
            getKeyByTexture: function(texture) {
                for (var key in this._textures) {
                    if (this._textures[key] === texture) {
                        return key;
                    }
                }
                return null;
            },
            _generalTextureKey: function(id) {
                return "_textureKey_" + id;
            },
            getTextureColors: function(texture) {
                var image = texture._htmlElementObj;
                var key = this.getKeyByTexture(image);
                key || (key = image instanceof HTMLImageElement ? image.src : this._generalTextureKey(texture.__instanceId));
                this._textureColorsCache[key] || (this._textureColorsCache[key] = texture._generateTextureCacheForColor());
                return this._textureColorsCache[key];
            },
            getAllTextures: function() {
                var texs = [];
                for (var key in this._textures) {
                    var item = this._textures[key];
                    texs.push(item);
                }
                return texs;
            },
            removeAllTextures: function() {
                var locTextures = this._textures;
                for (var selKey in locTextures) {
                    locTextures[selKey] && locTextures[selKey].releaseTexture();
                }
                this._textures = {};
            },
            removeTexture: function(texture) {
                if (!texture) {
                    return;
                }
                var locTextures = this._textures;
                for (var selKey in locTextures) {
                    if (locTextures[selKey] === texture) {
                        locTextures[selKey].releaseTexture();
                        delete locTextures[selKey];
                    }
                }
            },
            removeTextureForKey: function(textureKeyName) {
                if ("string" !== typeof textureKeyName) {
                    return;
                }
                var locTextures = this._textures;
                if (locTextures[textureKeyName]) {
                    locTextures[textureKeyName].releaseTexture();
                    delete locTextures[textureKeyName];
                }
            },
            addImage: null,
            addImageAsync: null,
            cacheImage: function(path, texture) {
                cc.assertID(path, 3009);
                if (texture instanceof Texture2D) {
                    this._textures[path] = texture;
                    return;
                }
                var texture2d = new Texture2D();
                texture2d.initWithElement(texture);
                texture2d.handleLoadedTexture();
                this._textures[path] = texture2d;
            },
            addUIImage: function(image, key) {
                cc.assertID(image, 3008);
                if (key && this._textures[key]) {
                    return this._textures[key];
                }
                var texture = new Texture2D();
                texture.initWithImage(image);
                null != key ? this._textures[key] = texture : cc.logID(3004);
                return texture;
            },
            dumpCachedTextureInfo: function() {
                var count = 0;
                var totalBytes = 0, locTextures = this._textures;
                for (var key in locTextures) {
                    var selTexture = locTextures[key];
                    count++;
                    selTexture.getHtmlElementObj() instanceof HTMLImageElement ? cc.logID(3005, key, selTexture.getHtmlElementObj().src, selTexture.getPixelWidth(), selTexture.getPixelHeight()) : cc.logID(3006, key, selTexture.getPixelWidth(), selTexture.getPixelHeight());
                    totalBytes += selTexture.getPixelWidth() * selTexture.getPixelHeight() * 4;
                }
                var locTextureColorsCache = this._textureColorsCache;
                for (key in locTextureColorsCache) {
                    var selCanvasColorsArr = locTextureColorsCache[key];
                    for (var selCanvasKey in selCanvasColorsArr) {
                        var selCanvas = selCanvasColorsArr[selCanvasKey];
                        count++;
                        cc.logID(3006, key, selCanvas.width, selCanvas.height);
                        totalBytes += selCanvas.width * selCanvas.height * 4;
                    }
                }
                cc.logID(3007, count, totalBytes / 1024, (totalBytes / 1048576).toFixed(2));
            },
            _clear: function() {
                this._textures = {};
                this._textureColorsCache = {};
                this._textureKeySeq = 0 | 1e3 * Math.random();
                this._loadedTexturesBefore = {};
            }
        };
        game.once(game.EVENT_RENDERER_INITED, (function() {
            var _p = textureCache;
            if (cc._renderType === game.RENDER_TYPE_CANVAS) {
                _p.handleLoadedTexture = function(url) {
                    var locTexs = this._textures;
                    var tex = locTexs[url];
                    if (!tex) {
                        cc.assertID(url, 3009);
                        tex = locTexs[url] = new Texture2D();
                        tex.url = url;
                    }
                    tex.handleLoadedTexture();
                };
                _p.addImage = function(url, cb, target) {
                    cc.assertID(url, 3103);
                    var locTexs = this._textures;
                    var tex = locTexs[url];
                    if (tex) {
                        if (tex.isLoaded()) {
                            cb && cb.call(target, tex);
                            return tex;
                        }
                        tex.once("load", (function() {
                            cb && cb.call(target, tex);
                        }), target);
                        return tex;
                    }
                    tex = locTexs[url] = new Texture2D();
                    tex.url = url;
                    cc.loader.load(url, (function(err, texture) {
                        if (err) {
                            return cb && cb.call(target, err || new Error("Unknown error"));
                        }
                        textureCache.handleLoadedTexture(url);
                        cb && cb.call(target, tex);
                    }));
                    return tex;
                };
                _p.addImageAsync = _p.addImage;
            } else {
                if (cc._renderType === game.RENDER_TYPE_WEBGL) {
                    _p.handleLoadedTexture = function(url) {
                        var locTexs = this._textures, tex, premultiplied;
                        cc.game._rendererInitialized || (locTexs = this._loadedTexturesBefore);
                        tex = locTexs[url];
                        if (!tex) {
                            cc.assertID(url, 3009);
                            tex = locTexs[url] = new Texture2D();
                            tex.url = url;
                        }
                        premultiplied = cc.macro.AUTO_PREMULTIPLIED_ALPHA_FOR_PNG && ".png" === cc.path.extname(url);
                        tex.handleLoadedTexture(premultiplied);
                    };
                    _p.addImage = function(url, cb, target) {
                        cc.assertID(url, 3112);
                        var locTexs = this._textures;
                        cc.game._rendererInitialized || (locTexs = this._loadedTexturesBefore);
                        var tex = locTexs[url];
                        if (tex) {
                            if (tex.isLoaded()) {
                                cb && cb.call(target, tex);
                                return tex;
                            }
                            tex.once("load", (function() {
                                cb && cb.call(target, tex);
                            }), target);
                            return tex;
                        }
                        tex = locTexs[url] = new Texture2D();
                        tex.url = url;
                        cc.loader.load(url, (function(err, texture) {
                            if (err) {
                                return cb && cb.call(target, err || new Error("Unknown error"));
                            }
                            textureCache.handleLoadedTexture(url);
                            cb && cb.call(target, tex);
                        }));
                        return tex;
                    };
                    _p.addImageAsync = _p.addImage;
                }
            }
        }));
        cc.textureCache = module.exports = textureCache;
    }), {
        "../CCGame": 40,
        "./CCTexture2D": 213
    } ],
    216: [ (function(require, module, exports) {
        require("./CCTexture2D");
        require("./CCTextureAtlas");
        require("./CCTextureCache");
    }), {
        "./CCTexture2D": 213,
        "./CCTextureAtlas": 214,
        "./CCTextureCache": 215
    } ],
    217: [ (function(require, module, exports) {
        require("../platform/CCSys");
        var EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/;
        var NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
        cc.path = {
            join: function() {
                var l = arguments.length;
                var result = "";
                for (var i = 0; i < l; i++) {
                    result = (result + ("" === result ? "" : "/") + arguments[i]).replace(/(\/|\\\\)$/, "");
                }
                return result;
            },
            extname: function(pathStr) {
                var temp = EXTNAME_RE.exec(pathStr);
                return temp ? temp[1] : "";
            },
            mainFileName: function(fileName) {
                if (fileName) {
                    var idx = fileName.lastIndexOf(".");
                    if (idx !== -1) {
                        return fileName.substring(0, idx);
                    }
                }
                return fileName;
            },
            basename: function(pathStr, extname) {
                var index = pathStr.indexOf("?");
                index > 0 && (pathStr = pathStr.substring(0, index));
                var reg = /(\/|\\\\)([^(\/|\\\\)]+)$/g;
                var result = reg.exec(pathStr.replace(/(\/|\\\\)$/, ""));
                if (!result) {
                    return null;
                }
                var baseName = result[2];
                if (extname && pathStr.substring(pathStr.length - extname.length).toLowerCase() === extname.toLowerCase()) {
                    return baseName.substring(0, baseName.length - extname.length);
                }
                return baseName;
            },
            dirname: function(pathStr) {
                return pathStr.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2");
            },
            changeExtname: function(pathStr, extname) {
                extname = extname || "";
                var index = pathStr.indexOf("?");
                var tempStr = "";
                if (index > 0) {
                    tempStr = pathStr.substring(index);
                    pathStr = pathStr.substring(0, index);
                }
                index = pathStr.lastIndexOf(".");
                if (index < 0) {
                    return pathStr + extname + tempStr;
                }
                return pathStr.substring(0, index) + extname + tempStr;
            },
            changeBasename: function(pathStr, basename, isSameExt) {
                if (0 === basename.indexOf(".")) {
                    return this.changeExtname(pathStr, basename);
                }
                var index = pathStr.indexOf("?");
                var tempStr = "";
                var ext = isSameExt ? this.extname(pathStr) : "";
                if (index > 0) {
                    tempStr = pathStr.substring(index);
                    pathStr = pathStr.substring(0, index);
                }
                index = pathStr.lastIndexOf("/");
                index = index <= 0 ? 0 : index + 1;
                return pathStr.substring(0, index) + basename + ext + tempStr;
            },
            _normalize: function(url) {
                var oldUrl = url = String(url);
                do {
                    oldUrl = url;
                    url = url.replace(NORMALIZE_RE, "");
                } while (oldUrl.length !== url.length);
                return url;
            },
            sep: cc.sys.os === cc.sys.OS_WINDOWS ? "\\" : "/",
            _setEndWithSep: function(path, endsWithSep) {
                var sep = cc.path.sep;
                if ("undefined" === typeof endsWithSep) {
                    endsWithSep = true;
                } else {
                    if ("string" === typeof endsWithSep) {
                        sep = endsWithSep;
                        endsWithSep = !!endsWithSep;
                    }
                }
                var endChar = path[path.length - 1];
                var oldEndWithSep = "\\" === endChar || "/" === endChar;
                !oldEndWithSep && endsWithSep ? path += sep : oldEndWithSep && !endsWithSep && (path = path.slice(0, -1));
                return path;
            }
        };
        module.exports = cc.path;
    }), {
        "../platform/CCSys": 182
    } ],
    218: [ (function(require, module, exports) {
        var PStats = require("../../../external/pstats/pstats");
        var macro = require("../platform/CCMacro");
        var _fps = document.createElement("div");
        _fps.id = "fps";
        var stats = PStats.new(_fps, {
            values: {
                frame: {
                    desc: "Frame time (ms)",
                    min: 0,
                    max: 50,
                    average: 500
                },
                fps: {
                    desc: "Framerate (FPS)",
                    below: 30,
                    average: 500
                },
                draws: {
                    desc: "Draw call"
                },
                logic: {
                    desc: "Game Logic (ms)",
                    min: 0,
                    max: 50,
                    average: 500,
                    color: "#080"
                },
                render: {
                    desc: "Renderer (ms)",
                    min: 0,
                    max: 50,
                    average: 500,
                    color: "#f90"
                }
            },
            css: ".pstats {left: " + macro.DIRECTOR_STATS_POSITION.x + "px; bottom: " + macro.DIRECTOR_STATS_POSITION.y + "px;}"
        });
        var _showFPS = false;
        function beforeUpdate() {
            stats("frame").start();
            stats("logic").start();
        }
        function afterVisit() {
            cc.director.isPaused() ? stats("frame").start() : stats("logic").end();
            stats("render").start();
        }
        function afterDraw() {
            stats("render").end();
            stats("draws").value = cc.g_NumberOfDraws;
            stats("frame").end();
            stats("fps").frame();
            stats().tick();
        }
        cc.profiler = module.exports = {
            isShowingStats: function() {
                return _showFPS;
            },
            hideStats: function() {
                if (_showFPS) {
                    _fps.parentElement === document.body && document.body.removeChild(_fps);
                    cc.director.off(cc.Director.EVENT_BEFORE_UPDATE, beforeUpdate);
                    cc.director.off(cc.Director.EVENT_AFTER_VISIT, afterVisit);
                    cc.director.off(cc.Director.EVENT_AFTER_DRAW, afterDraw);
                    _showFPS = false;
                }
            },
            showStats: function() {
                if (!_showFPS) {
                    null === _fps.parentElement && document.body.appendChild(_fps);
                    cc.director.on(cc.Director.EVENT_BEFORE_UPDATE, beforeUpdate);
                    cc.director.on(cc.Director.EVENT_AFTER_VISIT, afterVisit);
                    cc.director.on(cc.Director.EVENT_AFTER_DRAW, afterDraw);
                    _showFPS = true;
                }
            }
        };
    }), {
        "../../../external/pstats/pstats": 312,
        "../platform/CCMacro": 178
    } ],
    219: [ (function(require, module, exports) {
        var Flags = require("../platform/CCObject").Flags;
        var Misc = require("./misc");
        var IdGenerater = require("../platform/id-generater");
        var JS = cc.js;
        var Destroying = Flags.Destroying;
        var DontDestroy = Flags.DontDestroy;
        var CHILD_ADDED = "child-added";
        var CHILD_REMOVED = "child-removed";
        var idGenerater = new IdGenerater("Node");
        function getConstructor(typeOrClassName) {
            if (!typeOrClassName) {
                cc.errorID(3804);
                return null;
            }
            if ("string" === typeof typeOrClassName) {
                return JS.getClassByName(typeOrClassName);
            }
            return typeOrClassName;
        }
        function findComponent(node, constructor) {
            for (var i = 0; i < node._components.length; ++i) {
                var comp = node._components[i];
                if (comp instanceof constructor) {
                    return comp;
                }
            }
            return null;
        }
        function findComponents(node, constructor, components) {
            for (var i = 0; i < node._components.length; ++i) {
                var comp = node._components[i];
                comp instanceof constructor && components.push(comp);
            }
        }
        function findChildComponent(children, constructor) {
            for (var i = 0; i < children.length; ++i) {
                var node = children[i];
                var comp = findComponent(node, constructor);
                if (comp) {
                    return comp;
                }
                if (node._children.length > 0) {
                    comp = findChildComponent(node._children, constructor);
                    if (comp) {
                        return comp;
                    }
                }
            }
            return null;
        }
        function findChildComponents(children, constructor, components) {
            for (var i = 0; i < children.length; ++i) {
                var node = children[i];
                findComponents(node, constructor, components);
                node._children.length > 0 && findChildComponents(node._children, constructor, components);
            }
        }
        var BaseNode = cc.Class({
            name: "cc._BaseNode",
            extends: cc.Object,
            mixins: [ cc.EventTarget ],
            properties: {
                _parent: null,
                _children: [],
                _tag: cc.macro.NODE_TAG_INVALID,
                _active: true,
                _components: [],
                _prefab: null,
                _persistNode: {
                    get: function() {
                        return (this._objFlags & DontDestroy) > 0;
                    },
                    set: function(value) {
                        value ? this._objFlags |= DontDestroy : this._objFlags &= ~DontDestroy;
                    }
                },
                name: {
                    get: function() {
                        return this._name;
                    },
                    set: function(value) {
                        if (value.indexOf("/") !== -1) {
                            cc.errorID(1632);
                            return;
                        }
                        this._name = value;
                    }
                },
                _id: {
                    default: "",
                    editorOnly: true
                },
                uuid: {
                    get: function() {
                        var id = this._id;
                        id || (id = this._id = idGenerater.getNewId());
                        return id;
                    }
                },
                children: {
                    get: function() {
                        return this._children;
                    }
                },
                childrenCount: {
                    get: function() {
                        return this._children.length;
                    }
                },
                active: {
                    get: function() {
                        return this._active;
                    },
                    set: function(value) {
                        value = !!value;
                        if (this._active !== value) {
                            this._active = value;
                            var parent = this._parent;
                            if (parent) {
                                var couldActiveInScene = parent._activeInHierarchy;
                                couldActiveInScene && cc.director._nodeActivator.activateNode(this, value);
                            }
                        }
                    }
                },
                activeInHierarchy: {
                    get: function() {
                        return this._activeInHierarchy;
                    }
                }
            },
            ctor: function(name) {
                this._name = "undefined" !== typeof name ? name : "New Node";
                this._activeInHierarchy = false;
                this.__instanceId = this._id || cc.ClassManager.getNewInstanceId();
                this.__eventTargets = [];
            },
            getTag: function() {
                return this._tag;
            },
            setTag: function(tag) {
                this._tag = tag;
            },
            getParent: function() {
                return this._parent;
            },
            setParent: function(value) {
                if (this._parent === value) {
                    return;
                }
                var oldParent = this._parent;
                this._parent = value || null;
                this._onSetParent(value);
                if (value) {
                    cc.eventManager._setDirtyForNode(this);
                    value._children.push(this);
                    value.emit(CHILD_ADDED, this);
                }
                if (oldParent) {
                    if (!(oldParent._objFlags & Destroying)) {
                        var removeAt = oldParent._children.indexOf(this);
                        if (removeAt < 0) {
                            return cc.errorID(1633);
                        }
                        oldParent._children.splice(removeAt, 1);
                        oldParent.emit(CHILD_REMOVED, this);
                        this._onHierarchyChanged(oldParent);
                    }
                } else {
                    value && this._onHierarchyChanged(null);
                }
            },
            init: function() {
                return true;
            },
            attr: function(attrs) {
                for (var key in attrs) {
                    this[key] = attrs[key];
                }
            },
            getChildByTag: function(aTag) {
                var children = this._children;
                if (null !== children) {
                    for (var i = 0; i < children.length; i++) {
                        var node = children[i];
                        if (node && node._tag === aTag) {
                            return node;
                        }
                    }
                }
                return null;
            },
            getChildByUuid: function(uuid) {
                if (!uuid) {
                    cc.log("Invalid uuid");
                    return null;
                }
                var locChildren = this._children;
                for (var i = 0, len = locChildren.length; i < len; i++) {
                    if (locChildren[i]._id === uuid) {
                        return locChildren[i];
                    }
                }
                return null;
            },
            getChildByName: function(name) {
                if (!name) {
                    cc.log("Invalid name");
                    return null;
                }
                var locChildren = this._children;
                for (var i = 0, len = locChildren.length; i < len; i++) {
                    if (locChildren[i]._name === name) {
                        return locChildren[i];
                    }
                }
                return null;
            },
            addChild: function(child) {
                if (!(child instanceof cc._BaseNode)) {
                    return cc.errorID(1634, cc.js.getClassName(child));
                }
                cc.assertID(child, 1606);
                cc.assertID(null === child._parent, 1605);
                child.setParent(this);
            },
            getSiblingIndex: function() {
                return this._parent ? this._parent._children.indexOf(this) : 0;
            },
            setSiblingIndex: function(index) {
                if (!this._parent) {
                    return;
                }
                var siblings = this._parent._children;
                index = index !== -1 ? index : siblings.length - 1;
                var oldIndex = siblings.indexOf(this);
                if (index !== oldIndex) {
                    siblings.splice(oldIndex, 1);
                    index < siblings.length ? siblings.splice(index, 0, this) : siblings.push(this);
                    this._onSiblingIndexChanged && this._onSiblingIndexChanged(index);
                }
            },
            cleanup: function() {},
            removeFromParent: function(cleanup) {
                if (this._parent) {
                    void 0 === cleanup && (cleanup = true);
                    this._parent.removeChild(this, cleanup);
                }
            },
            removeChild: function(child, cleanup) {
                if (this._children.indexOf(child) > -1) {
                    (cleanup || void 0 === cleanup) && child.cleanup();
                    child.parent = null;
                }
            },
            removeChildByTag: function(tag, cleanup) {
                tag === cc.macro.NODE_TAG_INVALID && cc.logID(1609);
                var child = this.getChildByTag(tag);
                child ? this.removeChild(child, cleanup) : cc.logID(1610, tag);
            },
            removeAllChildren: function(cleanup) {
                var children = this._children;
                void 0 === cleanup && (cleanup = true);
                for (var i = children.length - 1; i >= 0; i--) {
                    var node = children[i];
                    if (node) {
                        cleanup && node.cleanup();
                        node.parent = null;
                    }
                }
                this._children.length = 0;
            },
            isChildOf: function(parent) {
                var child = this;
                do {
                    if (child === parent) {
                        return true;
                    }
                    child = child._parent;
                } while (child);
                return false;
            },
            getComponent: function(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName);
                if (constructor) {
                    return findComponent(this, constructor);
                }
                return null;
            },
            getComponents: function(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName), components = [];
                constructor && findComponents(this, constructor, components);
                return components;
            },
            getComponentInChildren: function(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName);
                if (constructor) {
                    return findChildComponent(this._children, constructor);
                }
                return null;
            },
            getComponentsInChildren: function(typeOrClassName) {
                var constructor = getConstructor(typeOrClassName), components = [];
                if (constructor) {
                    findComponents(this, constructor, components);
                    findChildComponents(this._children, constructor, components);
                }
                return components;
            },
            _checkMultipleComp: false,
            addComponent: function(typeOrClassName) {
                var constructor;
                if ("string" === typeof typeOrClassName) {
                    constructor = JS.getClassByName(typeOrClassName);
                    if (!constructor) {
                        cc.errorID(3807, typeOrClassName);
                        cc._RFpeek() && cc.errorID(3808, typeOrClassName);
                        return null;
                    }
                } else {
                    if (!typeOrClassName) {
                        cc.errorID(3804);
                        return null;
                    }
                    constructor = typeOrClassName;
                }
                if ("function" !== typeof constructor) {
                    cc.errorID(3809);
                    return null;
                }
                if (!cc.isChildClassOf(constructor, cc.Component)) {
                    cc.errorID(3810);
                    return null;
                }
                var ReqComp = constructor._requireComponent;
                if (ReqComp && !this.getComponent(ReqComp)) {
                    var depended = this.addComponent(ReqComp);
                    if (!depended) {
                        return null;
                    }
                }
                var component = new constructor();
                component.node = this;
                this._components.push(component);
                this._activeInHierarchy && cc.director._nodeActivator.activateComp(component);
                return component;
            },
            _addComponentAt: false,
            removeComponent: function(component) {
                if (!component) {
                    cc.errorID(3813);
                    return;
                }
                component instanceof cc.Component || (component = this.getComponent(component));
                component && component.destroy();
            },
            _getDependComponent: false,
            _removeComponent: function(component) {
                if (!component) {
                    cc.errorID(3814);
                    return;
                }
                if (!(this._objFlags & Destroying)) {
                    var i = this._components.indexOf(component);
                    i !== -1 ? this._components.splice(i, 1) : component.node !== this && cc.errorID(3815);
                }
            },
            _disableChildComps: function() {
                var i, len = this._components.length;
                for (i = 0; i < len; ++i) {
                    var component = this._components[i];
                    component._enabled && cc.director._compScheduler.disableComp(component);
                }
                for (i = 0, len = this._children.length; i < len; ++i) {
                    var node = this._children[i];
                    node._active && node._disableChildComps();
                }
            },
            destroy: function() {
                cc.Object.prototype.destroy.call(this) && this._activeInHierarchy && this._disableChildComps();
            },
            destroyAllChildren: function() {
                var children = this._children;
                for (var i = 0; i < children.length; ++i) {
                    children[i].destroy();
                }
            },
            _onSetParent: function(value) {},
            _onPostActivated: function() {},
            _onHierarchyChanged: function(oldParent) {
                var newParent = this._parent;
                !this._persistNode || newParent instanceof cc.Scene || cc.game.removePersistRootNode(this);
                var shouldActiveNow = this._active && !!(newParent && newParent._activeInHierarchy);
                this._activeInHierarchy !== shouldActiveNow && cc.director._nodeActivator.activateNode(this, shouldActiveNow);
                var scene;
                var inCurrentSceneBefore;
                var inCurrentSceneNow;
                var newPrefabRoot;
                var myPrefabInfo;
            },
            _onBatchCreated: function() {
                var prefabInfo = this._prefab;
                prefabInfo && prefabInfo.sync && !prefabInfo._synced && prefabInfo.root === this && PrefabHelper.syncWithPrefab(this);
                var children = this._children;
                for (var i = 0, len = children.length; i < len; i++) {
                    children[i]._onBatchCreated();
                }
            },
            _instantiate: function(cloned) {
                cloned || (cloned = cc.instantiate._clone(this, this));
                var thisPrefabInfo = this._prefab;
                var syncing = thisPrefabInfo && this === thisPrefabInfo.root && thisPrefabInfo.sync;
                syncing && (cloned._prefab._synced = thisPrefabInfo._synced);
                cloned._parent = null;
                cloned._onBatchCreated();
                return cloned;
            },
            _registerIfAttached: false,
            _onPreDestroy: function() {
                var i, len;
                this._objFlags |= Destroying;
                var parent = this._parent;
                var destroyByParent = parent && parent._objFlags & Destroying;
                !destroyByParent && false && this._registerIfAttached(false);
                var children = this._children;
                for (i = 0, len = children.length; i < len; ++i) {
                    children[i]._destroyImmediate();
                }
                for (i = 0, len = this._components.length; i < len; ++i) {
                    var component = this._components[i];
                    component._destroyImmediate();
                }
                var eventTargets = this.__eventTargets;
                for (i = 0, len = eventTargets.length; i < len; ++i) {
                    var target = eventTargets[i];
                    target && target.targetOff(this);
                }
                eventTargets.length = 0;
                this._persistNode && cc.game.removePersistRootNode(this);
                if (!destroyByParent && parent) {
                    var childIndex = parent._children.indexOf(this);
                    parent._children.splice(childIndex, 1);
                    parent.emit("child-removed", this);
                }
                return destroyByParent;
            },
            onRestore: false
        });
        BaseNode.prototype._onPreDestroyBase = BaseNode.prototype._onPreDestroy;
        BaseNode.prototype._onHierarchyChangedBase = BaseNode.prototype._onHierarchyChanged;
        var SameNameGetSets = [ "name", "children", "childrenCount" ];
        Misc.propertyDefine(BaseNode, SameNameGetSets, {});
        JS.get(BaseNode.prototype, " INFO ", (function() {
            var path = "";
            var node = this;
            while (node && !(node instanceof cc.Scene)) {
                path = path ? node.name + "/" + path : node.name;
                node = node._parent;
            }
            return this.name + ", path: " + path;
        }));
        cc._BaseNode = module.exports = BaseNode;
    }), {
        "../platform/CCObject": 179,
        "../platform/id-generater": 189,
        "./misc": 223
    } ],
    220: [ (function(require, module, exports) {
        var EPSILON = 1e-6;
        function binarySearchEpsilon(array, value) {
            for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
                var test = array[m];
                if (test > value + EPSILON) {
                    h = m - 1;
                } else {
                    if (!(test < value - EPSILON)) {
                        return m;
                    }
                    l = m + 1;
                }
            }
            return ~l;
        }
        module.exports = {
            binarySearchEpsilon: binarySearchEpsilon
        };
    }), {} ],
    221: [ (function(require, module, exports) {
        cc.find = module.exports = function(path, referenceNode) {
            if (null == path) {
                cc.errorID(5600);
                return null;
            }
            if (referenceNode) {
                if (!referenceNode.isValid) {
                    cc.warnID(5603);
                    return null;
                }
            } else {
                var scene = cc.director.getScene();
                if (!scene) {
                    cc.warnID(5601);
                    return null;
                }
                if (!scene.isValid) {
                    cc.warnID(5602);
                    return null;
                }
                referenceNode = scene;
            }
            var match = referenceNode;
            var startIndex = "/" !== path[0] ? 0 : 1;
            var nameList = path.split("/");
            for (var n = startIndex; n < nameList.length; n++) {
                var name = nameList[n];
                var children = match._children;
                match = null;
                for (var t = 0, len = children.length; t < len; ++t) {
                    var subChild = children[t];
                    if (subChild.name === name) {
                        match = subChild;
                        break;
                    }
                }
                if (!match) {
                    return null;
                }
            }
            return match;
        };
    }), {} ],
    222: [ (function(require, module, exports) {
        require("./CCPath");
        require("./CCProfiler");
        require("./find");
        require("./mutable-forward-iterator");
    }), {
        "./CCPath": 217,
        "./CCProfiler": 218,
        "./find": 221,
        "./mutable-forward-iterator": 224
    } ],
    223: [ (function(require, module, exports) {
        var JS = require("../platform/js");
        var misc = {};
        misc.propertyDefine = function(ctor, sameNameGetSets, diffNameGetSets) {
            function define(np, propName, getter, setter) {
                var pd = Object.getOwnPropertyDescriptor(np, propName);
                if (pd) {
                    pd.get && (np[getter] = pd.get);
                    pd.set && setter && (np[setter] = pd.set);
                } else {
                    var getterFunc = np[getter];
                    if (getterFunc) {
                        cc.js.getset(np, propName, getterFunc, np[setter]);
                    } else {
                        var clsName = cc.Class._isCCClass(ctor) && cc.js.getClassName(ctor) || ctor.name || "(anonymous class)";
                        cc.warnID(5700, propName, getter, clsName);
                    }
                }
            }
            var propName, np = ctor.prototype;
            for (var i = 0; i < sameNameGetSets.length; i++) {
                propName = sameNameGetSets[i];
                var suffix = propName[0].toUpperCase() + propName.slice(1);
                define(np, propName, "get" + suffix, "set" + suffix);
            }
            for (propName in diffNameGetSets) {
                var getset = diffNameGetSets[propName];
                define(np, propName, getset[0], getset[1]);
            }
        };
        misc.NextPOT = function(x) {
            x -= 1;
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            x |= x >> 16;
            return x + 1;
        };
        misc.imagePool = new JS.Pool(function(img) {
            if (img instanceof HTMLImageElement) {
                img.src = this._smallImg;
                return true;
            }
            return false;
        }, 10);
        misc.imagePool.get = function() {
            return this._get() || new Image();
        };
        misc.imagePool._smallImg = "data:image/gif;base64,R0lGODlhAQABAAAAACwAAAAAAQABAAA=";
        misc.isBuiltinClassId = function(id) {
            return id.startsWith("cc.") || id.startsWith("dragonBones.") || id.startsWith("sp.") || id.startsWith("ccsg.");
        };
        module.exports = misc;
    }), {
        "../platform/js": 193
    } ],
    224: [ (function(require, module, exports) {
        function MutableForwardIterator(array) {
            this.i = 0;
            this.array = array;
        }
        var proto = MutableForwardIterator.prototype;
        proto.remove = function(value) {
            var index = this.array.indexOf(value);
            index >= 0 && this.removeAt(index);
        };
        proto.removeAt = function(i) {
            this.array.splice(i, 1);
            i <= this.i && --this.i;
        };
        proto.fastRemove = function(value) {
            var index = this.array.indexOf(value);
            index >= 0 && this.fastRemoveAt(index);
        };
        proto.fastRemoveAt = function(i) {
            var array = this.array;
            array[i] = array[array.length - 1];
            --array.length;
            i <= this.i && --this.i;
        };
        proto.push = function(item) {
            this.array.push(item);
        };
        module.exports = MutableForwardIterator;
    }), {} ],
    225: [ (function(require, module, exports) {
        cc._PrefabInfo = cc.Class({
            name: "cc.PrefabInfo",
            properties: {
                root: null,
                asset: null,
                fileId: "",
                sync: false,
                _synced: {
                    default: false,
                    serializable: false
                }
            }
        });
        module.exports = {
            syncWithPrefab: function(node) {
                var _prefab = node._prefab;
                _prefab._synced = true;
                if (!_prefab.asset) {
                    cc.errorID(3701, node.name);
                    node._prefab = null;
                    return;
                }
                var _objFlags = node._objFlags;
                var _parent = node._parent;
                var _id = node._id;
                var _name = node._name;
                var _active = node._active;
                var _position = node._position;
                var _rotationX = node._rotationX;
                var _rotationY = node._rotationY;
                var _localZOrder = node._localZOrder;
                var _globalZOrder = node._globalZOrder;
                cc.game._isCloning = true;
                _prefab.asset._doInstantiate(node);
                cc.game._isCloning = false;
                node._objFlags = _objFlags;
                node._parent = _parent;
                node._id = _id;
                node._prefab = _prefab;
                node._name = _name;
                node._active = _active;
                node._position = _position;
                node._rotationX = _rotationX;
                node._rotationY = _rotationY;
                node._localZOrder = _localZOrder;
                node._globalZOrder = _globalZOrder;
            }
        };
    }), {} ],
    226: [ (function(require, module, exports) {
        var SceneGraphUtils = {
            removeSgNode: function() {
                var node = this._sgNode;
                if (node) {
                    var parent = node._parent;
                    parent && parent.removeChild(node);
                    node.release();
                    this._sgNode._entity && (this._sgNode._entity = null);
                }
            }
        };
        SceneGraphUtils._getChildrenOffset = function(entityParent) {
            if (entityParent) {
                var sgParent = entityParent._sgNode;
                var firstChildEntity = entityParent._children[0];
                if (firstChildEntity) {
                    var firstChildSg = firstChildEntity._sgNode;
                    var offset = sgParent._children.indexOf(firstChildSg);
                    if (offset !== -1) {
                        return offset;
                    }
                    cc.errorID(3510, firstChildEntity.name);
                    return -1;
                }
                return sgParent._children.length;
            }
            return 0;
        };
        SceneGraphUtils.checkMatchCurrentScene = function() {
            var scene = cc.director.getScene();
            var sgScene = cc.director.getRunningScene();
            function checkMatch(ent, sgNode) {
                if (ent._sgNode !== sgNode) {
                    throw new Error("scene graph node not equal: " + ent.name);
                }
                var childCount = ent._children.length;
                var childrenOffset = SceneGraphUtils._getChildrenOffset(ent);
                if (sgNode._children.length !== childCount + childrenOffset) {
                    throw new Error("Mismatched child scene graphs: " + ent.name);
                }
                for (var i = 0; i < childCount; i++) {
                    checkMatch(ent._children[i], sgNode._children[childrenOffset + i]);
                }
            }
            checkMatch(scene, sgScene);
        };
        cc._Test.SceneGraphUtils = SceneGraphUtils;
        module.exports = SceneGraphUtils;
    }), {} ],
    227: [ (function(require, module, exports) {
        cc.AffineTransform = function(a, b, c, d, tx, ty) {
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
        };
        cc.affineTransformMake = function(a, b, c, d, tx, ty) {
            return {
                a: a,
                b: b,
                c: c,
                d: d,
                tx: tx,
                ty: ty
            };
        };
        cc.affineTransformClone = function(t) {
            return {
                a: t.a,
                b: t.b,
                c: t.c,
                d: t.d,
                tx: t.tx,
                ty: t.ty
            };
        };
        cc.pointApplyAffineTransform = function(point, transOrY, t) {
            var x, y;
            if (void 0 === t) {
                t = transOrY;
                x = point.x;
                y = point.y;
            } else {
                x = point;
                y = transOrY;
            }
            return {
                x: t.a * x + t.c * y + t.tx,
                y: t.b * x + t.d * y + t.ty
            };
        };
        cc._pointApplyAffineTransformIn = function(point, transOrY, transOrOut, out) {
            var x, y, t;
            if (void 0 === out) {
                t = transOrY;
                x = point.x;
                y = point.y;
                out = transOrOut;
            } else {
                x = point;
                y = transOrY;
                t = transOrOut;
            }
            out.x = t.a * x + t.c * y + t.tx;
            out.y = t.b * x + t.d * y + t.ty;
        };
        cc._pointApplyAffineTransform = function(x, y, t) {
            return cc.pointApplyAffineTransform(x, y, t);
        };
        cc.sizeApplyAffineTransform = function(size, t) {
            return {
                width: t.a * size.width + t.c * size.height,
                height: t.b * size.width + t.d * size.height
            };
        };
        cc.affineTransformMakeIdentity = function() {
            return {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                tx: 0,
                ty: 0
            };
        };
        cc.affineTransformIdentity = function() {
            return {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                tx: 0,
                ty: 0
            };
        };
        cc.rectApplyAffineTransform = function(rect, t) {
            var ol = rect.x;
            var ob = rect.y;
            var or = ol + rect.width;
            var ot = ob + rect.height;
            var lbx = t.a * ol + t.c * ob + t.tx;
            var lby = t.b * ol + t.d * ob + t.ty;
            var rbx = t.a * or + t.c * ob + t.tx;
            var rby = t.b * or + t.d * ob + t.ty;
            var ltx = t.a * ol + t.c * ot + t.tx;
            var lty = t.b * ol + t.d * ot + t.ty;
            var rtx = t.a * or + t.c * ot + t.tx;
            var rty = t.b * or + t.d * ot + t.ty;
            var minX = Math.min(lbx, rbx, ltx, rtx);
            var maxX = Math.max(lbx, rbx, ltx, rtx);
            var minY = Math.min(lby, rby, lty, rty);
            var maxY = Math.max(lby, rby, lty, rty);
            return cc.rect(minX, minY, maxX - minX, maxY - minY);
        };
        cc._rectApplyAffineTransformIn = function(rect, t) {
            var ol = rect.x;
            var ob = rect.y;
            var or = ol + rect.width;
            var ot = ob + rect.height;
            var lbx = t.a * ol + t.c * ob + t.tx;
            var lby = t.b * ol + t.d * ob + t.ty;
            var rbx = t.a * or + t.c * ob + t.tx;
            var rby = t.b * or + t.d * ob + t.ty;
            var ltx = t.a * ol + t.c * ot + t.tx;
            var lty = t.b * ol + t.d * ot + t.ty;
            var rtx = t.a * or + t.c * ot + t.tx;
            var rty = t.b * or + t.d * ot + t.ty;
            var minX = Math.min(lbx, rbx, ltx, rtx);
            var maxX = Math.max(lbx, rbx, ltx, rtx);
            var minY = Math.min(lby, rby, lty, rty);
            var maxY = Math.max(lby, rby, lty, rty);
            rect.x = minX;
            rect.y = minY;
            rect.width = maxX - minX;
            rect.height = maxY - minY;
            return rect;
        };
        cc.obbApplyAffineTransform = function(rect, anAffineTransform, out_bl, out_tl, out_tr, out_br) {
            var x = rect.x;
            var y = rect.y;
            var width = rect.width;
            var height = rect.height;
            var tx = anAffineTransform.a * x + anAffineTransform.c * y + anAffineTransform.tx;
            var ty = anAffineTransform.b * x + anAffineTransform.d * y + anAffineTransform.ty;
            var xa = anAffineTransform.a * width;
            var xb = anAffineTransform.b * width;
            var yc = anAffineTransform.c * height;
            var yd = anAffineTransform.d * height;
            out_tl.x = tx;
            out_tl.y = ty;
            out_tr.x = xa + tx;
            out_tr.y = xb + ty;
            out_bl.x = yc + tx;
            out_bl.y = yd + ty;
            out_br.x = xa + yc + tx;
            out_br.y = xb + yd + ty;
        };
        cc.affineTransformTranslate = function(t, tx, ty) {
            return {
                a: t.a,
                b: t.b,
                c: t.c,
                d: t.d,
                tx: t.tx + t.a * tx + t.c * ty,
                ty: t.ty + t.b * tx + t.d * ty
            };
        };
        cc.affineTransformScale = function(t, sx, sy) {
            return {
                a: t.a * sx,
                b: t.b * sx,
                c: t.c * sy,
                d: t.d * sy,
                tx: t.tx,
                ty: t.ty
            };
        };
        cc.affineTransformRotate = function(aTransform, anAngle) {
            var fSin = Math.sin(anAngle);
            var fCos = Math.cos(anAngle);
            return {
                a: aTransform.a * fCos + aTransform.c * fSin,
                b: aTransform.b * fCos + aTransform.d * fSin,
                c: aTransform.c * fCos - aTransform.a * fSin,
                d: aTransform.d * fCos - aTransform.b * fSin,
                tx: aTransform.tx,
                ty: aTransform.ty
            };
        };
        cc.affineTransformConcat = function(t1, t2) {
            return {
                a: t1.a * t2.a + t1.b * t2.c,
                b: t1.a * t2.b + t1.b * t2.d,
                c: t1.c * t2.a + t1.d * t2.c,
                d: t1.c * t2.b + t1.d * t2.d,
                tx: t1.tx * t2.a + t1.ty * t2.c + t2.tx,
                ty: t1.tx * t2.b + t1.ty * t2.d + t2.ty
            };
        };
        cc.affineTransformConcatIn = function(t1, t2) {
            var a = t1.a, b = t1.b, c = t1.c, d = t1.d, tx = t1.tx, ty = t1.ty;
            t1.a = a * t2.a + b * t2.c;
            t1.b = a * t2.b + b * t2.d;
            t1.c = c * t2.a + d * t2.c;
            t1.d = c * t2.b + d * t2.d;
            t1.tx = tx * t2.a + ty * t2.c + t2.tx;
            t1.ty = tx * t2.b + ty * t2.d + t2.ty;
            return t1;
        };
        cc.affineTransformEqualToTransform = function(t1, t2) {
            return t1.a === t2.a && t1.b === t2.b && t1.c === t2.c && t1.d === t2.d && t1.tx === t2.tx && t1.ty === t2.ty;
        };
        cc.affineTransformInvert = function(t) {
            var determinant = 1 / (t.a * t.d - t.b * t.c);
            return {
                a: determinant * t.d,
                b: -determinant * t.b,
                c: -determinant * t.c,
                d: determinant * t.a,
                tx: determinant * (t.c * t.ty - t.d * t.tx),
                ty: determinant * (t.b * t.tx - t.a * t.ty)
            };
        };
        cc.affineTransformInvertOut = function(t, out) {
            var a = t.a, b = t.b, c = t.c, d = t.d;
            var determinant = 1 / (a * d - b * c);
            out.a = determinant * d;
            out.b = -determinant * b;
            out.c = -determinant * c;
            out.d = determinant * a;
            out.tx = determinant * (c * t.ty - d * t.tx);
            out.ty = determinant * (b * t.tx - a * t.ty);
        };
    }), {} ],
    228: [ (function(require, module, exports) {
        var ValueType = require("./CCValueType");
        var JS = require("../platform/js");
        var Color = (function() {
            function Color(r, g, b, a) {
                if ("object" === typeof r) {
                    g = r.g;
                    b = r.b;
                    a = r.a;
                    r = r.r;
                }
                r = r || 0;
                g = g || 0;
                b = b || 0;
                a = "number" === typeof a ? a : 255;
                this._val = (~~r << 24 >>> 0) + (~~g << 16) + (~~b << 8) + ~~a;
            }
            JS.extend(Color, ValueType);
            require("../platform/CCClass").fastDefine("cc.Color", Color, {
                r: 0,
                g: 0,
                b: 0,
                a: 255
            });
            var DefaultColors = {
                WHITE: [ 255, 255, 255, 255 ],
                BLACK: [ 0, 0, 0, 255 ],
                TRANSPARENT: [ 0, 0, 0, 0 ],
                GRAY: [ 127.5, 127.5, 127.5 ],
                RED: [ 255, 0, 0 ],
                GREEN: [ 0, 255, 0 ],
                BLUE: [ 0, 0, 255 ],
                YELLOW: [ 255, 235, 4 ],
                ORANGE: [ 255, 127, 0 ],
                CYAN: [ 0, 255, 255 ],
                MAGENTA: [ 255, 0, 255 ]
            };
            for (var colorName in DefaultColors) {
                JS.get(Color, colorName, (function(rgba) {
                    return function() {
                        return new Color(rgba[0], rgba[1], rgba[2], rgba[3]);
                    };
                })(DefaultColors[colorName]));
            }
            var proto = Color.prototype;
            proto.clone = function() {
                var ret = new Color();
                ret._val = this._val;
                return ret;
            };
            proto.equals = function(other) {
                return other && this._val === other._val;
            };
            proto.lerp = function(to, ratio, out) {
                out = out || new Color();
                var r = this.r;
                var g = this.g;
                var b = this.b;
                var a = this.a;
                out.r = r + (to.r - r) * ratio;
                out.g = g + (to.g - g) * ratio;
                out.b = b + (to.b - b) * ratio;
                out.a = a + (to.a - a) * ratio;
                return out;
            };
            proto.toString = function() {
                return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")";
            };
            proto.getR = function() {
                return (4278190080 & this._val) >>> 24;
            };
            proto.setR = function(red) {
                this._val = (16777215 & this._val | ~~red << 24 >>> 0) >>> 0;
                return this;
            };
            proto.getG = function() {
                return (16711680 & this._val) >> 16;
            };
            proto.setG = function(green) {
                this._val = (4278255615 & this._val | ~~green << 16) >>> 0;
                return this;
            };
            proto.getB = function() {
                return (65280 & this._val) >> 8;
            };
            proto.setB = function(blue) {
                this._val = (4294902015 & this._val | ~~blue << 8) >>> 0;
                return this;
            };
            proto.getA = function() {
                return 255 & this._val;
            };
            proto.setA = function(alpha) {
                this._val = (4294967040 & this._val | ~~alpha) >>> 0;
                return this;
            };
            JS.getset(proto, "r", proto.getR, proto.setR, true);
            JS.getset(proto, "g", proto.getG, proto.setG, true);
            JS.getset(proto, "b", proto.getB, proto.setB, true);
            JS.getset(proto, "a", proto.getA, proto.setA, true);
            proto.toCSS = function(opt) {
                return "rgba" === opt ? "rgba(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + "," + (this.a / 255).toFixed(2) + ")" : "rgb" === opt ? "rgb(" + (0 | this.r) + "," + (0 | this.g) + "," + (0 | this.b) + ")" : "#" + this.toHEX(opt);
            };
            proto.clamp = function() {
                return;
            };
            proto.fromHEX = function(hexString) {
                hexString.length < 8 && (hexString += "FF");
                var hex = parseInt(hexString.indexOf("#") > -1 ? hexString.substring(1) : hexString, 16);
                this._val = (4278190080 & this._val | hex) >>> 0;
                return this;
            };
            proto.toHEX = function(fmt) {
                var hex = [ (0 | this.r).toString(16), (0 | this.g).toString(16), (0 | this.b).toString(16) ];
                var i = -1;
                if ("#rgb" === fmt) {
                    for (i = 0; i < hex.length; ++i) {
                        hex[i].length > 1 && (hex[i] = hex[i][0]);
                    }
                } else {
                    if ("#rrggbb" === fmt) {
                        for (i = 0; i < hex.length; ++i) {
                            1 === hex[i].length && (hex[i] = "0" + hex[i]);
                        }
                    }
                }
                return hex.join("");
            };
            proto.toRGBValue = function() {
                return 16777215 & this._val;
            };
            proto.fromHSV = function(h, s, v) {
                var rgb = Color.hsv2rgb(h, s, v);
                this._val = (rgb.r << 24 >>> 0) + (rgb.g << 16) + (rgb.b << 8) + this.a;
                return this;
            };
            proto.toHSV = function() {
                return Color.rgb2hsv(this.r, this.g, this.b);
            };
            proto.fromColor = function(color) {
                if (color._val) {
                    this._val = color._val;
                } else {
                    this.r = color.r;
                    this.g = color.g;
                    this.b = color.b;
                    this.a = color.a;
                }
            };
            return Color;
        })();
        Color.rgb2hsv = function(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;
            var hsv = {
                h: 0,
                s: 0,
                v: 0
            };
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var delta = 0;
            hsv.v = max;
            hsv.s = max ? (max - min) / max : 0;
            if (hsv.s) {
                delta = max - min;
                r === max ? hsv.h = (g - b) / delta : g === max ? hsv.h = 2 + (b - r) / delta : hsv.h = 4 + (r - g) / delta;
                hsv.h /= 6;
                hsv.h < 0 && (hsv.h += 1);
            } else {
                hsv.h = 0;
            }
            return hsv;
        };
        Color.hsv2rgb = function(h, s, v) {
            var rgb = {
                r: 0,
                g: 0,
                b: 0
            };
            if (0 === s) {
                rgb.r = rgb.g = rgb.b = v;
            } else {
                if (0 === v) {
                    rgb.r = rgb.g = rgb.b = 0;
                } else {
                    1 === h && (h = 0);
                    h *= 6;
                    s = s;
                    v = v;
                    var i = Math.floor(h);
                    var f = h - i;
                    var p = v * (1 - s);
                    var q = v * (1 - s * f);
                    var t = v * (1 - s * (1 - f));
                    switch (i) {
                      case 0:
                        rgb.r = v;
                        rgb.g = t;
                        rgb.b = p;
                        break;

                      case 1:
                        rgb.r = q;
                        rgb.g = v;
                        rgb.b = p;
                        break;

                      case 2:
                        rgb.r = p;
                        rgb.g = v;
                        rgb.b = t;
                        break;

                      case 3:
                        rgb.r = p;
                        rgb.g = q;
                        rgb.b = v;
                        break;

                      case 4:
                        rgb.r = t;
                        rgb.g = p;
                        rgb.b = v;
                        break;

                      case 5:
                        rgb.r = v;
                        rgb.g = p;
                        rgb.b = q;
                    }
                }
            }
            rgb.r *= 255;
            rgb.g *= 255;
            rgb.b *= 255;
            return rgb;
        };
        cc.Color = Color;
        cc.color = function color(r, g, b, a) {
            if ("string" === typeof r) {
                var result = new cc.Color();
                return result.fromHEX(r);
            }
            if ("object" === typeof r) {
                return new cc.Color(r.r, r.g, r.b, r.a);
            }
            return new cc.Color(r, g, b, a);
        };
        cc.colorEqual = function(color1, color2) {
            return void 0 !== color1._val && void 0 !== color2._val ? color1._val === color2._val : color1.r === color2.r && color1.g === color2.g && color1.b === color2.b;
        };
        cc.hexToColor = function(hex) {
            hex = hex.replace(/^#?/, "0x");
            var c = parseInt(hex);
            var r = c >> 16;
            var g = (65280 & c) >> 8;
            var b = 255 & c;
            return cc.color(r, g, b);
        };
        cc.colorToHex = function(color) {
            var hR = color.r.toString(16), hG = color.g.toString(16), hB = color.b.toString(16);
            return "#" + (color.r < 16 ? "0" + hR : hR) + (color.g < 16 ? "0" + hG : hG) + (color.b < 16 ? "0" + hB : hB);
        };
        module.exports = cc.Color;
    }), {
        "../platform/CCClass": 173,
        "../platform/js": 193,
        "./CCValueType": 234
    } ],
    229: [ (function(require, module, exports) {
        var POINT_EPSILON = parseFloat("1.192092896e-07F");
        cc.pNeg = function(point) {
            return cc.p(-point.x, -point.y);
        };
        cc.pAdd = function(v1, v2) {
            return cc.p(v1.x + v2.x, v1.y + v2.y);
        };
        cc.pSub = function(v1, v2) {
            return cc.p(v1.x - v2.x, v1.y - v2.y);
        };
        cc.pMult = function(point, floatVar) {
            return cc.p(point.x * floatVar, point.y * floatVar);
        };
        cc.pMidpoint = function(v1, v2) {
            return cc.pMult(cc.pAdd(v1, v2), .5);
        };
        cc.pDot = function(v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        };
        cc.pCross = function(v1, v2) {
            return v1.x * v2.y - v1.y * v2.x;
        };
        cc.pPerp = function(point) {
            return cc.p(-point.y, point.x);
        };
        cc.pRPerp = function(point) {
            return cc.p(point.y, -point.x);
        };
        cc.pProject = function(v1, v2) {
            return cc.pMult(v2, cc.pDot(v1, v2) / cc.pDot(v2, v2));
        };
        cc.pLengthSQ = function(v) {
            return cc.pDot(v, v);
        };
        cc.pDistanceSQ = function(point1, point2) {
            return cc.pLengthSQ(cc.pSub(point1, point2));
        };
        cc.pLength = function(v) {
            return Math.sqrt(cc.pLengthSQ(v));
        };
        cc.pDistance = function(v1, v2) {
            return cc.pLength(cc.pSub(v1, v2));
        };
        cc.pNormalize = function(v) {
            var n = cc.pLength(v);
            return 0 === n ? cc.p(v) : cc.pMult(v, 1 / n);
        };
        cc.pForAngle = function(a) {
            return cc.p(Math.cos(a), Math.sin(a));
        };
        cc.pToAngle = function(v) {
            return Math.atan2(v.y, v.x);
        };
        cc.clampf = function(value, min_inclusive, max_inclusive) {
            if (min_inclusive > max_inclusive) {
                var temp = min_inclusive;
                min_inclusive = max_inclusive;
                max_inclusive = temp;
            }
            return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
        };
        cc.clamp01 = function(value) {
            return value < 0 ? 0 : value < 1 ? value : 1;
        };
        cc.pClamp = function(p, min_inclusive, max_inclusive) {
            return cc.p(cc.clampf(p.x, min_inclusive.x, max_inclusive.x), cc.clampf(p.y, min_inclusive.y, max_inclusive.y));
        };
        cc.pFromSize = function(s) {
            return cc.p(s.width, s.height);
        };
        cc.pCompOp = function(p, opFunc) {
            return cc.p(opFunc(p.x), opFunc(p.y));
        };
        cc.pLerp = function(a, b, alpha) {
            return cc.pAdd(cc.pMult(a, 1 - alpha), cc.pMult(b, alpha));
        };
        cc.pFuzzyEqual = function(a, b, variance) {
            if (a.x - variance <= b.x && b.x <= a.x + variance && a.y - variance <= b.y && b.y <= a.y + variance) {
                return true;
            }
            return false;
        };
        cc.pCompMult = function(a, b) {
            return cc.p(a.x * b.x, a.y * b.y);
        };
        cc.pAngleSigned = function(a, b) {
            var a2 = cc.pNormalize(a);
            var b2 = cc.pNormalize(b);
            var angle = Math.atan2(a2.x * b2.y - a2.y * b2.x, cc.pDot(a2, b2));
            if (Math.abs(angle) < POINT_EPSILON) {
                return 0;
            }
            return angle;
        };
        cc.pAngle = function(a, b) {
            var angle = Math.acos(cc.pDot(cc.pNormalize(a), cc.pNormalize(b)));
            if (Math.abs(angle) < POINT_EPSILON) {
                return 0;
            }
            return angle;
        };
        cc.pRotateByAngle = function(v, pivot, angle) {
            var r = cc.pSub(v, pivot);
            var cosa = Math.cos(angle), sina = Math.sin(angle);
            var t = r.x;
            r.x = t * cosa - r.y * sina + pivot.x;
            r.y = t * sina + r.y * cosa + pivot.y;
            return r;
        };
        cc.pLineIntersect = function(A, B, C, D, retP) {
            if (A.x === B.x && A.y === B.y || C.x === D.x && C.y === D.y) {
                return false;
            }
            var BAx = B.x - A.x;
            var BAy = B.y - A.y;
            var DCx = D.x - C.x;
            var DCy = D.y - C.y;
            var ACx = A.x - C.x;
            var ACy = A.y - C.y;
            var denom = DCy * BAx - DCx * BAy;
            retP.x = DCx * ACy - DCy * ACx;
            retP.y = BAx * ACy - BAy * ACx;
            if (0 === denom) {
                if (0 === retP.x || 0 === retP.y) {
                    return true;
                }
                return false;
            }
            retP.x = retP.x / denom;
            retP.y = retP.y / denom;
            return true;
        };
        cc.pSegmentIntersect = function(A, B, C, D) {
            var retP = cc.p(0, 0);
            if (cc.pLineIntersect(A, B, C, D, retP) && retP.x >= 0 && retP.x <= 1 && retP.y >= 0 && retP.y <= 1) {
                return true;
            }
            return false;
        };
        cc.pIntersectPoint = function(A, B, C, D) {
            var retP = cc.p(0, 0);
            if (cc.pLineIntersect(A, B, C, D, retP)) {
                var P = cc.p(0, 0);
                P.x = A.x + retP.x * (B.x - A.x);
                P.y = A.y + retP.x * (B.y - A.y);
                return P;
            }
            return cc.p(0, 0);
        };
        cc.pSameAs = function(A, B) {
            if (null != A && null != B) {
                return A.x === B.x && A.y === B.y;
            }
            return false;
        };
        cc.pZeroIn = function(v) {
            v.x = 0;
            v.y = 0;
        };
        cc.pIn = function(v1, v2) {
            v1.x = v2.x;
            v1.y = v2.y;
        };
        cc.pMultIn = function(point, floatVar) {
            point.x *= floatVar;
            point.y *= floatVar;
        };
        cc.pSubIn = function(v1, v2) {
            v1.x -= v2.x;
            v1.y -= v2.y;
        };
        cc.pAddIn = function(v1, v2) {
            v1.x += v2.x;
            v1.y += v2.y;
        };
        cc.pNormalizeIn = function(v) {
            cc.pMultIn(v, 1 / Math.sqrt(v.x * v.x + v.y * v.y));
        };
    }), {} ],
    230: [ (function(require, module, exports) {
        var ValueType = require("./CCValueType");
        var JS = require("../platform/js");
        function Rect(x, y, w, h) {
            if (x && "object" === typeof x) {
                y = x.y;
                w = x.width;
                h = x.height;
                x = x.x;
            }
            this.x = x || 0;
            this.y = y || 0;
            this.width = w || 0;
            this.height = h || 0;
        }
        JS.extend(Rect, ValueType);
        require("../platform/CCClass").fastDefine("cc.Rect", Rect, {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        });
        Rect.fromMinMax = function(v1, v2) {
            var min_x = Math.min(v1.x, v2.x);
            var min_y = Math.min(v1.y, v2.y);
            var max_x = Math.max(v1.x, v2.x);
            var max_y = Math.max(v1.y, v2.y);
            return new Rect(min_x, min_y, max_x - min_x, max_y - min_y);
        };
        Rect.contain = function _Contain(a, b) {
            if (a.x < b.x && a.x + a.width > b.x + b.width && a.y < b.y && a.y + a.height > b.y + b.height) {
                return 1;
            }
            if (b.x < a.x && b.x + b.width > a.x + a.width && b.y < a.y && b.y + b.height > a.y + a.height) {
                return -1;
            }
            return 0;
        };
        var proto = Rect.prototype;
        proto.clone = function() {
            return new Rect(this.x, this.y, this.width, this.height);
        };
        proto.equals = function(other) {
            return other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
        };
        proto.lerp = function(to, ratio, out) {
            out = out || new Rect();
            var x = this.x;
            var y = this.y;
            var width = this.width;
            var height = this.height;
            out.x = x + (to.x - x) * ratio;
            out.y = y + (to.y - y) * ratio;
            out.width = width + (to.width - width) * ratio;
            out.height = height + (to.height - height) * ratio;
            return out;
        };
        proto.toString = function() {
            return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
        };
        JS.getset(proto, "xMin", (function() {
            return this.x;
        }), (function(value) {
            this.width += this.x - value;
            this.x = value;
        }));
        JS.getset(proto, "yMin", (function() {
            return this.y;
        }), (function(value) {
            this.height += this.y - value;
            this.y = value;
        }));
        JS.getset(proto, "xMax", (function() {
            return this.x + this.width;
        }), (function(value) {
            this.width = value - this.x;
        }));
        JS.getset(proto, "yMax", (function() {
            return this.y + this.height;
        }), (function(value) {
            this.height = value - this.y;
        }));
        JS.getset(proto, "center", (function() {
            return new cc.Vec2(this.x + .5 * this.width, this.y + .5 * this.height);
        }), (function(value) {
            this.x = value.x - .5 * this.width;
            this.y = value.y - .5 * this.height;
        }));
        JS.getset(proto, "origin", (function() {
            return new cc.Vec2(this.x, this.y);
        }), (function(value) {
            this.x = value.x;
            this.y = value.y;
        }));
        JS.getset(proto, "size", (function() {
            return new cc.Size(this.width, this.height);
        }), (function(value) {
            this.width = value.width;
            this.height = value.height;
        }));
        proto.intersects = function(rect) {
            return cc.rectIntersectsRect(this, rect);
        };
        proto.contains = function(point) {
            return this.x < point.x && this.x + this.width > point.x && this.y < point.y && this.y + this.height > point.y;
        };
        proto.containsRect = function(rect) {
            return this.x < rect.x && this.x + this.width > rect.x + rect.width && this.y < rect.y && this.y + this.height > rect.y + rect.height;
        };
        cc.Rect = Rect;
        cc.rect = function rect(x, y, w, h) {
            return new Rect(x, y, w, h);
        };
        cc.rectEqualToRect = function(rect1, rect2) {
            return rect1 && rect2 && rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
        };
        cc._rectEqualToZero = function(rect) {
            return rect && 0 === rect.x && 0 === rect.y && 0 === rect.width && 0 === rect.height;
        };
        cc.rectContainsRect = function(rect1, rect2) {
            if (!rect1 || !rect2) {
                return false;
            }
            return !(rect1.x >= rect2.x || rect1.y >= rect2.y || rect1.x + rect1.width <= rect2.x + rect2.width || rect1.y + rect1.height <= rect2.y + rect2.height);
        };
        cc.rectGetMaxX = function(rect) {
            return rect.x + rect.width;
        };
        cc.rectGetMidX = function(rect) {
            return rect.x + rect.width / 2;
        };
        cc.rectGetMinX = function(rect) {
            return rect.x;
        };
        cc.rectGetMaxY = function(rect) {
            return rect.y + rect.height;
        };
        cc.rectGetMidY = function(rect) {
            return rect.y + rect.height / 2;
        };
        cc.rectGetMinY = function(rect) {
            return rect.y;
        };
        cc.rectContainsPoint = function(rect, point) {
            return point.x >= cc.rectGetMinX(rect) && point.x <= cc.rectGetMaxX(rect) && point.y >= cc.rectGetMinY(rect) && point.y <= cc.rectGetMaxY(rect);
        };
        cc.rectIntersectsRect = function(ra, rb) {
            var maxax = ra.x + ra.width, maxay = ra.y + ra.height, maxbx = rb.x + rb.width, maxby = rb.y + rb.height;
            return !(maxax < rb.x || maxbx < ra.x || maxay < rb.y || maxby < ra.y);
        };
        cc.rectOverlapsRect = function(rectA, rectB) {
            return !(rectA.x + rectA.width < rectB.x || rectB.x + rectB.width < rectA.x || rectA.y + rectA.height < rectB.y || rectB.y + rectB.height < rectA.y);
        };
        cc.rectUnion = function(rectA, rectB) {
            var rect = cc.rect(0, 0, 0, 0);
            rect.x = Math.min(rectA.x, rectB.x);
            rect.y = Math.min(rectA.y, rectB.y);
            rect.width = Math.max(rectA.x + rectA.width, rectB.x + rectB.width) - rect.x;
            rect.height = Math.max(rectA.y + rectA.height, rectB.y + rectB.height) - rect.y;
            return rect;
        };
        cc.rectIntersection = function(rectA, rectB) {
            var intersection = cc.rect(Math.max(cc.rectGetMinX(rectA), cc.rectGetMinX(rectB)), Math.max(cc.rectGetMinY(rectA), cc.rectGetMinY(rectB)), 0, 0);
            intersection.width = Math.min(cc.rectGetMaxX(rectA), cc.rectGetMaxX(rectB)) - cc.rectGetMinX(intersection);
            intersection.height = Math.min(cc.rectGetMaxY(rectA), cc.rectGetMaxY(rectB)) - cc.rectGetMinY(intersection);
            return intersection;
        };
        module.exports = cc.Rect;
    }), {
        "../platform/CCClass": 173,
        "../platform/js": 193,
        "./CCValueType": 234
    } ],
    231: [ (function(require, module, exports) {
        var ValueType = require("./CCValueType");
        var JS = require("../platform/js");
        function Size(width, height) {
            if (width && "object" === typeof width) {
                height = width.height;
                width = width.width;
            }
            this.width = width || 0;
            this.height = height || 0;
        }
        JS.extend(Size, ValueType);
        require("../platform/CCClass").fastDefine("cc.Size", Size, {
            width: 0,
            height: 0
        });
        JS.get(Size, "ZERO", (function() {
            return new Size(0, 0);
        }));
        var proto = Size.prototype;
        proto.clone = function() {
            return new Size(this.width, this.height);
        };
        proto.equals = function(other) {
            return other && this.width === other.width && this.height === other.height;
        };
        proto.lerp = function(to, ratio, out) {
            out = out || new Size();
            var width = this.width;
            var height = this.height;
            out.width = width + (to.width - width) * ratio;
            out.height = height + (to.height - height) * ratio;
            return out;
        };
        proto.toString = function() {
            return "(" + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
        };
        cc.size = function(w, h) {
            return new Size(w, h);
        };
        cc.sizeEqualToSize = function(size1, size2) {
            return size1 && size2 && size1.width === size2.width && size1.height === size2.height;
        };
        cc.Size = module.exports = Size;
    }), {
        "../platform/CCClass": 173,
        "../platform/js": 193,
        "./CCValueType": 234
    } ],
    232: [ (function(require, module, exports) {
        cc.Acceleration = function(x, y, z, timestamp) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.timestamp = timestamp || 0;
        };
        cc.BlendFunc = function(src1, dst1) {
            this.src = src1;
            this.dst = dst1;
        };
        var BlendFactor = cc.Enum({
            ONE: 1,
            ZERO: 0,
            SRC_ALPHA: 770,
            SRC_COLOR: 768,
            DST_ALPHA: 772,
            DST_COLOR: 774,
            ONE_MINUS_SRC_ALPHA: 771,
            ONE_MINUS_SRC_COLOR: 769,
            ONE_MINUS_DST_ALPHA: 773,
            ONE_MINUS_DST_COLOR: 775
        });
        cc.BlendFunc._disable = function() {
            return new cc.BlendFunc(BlendFactor.ONE, BlendFactor.ZERO);
        };
        cc.BlendFunc._alphaPremultiplied = function() {
            return new cc.BlendFunc(BlendFactor.ONE, BlendFactor.ONE_MINUS_SRC_ALPHA);
        };
        cc.BlendFunc._alphaNonPremultiplied = function() {
            return new cc.BlendFunc(BlendFactor.SRC_ALPHA, BlendFactor.ONE_MINUS_SRC_ALPHA);
        };
        cc.BlendFunc._additive = function() {
            return new cc.BlendFunc(BlendFactor.SRC_ALPHA, BlendFactor.ONE);
        };
        cc.BlendFunc.BlendFactor = BlendFactor;
        cc.BlendFunc.DISABLE;
        cc.js.get(cc.BlendFunc, "DISABLE", cc.BlendFunc._disable);
        cc.BlendFunc.ALPHA_PREMULTIPLIED;
        cc.js.get(cc.BlendFunc, "ALPHA_PREMULTIPLIED", cc.BlendFunc._alphaPremultiplied);
        cc.BlendFunc.ALPHA_NON_PREMULTIPLIED;
        cc.js.get(cc.BlendFunc, "ALPHA_NON_PREMULTIPLIED", cc.BlendFunc._alphaNonPremultiplied);
        cc.BlendFunc.ADDITIVE;
        cc.js.get(cc.BlendFunc, "ADDITIVE", cc.BlendFunc._additive);
        cc.blendFuncDisable = cc.BlendFunc._disable;
        cc.FontDefinition = function(properties) {
            var _t = this;
            _t.fontName = "Arial";
            _t.fontSize = 12;
            _t.textAlign = cc.TextAlignment.CENTER;
            _t.verticalAlign = cc.VerticalTextAlignment.TOP;
            _t.fillStyle = cc.color(255, 255, 255, 255);
            _t.boundingWidth = 0;
            _t.boundingHeight = 0;
            _t.strokeEnabled = false;
            _t.strokeStyle = cc.color(255, 255, 255, 255);
            _t.lineWidth = 1;
            _t.lineHeight = "normal";
            _t.fontStyle = "normal";
            _t.fontWeight = "normal";
            _t.shadowEnabled = false;
            _t.shadowOffsetX = 0;
            _t.shadowOffsetY = 0;
            _t.shadowBlur = 0;
            _t.shadowOpacity = 1;
            if (properties && properties instanceof Object) {
                for (var key in properties) {
                    _t[key] = properties[key];
                }
            }
        };
        cc.FontDefinition.prototype._getCanvasFontStr = function() {
            var lineHeight = this.lineHeight.charAt ? this.lineHeight : this.lineHeight + "px";
            return this.fontStyle + " " + this.fontWeight + " " + this.fontSize + "px/" + lineHeight + " '" + this.fontName + "'";
        };
        cc.TextAlignment = cc.Enum({
            LEFT: 0,
            CENTER: 1,
            RIGHT: 2
        });
        cc.VerticalTextAlignment = cc.Enum({
            TOP: 0,
            CENTER: 1,
            BOTTOM: 2
        });
        cc._Dictionary = cc.Class({
            ctor: function() {
                this._keyMapTb = {};
                this._valueMapTb = {};
                this.__currId = 2 << (0 | 10 * Math.random());
            },
            __getKey: function() {
                this.__currId++;
                return "key_" + this.__currId;
            },
            setObject: function(value, key) {
                if (null == key) {
                    return;
                }
                var keyId = this.__getKey();
                this._keyMapTb[keyId] = key;
                this._valueMapTb[keyId] = value;
            },
            objectForKey: function(key) {
                if (null == key) {
                    return null;
                }
                var locKeyMapTb = this._keyMapTb;
                for (var keyId in locKeyMapTb) {
                    if (locKeyMapTb[keyId] === key) {
                        return this._valueMapTb[keyId];
                    }
                }
                return null;
            },
            valueForKey: function(key) {
                return this.objectForKey(key);
            },
            removeObjectForKey: function(key) {
                if (null == key) {
                    return;
                }
                var locKeyMapTb = this._keyMapTb;
                for (var keyId in locKeyMapTb) {
                    if (locKeyMapTb[keyId] === key) {
                        delete this._valueMapTb[keyId];
                        delete locKeyMapTb[keyId];
                        return;
                    }
                }
            },
            removeObjectsForKeys: function(keys) {
                if (null == keys) {
                    return;
                }
                for (var i = 0; i < keys.length; i++) {
                    this.removeObjectForKey(keys[i]);
                }
            },
            allKeys: function() {
                var keyArr = [], locKeyMapTb = this._keyMapTb;
                for (var key in locKeyMapTb) {
                    keyArr.push(locKeyMapTb[key]);
                }
                return keyArr;
            },
            removeAllObjects: function() {
                this._keyMapTb = {};
                this._valueMapTb = {};
            },
            count: function() {
                return this.allKeys().length;
            }
        });
    }), {} ],
    233: [ (function(require, module, exports) {
        cc.WebGLColor = function(r, g, b, a, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.WebGLColor.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locOffset = this._offset;
            this._view = new Uint8Array(locArrayBuffer, locOffset, 4);
            this._view[0] = r || 0;
            this._view[1] = g || 0;
            this._view[2] = b || 0;
            if ("number" === typeof a) {
                this._view[3] = a;
            } else {
                this._view[3] = 255;
                this.a_undefined = true;
            }
        };
        cc.WebGLColor.BYTES_PER_ELEMENT = 4;
        var _p = cc.WebGLColor.prototype;
        _p._getR = function() {
            return this._view[0];
        };
        _p._setR = function(value) {
            this._view[0] = value < 0 ? 0 : value;
        };
        _p._getG = function() {
            return this._view[1];
        };
        _p._setG = function(value) {
            this._view[1] = value < 0 ? 0 : value;
        };
        _p._getB = function() {
            return this._view[2];
        };
        _p._setB = function(value) {
            this._view[2] = value < 0 ? 0 : value;
        };
        _p._getA = function() {
            return this._view[3];
        };
        _p._setA = function(value) {
            this._view[3] = value < 0 ? 0 : value;
        };
        _p.r;
        cc.js.getset(_p, "r", _p._getR, _p._setR);
        _p.g;
        cc.js.getset(_p, "g", _p._getG, _p._setG);
        _p.b;
        cc.js.getset(_p, "b", _p._getB, _p._setB);
        _p.a;
        cc.js.getset(_p, "a", _p._getA, _p._setA);
        cc.Vertex2F = function(x, y, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Vertex2F.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            this._view = new Float32Array(this._arrayBuffer, this._offset, 2);
            this._view[0] = x || 0;
            this._view[1] = y || 0;
        };
        cc.Vertex2F.BYTES_PER_ELEMENT = 8;
        var _p = cc.Vertex2F.prototype;
        _p._getX = function() {
            return this._view[0];
        };
        _p._setX = function(xValue) {
            this._view[0] = xValue;
        };
        _p._getY = function() {
            return this._view[1];
        };
        _p._setY = function(yValue) {
            this._view[1] = yValue;
        };
        cc.js.getset(_p, "x", _p._getX, _p._setX);
        cc.js.getset(_p, "y", _p._getY, _p._setY);
        cc.Vertex3F = function(x, y, z, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Vertex3F.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locOffset = this._offset;
            this._view = new Float32Array(locArrayBuffer, locOffset, 3);
            this._view[0] = x || 0;
            this._view[1] = y || 0;
            this._view[2] = z || 0;
        };
        cc.Vertex3F.BYTES_PER_ELEMENT = 12;
        _p = cc.Vertex3F.prototype;
        _p._getX = function() {
            return this._view[0];
        };
        _p._setX = function(xValue) {
            this._view[0] = xValue;
        };
        _p._getY = function() {
            return this._view[1];
        };
        _p._setY = function(yValue) {
            this._view[1] = yValue;
        };
        _p._getZ = function() {
            return this._view[2];
        };
        _p._setZ = function(zValue) {
            this._view[2] = zValue;
        };
        cc.js.getset(_p, "x", _p._getX, _p._setX);
        cc.js.getset(_p, "y", _p._getY, _p._setY);
        cc.js.getset(_p, "z", _p._getZ, _p._setZ);
        cc.Tex2F = function(u, v, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Tex2F.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            this._view = new Float32Array(this._arrayBuffer, this._offset, 2);
            this._view[0] = u || 0;
            this._view[1] = v || 0;
        };
        cc.Tex2F.BYTES_PER_ELEMENT = 8;
        _p = cc.Tex2F.prototype;
        _p._getU = function() {
            return this._view[0];
        };
        _p._setU = function(xValue) {
            this._view[0] = xValue;
        };
        _p._getV = function() {
            return this._view[1];
        };
        _p._setV = function(yValue) {
            this._view[1] = yValue;
        };
        cc.js.getset(_p, "u", _p._getU, _p._setU);
        cc.js.getset(_p, "v", _p._getV, _p._setV);
        cc.Quad2 = function(tl, tr, bl, br, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Quad2.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locOffset = this._offset, locElementLen = cc.Vertex2F.BYTES_PER_ELEMENT;
            this._tl = tl ? new cc.Vertex2F(tl.x, tl.y, locArrayBuffer, locOffset) : new cc.Vertex2F(0, 0, locArrayBuffer, locOffset);
            locOffset += locElementLen;
            this._tr = tr ? new cc.Vertex2F(tr.x, tr.y, locArrayBuffer, locOffset) : new cc.Vertex2F(0, 0, locArrayBuffer, locOffset);
            locOffset += locElementLen;
            this._bl = bl ? new cc.Vertex2F(bl.x, bl.y, locArrayBuffer, locOffset) : new cc.Vertex2F(0, 0, locArrayBuffer, locOffset);
            locOffset += locElementLen;
            this._br = br ? new cc.Vertex2F(br.x, br.y, locArrayBuffer, locOffset) : new cc.Vertex2F(0, 0, locArrayBuffer, locOffset);
        };
        cc.Quad2.BYTES_PER_ELEMENT = 32;
        _p = cc.Quad2.prototype;
        _p._getTL = function() {
            return this._tl;
        };
        _p._setTL = function(tlValue) {
            this._tl._view[0] = tlValue.x;
            this._tl._view[1] = tlValue.y;
        };
        _p._getTR = function() {
            return this._tr;
        };
        _p._setTR = function(trValue) {
            this._tr._view[0] = trValue.x;
            this._tr._view[1] = trValue.y;
        };
        _p._getBL = function() {
            return this._bl;
        };
        _p._setBL = function(blValue) {
            this._bl._view[0] = blValue.x;
            this._bl._view[1] = blValue.y;
        };
        _p._getBR = function() {
            return this._br;
        };
        _p._setBR = function(brValue) {
            this._br._view[0] = brValue.x;
            this._br._view[1] = brValue.y;
        };
        cc.js.getset(_p, "tl", _p._getTL, _p._setTL);
        cc.js.getset(_p, "tr", _p._getTR, _p._setTR);
        cc.js.getset(_p, "bl", _p._getBL, _p._setBL);
        cc.js.getset(_p, "br", _p._getBR, _p._setBR);
        cc.Quad3 = function(bl1, br1, tl1, tr1, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.Quad3.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locOffset = this._offset, locElementLen = cc.Vertex3F.BYTES_PER_ELEMENT;
            this.bl = bl ? new cc.Vertex3F(bl.x, bl.y, bl.z, locArrayBuffer, locOffset) : new cc.Vertex3F(0, 0, 0, locArrayBuffer, locOffset);
            locOffset += locElementLen;
            this.br = br ? new cc.Vertex3F(br.x, br.y, br.z, locArrayBuffer, locOffset) : new cc.Vertex3F(0, 0, 0, locArrayBuffer, locOffset);
            locOffset += locElementLen;
            this.tl = tl ? new cc.Vertex3F(tl.x, tl.y, tl.z, locArrayBuffer, locOffset) : new cc.Vertex3F(0, 0, 0, locArrayBuffer, locOffset);
            locOffset += locElementLen;
            this.tr = tr ? new cc.Vertex3F(tr.x, tr.y, tr.z, locArrayBuffer, locOffset) : new cc.Vertex3F(0, 0, 0, locArrayBuffer, locOffset);
        };
        cc.Quad3.BYTES_PER_ELEMENT = 48;
        cc.V3F_C4B_T2F = function(vertices, colors, texCoords, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V3F_C4B_T2F.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locOffset = this._offset;
            this._vertices = vertices ? new cc.Vertex3F(vertices.x, vertices.y, vertices.z, locArrayBuffer, locOffset) : new cc.Vertex3F(0, 0, 0, locArrayBuffer, locOffset);
            locOffset += cc.Vertex3F.BYTES_PER_ELEMENT;
            this._colors = colors ? new cc.WebGLColor(colors.r, colors.g, colors.b, colors.a, locArrayBuffer, locOffset) : new cc.WebGLColor(0, 0, 0, 0, locArrayBuffer, locOffset);
            locOffset += cc.WebGLColor.BYTES_PER_ELEMENT;
            this._texCoords = texCoords ? new cc.Tex2F(texCoords.u, texCoords.v, locArrayBuffer, locOffset) : new cc.Tex2F(0, 0, locArrayBuffer, locOffset);
        };
        cc.V3F_C4B_T2F.BYTES_PER_ELEMENT = 24;
        _p = cc.V3F_C4B_T2F.prototype;
        _p._getVertices = function() {
            return this._vertices;
        };
        _p._setVertices = function(verticesValue) {
            var locVertices = this._vertices;
            locVertices._view[0] = verticesValue.x;
            locVertices._view[1] = verticesValue.y;
            locVertices._view[2] = verticesValue.z;
        };
        _p._getColor = function() {
            return this._colors;
        };
        _p._setColor = function(colorValue) {
            var locColors = this._colors;
            locColors._view[0] = colorValue.r;
            locColors._view[1] = colorValue.g;
            locColors._view[2] = colorValue.b;
            locColors._view[3] = colorValue.a;
        };
        _p._getTexCoords = function() {
            return this._texCoords;
        };
        _p._setTexCoords = function(texValue) {
            this._texCoords._view[0] = texValue.u;
            this._texCoords._view[1] = texValue.v;
        };
        cc.js.getset(_p, "vertices", _p._getVertices, _p._setVertices);
        cc.js.getset(_p, "colors", _p._getColor, _p._setColor);
        cc.js.getset(_p, "texCoords", _p._getTexCoords, _p._setTexCoords);
        cc.V3F_C4B_T2F_Quad = function(tl, bl, tr, br, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locOffset = this._offset, locElementLen = cc.V3F_C4B_T2F.BYTES_PER_ELEMENT;
            this._tl = tl ? new cc.V3F_C4B_T2F(tl.vertices, tl.colors, tl.texCoords, locArrayBuffer, locOffset) : new cc.V3F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
            locOffset += locElementLen;
            this._bl = bl ? new cc.V3F_C4B_T2F(bl.vertices, bl.colors, bl.texCoords, locArrayBuffer, locOffset) : new cc.V3F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
            locOffset += locElementLen;
            this._tr = tr ? new cc.V3F_C4B_T2F(tr.vertices, tr.colors, tr.texCoords, locArrayBuffer, locOffset) : new cc.V3F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
            locOffset += locElementLen;
            this._br = br ? new cc.V3F_C4B_T2F(br.vertices, br.colors, br.texCoords, locArrayBuffer, locOffset) : new cc.V3F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
        };
        cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT = 96;
        _p = cc.V3F_C4B_T2F_Quad.prototype;
        _p._getTL = function() {
            return this._tl;
        };
        _p._setTL = function(tlValue) {
            var locTl = this._tl;
            locTl.vertices = tlValue.vertices;
            locTl.colors = tlValue.colors;
            locTl.texCoords = tlValue.texCoords;
        };
        _p._getBL = function() {
            return this._bl;
        };
        _p._setBL = function(blValue) {
            var locBl = this._bl;
            locBl.vertices = blValue.vertices;
            locBl.colors = blValue.colors;
            locBl.texCoords = blValue.texCoords;
        };
        _p._getTR = function() {
            return this._tr;
        };
        _p._setTR = function(trValue) {
            var locTr = this._tr;
            locTr.vertices = trValue.vertices;
            locTr.colors = trValue.colors;
            locTr.texCoords = trValue.texCoords;
        };
        _p._getBR = function() {
            return this._br;
        };
        _p._setBR = function(brValue) {
            var locBr = this._br;
            locBr.vertices = brValue.vertices;
            locBr.colors = brValue.colors;
            locBr.texCoords = brValue.texCoords;
        };
        _p._getArrayBuffer = function() {
            return this._arrayBuffer;
        };
        cc.js.getset(_p, "tl", _p._getTL, _p._setTL);
        cc.js.getset(_p, "tr", _p._getTR, _p._setTR);
        cc.js.getset(_p, "bl", _p._getBL, _p._setBL);
        cc.js.getset(_p, "br", _p._getBR, _p._setBR);
        cc.js.get(_p, "arrayBuffer", _p._getArrayBuffer);
        cc.V3F_C4B_T2F_QuadZero = function() {
            return new cc.V3F_C4B_T2F_Quad();
        };
        cc.V3F_C4B_T2F_QuadCopy = function(sourceQuad) {
            if (!sourceQuad) {
                return cc.V3F_C4B_T2F_QuadZero();
            }
            var srcTL = sourceQuad.tl, srcBL = sourceQuad.bl, srcTR = sourceQuad.tr, srcBR = sourceQuad.br;
            return {
                tl: {
                    vertices: {
                        x: srcTL.vertices.x,
                        y: srcTL.vertices.y,
                        z: srcTL.vertices.z
                    },
                    colors: {
                        r: srcTL.colors.r,
                        g: srcTL.colors.g,
                        b: srcTL.colors.b,
                        a: srcTL.colors.a
                    },
                    texCoords: {
                        u: srcTL.texCoords.u,
                        v: srcTL.texCoords.v
                    }
                },
                bl: {
                    vertices: {
                        x: srcBL.vertices.x,
                        y: srcBL.vertices.y,
                        z: srcBL.vertices.z
                    },
                    colors: {
                        r: srcBL.colors.r,
                        g: srcBL.colors.g,
                        b: srcBL.colors.b,
                        a: srcBL.colors.a
                    },
                    texCoords: {
                        u: srcBL.texCoords.u,
                        v: srcBL.texCoords.v
                    }
                },
                tr: {
                    vertices: {
                        x: srcTR.vertices.x,
                        y: srcTR.vertices.y,
                        z: srcTR.vertices.z
                    },
                    colors: {
                        r: srcTR.colors.r,
                        g: srcTR.colors.g,
                        b: srcTR.colors.b,
                        a: srcTR.colors.a
                    },
                    texCoords: {
                        u: srcTR.texCoords.u,
                        v: srcTR.texCoords.v
                    }
                },
                br: {
                    vertices: {
                        x: srcBR.vertices.x,
                        y: srcBR.vertices.y,
                        z: srcBR.vertices.z
                    },
                    colors: {
                        r: srcBR.colors.r,
                        g: srcBR.colors.g,
                        b: srcBR.colors.b,
                        a: srcBR.colors.a
                    },
                    texCoords: {
                        u: srcBR.texCoords.u,
                        v: srcBR.texCoords.v
                    }
                }
            };
        };
        cc.V3F_C4B_T2F_QuadsCopy = function(sourceQuads) {
            if (!sourceQuads) {
                return [];
            }
            var retArr = [];
            for (var i = 0; i < sourceQuads.length; i++) {
                retArr.push(cc.V3F_C4B_T2F_QuadCopy(sourceQuads[i]));
            }
            return retArr;
        };
        cc.V2F_C4B_T2F = function(vertices, colors, texCoords, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V2F_C4B_T2F.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locOffset = this._offset;
            this._vertices = vertices ? new cc.Vertex2F(vertices.x, vertices.y, locArrayBuffer, locOffset) : new cc.Vertex2F(0, 0, locArrayBuffer, locOffset);
            locOffset += cc.Vertex2F.BYTES_PER_ELEMENT;
            this._colors = colors ? new cc.WebGLColor(colors.r, colors.g, colors.b, colors.a, locArrayBuffer, locOffset) : new cc.WebGLColor(0, 0, 0, 0, locArrayBuffer, locOffset);
            locOffset += cc.WebGLColor.BYTES_PER_ELEMENT;
            this._texCoords = texCoords ? new cc.Tex2F(texCoords.u, texCoords.v, locArrayBuffer, locOffset) : new cc.Tex2F(0, 0, locArrayBuffer, locOffset);
        };
        cc.V2F_C4B_T2F.BYTES_PER_ELEMENT = 20;
        _p = cc.V2F_C4B_T2F.prototype;
        _p._getVertices = function() {
            return this._vertices;
        };
        _p._setVertices = function(verticesValue) {
            this._vertices._view[0] = verticesValue.x;
            this._vertices._view[1] = verticesValue.y;
        };
        _p._getColor = function() {
            return this._colors;
        };
        _p._setColor = function(colorValue) {
            var locColors = this._colors;
            locColors._view[0] = colorValue.r;
            locColors._view[1] = colorValue.g;
            locColors._view[2] = colorValue.b;
            locColors._view[3] = colorValue.a;
        };
        _p._getTexCoords = function() {
            return this._texCoords;
        };
        _p._setTexCoords = function(texValue) {
            this._texCoords._view[0] = texValue.u;
            this._texCoords._view[1] = texValue.v;
        };
        cc.js.getset(_p, "vertices", _p._getVertices, _p._setVertices);
        cc.js.getset(_p, "colors", _p._getColor, _p._setColor);
        cc.js.getset(_p, "texCoords", _p._getTexCoords, _p._setTexCoords);
        cc.V2F_C4B_T2F_Triangle = function(a, b, c, arrayBuffer, offset) {
            this._arrayBuffer = arrayBuffer || new ArrayBuffer(cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT);
            this._offset = offset || 0;
            var locArrayBuffer = this._arrayBuffer, locOffset = this._offset, locElementLen = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
            this._a = a ? new cc.V2F_C4B_T2F(a.vertices, a.colors, a.texCoords, locArrayBuffer, locOffset) : new cc.V2F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
            locOffset += locElementLen;
            this._b = b ? new cc.V2F_C4B_T2F(b.vertices, b.colors, b.texCoords, locArrayBuffer, locOffset) : new cc.V2F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
            locOffset += locElementLen;
            this._c = c ? new cc.V2F_C4B_T2F(c.vertices, c.colors, c.texCoords, locArrayBuffer, locOffset) : new cc.V2F_C4B_T2F(null, null, null, locArrayBuffer, locOffset);
        };
        cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT = 60;
        _p = cc.V2F_C4B_T2F_Triangle.prototype;
        _p._getA = function() {
            return this._a;
        };
        _p._setA = function(aValue) {
            var locA = this._a;
            locA.vertices = aValue.vertices;
            locA.colors = aValue.colors;
            locA.texCoords = aValue.texCoords;
        };
        _p._getB = function() {
            return this._b;
        };
        _p._setB = function(bValue) {
            var locB = this._b;
            locB.vertices = bValue.vertices;
            locB.colors = bValue.colors;
            locB.texCoords = bValue.texCoords;
        };
        _p._getC = function() {
            return this._c;
        };
        _p._setC = function(cValue) {
            var locC = this._c;
            locC.vertices = cValue.vertices;
            locC.colors = cValue.colors;
            locC.texCoords = cValue.texCoords;
        };
        cc.js.getset(_p, "a", _p._getA, _p._setA);
        cc.js.getset(_p, "b", _p._getB, _p._setB);
        cc.js.getset(_p, "c", _p._getC, _p._setC);
    }), {} ],
    234: [ (function(require, module, exports) {
        var JS = require("../platform/js");
        function ValueType() {}
        JS.setClassName("cc.ValueType", ValueType);
        var proto = ValueType.prototype;
        proto.toString = function() {
            return "" + {};
        };
        cc.ValueType = ValueType;
        module.exports = ValueType;
    }), {
        "../platform/js": 193
    } ],
    235: [ (function(require, module, exports) {
        var ValueType = require("./CCValueType");
        var JS = require("../platform/js");
        var CCClass = require("../platform/CCClass");
        function Vec2(x, y) {
            if (x && "object" === typeof x) {
                y = x.y;
                x = x.x;
            }
            this.x = x || 0;
            this.y = y || 0;
        }
        JS.extend(Vec2, ValueType);
        CCClass.fastDefine("cc.Vec2", Vec2, {
            x: 0,
            y: 0
        });
        var proto = Vec2.prototype;
        proto.clone = function() {
            return new Vec2(this.x, this.y);
        };
        proto.set = function(newValue) {
            this.x = newValue.x;
            this.y = newValue.y;
            return this;
        };
        proto.equals = function(other) {
            return other && this.x === other.x && this.y === other.y;
        };
        proto.toString = function() {
            return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ")";
        };
        proto.lerp = function(to, ratio, out) {
            out = out || new Vec2();
            var x = this.x;
            var y = this.y;
            out.x = x + (to.x - x) * ratio;
            out.y = y + (to.y - y) * ratio;
            return out;
        };
        proto.addSelf = function(vector) {
            this.x += vector.x;
            this.y += vector.y;
            return this;
        };
        proto.add = function(vector, out) {
            out = out || new Vec2();
            out.x = this.x + vector.x;
            out.y = this.y + vector.y;
            return out;
        };
        proto.subSelf = function(vector) {
            this.x -= vector.x;
            this.y -= vector.y;
            return this;
        };
        proto.sub = function(vector, out) {
            out = out || new Vec2();
            out.x = this.x - vector.x;
            out.y = this.y - vector.y;
            return out;
        };
        proto.mulSelf = function(num) {
            this.x *= num;
            this.y *= num;
            return this;
        };
        proto.mul = function(num, out) {
            out = out || new Vec2();
            out.x = this.x * num;
            out.y = this.y * num;
            return out;
        };
        proto.scaleSelf = function(vector) {
            this.x *= vector.x;
            this.y *= vector.y;
            return this;
        };
        proto.scale = function(vector, out) {
            out = out || new Vec2();
            out.x = this.x * vector.x;
            out.y = this.y * vector.y;
            return out;
        };
        proto.divSelf = function(num) {
            this.x /= num;
            this.y /= num;
            return this;
        };
        proto.div = function(num, out) {
            out = out || new Vec2();
            out.x = this.x / num;
            out.y = this.y / num;
            return out;
        };
        proto.negSelf = function() {
            this.x = -this.x;
            this.y = -this.y;
            return this;
        };
        proto.neg = function(out) {
            out = out || new Vec2();
            out.x = -this.x;
            out.y = -this.y;
            return out;
        };
        proto.dot = function(vector) {
            return this.x * vector.x + this.y * vector.y;
        };
        proto.cross = function(vector) {
            return this.y * vector.x - this.x * vector.y;
        };
        proto.mag = function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        };
        proto.magSqr = function() {
            return this.x * this.x + this.y * this.y;
        };
        proto.normalizeSelf = function() {
            var magSqr = this.x * this.x + this.y * this.y;
            if (1 === magSqr) {
                return this;
            }
            if (0 === magSqr) {
                console.warn("Can't normalize zero vector");
                return this;
            }
            var invsqrt = 1 / Math.sqrt(magSqr);
            this.x *= invsqrt;
            this.y *= invsqrt;
            return this;
        };
        proto.normalize = function(out) {
            out = out || new Vec2();
            out.x = this.x;
            out.y = this.y;
            out.normalizeSelf();
            return out;
        };
        proto.angle = function(vector) {
            var magSqr1 = this.magSqr();
            var magSqr2 = vector.magSqr();
            if (0 === magSqr1 || 0 === magSqr2) {
                console.warn("Can't get angle between zero vector");
                return 0;
            }
            var dot = this.dot(vector);
            var theta = dot / Math.sqrt(magSqr1 * magSqr2);
            theta = cc.clampf(theta, -1, 1);
            return Math.acos(theta);
        };
        proto.signAngle = function(vector) {
            return Math.atan2(this.y, this.x) - Math.atan2(vector.y, vector.x);
        };
        proto.rotate = function(radians, out) {
            out = out || new Vec2();
            out.x = this.x;
            out.y = this.y;
            return out.rotateSelf(radians);
        };
        proto.rotateSelf = function(radians) {
            var sin = Math.sin(radians);
            var cos = Math.cos(radians);
            var x = this.x;
            this.x = cos * x - sin * this.y;
            this.y = sin * x + cos * this.y;
            return this;
        };
        JS.get(Vec2, "ONE", (function() {
            return new Vec2(1, 1);
        }));
        JS.get(Vec2, "ZERO", (function() {
            return new Vec2(0, 0);
        }));
        JS.get(Vec2, "UP", (function() {
            return new Vec2(0, 1);
        }));
        JS.get(Vec2, "RIGHT", (function() {
            return new Vec2(1, 0);
        }));
        cc.Vec2 = Vec2;
        cc.v2 = function v2(x, y) {
            return new Vec2(x, y);
        };
        cc.p = cc.v2;
        cc.pointEqualToPoint = function(point1, point2) {
            return point1 && point2 && point1.x === point2.x && point1.y === point2.y;
        };
        module.exports = cc.Vec2;
    }), {
        "../platform/CCClass": 173,
        "../platform/js": 193,
        "./CCValueType": 234
    } ],
    236: [ (function(require, module, exports) {
        require("./CCValueType");
        require("./CCVec2");
        require("./CCPointExtension");
        require("./CCSize");
        require("./CCRect");
        require("./CCColor");
        require("./CCTypes");
        require("./CCAffineTransform");
        require("./CCTypesWebGL");
    }), {
        "./CCAffineTransform": 227,
        "./CCColor": 228,
        "./CCPointExtension": 229,
        "./CCRect": 230,
        "./CCSize": 231,
        "./CCTypes": 232,
        "./CCTypesWebGL": 233,
        "./CCValueType": 234,
        "./CCVec2": 235
    } ],
    237: [ (function(require, module, exports) {
        var Utils = require("../platform/utils");
        _ccsg.VideoPlayer = _ccsg.Node.extend({
            ctor: function() {
                _ccsg.Node.prototype.ctor.call(this);
                this._EventList = {};
            },
            _createRenderCmd: function() {
                return new _ccsg.VideoPlayer.RenderCmd(this);
            },
            setURL: function(url) {
                this._renderCmd.updateURL(url);
            },
            getURL: function() {
                return this._renderCmd._url;
            },
            play: function() {
                this._renderCmd.play();
            },
            pause: function() {
                this._renderCmd.pause();
            },
            _resume: function() {
                this._renderCmd.play();
            },
            stop: function() {
                this._renderCmd.stop();
            },
            seekTo: function(time) {
                this._renderCmd.seekTo(time);
            },
            isPlaying: function() {
                return this._renderCmd.isPlaying();
            },
            duration: function() {
                return this._renderCmd.duration();
            },
            currentTime: function() {
                return this._renderCmd.currentTime();
            },
            createDomElementIfNeeded: function() {
                this._renderCmd._video || this._renderCmd.createDom();
            },
            setKeepAspectRatioEnabled: function() {
                cc.logID(7700);
            },
            isKeepAspectRatioEnabled: function() {
                return true;
            },
            setFullScreenEnabled: function(enable) {
                var video = this._renderCmd._video;
                if (!video) {
                    return;
                }
                enable ? cc.screen.requestFullScreen(video) : cc.screen.exitFullScreen(video);
            },
            isFullScreenEnabled: function() {
                cc.logID(7701);
            },
            setEventListener: function(event, callback) {
                this._EventList[event] = callback;
            },
            removeEventListener: function(event) {
                this._EventList[event] = null;
            },
            _dispatchEvent: function(event) {
                var callback = this._EventList[event];
                callback && callback.call(this, this, this._renderCmd._video.src);
            },
            onPlayEvent: function() {
                var callback = this._EventList[_ccsg.VideoPlayer.EventType.PLAYING];
                callback.call(this, this, this._renderCmd._video.src);
            },
            setContentSize: function(width, height) {
                if (void 0 !== width.width && void 0 !== width.height) {
                    height = width.height;
                    width = width.width;
                }
                _ccsg.Node.prototype.setContentSize.call(this, width, height);
                this._renderCmd.updateSize(width, height);
            },
            onEnter: function() {
                _ccsg.Node.prototype.onEnter.call(this);
                var list = _ccsg.VideoPlayer.elements;
                list.indexOf(this) === -1 && list.push(this);
            },
            cleanup: function() {
                this._super();
                this._renderCmd.removeDom();
            },
            onExit: function() {
                _ccsg.Node.prototype.onExit.call(this);
                var list = _ccsg.VideoPlayer.elements;
                var index = list.indexOf(this);
                index !== -1 && list.splice(index, 1);
            },
            setVisible: function(visible) {
                _ccsg.Node.prototype.setVisible.call(this, visible);
                this._renderCmd.updateVisibility();
            }
        });
        _ccsg.VideoPlayer.elements = [];
        _ccsg.VideoPlayer.pauseElements = [];
        cc.eventManager.addCustomListener(cc.game.EVENT_HIDE, (function() {
            var list = _ccsg.VideoPlayer.elements;
            for (var node, i = 0; i < list.length; i++) {
                node = list[i];
                if (list[i]._playing) {
                    node.pause();
                    _ccsg.VideoPlayer.pauseElements.push(node);
                }
            }
        }));
        cc.game.on(cc.game.EVENT_SHOW, (function() {
            var list = _ccsg.VideoPlayer.pauseElements;
            var node = list.pop();
            while (node) {
                node.play();
                node = list.pop();
            }
        }));
        _ccsg.VideoPlayer.EventType = {
            PLAYING: 0,
            PAUSED: 1,
            STOPPED: 2,
            COMPLETED: 3,
            META_LOADED: 4,
            CLICKED: 5,
            READY_TO_PLAY: 6
        };
        (function(video) {
            video._polyfill = {
                devicePixelRatio: false,
                event: "canplay",
                canPlayType: []
            };
            (function() {
                var dom = document.createElement("video");
                if (dom.canPlayType("video/ogg")) {
                    video._polyfill.canPlayType.push(".ogg");
                    video._polyfill.canPlayType.push(".ogv");
                }
                dom.canPlayType("video/mp4") && video._polyfill.canPlayType.push(".mp4");
                dom.canPlayType("video/webm") && video._polyfill.canPlayType.push(".webm");
            })();
            cc.sys.browserType === cc.sys.BROWSER_TYPE_FIREFOX && (video._polyfill.autoplayAfterOperation = true);
            cc.sys.OS_ANDROID !== cc.sys.os || cc.sys.browserType !== cc.sys.BROWSER_TYPE_SOUGOU && cc.sys.browserType !== cc.sys.BROWSER_TYPE_360 || (video._polyfill.zoomInvalid = true);
            var style = document.createElement("style");
            style.innerHTML = ".cocosVideo:-moz-full-screen{transform:matrix(1,0,0,1,0,0) !important;}.cocosVideo:full-screen{transform:matrix(1,0,0,1,0,0) !important;}.cocosVideo:-webkit-full-screen{transform:matrix(1,0,0,1,0,0) !important;}";
            document.head.appendChild(style);
        })(_ccsg.VideoPlayer);
        (function(polyfill) {
            _ccsg.VideoPlayer.RenderCmd = function(node) {
                this._rootCtor(node);
                this._video = null;
                this._url = "";
                this._played = false;
                this._playing = false;
                this._ignorePause = false;
            };
            var proto = _ccsg.VideoPlayer.RenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
            proto.constructor = _ccsg.VideoPlayer.RenderCmd;
            proto.transform = function(parentCmd, recursive) {
                this.originTransform(parentCmd, recursive);
                this.updateMatrix();
            };
            proto.updateMatrix = function() {
                if (!this._video) {
                    return;
                }
                var node = this._node, scaleX = cc.view._scaleX, scaleY = cc.view._scaleY;
                var dpr = cc.view._devicePixelRatio;
                var t = this._worldTransform;
                scaleX /= dpr;
                scaleY /= dpr;
                var container = cc.game.container;
                var a = t.a * scaleX, b = t.b, c = t.c, d = t.d * scaleY;
                var offsetX = container && container.style.paddingLeft && parseInt(container.style.paddingLeft);
                var offsetY = container && container.style.paddingBottom && parseInt(container.style.paddingBottom);
                var tx = t.tx * scaleX + offsetX, ty = t.ty * scaleY + offsetY;
                if (polyfill.zoomInvalid) {
                    this.updateSize(node._contentSize.width * a, node._contentSize.height * d);
                    a = 1;
                    d = 1;
                }
                var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
                this._video.style["transform"] = matrix;
                this._video.style["-webkit-transform"] = matrix;
                this._video.style["transform-origin"] = "0px 100% 0px";
                this._video.style["-webkit-transform-origin"] = "0px 100% 0px";
            };
            proto.updateURL = function(path) {
                var source, video, extname;
                var node = this._node;
                if (this._url == path) {
                    return;
                }
                this._url = path;
                cc.loader.resPath && !/^http/.test(path) && (path = cc.path.join(cc.loader.resPath, path));
                this.removeDom();
                this.createDom();
                this.bindEvent();
                video = this._video;
                var cb = function() {
                    if (true == this._loaded) {
                        return;
                    }
                    this._loaded = true;
                    node.setContentSize(node._contentSize.width, node._contentSize.height);
                    video.currentTime = 0;
                    node._dispatchEvent(_ccsg.VideoPlayer.EventType.READY_TO_PLAY);
                    this.updateVisibility();
                    this.updateMatrix();
                }.bind(this);
                video.oncanplay = cb;
                video.style["visibility"] = "hidden";
                this._loaded = false;
                this._played = false;
                this._playing = false;
                source = document.createElement("source");
                source.src = path;
                video.appendChild(source);
                extname = cc.path.extname(path);
                for (var i = 0; i < polyfill.canPlayType.length; i++) {
                    if (extname !== polyfill.canPlayType[i]) {
                        source = document.createElement("source");
                        source.src = path.replace(extname, polyfill.canPlayType[i]);
                        video.appendChild(source);
                    }
                }
            };
            proto.bindEvent = function() {
                var node = this._node, video = this._video, self = this;
                video.onloadedmetadata = function() {
                    node._dispatchEvent(_ccsg.VideoPlayer.EventType.META_LOADED);
                };
                video.addEventListener("ended", function() {
                    if (self._video !== video) {
                        return;
                    }
                    this._playing = false;
                    node._dispatchEvent(_ccsg.VideoPlayer.EventType.COMPLETED);
                }.bind(this));
                video.addEventListener("play", (function() {
                    if (self._video !== video) {
                        return;
                    }
                    node._dispatchEvent(_ccsg.VideoPlayer.EventType.PLAYING);
                }));
                video.addEventListener("pause", (function() {
                    if (self._ignorePause || self._video !== video) {
                        return;
                    }
                    node._dispatchEvent(_ccsg.VideoPlayer.EventType.PAUSED);
                }));
                video.addEventListener("click", (function() {
                    node._dispatchEvent(_ccsg.VideoPlayer.EventType.CLICKED);
                }));
            };
            proto.updateVisibility = function() {
                var node = this._node;
                if (!this._video) {
                    return;
                }
                var video = this._video;
                if (node.visible) {
                    video.style.visibility = "visible";
                } else {
                    video.style.visibility = "hidden";
                    video.pause();
                    this._playing = false;
                }
            };
            proto.createDom = function() {
                var video = document.createElement("video");
                video.style.position = "absolute";
                video.style.bottom = "0px";
                video.style.left = "0px";
                video.className = "cocosVideo";
                video.setAttribute("preload", true);
                video.setAttribute("webkit-playsinline", "");
                video.setAttribute("playsinline", "");
                this._video = video;
                cc.game.container.appendChild(video);
            };
            proto.removeDom = function() {
                var video = this._video;
                if (video) {
                    var hasChild = Utils.contains(cc.game.container, video);
                    hasChild && cc.game.container.removeChild(video);
                }
                this._video = null;
                this._url = "";
            };
            proto.updateSize = function(width, height) {
                var video = this._video;
                if (!video) {
                    return;
                }
                video.style["width"] = width + "px";
                video.style["height"] = height + "px";
            };
            proto.play = function() {
                var video = this._video;
                if (!video || !this._node.isVisible()) {
                    return;
                }
                this._played = true;
                if (this._playing) {
                    return;
                }
                if (_ccsg.VideoPlayer._polyfill.autoplayAfterOperation) {
                    var self = this;
                    setTimeout((function() {
                        video.play();
                        self._playing = true;
                    }), 20);
                } else {
                    video.play();
                    this._playing = true;
                }
            };
            proto.pause = function() {
                var video = this._video;
                if (!this._playing) {
                    return;
                }
                this._playing = false;
                if (!video) {
                    return;
                }
                video.pause();
            };
            proto.stop = function() {
                var video = this._video;
                if (!video || !this._node.isVisible()) {
                    return;
                }
                this._ignorePause = true;
                video.pause();
                var node = this._node;
                setTimeout(function() {
                    node._dispatchEvent(_ccsg.VideoPlayer.EventType.STOPPED);
                    this._ignorePause = false;
                }.bind(this), 0);
                video.currentTime = 0;
                this._playing = false;
            };
            proto.seekTo = function(sec) {
                var video = this._video;
                if (!video) {
                    return;
                }
                if (this._loaded) {
                    video.currentTime = sec;
                } else {
                    var cb = function() {
                        video.currentTime = sec;
                        video.removeEventListener(polyfill.event, cb);
                    };
                    video.addEventListener(polyfill.event, cb);
                }
                _ccsg.VideoPlayer._polyfill.autoplayAfterOperation && this.isPlaying() && setTimeout((function() {
                    video.play();
                }), 20);
            };
            proto.isPlaying = function() {
                var video = this._video;
                _ccsg.VideoPlayer._polyfill.autoplayAfterOperation && this._playing && setTimeout((function() {
                    video.play();
                }), 20);
                return this._playing;
            };
            proto.duration = function() {
                var video = this._video;
                var duration = -1;
                if (!video) {
                    return duration;
                }
                duration = video.duration;
                duration <= 0 && cc.logID(7702);
                return duration;
            };
            proto.currentTime = function() {
                var video = this._video;
                if (!video) {
                    return -1;
                }
                return video.currentTime;
            };
        })(_ccsg.VideoPlayer._polyfill);
    }), {
        "../platform/utils": 198
    } ],
    238: [ (function(require, module, exports) {
        var Utils = require("../platform/utils");
        _ccsg.WebView = _ccsg.Node.extend({
            ctor: function() {
                _ccsg.Node.prototype.ctor.call(this);
                this.setContentSize(cc.size(300, 200));
                this._EventList = {};
            },
            createDomElementIfNeeded: function() {
                this._renderCmd._div || this._renderCmd.createNativeControl();
            },
            setJavascriptInterfaceScheme: function(scheme) {},
            loadData: function(data, MIMEType, encoding, baseURL) {},
            loadHTMLString: function(string, baseURL) {},
            loadURL: function(url) {
                this._renderCmd.updateURL(url);
                this._dispatchEvent(_ccsg.WebView.EventType.LOADING);
            },
            stopLoading: function() {
                cc.logID(7800);
            },
            reload: function() {
                var iframe = this._renderCmd._iframe;
                if (iframe) {
                    var win = iframe.contentWindow;
                    win && win.location && win.location.reload();
                }
            },
            canGoBack: function() {
                cc.logID(7801);
                return true;
            },
            canGoForward: function() {
                cc.logID(7802);
                return true;
            },
            goBack: function() {
                try {
                    if (_ccsg.WebView._polyfill.closeHistory) {
                        return cc.logID(7803);
                    }
                    var iframe = this._renderCmd._iframe;
                    if (iframe) {
                        var win = iframe.contentWindow;
                        win && win.location && win.history.back.call(win);
                    }
                } catch (err) {
                    cc.log(err);
                }
            },
            goForward: function() {
                try {
                    if (_ccsg.WebView._polyfill.closeHistory) {
                        return cc.logID(7804);
                    }
                    var iframe = this._renderCmd._iframe;
                    if (iframe) {
                        var win = iframe.contentWindow;
                        win && win.location && win.history.forward.call(win);
                    }
                } catch (err) {
                    cc.log(err);
                }
            },
            evaluateJS: function(str) {
                var iframe = this._renderCmd._iframe;
                if (iframe) {
                    var win = iframe.contentWindow;
                    try {
                        win.eval(str);
                        this._dispatchEvent(_ccsg.WebView.EventType.JS_EVALUATED);
                    } catch (err) {
                        console.error(err);
                    }
                }
            },
            setScalesPageToFit: function() {
                cc.logID(7805);
            },
            setEventListener: function(event, callback) {
                this._EventList[event] = callback;
            },
            removeEventListener: function(event) {
                this._EventList[event] = null;
            },
            _dispatchEvent: function(event) {
                var callback = this._EventList[event];
                callback && callback.call(this, this, this._renderCmd._iframe.src);
            },
            _createRenderCmd: function() {
                return new _ccsg.WebView.RenderCmd(this);
            },
            setContentSize: function(width, height) {
                if (void 0 !== width.width && void 0 !== width.height) {
                    height = width.height;
                    width = width.width;
                }
                _ccsg.Node.prototype.setContentSize.call(this, width, height);
                this._renderCmd.updateSize(width, height);
            },
            cleanup: function() {
                this._super();
                this._renderCmd.removeDom();
            },
            setVisible: function(visible) {
                _ccsg.Node.prototype.setVisible.call(this, visible);
                this._renderCmd.updateVisibility();
            }
        });
        _ccsg.WebView.EventType = {
            LOADING: 0,
            LOADED: 1,
            ERROR: 2,
            JS_EVALUATED: 3
        };
        (function() {
            var polyfill = _ccsg.WebView._polyfill = {
                devicePixelRatio: false,
                enableDiv: false
            };
            cc.sys.os === cc.sys.OS_IOS && (polyfill.enableDiv = true);
            cc.sys.isMobile ? cc.sys.browserType === cc.sys.BROWSER_TYPE_FIREFOX && (polyfill.enableBG = true) : cc.sys.browserType === cc.sys.BROWSER_TYPE_IE && (polyfill.closeHistory = true);
        })();
        (function(polyfill) {
            var RenderCmd;
            RenderCmd = cc._renderType === cc.game.RENDER_TYPE_CANVAS ? _ccsg.Node.CanvasRenderCmd : _ccsg.Node.WebGLRenderCmd;
            _ccsg.WebView.RenderCmd = function(node) {
                this._rootCtor(node);
                this._parent = null;
                this._div = null;
                this._iframe = null;
                this._listener = null;
            };
            var proto = _ccsg.WebView.RenderCmd.prototype = Object.create(RenderCmd.prototype);
            proto.constructor = _ccsg.WebView.RenderCmd;
            proto.transform = function(parentCmd, recursive) {
                this.originTransform(parentCmd, recursive);
                this.updateMatrix();
            };
            proto.updateStatus = function() {
                polyfill.devicePixelRatio = cc.view.isRetinaEnabled();
                var flags = _ccsg.Node._dirtyFlags, locFlag = this._dirtyFlag;
                if (locFlag & flags.transformDirty) {
                    this.transform(this.getParentRenderCmd(), true);
                    this.updateMatrix();
                    this._dirtyFlag &= ~_ccsg.Node._dirtyFlags.transformDirty;
                }
            };
            proto.initEvent = function() {
                var node = this._node;
                this._iframe.addEventListener("load", (function() {
                    node._dispatchEvent(_ccsg.WebView.EventType.LOADED);
                }));
                this._iframe.addEventListener("error", (function() {
                    node._dispatchEvent(_ccsg.WebView.EventType.ERROR);
                }));
            };
            proto.resize = function(view) {
                view = view || cc.view;
                var node = this._node, eventManager = cc.eventManager;
                if (node._parent && node._visible) {
                    this.updateMatrix();
                } else {
                    var list = eventManager._listenersMap[cc.game.EVENT_RESIZE].getFixedPriorityListeners();
                    eventManager._removeListenerInVector(list, this._listener);
                    this._listener = null;
                }
            };
            proto.updateMatrix = function() {
                if (!this._div) {
                    return;
                }
                var node = this._node, scaleX = cc.view._scaleX, scaleY = cc.view._scaleY;
                var dpr = cc.view._devicePixelRatio;
                var t = this._worldTransform;
                scaleX /= dpr;
                scaleY /= dpr;
                var container = cc.game.container;
                var a = t.a * scaleX, b = t.b, c = t.c, d = t.d * scaleY;
                var offsetX = container && container.style.paddingLeft && parseInt(container.style.paddingLeft);
                var offsetY = container && container.style.paddingBottom && parseInt(container.style.paddingBottom);
                var tx = t.tx * scaleX + offsetX, ty = t.ty * scaleY + offsetY;
                var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
                this._div.style["transform"] = matrix;
                this._div.style["-webkit-transform"] = matrix;
                this._div.style["transform-origin"] = "0px 100% 0px";
                this._div.style["-webkit-transform-origin"] = "0px 100% 0px";
            };
            proto.initStyle = function() {
                if (!this._div) {
                    return;
                }
                var div = this._div;
                div.style.position = "absolute";
                div.style.bottom = "0px";
                div.style.left = "0px";
            };
            proto.updateURL = function(url) {
                var iframe = this._iframe;
                iframe.src = url;
                var self = this;
                var cb = function() {
                    self._loaded = true;
                    self.updateVisibility();
                    iframe.removeEventListener("load", cb);
                };
                iframe.addEventListener("load", cb);
            };
            proto.updateSize = function(w, h) {
                var div = this._div;
                if (div) {
                    div.style["width"] = w + "px";
                    div.style["height"] = h + "px";
                }
            };
            proto.createDom = function() {
                if (polyfill.enableDiv) {
                    this._div = document.createElement("div");
                    this._div.style["-webkit-overflow"] = "auto";
                    this._div.style["-webkit-overflow-scrolling"] = "touch";
                    this._iframe = document.createElement("iframe");
                    this._div.appendChild(this._iframe);
                    this._iframe.style.width = "100%";
                    this._iframe.style.height = "100%";
                } else {
                    this._div = this._iframe = document.createElement("iframe");
                }
                polyfill.enableBG && (this._div.style["background"] = "#FFF");
                this._div.style["background"] = "#FFF";
                var contentSize = this._node._contentSize;
                this._div.style.height = contentSize.height + "px";
                this._div.style.width = contentSize.width + "px";
                this._div.style.overflow = "scroll";
                this._div.style.border = "none";
                cc.game.container.appendChild(this._div);
                this.updateVisibility();
            };
            proto.createNativeControl = function() {
                this.createDom();
                this.initStyle();
                this.initEvent();
            };
            proto.removeDom = function() {
                var div = this._div;
                if (div) {
                    var hasChild = Utils.contains(cc.game.container, div);
                    hasChild && cc.game.container.removeChild(div);
                }
                this._div = null;
            };
            proto.updateVisibility = function() {
                var node = this._node;
                if (!this._div) {
                    return;
                }
                var div = this._div;
                node.visible ? div.style.visibility = "visible" : div.style.visibility = "hidden";
            };
        })(_ccsg.WebView._polyfill);
    }), {
        "../platform/utils": 198
    } ],
    239: [ (function(require, module, exports) {
        var js = cc.js;
        js.get(cc, "spriteFrameCache", (function() {
            cc.errorID(1404);
        }));
        cc.Label && js.obsolete(cc.Label.prototype, "cc.Label.file", "font", true);
        js.get(cc, "inject", (function() {
            cc.warnID(1400, "cc.inject", "cc.js.mixin");
            cc.warnID(1401);
            return function(lhs, rhs) {
                return js.mixin(rhs, lhs);
            };
        }));
        js.get(cc, "extend", (function() {
            cc.warnID(1400, "cc.extend", "cc.js.mixin");
            return js.mixin;
        }));
        js.get(cc, "newElement", (function() {
            cc.warnID(1400, "cc.newElement", "document.createElement");
            return document.createElement;
        }));
        js.get(cc, "isFunction", (function() {
            cc.warnID(1400, "cc.isFunction", "\"typeof obj === 'function'\"");
            return function(obj) {
                return "function" === typeof obj;
            };
        }));
        js.get(cc.js, "isFunction", (function() {
            cc.warnID(1400, "cc.js.isFunction", "\"typeof obj === 'function'\"");
            return function(obj) {
                return "function" === typeof obj;
            };
        }));
        js.get(cc, "isNumber", (function() {
            cc.warnID(1400, "cc.isNumber", "cc.js.isNumber");
            return js.isNumber;
        }));
        js.get(cc, "isString", (function() {
            cc.warnID(1400, "cc.isString", "cc.js.isString");
            return js.isString;
        }));
        js.get(cc, "isArray", (function() {
            cc.warnID(1400, "cc.isArray", "cc.js.isArray");
            return function(obj) {
                return Array.isArray(obj);
            };
        }));
        js.get(cc.js, "isArray", (function() {
            cc.warnID(1400, "cc.js.isArray", '"Array.isArray(obj)"');
            return function(obj) {
                return Array.isArray(obj);
            };
        }));
        js.get(cc, "isUndefined", (function() {
            cc.warnID(1400, "cc.isUndefined", "\"typeof obj === 'undefined'\"");
            return function(obj) {
                return "undefined" === typeof obj;
            };
        }));
        js.get(cc.js, "isUndefined", (function() {
            cc.warnID(1400, "cc.js.isUndefined", "\"typeof obj === 'undefined'\"");
            return function(obj) {
                return "undefined" === typeof obj;
            };
        }));
        js.get(cc, "isObject", (function() {
            cc.warnID(1400, "cc.isObject", "\"typeof obj === 'object'\"");
            return function(obj) {
                return "object" === typeof obj;
            };
        }));
        js.get(cc.js, "isObject", (function() {
            cc.warnID(1400, "cc.js.isObject", "\"typeof obj === 'object'\"");
            return function(obj) {
                return "object" === typeof obj;
            };
        }));
        js.obsoletes(cc, "cc", {
            Point: "Vec2"
        });
        js.get(cc, "arrayVerifyType", (function() {
            cc.warnID(1400, "cc.arrayVerifyType", "cc.js.array.verifyType");
            return cc.js.array.verifyType;
        }));
        js.get(cc, "arrayRemoveObject", (function() {
            cc.warnID(1400, "cc.arrayRemoveObject", "cc.js.array.remove");
            return cc.js.array.remove;
        }));
        js.get(cc, "arrayRemoveArray", (function() {
            cc.warnID(1400, "cc.arrayRemoveArray", "cc.js.array.removeArray");
            return cc.js.array.removeArray;
        }));
        js.get(cc, "arrayAppendObjectsToIndex", (function() {
            cc.warnID(1400, "cc.arrayAppendObjectsToIndex", "cc.js.array.appendObjectsAt");
            return cc.js.array.appendObjectsAt;
        }));
        js.get(cc, "copyArray", (function() {
            cc.warnID(1400, "cc.copyArray", "cc.js.array.copy");
            return cc.js.array.copy;
        }));
        js.get(cc, "PI", (function() {
            cc.warnID(1400, "cc.PI", "Math.PI");
            return Math.PI;
        }));
        if (cc.TiledLayer) {
            js.obsolete(cc.TiledLayer.prototype, "cc.TiledLayer.getTileset", "getTileSet");
            js.obsolete(cc.TiledLayer.prototype, "cc.TiledLayer.setTileset", "setTileSet");
        }
        Object.defineProperty(cc._SGComponent.prototype, "visible", {
            get: function() {
                cc.warnID(1402, cc.js.getClassName(this));
                return this.enabled;
            },
            set: function(value) {
                var printWarning = this.visible;
                this.enabled = value;
            }
        });
        function deprecateEnum(obj, oldPath, newPath, hasTypePrefixBefore) {
            hasTypePrefixBefore = false !== hasTypePrefixBefore;
            var enumDef = Function("return " + newPath)();
            var entries = cc.Enum.getList(enumDef);
            var delimiter = hasTypePrefixBefore ? "_" : ".";
            for (var i = 0; i < entries.length; i++) {
                var entry = entries[i].name;
                var oldPropName;
                if (hasTypePrefixBefore) {
                    var oldTypeName = oldPath.split(".").slice(-1)[0];
                    oldPropName = oldTypeName + "_" + entry;
                } else {
                    oldPropName = entry;
                }
                js.get(obj, oldPropName, function(entry) {
                    cc.warnID(1400, oldPath + delimiter + entry, newPath + "." + entry);
                    return enumDef[entry];
                }.bind(null, entry));
            }
        }
        deprecateEnum(cc, "cc.TEXT_ALIGNMENT", "cc.TextAlignment");
        deprecateEnum(cc, "cc.VERTICAL_TEXT_ALIGNMENT", "cc.VerticalTextAlignment");
        if (_ccsg.ParticleSystem) {
            deprecateEnum(_ccsg.ParticleSystem, "_ccsg.ParticleSystem.TYPE", "_ccsg.ParticleSystem.Type");
            deprecateEnum(_ccsg.ParticleSystem, "_ccsg.ParticleSystem.MODE", "_ccsg.ParticleSystem.Mode");
        }
        if (cc.ParticleSystem) {
            deprecateEnum(cc.ParticleSystem, "cc.ParticleSystem.TYPE", "cc.ParticleSystem.PositionType");
            deprecateEnum(cc.ParticleSystem, "cc.ParticleSystem.MODE", "cc.ParticleSystem.EmitterMode");
        }
        deprecateEnum(cc.game, "cc.game.DEBUG_MODE", "cc.DebugMode");
        deprecateEnum(cc, "cc", "cc.Texture2D.WrapMode", false);
        if (_ccsg.EditBox) {
            deprecateEnum(cc, "cc.KEYBOARD_RETURNTYPE", "_ccsg.EditBox.KeyboardReturnType");
            deprecateEnum(cc, "cc.EDITBOX_INPUT_MODE", "_ccsg.EditBox.InputMode");
            deprecateEnum(cc, "cc.EDITBOX_INPUT_FLAG", "_ccsg.EditBox.InputFlag");
        }
        function markAsRemoved(ownerCtor, removedProps, ownerName) {
            if (!ownerCtor) {
                return;
            }
            ownerName = ownerName || js.getClassName(ownerCtor);
            removedProps.forEach((function(prop) {
                function error() {
                    cc.error("Sorry, %s.%s is removed.", ownerName, prop);
                }
                js.getset(ownerCtor.prototype, prop, error, error);
            }));
        }
        function provideClearError(owner, obj, ownerName) {
            if (!owner) {
                return;
            }
            var className = ownerName || cc.js.getClassName(owner);
            var Info = "Sorry, " + className + ".%s is removed, please use %s instead.";
            var _loop = function() {
                function define(prop, getset) {
                    function accessor(newProp) {
                        cc.error(Info, prop, newProp);
                    }
                    Array.isArray(getset) || (getset = getset.split(",").map((function(x) {
                        return x.trim();
                    })));
                    try {
                        js.getset(owner, prop, accessor.bind(null, getset[0]), getset[1] && accessor.bind(null, getset[1]));
                    } catch (e) {}
                }
                getset = obj[prop];
                if ("*" === prop[0]) {
                    etProp = prop.slice(1);
                    define("g" + etProp, getset);
                    define("s" + etProp, getset);
                } else {
                    prop.split(",").map((function(x) {
                        return x.trim();
                    })).forEach((function(x) {
                        define(x, getset);
                    }));
                }
            };
            for (var prop in obj) {
                var getset;
                var etProp;
                _loop();
            }
        }
        provideClearError(cc.Director.prototype, {
            getSecondsPerFrame: "getDeltaTime"
        });
        markAsRemoved(cc.Pipeline, [ "loadJsWithImg", "loadCsb", "getUrl", "loadAliases", "register" ], "cc.loader");
        provideClearError(cc.loader, {
            loadJs: "load",
            loadTxt: "load",
            loadJson: "load",
            loadImg: "load"
        }, "cc.loader");
        markAsRemoved(cc.Node, [ "_componentContainer", "_camera", "_additionalTransform", "_scheduler", "_actionManager", "actionManager", "_isTransitionFinished", "_additionalTransformDirty", "_shaderProgram", "shaderProgram", "_normalizedPositionDirty", "_normalizedPosition", "_usingNormalizedPosition", "_renderCmd", "_vertexZ", "_showNode", "_arrayMakeObjectsPerformSelector", "getActionManager", "setActionManager", "getScheduler", "setScheduler", "reorderChild", "draw", "transformAncestors", "onEnter", "onEnterTransitionDidFinish", "onExitTransitionDidStart", "onExit", "scheduleUpdate", "scheduleUpdateWithPriority", "unscheduleUpdate", "schedule", "scheduleOnce", "unschedule", "unscheduleAllCallbacks", "resumeSchedulerAndActions", "resume", "pauseSchedulerAndActions", "pause", "setAdditionalTransform", "updateTransform", "retain", "release", "visit", "transform", "getCamera", "grid", "getOrderOfArrival", "setOrderOfArrival", "getGrid", "setGrid", "getShaderProgram", "setShaderProgram", "getGLServerState", "setGLServerState", "_initRendererCmd", "_createRenderCmd", "updateDisplayedOpacity", "updateDisplayedColor", "userData", "userObject", "_cascadeColorEnabled", "cascadeColor", "isCascadeColorEnabled", "setCascadeColorEnabled", "ignoreAnchor", "isIgnoreAnchorPointForPosition", "ignoreAnchorPointForPosition" ]);
        provideClearError(cc.Node.prototype, {
            arrivalOrder: "getSiblingIndex, setSiblingIndex",
            _visible: "_activeInHierarchy, active",
            _running: "_activeInHierarchy, active",
            running: "activeInHierarchy, active",
            _realOpacity: "_opacity, _opacity",
            _realColor: "_color, _color",
            _insertChild: "addChild",
            _addChildHelper: "addChild",
            _detachChild: "removeChild",
            getZOrder: "getLocalZOrder",
            setZOrder: "setLocalZOrder",
            boundingBox: "getBoundingBox",
            removeFromParentAndCleanup: "removeFromParent",
            removeAllChildrenWithCleanup: "removeAllChildren",
            parentToNodeTransform: "getParentToNodeTransform",
            nodeToWorldTransform: "getNodeToWorlshaderProgramdTransform",
            worldToNodeTransform: "getWorldToNodeTransform",
            nodeToParentTransform: "getNodeToParentTransform",
            removeAllComponents: "removeComponent",
            getNodeToParentAffineTransform: "getNodeToParentTransform"
        });
        function shouldNotUseNodeProp(component) {
            var compProto = component.prototype;
            for (var prop in cc.Node.prototype) {
                (function(prop) {
                    prop in compProto || "_" === prop[0] || Object.defineProperty(compProto, prop, {
                        get: function() {
                            var compName = cc.js.getClassName(this);
                            var Info = "Sorry, " + compName + ".%s is undefined, please use cc.Node.%s instead.";
                            cc.error(Info, prop, prop);
                        },
                        enumerable: false,
                        configurable: true
                    });
                })(prop);
            }
        }
        shouldNotUseNodeProp(cc._SGComponent);
        markAsRemoved(cc.Sprite, [ "textureLoaded", "setBlendFunc", "getBlendFunc", "setState", "getState", "resizableSpriteWithCapInsets", "flippedX", "flippedY", "setFlippedX", "setFlippedY", "isFlippedX", "isFlippedY", "getCapInsets", "setCapInsets" ]);
        provideClearError(cc.Sprite, {
            create: "node.addComponent",
            createWithTexture: "node.addComponent",
            createWithSpriteFrameName: "node.addComponent",
            createWithSpriteFrame: "node.addComponent"
        });
        provideClearError(cc.Sprite.prototype, {
            getPreferredSize: "node.getContentSize",
            setPreferredSize: "node.setContentSize",
            updateWithSprite: "spriteFrame",
            getSpriteFrame: "spriteFrame",
            setSpriteFrame: "spriteFrame",
            useOriginalSize: "sizeMode"
        });
        if (cc.ParticleSystem) {
            markAsRemoved(cc.ParticleSystem, [ "batchNode", "drawMode", "getDrawMode", "setDrawMode", "shapeType", "getShapeType", "setShapeType", "atlasIndex", "init", "initParticle", "updateWithNoTime" ]);
            provideClearError(cc.ParticleSystem, {
                initWithFile: "instance.file",
                initWithDictionary: "instance.file",
                initWithTotalParticles: "instance.totalParticles"
            });
            provideClearError(cc.ParticleSystem.prototype, {
                destroyParticleSystem: "destroy",
                clone: "cc.instantiate",
                isActive: "active",
                "*etParticleCount": "particleCount",
                "*etDuration": "duration",
                "*etSourcePosition": "sourcePos",
                "*etPosVar": "posVar",
                "*etGravity": "gravity",
                "*etSpeed": "speed",
                "*etSpeedVar": "speedVar",
                "*etTangentialAccel": "tangentialAccel",
                "*etTangentialAccelVar": "tangentialAccelVar",
                "*etRadialAccel": "radialAccel",
                "*etRadialAccelVar": "radialAccelVar",
                "*etRotationIsDir": "rotationIsDir",
                "*etStartRadius": "startRadius",
                "*etStartRadiusVar": "startRadiusVar",
                "*etEndRadius": "endRadius",
                "*etEndRadiusVar": "endRadiusVar",
                "*etRotatePerSecond": "rotatePerS",
                "*etRotatePerSecondVar": "rotatePerSVar",
                "*etStartColor": "startColor",
                "*etStartColorVar": "startColorVar",
                "*etEndColor": "endColor",
                "*etEndColorVar": "endColorVar",
                "*etTotalParticles": "totalParticles",
                "*etTexture": "texture"
            });
            js.obsoletes(cc.ParticleSystem, "cc.ParticleSystem", {
                Type: "PositionType",
                Mode: "EmitterMode"
            });
        }
        markAsRemoved(_ccsg.Node, [ "_normalizedPositionDirty", "_normalizedPosition", "_usingNormalizedPosition", "grid", "userData", "userObject", "actionManager", "getActionManager", "setActionManager", "getNormalizedPosition", "setNormalizedPosition", "getCamera", "getUserData", "setUserData", "getUserObject", "setUserObject", "getComponent", "addComponent", "removeComponent", "removeAllComponents", "enumerateChildren", "setCameraMask", "getCameraMask" ], "_ccsg.Node");
        js.obsolete(_ccsg.Node.prototype, "_ccsg.Node.ignoreAnchorPointForPosition", "setIgnoreAnchorPointForPosition");
        js.obsoletes(cc.Scale9Sprite.prototype, "cc.Scale9Sprite", {
            setPreferredSize: "setContentSize",
            getPreferredSize: "getContentSize"
        });
        cc.ActionManager && js.obsoletes(cc.ActionManager.prototype, "cc.ActionManager", {
            numberOfRunningActionsInTarget: "getNumberOfRunningActionsInTarget"
        });
        if (cc.Layout) {
            js.obsolete(cc.Layout.prototype, "cc.Layout.layoutType", "type");
            js.obsolete(cc.Layout.prototype, "cc.Layout.ResizeType", "ResizeMode");
            js.obsolete(cc.Layout.prototype, "cc.Layout.resize", "resizeMode");
        }
        markAsRemoved(cc.Scale9Sprite, [ "resizableSpriteWithCapInsets", "updateWithSprite", "getOriginalSize", "setCapInsets", "getCapInsets", "setScale9Enabled", "isScale9Enabled", "getSprite", "setFlippedX", "isFlippedX", "setFlippedY", "isFlippedY" ]);
        if ("undefined" !== typeof sp) {
            deprecateEnum(sp, "sp.ANIMATION_EVENT_TYPE", "sp.AnimationEventType");
            js.obsolete(sp, "sp.SkeletonAnimation", "Skeleton");
            provideClearError(sp.Skeleton, {
                create: "node.addComponent"
            });
            provideClearError(sp.Skeleton.prototype, {
                "*etDebugSlotsEnabled": "debugSlots",
                "*etDebugBonesEnabled": "debugBones",
                setDebugSolots: "debugSlots",
                setDebugBones: "debugBones",
                "*etTimeScale": "timeScale"
            });
        }
        var ERR = '"%s" is not defined in the Scene, it is only defined in normal nodes.';
        Object.defineProperties(cc.Scene.prototype, {
            active: {
                get: function() {
                    cc.error(ERR, "active");
                    return true;
                },
                set: function() {
                    cc.error(ERR, "active");
                }
            },
            activeInHierarchy: {
                get: function() {
                    cc.error(ERR, "activeInHierarchy");
                    return true;
                }
            },
            getComponent: {
                get: function() {
                    cc.error(ERR, "getComponent");
                    return function() {
                        return null;
                    };
                }
            },
            addComponent: {
                get: function() {
                    cc.error(ERR, "addComponent");
                    return function() {
                        return null;
                    };
                }
            }
        });
        js.obsolete(cc.loader, "cc.loader.loadResAll", "loadResDir");
    }), {} ],
    240: [ (function(require, module, exports) {
        require("./core/base-nodes/BaseNodesPropertyDefine.js");
        require("./core/base-nodes/CCSGNode.js");
        require("./core/base-nodes/CCSGNodeCanvasRenderCmd.js");
        require("./core/base-nodes/CCSGNodeWebGLRenderCmd.js");
        require("./core/scenes/CCSGScene.js");
        require("./core/CCConfiguration.js");
        require("./core/CCDrawingPrimitivesCanvas.js");
        require("./core/CCDrawingPrimitivesWebGL.js");
        require("./core/sprites/SpritesPropertyDefine.js");
        require("./core/sprites/CCSGSprite.js");
        require("./core/sprites/CCSGSpriteCanvasRenderCmd.js");
        require("./core/sprites/CCSGSpriteWebGLRenderCmd.js");
        require("./core/sprites/CCScale9Sprite.js");
        require("./core/sprites/CCScale9SpriteCanvasRenderCmd.js");
        require("./core/sprites/CCScale9SpriteWebGLRenderCmd.js");
        require("./core/sprites/CCSpriteBatchNode.js");
        require("./shape-nodes/CCDrawNode.js");
        require("./shape-nodes/CCDrawNodeCanvasRenderCmd.js");
        require("./shape-nodes/CCDrawNodeWebGLRenderCmd.js");
        require("./render-texture/CCRenderTexture.js");
        require("./render-texture/CCRenderTextureCanvasRenderCmd.js");
        require("./render-texture/CCRenderTextureWebGLRenderCmd.js");
    }), {
        "./core/CCConfiguration.js": 34,
        "./core/CCDrawingPrimitivesCanvas.js": 38,
        "./core/CCDrawingPrimitivesWebGL.js": 39,
        "./core/base-nodes/BaseNodesPropertyDefine.js": 56,
        "./core/base-nodes/CCSGNode.js": 57,
        "./core/base-nodes/CCSGNodeCanvasRenderCmd.js": 58,
        "./core/base-nodes/CCSGNodeWebGLRenderCmd.js": 59,
        "./core/scenes/CCSGScene.js": 203,
        "./core/sprites/CCSGSprite.js": 204,
        "./core/sprites/CCSGSpriteCanvasRenderCmd.js": 205,
        "./core/sprites/CCSGSpriteWebGLRenderCmd.js": 206,
        "./core/sprites/CCScale9Sprite.js": 207,
        "./core/sprites/CCScale9SpriteCanvasRenderCmd.js": 208,
        "./core/sprites/CCScale9SpriteWebGLRenderCmd.js": 209,
        "./core/sprites/CCSpriteBatchNode.js": 210,
        "./core/sprites/SpritesPropertyDefine.js": 212,
        "./render-texture/CCRenderTexture.js": 267,
        "./render-texture/CCRenderTextureCanvasRenderCmd.js": 268,
        "./render-texture/CCRenderTextureWebGLRenderCmd.js": 269,
        "./shape-nodes/CCDrawNode.js": 275,
        "./shape-nodes/CCDrawNodeCanvasRenderCmd.js": 276,
        "./shape-nodes/CCDrawNodeWebGLRenderCmd.js": 277
    } ],
    241: [ (function(require, module, exports) {
        cc.math.AABB = function(min, max) {
            this.min = min || new cc.math.Vec3();
            this.max = max || new cc.math.Vec3();
        };
        cc.math.AABB.prototype.containsPoint = function(point) {
            return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
        };
        cc.math.AABB.containsPoint = function(pPoint, pBox) {
            return pPoint.x >= pBox.min.x && pPoint.x <= pBox.max.x && pPoint.y >= pBox.min.y && pPoint.y <= pBox.max.y && pPoint.z >= pBox.min.z && pPoint.z <= pBox.max.z;
        };
        cc.math.AABB.prototype.assignFrom = function(aabb) {
            this.min.assignFrom(aabb.min);
            this.max.assignFrom(aabb.max);
        };
        cc.math.AABB.assign = function(pOut, pIn) {
            pOut.min.assignFrom(pIn.min);
            pOut.max.assignFrom(pIn.max);
            return pOut;
        };
    }), {} ],
    242: [ (function(require, module, exports) {
        cc.math.Matrix4Stack = function(top, stack) {
            this.top = top;
            this.stack = stack || [];
            this.lastUpdated = 0;
        };
        var proto = cc.math.Matrix4Stack.prototype;
        proto.initialize = function() {
            this.stack.length = 0;
            this.top = null;
        };
        proto.push = function(item) {
            item = item || this.top;
            this.stack.push(this.top);
            this.top = new cc.math.Matrix4(item);
            this.update();
        };
        proto.pop = function() {
            this.top = this.stack.pop();
            this.update();
        };
        proto.update = function() {
            this.lastUpdated++;
        };
        proto.release = function() {
            this.stack = null;
            this.top = null;
            this._matrixPool = null;
        };
        proto._getFromPool = function(item) {
            var pool = this._matrixPool;
            if (0 === pool.length) {
                return new cc.math.Matrix4(item);
            }
            var ret = pool.pop();
            ret.assignFrom(item);
            return ret;
        };
        proto._putInPool = function(matrix) {
            this._matrixPool.push(matrix);
        };
    }), {} ],
    243: [ (function(require, module, exports) {
        var math = cc.math;
        math.KM_GL_MODELVIEW = 5888;
        math.KM_GL_PROJECTION = 5889;
        math.KM_GL_TEXTURE = 5890;
        math.modelview_matrix_stack = new math.Matrix4Stack();
        math.projection_matrix_stack = new math.Matrix4Stack();
        math.texture_matrix_stack = new math.Matrix4Stack();
        cc.current_stack = null;
        var initialized = false;
        var lazyInitialize = function() {
            if (!initialized) {
                var identity = new math.Matrix4();
                math.modelview_matrix_stack.initialize();
                math.projection_matrix_stack.initialize();
                math.texture_matrix_stack.initialize();
                cc.current_stack = math.modelview_matrix_stack;
                initialized = true;
                identity.identity();
                math.modelview_matrix_stack.push(identity);
                math.projection_matrix_stack.push(identity);
                math.texture_matrix_stack.push(identity);
            }
        };
        lazyInitialize();
        math.glFreeAll = function() {
            math.modelview_matrix_stack.release();
            math.modelview_matrix_stack = null;
            math.projection_matrix_stack.release();
            math.projection_matrix_stack = null;
            math.texture_matrix_stack.release();
            math.texture_matrix_stack = null;
            initialized = false;
            cc.current_stack = null;
        };
        math.glPushMatrix = function() {
            cc.current_stack.push(cc.current_stack.top);
        };
        math.glPushMatrixWitMat4 = function(saveMat) {
            cc.current_stack.stack.push(cc.current_stack.top);
            saveMat.assignFrom(cc.current_stack.top);
            cc.current_stack.top = saveMat;
        };
        math.glPopMatrix = function() {
            cc.current_stack.top = cc.current_stack.stack.pop();
        };
        math.glMatrixMode = function(mode) {
            switch (mode) {
              case math.KM_GL_MODELVIEW:
                cc.current_stack = math.modelview_matrix_stack;
                break;

              case math.KM_GL_PROJECTION:
                cc.current_stack = math.projection_matrix_stack;
                break;

              case math.KM_GL_TEXTURE:
                cc.current_stack = math.texture_matrix_stack;
                break;

              default:
                throw new Error("Invalid matrix mode specified");
            }
        };
        math.glLoadIdentity = function() {
            cc.current_stack.top.identity();
            cc.current_stack.update();
        };
        math.glLoadMatrix = function(pIn) {
            cc.current_stack.top.assignFrom(pIn);
            cc.current_stack.update();
        };
        math.glMultMatrix = function(pIn) {
            cc.current_stack.top.multiply(pIn);
            cc.current_stack.update();
        };
        var tempMatrix = new math.Matrix4();
        math.glTranslatef = function(x, y, z) {
            var translation = math.Matrix4.createByTranslation(x, y, z, tempMatrix);
            cc.current_stack.top.multiply(translation);
            cc.current_stack.update();
        };
        var tempVector3 = new math.Vec3();
        math.glRotatef = function(angle, x, y, z) {
            tempVector3.fill(x, y, z);
            var rotation = math.Matrix4.createByAxisAndAngle(tempVector3, cc.degreesToRadians(angle), tempMatrix);
            cc.current_stack.top.multiply(rotation);
            cc.current_stack.update();
        };
        math.glScalef = function(x, y, z) {
            var scaling = math.Matrix4.createByScale(x, y, z, tempMatrix);
            cc.current_stack.top.multiply(scaling);
            cc.current_stack.update();
        };
        math.glGetMatrix = function(mode, pOut) {
            switch (mode) {
              case math.KM_GL_MODELVIEW:
                pOut.assignFrom(math.modelview_matrix_stack.top);
                break;

              case math.KM_GL_PROJECTION:
                pOut.assignFrom(math.projection_matrix_stack.top);
                break;

              case math.KM_GL_TEXTURE:
                pOut.assignFrom(math.texture_matrix_stack.top);
                break;

              default:
                throw new Error("Invalid matrix mode specified");
            }
        };
    }), {} ],
    244: [ (function(require, module, exports) {
        require("./utility");
        require("./vec2");
        require("./vec3");
        require("./vec4");
        require("./ray2");
        require("./mat3");
        require("./mat4");
        require("./plane");
        require("./quaternion");
        require("./aabb");
        require("./gl/mat4stack");
        require("./gl/matrix");
    }), {
        "./aabb": 241,
        "./gl/mat4stack": 242,
        "./gl/matrix": 243,
        "./mat3": 245,
        "./mat4": 246,
        "./plane": 247,
        "./quaternion": 248,
        "./ray2": 249,
        "./utility": 250,
        "./vec2": 251,
        "./vec3": 252,
        "./vec4": 253
    } ],
    245: [ (function(require, module, exports) {
        window.Uint16Array = window.Uint16Array || window.Array;
        window.Float32Array = window.Float32Array || window.Array;
        cc.math.Matrix3 = function(mat3) {
            mat3 && mat3.mat ? this.mat = new Float32Array(mat3.mat) : this.mat = new Float32Array(9);
        };
        var proto = cc.math.Matrix3.prototype;
        proto.fill = function(mat3) {
            var mat = this.mat, matIn = mat3.mat;
            mat[0] = matIn[0];
            mat[1] = matIn[1];
            mat[2] = matIn[2];
            mat[3] = matIn[3];
            mat[4] = matIn[4];
            mat[5] = matIn[5];
            mat[6] = matIn[6];
            mat[7] = matIn[7];
            mat[8] = matIn[8];
            return this;
        };
        proto.adjugate = function() {
            var mat = this.mat;
            var m0 = mat[0], m1 = mat[1], m2 = mat[2], m3 = mat[3], m4 = mat[4], m5 = mat[5], m6 = mat[6], m7 = mat[7], m8 = mat[8];
            mat[0] = m4 * m8 - m5 * m7;
            mat[1] = m2 * m7 - m1 * m8;
            mat[2] = m1 * m5 - m2 * m4;
            mat[3] = m5 * m6 - m3 * m8;
            mat[4] = m0 * m8 - m2 * m6;
            mat[5] = m2 * m3 - m0 * m5;
            mat[6] = m3 * m7 - m4 * m6;
            mat[8] = m0 * m4 - m1 * m3;
            return this;
        };
        proto.identity = function() {
            var mat = this.mat;
            mat[1] = mat[2] = mat[3] = mat[5] = mat[6] = mat[7] = 0;
            mat[0] = mat[4] = mat[8] = 1;
            return this;
        };
        var tmpMatrix = new cc.math.Matrix3();
        proto.inverse = function(determinate) {
            if (0 === determinate) {
                return this;
            }
            tmpMatrix.assignFrom(this);
            var detInv = 1 / determinate;
            this.adjugate();
            this.multiplyScalar(detInv);
            return this;
        };
        proto.isIdentity = function() {
            var mat = this.mat;
            return 1 === mat[0] && 0 === mat[1] && 0 === mat[2] && 0 === mat[3] && 1 === mat[4] && 0 === mat[5] && 0 === mat[6] && 0 === mat[7] && 1 === mat[8];
        };
        proto.transpose = function() {
            var mat = this.mat;
            var m1 = mat[1], m2 = mat[2], m3 = mat[3], m5 = mat[5], m6 = mat[6], m7 = mat[7];
            mat[1] = m3;
            mat[2] = m6;
            mat[3] = m1;
            mat[5] = m7;
            mat[6] = m2;
            mat[7] = m5;
            return this;
        };
        proto.determinant = function() {
            var mat = this.mat;
            var output = mat[0] * mat[4] * mat[8] + mat[1] * mat[5] * mat[6] + mat[2] * mat[3] * mat[7];
            output -= mat[2] * mat[4] * mat[6] + mat[0] * mat[5] * mat[7] + mat[1] * mat[3] * mat[8];
            return output;
        };
        proto.multiply = function(mat3) {
            var m1 = this.mat, m2 = mat3.mat;
            var a0 = m1[0], a1 = m1[1], a2 = m1[2], a3 = m1[3], a4 = m1[4], a5 = m1[5], a6 = m1[6], a7 = m1[7], a8 = m1[8];
            var b0 = m2[0], b1 = m2[1], b2 = m2[2], b3 = m2[3], b4 = m2[4], b5 = m2[5], b6 = m2[6], b7 = m2[7], b8 = m2[8];
            m1[0] = a0 * b0 + a3 * b1 + a6 * b2;
            m1[1] = a1 * b0 + a4 * b1 + a7 * b2;
            m1[2] = a2 * b0 + a5 * b1 + a8 * b2;
            m1[3] = a2 * b0 + a5 * b1 + a8 * b2;
            m1[4] = a1 * b3 + a4 * b4 + a7 * b5;
            m1[5] = a2 * b3 + a5 * b4 + a8 * b5;
            m1[6] = a0 * b6 + a3 * b7 + a6 * b8;
            m1[7] = a1 * b6 + a4 * b7 + a7 * b8;
            m1[8] = a2 * b6 + a5 * b7 + a8 * b8;
            return this;
        };
        proto.multiplyScalar = function(factor) {
            var mat = this.mat;
            mat[0] *= factor;
            mat[1] *= factor;
            mat[2] *= factor;
            mat[3] *= factor;
            mat[4] *= factor;
            mat[5] *= factor;
            mat[6] *= factor;
            mat[7] *= factor;
            mat[8] *= factor;
            return this;
        };
        cc.math.Matrix3.rotationAxisAngle = function(axis, radians) {
            var rcos = Math.cos(radians), rsin = Math.sin(radians);
            var retMat = new cc.math.Matrix3();
            var mat = retMat.mat;
            mat[0] = rcos + axis.x * axis.x * (1 - rcos);
            mat[1] = axis.z * rsin + axis.y * axis.x * (1 - rcos);
            mat[2] = -axis.y * rsin + axis.z * axis.x * (1 - rcos);
            mat[3] = -axis.z * rsin + axis.x * axis.y * (1 - rcos);
            mat[4] = rcos + axis.y * axis.y * (1 - rcos);
            mat[5] = axis.x * rsin + axis.z * axis.y * (1 - rcos);
            mat[6] = axis.y * rsin + axis.x * axis.z * (1 - rcos);
            mat[7] = -axis.x * rsin + axis.y * axis.z * (1 - rcos);
            mat[8] = rcos + axis.z * axis.z * (1 - rcos);
            return retMat;
        };
        proto.assignFrom = function(matIn) {
            if (this === matIn) {
                cc.logID(7900);
                return this;
            }
            var mat = this.mat, m2 = matIn.mat;
            mat[0] = m2[0];
            mat[1] = m2[1];
            mat[2] = m2[2];
            mat[3] = m2[3];
            mat[4] = m2[4];
            mat[5] = m2[5];
            mat[6] = m2[6];
            mat[7] = m2[7];
            mat[8] = m2[8];
            return this;
        };
        proto.equals = function(mat3) {
            if (this === mat3) {
                return true;
            }
            var EPSILON = cc.math.EPSILON, m1 = this.mat, m2 = mat3.mat;
            for (var i = 0; i < 9; ++i) {
                if (!(m1[i] + EPSILON > m2[i] && m1[i] - EPSILON < m2[i])) {
                    return false;
                }
            }
            return true;
        };
        cc.math.Matrix3.createByRotationX = function(radians) {
            var retMat = new cc.math.Matrix3(), mat = retMat.mat;
            mat[0] = 1;
            mat[1] = 0;
            mat[2] = 0;
            mat[3] = 0;
            mat[4] = Math.cos(radians);
            mat[5] = Math.sin(radians);
            mat[6] = 0;
            mat[7] = -Math.sin(radians);
            mat[8] = Math.cos(radians);
            return retMat;
        };
        cc.math.Matrix3.createByRotationY = function(radians) {
            var retMat = new cc.math.Matrix3(), mat = retMat.mat;
            mat[0] = Math.cos(radians);
            mat[1] = 0;
            mat[2] = -Math.sin(radians);
            mat[3] = 0;
            mat[4] = 1;
            mat[5] = 0;
            mat[6] = Math.sin(radians);
            mat[7] = 0;
            mat[8] = Math.cos(radians);
            return retMat;
        };
        cc.math.Matrix3.createByRotationZ = function(radians) {
            var retMat = new cc.math.Matrix3(), mat = retMat.mat;
            mat[0] = Math.cos(radians);
            mat[1] = -Math.sin(radians);
            mat[2] = 0;
            mat[3] = Math.sin(radians);
            mat[4] = Math.cos(radians);
            mat[5] = 0;
            mat[6] = 0;
            mat[7] = 0;
            mat[8] = 1;
            return retMat;
        };
        cc.math.Matrix3.createByRotation = function(radians) {
            var retMat = new cc.math.Matrix3(), mat = retMat.mat;
            mat[0] = Math.cos(radians);
            mat[1] = Math.sin(radians);
            mat[2] = 0;
            mat[3] = -Math.sin(radians);
            mat[4] = Math.cos(radians);
            mat[5] = 0;
            mat[6] = 0;
            mat[7] = 0;
            mat[8] = 1;
            return retMat;
        };
        cc.math.Matrix3.createByScale = function(x, y) {
            var ret = new cc.math.Matrix3();
            ret.identity();
            ret.mat[0] = x;
            ret.mat[4] = y;
            return ret;
        };
        cc.math.Matrix3.createByTranslation = function(x, y) {
            var ret = new cc.math.Matrix3();
            ret.identity();
            ret.mat[6] = x;
            ret.mat[7] = y;
            return ret;
        };
        cc.math.Matrix3.createByQuaternion = function(quaternion) {
            if (!quaternion) {
                return null;
            }
            var ret = new cc.math.Matrix3(), mat = ret.mat;
            mat[0] = 1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);
            mat[1] = 2 * (quaternion.x * quaternion.y - quaternion.w * quaternion.z);
            mat[2] = 2 * (quaternion.x * quaternion.z + quaternion.w * quaternion.y);
            mat[3] = 2 * (quaternion.x * quaternion.y + quaternion.w * quaternion.z);
            mat[4] = 1 - 2 * (quaternion.x * quaternion.x + quaternion.z * quaternion.z);
            mat[5] = 2 * (quaternion.y * quaternion.z - quaternion.w * quaternion.x);
            mat[6] = 2 * (quaternion.x * quaternion.z - quaternion.w * quaternion.y);
            mat[7] = 2 * (quaternion.y * quaternion.z + quaternion.w * quaternion.x);
            mat[8] = 1 - 2 * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);
            return ret;
        };
        proto.rotationToAxisAngle = function() {
            return cc.math.Quaternion.rotationMatrix(this).toAxisAndAngle();
        };
    }), {} ],
    246: [ (function(require, module, exports) {
        cc.math.Matrix4 = function(mat4) {
            mat4 && mat4.mat ? this.mat = new Float32Array(mat4.mat) : this.mat = new Float32Array(16);
        };
        var proto = cc.math.Matrix4.prototype;
        proto.fill = function(scalarArr) {
            var mat = this.mat;
            for (var i = 0; i < 16; i++) {
                mat[i] = scalarArr[i];
            }
            return this;
        };
        cc.math.mat4Identity = function(pOut) {
            var mat = pOut.mat;
            mat[1] = mat[2] = mat[3] = mat[4] = mat[6] = mat[7] = mat[8] = mat[9] = mat[11] = mat[12] = mat[13] = mat[14] = 0;
            mat[0] = mat[5] = mat[10] = mat[15] = 1;
            return pOut;
        };
        proto.identity = function() {
            var mat = this.mat;
            mat[1] = mat[2] = mat[3] = mat[4] = mat[6] = mat[7] = mat[8] = mat[9] = mat[11] = mat[12] = mat[13] = mat[14] = 0;
            mat[0] = mat[5] = mat[10] = mat[15] = 1;
            return this;
        };
        proto.get = function(row, col) {
            return this.mat[row + 4 * col];
        };
        proto.set = function(row, col, value) {
            this.mat[row + 4 * col] = value;
        };
        proto.swap = function(r1, c1, r2, c2) {
            var mat = this.mat, tmp = mat[r1 + 4 * c1];
            mat[r1 + 4 * c1] = mat[r2 + 4 * c2];
            mat[r2 + 4 * c2] = tmp;
        };
        cc.math.Matrix4._gaussj = function(a, b) {
            var i, icol = 0, irow = 0, j, k, l, ll, n = 4, m = 4, selElement;
            var big, dum, pivinv;
            var indxc = [ 0, 0, 0, 0 ], indxr = [ 0, 0, 0, 0 ], ipiv = [ 0, 0, 0, 0 ];
            for (i = 0; i < n; i++) {
                big = 0;
                for (j = 0; j < n; j++) {
                    if (1 !== ipiv[j]) {
                        for (k = 0; k < n; k++) {
                            if (0 === ipiv[k]) {
                                selElement = Math.abs(a.get(j, k));
                                if (selElement >= big) {
                                    big = selElement;
                                    irow = j;
                                    icol = k;
                                }
                            }
                        }
                    }
                }
                ++ipiv[icol];
                if (irow !== icol) {
                    for (l = 0; l < n; l++) {
                        a.swap(irow, l, icol, l);
                    }
                    for (l = 0; l < m; l++) {
                        b.swap(irow, l, icol, l);
                    }
                }
                indxr[i] = irow;
                indxc[i] = icol;
                if (0 === a.get(icol, icol)) {
                    return false;
                }
                pivinv = 1 / a.get(icol, icol);
                a.set(icol, icol, 1);
                for (l = 0; l < n; l++) {
                    a.set(icol, l, a.get(icol, l) * pivinv);
                }
                for (l = 0; l < m; l++) {
                    b.set(icol, l, b.get(icol, l) * pivinv);
                }
                for (ll = 0; ll < n; ll++) {
                    if (ll !== icol) {
                        dum = a.get(ll, icol);
                        a.set(ll, icol, 0);
                        for (l = 0; l < n; l++) {
                            a.set(ll, l, a.get(ll, l) - a.get(icol, l) * dum);
                        }
                        for (l = 0; l < m; l++) {
                            b.set(ll, l, a.get(ll, l) - b.get(icol, l) * dum);
                        }
                    }
                }
            }
            for (l = n - 1; l >= 0; l--) {
                if (indxr[l] !== indxc[l]) {
                    for (k = 0; k < n; k++) {
                        a.swap(k, indxr[l], k, indxc[l]);
                    }
                }
            }
            return true;
        };
        var identityMatrix = new cc.math.Matrix4().identity();
        cc.math.mat4Inverse = function(pOut, pM) {
            var inv = new cc.math.Matrix4(pM);
            var tmp = new cc.math.Matrix4(identityMatrix);
            if (false === cc.math.Matrix4._gaussj(inv, tmp)) {
                return null;
            }
            pOut.assignFrom(inv);
            return pOut;
        };
        proto.inverse = function() {
            var inv = new cc.math.Matrix4(this);
            var tmp = new cc.math.Matrix4(identityMatrix);
            if (false === cc.math.Matrix4._gaussj(inv, tmp)) {
                return null;
            }
            return inv;
        };
        proto.isIdentity = function() {
            var mat = this.mat;
            return 1 === mat[0] && 0 === mat[1] && 0 === mat[2] && 0 === mat[3] && 0 === mat[4] && 1 === mat[5] && 0 === mat[6] && 0 === mat[7] && 0 === mat[8] && 0 === mat[9] && 1 === mat[10] && 0 === mat[11] && 0 === mat[12] && 0 === mat[13] && 0 === mat[14] && 1 === mat[15];
        };
        proto.transpose = function() {
            var mat = this.mat;
            var m1 = mat[1], m2 = mat[2], m3 = mat[3], m4 = mat[4], m6 = mat[6], m7 = mat[7], m8 = mat[8], m9 = mat[9], m11 = mat[11], m12 = mat[12], m13 = mat[13], m14 = mat[14];
            mat[1] = m4;
            mat[2] = m8;
            mat[3] = m12;
            mat[4] = m1;
            mat[6] = m9;
            mat[7] = m13;
            mat[8] = m2;
            mat[9] = m6;
            mat[11] = m14;
            mat[12] = m3;
            mat[13] = m7;
            mat[14] = m11;
            return this;
        };
        cc.math.mat4Multiply = function(pOut, pM1, pM2) {
            var outArray = pOut.mat, mat1 = pM1.mat, mat2 = pM2.mat;
            var a00 = mat1[0], a01 = mat1[1], a02 = mat1[2], a03 = mat1[3];
            var a10 = mat1[4], a11 = mat1[5], a12 = mat1[6], a13 = mat1[7];
            var a20 = mat1[8], a21 = mat1[9], a22 = mat1[10], a23 = mat1[11];
            var a30 = mat1[12], a31 = mat1[13], a32 = mat1[14], a33 = mat1[15];
            var b00 = mat2[0], b01 = mat2[1], b02 = mat2[2], b03 = mat2[3];
            var b10 = mat2[4], b11 = mat2[5], b12 = mat2[6], b13 = mat2[7];
            var b20 = mat2[8], b21 = mat2[9], b22 = mat2[10], b23 = mat2[11];
            var b30 = mat2[12], b31 = mat2[13], b32 = mat2[14], b33 = mat2[15];
            outArray[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
            outArray[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
            outArray[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
            outArray[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
            outArray[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
            outArray[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
            outArray[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
            outArray[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
            outArray[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
            outArray[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
            outArray[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
            outArray[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
            outArray[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
            outArray[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
            outArray[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
            outArray[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
            return pOut;
        };
        proto.multiply = function(mat4) {
            var mat = this.mat, mat2 = mat4.mat;
            var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
            var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
            var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
            var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];
            var b00 = mat2[0], b01 = mat2[1], b02 = mat2[2], b03 = mat2[3];
            var b10 = mat2[4], b11 = mat2[5], b12 = mat2[6], b13 = mat2[7];
            var b20 = mat2[8], b21 = mat2[9], b22 = mat2[10], b23 = mat2[11];
            var b30 = mat2[12], b31 = mat2[13], b32 = mat2[14], b33 = mat2[15];
            mat[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
            mat[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
            mat[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
            mat[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
            mat[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
            mat[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
            mat[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
            mat[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
            mat[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
            mat[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
            mat[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
            mat[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
            mat[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
            mat[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
            mat[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
            mat[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
            return this;
        };
        cc.math.getMat4MultiplyValue = function(pM1, pM2) {
            var m1 = pM1.mat, m2 = pM2.mat;
            var mat = new Float32Array(16);
            mat[0] = m1[0] * m2[0] + m1[4] * m2[1] + m1[8] * m2[2] + m1[12] * m2[3];
            mat[1] = m1[1] * m2[0] + m1[5] * m2[1] + m1[9] * m2[2] + m1[13] * m2[3];
            mat[2] = m1[2] * m2[0] + m1[6] * m2[1] + m1[10] * m2[2] + m1[14] * m2[3];
            mat[3] = m1[3] * m2[0] + m1[7] * m2[1] + m1[11] * m2[2] + m1[15] * m2[3];
            mat[4] = m1[0] * m2[4] + m1[4] * m2[5] + m1[8] * m2[6] + m1[12] * m2[7];
            mat[5] = m1[1] * m2[4] + m1[5] * m2[5] + m1[9] * m2[6] + m1[13] * m2[7];
            mat[6] = m1[2] * m2[4] + m1[6] * m2[5] + m1[10] * m2[6] + m1[14] * m2[7];
            mat[7] = m1[3] * m2[4] + m1[7] * m2[5] + m1[11] * m2[6] + m1[15] * m2[7];
            mat[8] = m1[0] * m2[8] + m1[4] * m2[9] + m1[8] * m2[10] + m1[12] * m2[11];
            mat[9] = m1[1] * m2[8] + m1[5] * m2[9] + m1[9] * m2[10] + m1[13] * m2[11];
            mat[10] = m1[2] * m2[8] + m1[6] * m2[9] + m1[10] * m2[10] + m1[14] * m2[11];
            mat[11] = m1[3] * m2[8] + m1[7] * m2[9] + m1[11] * m2[10] + m1[15] * m2[11];
            mat[12] = m1[0] * m2[12] + m1[4] * m2[13] + m1[8] * m2[14] + m1[12] * m2[15];
            mat[13] = m1[1] * m2[12] + m1[5] * m2[13] + m1[9] * m2[14] + m1[13] * m2[15];
            mat[14] = m1[2] * m2[12] + m1[6] * m2[13] + m1[10] * m2[14] + m1[14] * m2[15];
            mat[15] = m1[3] * m2[12] + m1[7] * m2[13] + m1[11] * m2[14] + m1[15] * m2[15];
            return mat;
        };
        cc.math.mat4Assign = function(pOut, pIn) {
            if (pOut === pIn) {
                cc.logID(7901);
                return pOut;
            }
            var outArr = pOut.mat;
            var inArr = pIn.mat;
            outArr[0] = inArr[0];
            outArr[1] = inArr[1];
            outArr[2] = inArr[2];
            outArr[3] = inArr[3];
            outArr[4] = inArr[4];
            outArr[5] = inArr[5];
            outArr[6] = inArr[6];
            outArr[7] = inArr[7];
            outArr[8] = inArr[8];
            outArr[9] = inArr[9];
            outArr[10] = inArr[10];
            outArr[11] = inArr[11];
            outArr[12] = inArr[12];
            outArr[13] = inArr[13];
            outArr[14] = inArr[14];
            outArr[15] = inArr[15];
            return pOut;
        };
        proto.assignFrom = function(mat4) {
            if (this === mat4) {
                cc.logID(7902);
                return this;
            }
            var outArr = this.mat, inArr = mat4.mat;
            outArr[0] = inArr[0];
            outArr[1] = inArr[1];
            outArr[2] = inArr[2];
            outArr[3] = inArr[3];
            outArr[4] = inArr[4];
            outArr[5] = inArr[5];
            outArr[6] = inArr[6];
            outArr[7] = inArr[7];
            outArr[8] = inArr[8];
            outArr[9] = inArr[9];
            outArr[10] = inArr[10];
            outArr[11] = inArr[11];
            outArr[12] = inArr[12];
            outArr[13] = inArr[13];
            outArr[14] = inArr[14];
            outArr[15] = inArr[15];
            return this;
        };
        proto.equals = function(mat4) {
            if (this === mat4) {
                cc.logID(7903);
                return true;
            }
            var matA = this.mat, matB = mat4.mat, EPSILON = cc.math.EPSILON;
            for (var i = 0; i < 16; i++) {
                if (!(matA[i] + EPSILON > matB[i] && matA[i] - EPSILON < matB[i])) {
                    return false;
                }
            }
            return true;
        };
        cc.math.Matrix4.createByRotationX = function(radians, matrix) {
            matrix = matrix || new cc.math.Matrix4();
            var mat = matrix.mat;
            mat[0] = 1;
            mat[3] = mat[2] = mat[1] = 0;
            mat[4] = 0;
            mat[5] = Math.cos(radians);
            mat[6] = Math.sin(radians);
            mat[7] = 0;
            mat[8] = 0;
            mat[9] = -Math.sin(radians);
            mat[10] = Math.cos(radians);
            mat[11] = 0;
            mat[14] = mat[13] = mat[12] = 0;
            mat[15] = 1;
            return matrix;
        };
        cc.math.Matrix4.createByRotationY = function(radians, matrix) {
            matrix = matrix || new cc.math.Matrix4();
            var mat = matrix.mat;
            mat[0] = Math.cos(radians);
            mat[1] = 0;
            mat[2] = -Math.sin(radians);
            mat[3] = 0;
            mat[7] = mat[6] = mat[4] = 0;
            mat[5] = 1;
            mat[8] = Math.sin(radians);
            mat[9] = 0;
            mat[10] = Math.cos(radians);
            mat[11] = 0;
            mat[14] = mat[13] = mat[12] = 0;
            mat[15] = 1;
            return matrix;
        };
        cc.math.Matrix4.createByRotationZ = function(radians, matrix) {
            matrix = matrix || new cc.math.Matrix4();
            var mat = matrix.mat;
            mat[0] = Math.cos(radians);
            mat[1] = Math.sin(radians);
            mat[3] = mat[2] = 0;
            mat[4] = -Math.sin(radians);
            mat[5] = Math.cos(radians);
            mat[7] = mat[6] = 0;
            mat[11] = mat[9] = mat[8] = 0;
            mat[10] = 1;
            mat[14] = mat[13] = mat[12] = 0;
            mat[15] = 1;
            return matrix;
        };
        cc.math.Matrix4.createByPitchYawRoll = function(pitch, yaw, roll, matrix) {
            matrix = matrix || new cc.math.Matrix4();
            var cr = Math.cos(pitch), sr = Math.sin(pitch);
            var cp = Math.cos(yaw), sp = Math.sin(yaw);
            var cy = Math.cos(roll), sy = Math.sin(roll);
            var srsp = sr * sp, crsp = cr * sp;
            var mat = matrix.mat;
            mat[0] = cp * cy;
            mat[4] = cp * sy;
            mat[8] = -sp;
            mat[1] = srsp * cy - cr * sy;
            mat[5] = srsp * sy + cr * cy;
            mat[9] = sr * cp;
            mat[2] = crsp * cy + sr * sy;
            mat[6] = crsp * sy - sr * cy;
            mat[10] = cr * cp;
            mat[3] = mat[7] = mat[11] = 0;
            mat[15] = 1;
            return matrix;
        };
        cc.math.Matrix4.createByQuaternion = function(quaternion, matrix) {
            matrix = matrix || new cc.math.Matrix4();
            var mat = matrix.mat;
            mat[0] = 1 - 2 * (quaternion.y * quaternion.y + quaternion.z * quaternion.z);
            mat[1] = 2 * (quaternion.x * quaternion.y + quaternion.z * quaternion.w);
            mat[2] = 2 * (quaternion.x * quaternion.z - quaternion.y * quaternion.w);
            mat[3] = 0;
            mat[4] = 2 * (quaternion.x * quaternion.y - quaternion.z * quaternion.w);
            mat[5] = 1 - 2 * (quaternion.x * quaternion.x + quaternion.z * quaternion.z);
            mat[6] = 2 * (quaternion.z * quaternion.y + quaternion.x * quaternion.w);
            mat[7] = 0;
            mat[8] = 2 * (quaternion.x * quaternion.z + quaternion.y * quaternion.w);
            mat[9] = 2 * (quaternion.y * quaternion.z - quaternion.x * quaternion.w);
            mat[10] = 1 - 2 * (quaternion.x * quaternion.x + quaternion.y * quaternion.y);
            mat[11] = 0;
            mat[14] = mat[13] = mat[12] = 0;
            mat[15] = 1;
            return matrix;
        };
        cc.math.Matrix4.createByRotationTranslation = function(rotation, translation, matrix) {
            matrix = matrix || new cc.math.Matrix4();
            var mat = matrix.mat, rMat = rotation.mat;
            mat[0] = rMat[0];
            mat[1] = rMat[1];
            mat[2] = rMat[2];
            mat[3] = 0;
            mat[4] = rMat[3];
            mat[5] = rMat[4];
            mat[6] = rMat[5];
            mat[7] = 0;
            mat[8] = rMat[6];
            mat[9] = rMat[7];
            mat[10] = rMat[8];
            mat[11] = 0;
            mat[12] = translation.x;
            mat[13] = translation.y;
            mat[14] = translation.z;
            mat[15] = 1;
            return matrix;
        };
        cc.math.Matrix4.createByScale = function(x, y, z, matrix) {
            matrix = matrix || new cc.math.Matrix4();
            var mat = matrix.mat;
            mat[0] = x;
            mat[5] = y;
            mat[10] = z;
            mat[15] = 1;
            mat[1] = mat[2] = mat[3] = mat[4] = mat[6] = mat[7] = mat[8] = mat[9] = mat[11] = mat[12] = mat[13] = mat[14] = 0;
            return matrix;
        };
        cc.math.mat4Translation = function(pOut, x, y, z) {
            pOut.mat[0] = pOut.mat[5] = pOut.mat[10] = pOut.mat[15] = 1;
            pOut.mat[1] = pOut.mat[2] = pOut.mat[3] = pOut.mat[4] = pOut.mat[6] = pOut.mat[7] = pOut.mat[8] = pOut.mat[9] = pOut.mat[11] = 0;
            pOut.mat[12] = x;
            pOut.mat[13] = y;
            pOut.mat[14] = z;
            return pOut;
        };
        cc.math.Matrix4.createByTranslation = function(x, y, z, matrix) {
            matrix = matrix || new cc.math.Matrix4();
            matrix.identity();
            matrix.mat[12] = x;
            matrix.mat[13] = y;
            matrix.mat[14] = z;
            return matrix;
        };
        proto.getUpVec3 = function() {
            var mat = this.mat;
            var ret = new cc.math.Vec3(mat[4], mat[5], mat[6]);
            return ret.normalize();
        };
        proto.getRightVec3 = function() {
            var mat = this.mat;
            var ret = new cc.math.Vec3(mat[0], mat[1], mat[2]);
            return ret.normalize();
        };
        proto.getForwardVec3 = function() {
            var mat = this.mat;
            var ret = new cc.math.Vec3(mat[8], mat[9], mat[10]);
            return ret.normalize();
        };
        cc.math.mat4PerspectiveProjection = function(pOut, fovY, aspect, zNear, zFar) {
            var r = cc.degreesToRadians(fovY / 2);
            var deltaZ = zFar - zNear;
            var s = Math.sin(r);
            if (0 === deltaZ || 0 === s || 0 === aspect) {
                return null;
            }
            var cotangent = Math.cos(r) / s;
            pOut.identity();
            pOut.mat[0] = cotangent / aspect;
            pOut.mat[5] = cotangent;
            pOut.mat[10] = -(zFar + zNear) / deltaZ;
            pOut.mat[11] = -1;
            pOut.mat[14] = -2 * zNear * zFar / deltaZ;
            pOut.mat[15] = 0;
            return pOut;
        };
        cc.math.Matrix4.createPerspectiveProjection = function(fovY, aspect, zNear, zFar) {
            var r = cc.degreesToRadians(fovY / 2), deltaZ = zFar - zNear;
            var s = Math.sin(r);
            if (0 === deltaZ || 0 === s || 0 === aspect) {
                return null;
            }
            var cotangent = Math.cos(r) / s;
            var matrix = new cc.math.Matrix4(), mat = matrix.mat;
            matrix.identity();
            mat[0] = cotangent / aspect;
            mat[5] = cotangent;
            mat[10] = -(zFar + zNear) / deltaZ;
            mat[11] = -1;
            mat[14] = -2 * zNear * zFar / deltaZ;
            mat[15] = 0;
            return matrix;
        };
        cc.math.mat4OrthographicProjection = function(pOut, left, right, bottom, top, nearVal, farVal) {
            pOut.identity();
            pOut.mat[0] = 2 / (right - left);
            pOut.mat[5] = 2 / (top - bottom);
            pOut.mat[10] = -2 / (farVal - nearVal);
            pOut.mat[12] = -((right + left) / (right - left));
            pOut.mat[13] = -((top + bottom) / (top - bottom));
            pOut.mat[14] = -((farVal + nearVal) / (farVal - nearVal));
            return pOut;
        };
        cc.math.Matrix4.createOrthographicProjection = function(left, right, bottom, top, nearVal, farVal) {
            var matrix = new cc.math.Matrix4(), mat = matrix.mat;
            matrix.identity();
            mat[0] = 2 / (right - left);
            mat[5] = 2 / (top - bottom);
            mat[10] = -2 / (farVal - nearVal);
            mat[12] = -((right + left) / (right - left));
            mat[13] = -((top + bottom) / (top - bottom));
            mat[14] = -((farVal + nearVal) / (farVal - nearVal));
            return matrix;
        };
        cc.math.mat4LookAt = function(pOut, pEye, pCenter, pUp) {
            var f = new cc.math.Vec3(pCenter), up = new cc.math.Vec3(pUp);
            f.subtract(pEye);
            f.normalize();
            up.normalize();
            var s = new cc.math.Vec3(f);
            s.cross(up);
            s.normalize();
            var u = new cc.math.Vec3(s);
            u.cross(f);
            s.normalize();
            pOut.identity();
            pOut.mat[0] = s.x;
            pOut.mat[4] = s.y;
            pOut.mat[8] = s.z;
            pOut.mat[1] = u.x;
            pOut.mat[5] = u.y;
            pOut.mat[9] = u.z;
            pOut.mat[2] = -f.x;
            pOut.mat[6] = -f.y;
            pOut.mat[10] = -f.z;
            var translate = cc.math.Matrix4.createByTranslation(-pEye.x, -pEye.y, -pEye.z);
            pOut.multiply(translate);
            return pOut;
        };
        var tempMatrix = new cc.math.Matrix4();
        proto.lookAt = function(eyeVec, centerVec, upVec) {
            var f = new cc.math.Vec3(centerVec), up = new cc.math.Vec3(upVec), mat = this.mat;
            f.subtract(eyeVec);
            f.normalize();
            up.normalize();
            var s = new cc.math.Vec3(f);
            s.cross(up);
            s.normalize();
            var u = new cc.math.Vec3(s);
            u.cross(f);
            s.normalize();
            this.identity();
            mat[0] = s.x;
            mat[4] = s.y;
            mat[8] = s.z;
            mat[1] = u.x;
            mat[5] = u.y;
            mat[9] = u.z;
            mat[2] = -f.x;
            mat[6] = -f.y;
            mat[10] = -f.z;
            tempMatrix = cc.math.Matrix4.createByTranslation(-eyeVec.x, -eyeVec.y, -eyeVec.z, tempMatrix);
            this.multiply(tempMatrix);
            return this;
        };
        cc.math.mat4RotationAxisAngle = function(pOut, axis, radians) {
            var rcos = Math.cos(radians), rsin = Math.sin(radians);
            var normalizedAxis = new cc.math.Vec3(axis);
            normalizedAxis.normalize();
            pOut.mat[0] = rcos + normalizedAxis.x * normalizedAxis.x * (1 - rcos);
            pOut.mat[1] = normalizedAxis.z * rsin + normalizedAxis.y * normalizedAxis.x * (1 - rcos);
            pOut.mat[2] = -normalizedAxis.y * rsin + normalizedAxis.z * normalizedAxis.x * (1 - rcos);
            pOut.mat[3] = 0;
            pOut.mat[4] = -normalizedAxis.z * rsin + normalizedAxis.x * normalizedAxis.y * (1 - rcos);
            pOut.mat[5] = rcos + normalizedAxis.y * normalizedAxis.y * (1 - rcos);
            pOut.mat[6] = normalizedAxis.x * rsin + normalizedAxis.z * normalizedAxis.y * (1 - rcos);
            pOut.mat[7] = 0;
            pOut.mat[8] = normalizedAxis.y * rsin + normalizedAxis.x * normalizedAxis.z * (1 - rcos);
            pOut.mat[9] = -normalizedAxis.x * rsin + normalizedAxis.y * normalizedAxis.z * (1 - rcos);
            pOut.mat[10] = rcos + normalizedAxis.z * normalizedAxis.z * (1 - rcos);
            pOut.mat[11] = 0;
            pOut.mat[12] = 0;
            pOut.mat[13] = 0;
            pOut.mat[14] = 0;
            pOut.mat[15] = 1;
            return pOut;
        };
        cc.math.Matrix4.createByAxisAndAngle = function(axis, radians, matrix) {
            matrix = matrix || new cc.math.Matrix4();
            var mat = this.mat, rcos = Math.cos(radians), rsin = Math.sin(radians);
            var normalizedAxis = new cc.math.Vec3(axis);
            normalizedAxis.normalize();
            mat[0] = rcos + normalizedAxis.x * normalizedAxis.x * (1 - rcos);
            mat[1] = normalizedAxis.z * rsin + normalizedAxis.y * normalizedAxis.x * (1 - rcos);
            mat[2] = -normalizedAxis.y * rsin + normalizedAxis.z * normalizedAxis.x * (1 - rcos);
            mat[3] = 0;
            mat[4] = -normalizedAxis.z * rsin + normalizedAxis.x * normalizedAxis.y * (1 - rcos);
            mat[5] = rcos + normalizedAxis.y * normalizedAxis.y * (1 - rcos);
            mat[6] = normalizedAxis.x * rsin + normalizedAxis.z * normalizedAxis.y * (1 - rcos);
            mat[7] = 0;
            mat[8] = normalizedAxis.y * rsin + normalizedAxis.x * normalizedAxis.z * (1 - rcos);
            mat[9] = -normalizedAxis.x * rsin + normalizedAxis.y * normalizedAxis.z * (1 - rcos);
            mat[10] = rcos + normalizedAxis.z * normalizedAxis.z * (1 - rcos);
            mat[11] = 0;
            mat[12] = mat[13] = mat[14] = 0;
            mat[15] = 1;
            return matrix;
        };
        proto.extractRotation = function() {
            var matrix = new cc.math.Matrix3(), mat4 = this.mat, mat3 = matrix.mat;
            mat3[0] = mat4[0];
            mat3[1] = mat4[1];
            mat3[2] = mat4[2];
            mat3[3] = mat4[4];
            mat3[4] = mat4[5];
            mat3[5] = mat4[6];
            mat3[6] = mat4[8];
            mat3[7] = mat4[9];
            mat3[8] = mat4[10];
            return matrix;
        };
        proto.extractPlane = function(planeType) {
            var plane = new cc.math.Plane(), mat = this.mat;
            switch (planeType) {
              case cc.math.Plane.RIGHT:
                plane.a = mat[3] - mat[0];
                plane.b = mat[7] - mat[4];
                plane.c = mat[11] - mat[8];
                plane.d = mat[15] - mat[12];
                break;

              case cc.math.Plane.LEFT:
                plane.a = mat[3] + mat[0];
                plane.b = mat[7] + mat[4];
                plane.c = mat[11] + mat[8];
                plane.d = mat[15] + mat[12];
                break;

              case cc.math.Plane.BOTTOM:
                plane.a = mat[3] + mat[1];
                plane.b = mat[7] + mat[5];
                plane.c = mat[11] + mat[9];
                plane.d = mat[15] + mat[13];
                break;

              case cc.math.Plane.TOP:
                plane.a = mat[3] - mat[1];
                plane.b = mat[7] - mat[5];
                plane.c = mat[11] - mat[9];
                plane.d = mat[15] - mat[13];
                break;

              case cc.math.Plane.FAR:
                plane.a = mat[3] - mat[2];
                plane.b = mat[7] - mat[6];
                plane.c = mat[11] - mat[10];
                plane.d = mat[15] - mat[14];
                break;

              case cc.math.Plane.NEAR:
                plane.a = mat[3] + mat[2];
                plane.b = mat[7] + mat[6];
                plane.c = mat[11] + mat[10];
                plane.d = mat[15] + mat[14];
                break;

              default:
                cc.logID(7904);
            }
            var t = Math.sqrt(plane.a * plane.a + plane.b * plane.b + plane.c * plane.c);
            plane.a /= t;
            plane.b /= t;
            plane.c /= t;
            plane.d /= t;
            return plane;
        };
        proto.toAxisAndAngle = function() {
            var rotation = this.extractRotation();
            var temp = cc.math.Quaternion.rotationMatrix(rotation);
            return temp.toAxisAndAngle();
        };
    }), {} ],
    247: [ (function(require, module, exports) {
        cc.math.Plane = function(a, b, c, d) {
            if (a && void 0 === b) {
                this.a = a.a;
                this.b = a.b;
                this.c = a.c;
                this.d = a.d;
            } else {
                this.a = a || 0;
                this.b = b || 0;
                this.c = c || 0;
                this.d = d || 0;
            }
        };
        var proto = cc.math.Plane.prototype;
        cc.math.Plane.LEFT = 0;
        cc.math.Plane.RIGHT = 1;
        cc.math.Plane.BOTTOM = 2;
        cc.math.Plane.TOP = 3;
        cc.math.Plane.NEAR = 4;
        cc.math.Plane.FAR = 5;
        cc.math.Plane.POINT_INFRONT_OF_PLANE = 0;
        cc.math.Plane.POINT_BEHIND_PLANE = 1;
        cc.math.Plane.POINT_ON_PLANE = 2;
        proto.dot = function(vec4) {
            return this.a * vec4.x + this.b * vec4.y + this.c * vec4.z + this.d * vec4.w;
        };
        proto.dotCoord = function(vec3) {
            return this.a * vec3.x + this.b * vec3.y + this.c * vec3.z + this.d;
        };
        proto.dotNormal = function(vec3) {
            return this.a * vec3.x + this.b * vec3.y + this.c * vec3.z;
        };
        cc.math.Plane.fromPointNormal = function(vec3, normal) {
            return new cc.math.Plane(normal.x, normal.y, normal.z, -normal.dot(vec3));
        };
        cc.math.Plane.fromPoints = function(vec1, vec2, vec3) {
            var v1 = new cc.math.Vec3(vec2), v2 = new cc.math.Vec3(vec3), plane = new cc.math.Plane();
            v1.subtract(vec1);
            v2.subtract(vec1);
            v1.cross(v2);
            v1.normalize();
            plane.a = v1.x;
            plane.b = v1.y;
            plane.c = v1.z;
            plane.d = v1.scale(-1).dot(vec1);
            return plane;
        };
        proto.normalize = function() {
            var n = new cc.math.Vec3(this.a, this.b, this.c), l = 1 / n.length();
            n.normalize();
            this.a = n.x;
            this.b = n.y;
            this.c = n.z;
            this.d = this.d * l;
            return this;
        };
        proto.classifyPoint = function(vec3) {
            var distance = this.a * vec3.x + this.b * vec3.y + this.c * vec3.z + this.d;
            if (distance > .001) {
                return cc.math.Plane.POINT_INFRONT_OF_PLANE;
            }
            if (distance < -.001) {
                return cc.math.Plane.POINT_BEHIND_PLANE;
            }
            return cc.math.Plane.POINT_ON_PLANE;
        };
    }), {} ],
    248: [ (function(require, module, exports) {
        cc.math.Quaternion = function(x, y, z, w) {
            if (x && void 0 === y) {
                this.x = x.x;
                this.y = x.y;
                this.z = x.z;
                this.w = x.w;
            } else {
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
                this.w = w || 0;
            }
        };
        var proto = cc.math.Quaternion.prototype;
        proto.conjugate = function(quaternion) {
            this.x = -quaternion.x;
            this.y = -quaternion.y;
            this.z = -quaternion.z;
            this.w = quaternion.w;
            return this;
        };
        proto.dot = function(quaternion) {
            return this.w * quaternion.w + this.x * quaternion.x + this.y * quaternion.y + this.z * quaternion.z;
        };
        proto.exponential = function() {
            return this;
        };
        proto.identity = function() {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;
            return this;
        };
        proto.inverse = function() {
            var len = this.length();
            if (Math.abs(len) > cc.math.EPSILON) {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 0;
                return this;
            }
            this.conjugate(this).scale(1 / len);
            return this;
        };
        proto.isIdentity = function() {
            return 0 === this.x && 0 === this.y && 0 === this.z && 1 === this.w;
        };
        proto.length = function() {
            return Math.sqrt(this.lengthSq());
        };
        proto.lengthSq = function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        };
        proto.multiply = function(quaternion) {
            var x = this.x, y = this.y, z = this.z, w = this.w;
            this.w = w * quaternion.w - x * quaternion.x - y * quaternion.y - z * quaternion.z;
            this.x = w * quaternion.x + x * quaternion.w + y * quaternion.z - z * quaternion.y;
            this.y = w * quaternion.y + y * quaternion.w + z * quaternion.x - x * quaternion.z;
            this.z = w * quaternion.z + z * quaternion.w + x * quaternion.y - y * quaternion.x;
            return this;
        };
        proto.normalize = function() {
            var length = this.length();
            if (Math.abs(length) <= cc.math.EPSILON) {
                throw new Error("current quaternion is an invalid value");
            }
            this.scale(1 / length);
            return this;
        };
        proto.rotationAxis = function(axis, angle) {
            var rad = .5 * angle, scale = Math.sin(rad);
            this.w = Math.cos(rad);
            this.x = axis.x * scale;
            this.y = axis.y * scale;
            this.z = axis.z * scale;
            return this;
        };
        cc.math.Quaternion.rotationMatrix = function(mat3) {
            if (!mat3) {
                return null;
            }
            var x, y, z, w;
            var m4x4 = [], mat = mat3.mat, scale = 0;
            m4x4[0] = mat[0];
            m4x4[1] = mat[3];
            m4x4[2] = mat[6];
            m4x4[4] = mat[1];
            m4x4[5] = mat[4];
            m4x4[6] = mat[7];
            m4x4[8] = mat[2];
            m4x4[9] = mat[5];
            m4x4[10] = mat[8];
            m4x4[15] = 1;
            var pMatrix = m4x4[0];
            var diagonal = pMatrix[0] + pMatrix[5] + pMatrix[10] + 1;
            if (diagonal > cc.math.EPSILON) {
                scale = 2 * Math.sqrt(diagonal);
                x = (pMatrix[9] - pMatrix[6]) / scale;
                y = (pMatrix[2] - pMatrix[8]) / scale;
                z = (pMatrix[4] - pMatrix[1]) / scale;
                w = .25 * scale;
            } else {
                if (pMatrix[0] > pMatrix[5] && pMatrix[0] > pMatrix[10]) {
                    scale = 2 * Math.sqrt(1 + pMatrix[0] - pMatrix[5] - pMatrix[10]);
                    x = .25 * scale;
                    y = (pMatrix[4] + pMatrix[1]) / scale;
                    z = (pMatrix[2] + pMatrix[8]) / scale;
                    w = (pMatrix[9] - pMatrix[6]) / scale;
                } else {
                    if (pMatrix[5] > pMatrix[10]) {
                        scale = 2 * Math.sqrt(1 + pMatrix[5] - pMatrix[0] - pMatrix[10]);
                        x = (pMatrix[4] + pMatrix[1]) / scale;
                        y = .25 * scale;
                        z = (pMatrix[9] + pMatrix[6]) / scale;
                        w = (pMatrix[2] - pMatrix[8]) / scale;
                    } else {
                        scale = 2 * Math.sqrt(1 + pMatrix[10] - pMatrix[0] - pMatrix[5]);
                        x = (pMatrix[2] + pMatrix[8]) / scale;
                        y = (pMatrix[9] + pMatrix[6]) / scale;
                        z = .25 * scale;
                        w = (pMatrix[4] - pMatrix[1]) / scale;
                    }
                }
            }
            return new cc.math.Quaternion(x, y, z, w);
        };
        cc.math.Quaternion.rotationYawPitchRoll = function(yaw, pitch, roll) {
            var ex, ey, ez;
            var cr, cp, cy, sr, sp, sy, cpcy, spsy;
            ex = cc.degreesToRadians(pitch) / 2;
            ey = cc.degreesToRadians(yaw) / 2;
            ez = cc.degreesToRadians(roll) / 2;
            cr = Math.cos(ex);
            cp = Math.cos(ey);
            cy = Math.cos(ez);
            sr = Math.sin(ex);
            sp = Math.sin(ey);
            sy = Math.sin(ez);
            cpcy = cp * cy;
            spsy = sp * sy;
            var ret = new cc.math.Quaternion();
            ret.w = cr * cpcy + sr * spsy;
            ret.x = sr * cpcy - cr * spsy;
            ret.y = cr * sp * cy + sr * cp * sy;
            ret.z = cr * cp * sy - sr * sp * cy;
            ret.normalize();
            return ret;
        };
        proto.slerp = function(quaternion, t) {
            if (this.x === quaternion.x && this.y === quaternion.y && this.z === quaternion.z && this.w === quaternion.w) {
                return this;
            }
            var ct = this.dot(quaternion), theta = Math.acos(ct), st = Math.sqrt(1 - cc.math.square(ct));
            var stt = Math.sin(t * theta) / st, somt = Math.sin((1 - t) * theta) / st;
            var temp2 = new cc.math.Quaternion(quaternion);
            this.scale(somt);
            temp2.scale(stt);
            this.add(temp2);
            return this;
        };
        proto.toAxisAndAngle = function() {
            var tempAngle;
            var scale;
            var retAngle, retAxis = new cc.math.Vec3();
            tempAngle = Math.acos(this.w);
            scale = Math.sqrt(cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z));
            if (scale > -cc.math.EPSILON && scale < cc.math.EPSILON || scale < 2 * Math.PI + cc.math.EPSILON && scale > 2 * Math.PI - cc.math.EPSILON) {
                retAngle = 0;
                retAxis.x = 0;
                retAxis.y = 0;
                retAxis.z = 1;
            } else {
                retAngle = 2 * tempAngle;
                retAxis.x = this.x / scale;
                retAxis.y = this.y / scale;
                retAxis.z = this.z / scale;
                retAxis.normalize();
            }
            return {
                axis: retAxis,
                angle: retAngle
            };
        };
        proto.scale = function(scale) {
            this.x *= scale;
            this.y *= scale;
            this.z *= scale;
            this.w *= scale;
            return this;
        };
        proto.assignFrom = function(quaternion) {
            this.x = quaternion.x;
            this.y = quaternion.y;
            this.z = quaternion.z;
            this.w = quaternion.w;
            return this;
        };
        proto.add = function(quaternion) {
            this.x += quaternion.x;
            this.y += quaternion.y;
            this.z += quaternion.z;
            this.w += quaternion.w;
            return this;
        };
        cc.math.Quaternion.rotationBetweenVec3 = function(vec1, vec2, fallback) {
            var v1 = new cc.math.Vec3(vec1), v2 = new cc.math.Vec3(vec2);
            v1.normalize();
            v2.normalize();
            var a = v1.dot(v2), quaternion = new cc.math.Quaternion();
            if (a >= 1) {
                quaternion.identity();
                return quaternion;
            }
            if (a < 1e-6 - 1) {
                if (Math.abs(fallback.lengthSq()) < cc.math.EPSILON) {
                    quaternion.rotationAxis(fallback, Math.PI);
                } else {
                    var axis = new cc.math.Vec3(1, 0, 0);
                    axis.cross(vec1);
                    if (Math.abs(axis.lengthSq()) < cc.math.EPSILON) {
                        axis.fill(0, 1, 0);
                        axis.cross(vec1);
                    }
                    axis.normalize();
                    quaternion.rotationAxis(axis, Math.PI);
                }
            } else {
                var s = Math.sqrt(2 * (1 + a)), invs = 1 / s;
                v1.cross(v2);
                quaternion.x = v1.x * invs;
                quaternion.y = v1.y * invs;
                quaternion.z = v1.z * invs;
                quaternion.w = .5 * s;
                quaternion.normalize();
            }
            return quaternion;
        };
        proto.multiplyVec3 = function(vec) {
            var x = this.x, y = this.y, z = this.z, retVec = new cc.math.Vec3(vec);
            var uv = new cc.math.Vec3(x, y, z), uuv = new cc.math.Vec3(x, y, z);
            uv.cross(vec);
            uuv.cross(uv);
            uv.scale(2 * q.w);
            uuv.scale(2);
            retVec.add(uv);
            retVec.add(uuv);
            return retVec;
        };
    }), {} ],
    249: [ (function(require, module, exports) {
        cc.math.Ray2 = function(start, dir) {
            this.start = start || new cc.math.Vec2();
            this.dir = dir || new cc.math.Vec2();
        };
        cc.math.Ray2.prototype.fill = function(px, py, vx, vy) {
            this.start.x = px;
            this.start.y = py;
            this.dir.x = vx;
            this.dir.y = vy;
        };
        cc.math.Ray2.prototype.intersectLineSegment = function(p1, p2, intersection) {
            var x1 = this.start.x, y1 = this.start.y;
            var x2 = this.start.x + this.dir.x, y2 = this.start.y + this.dir.y;
            var x3 = p1.x, y3 = p1.y;
            var x4 = p2.x, y4 = p2.y;
            var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
            var ua, x, y;
            if (denom > -cc.math.EPSILON && denom < cc.math.EPSILON) {
                return false;
            }
            ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
            x = x1 + ua * (x2 - x1);
            y = y1 + ua * (y2 - y1);
            if (x < Math.min(p1.x, p2.x) - cc.math.EPSILON || x > Math.max(p1.x, p2.x) + cc.math.EPSILON || y < Math.min(p1.y, p2.y) - cc.math.EPSILON || y > Math.max(p1.y, p2.y) + cc.math.EPSILON) {
                return false;
            }
            if (x < Math.min(x1, x2) - cc.math.EPSILON || x > Math.max(x1, x2) + cc.math.EPSILON || y < Math.min(y1, y2) - cc.math.EPSILON || y > Math.max(y1, y2) + cc.math.EPSILON) {
                return false;
            }
            intersection.x = x;
            intersection.y = y;
            return true;
        };
        function calculate_line_normal(p1, p2, normalOut) {
            var tmp = new cc.math.Vec2(p2);
            tmp.subtract(p1);
            normalOut.x = -tmp.y;
            normalOut.y = tmp.x;
            normalOut.normalize();
        }
        cc.math.Ray2.prototype.intersectTriangle = function(p1, p2, p3, intersection, normal_out) {
            var intersect = new cc.math.Vec2(), final_intersect = new cc.math.Vec2();
            var normal = new cc.math.Vec2(), distance = 1e4, intersected = false;
            var this_distance;
            if (this.intersectLineSegment(p1, p2, intersect)) {
                intersected = true;
                this_distance = intersect.subtract(this.start).length();
                if (this_distance < distance) {
                    final_intersect.x = intersect.x;
                    final_intersect.y = intersect.y;
                    distance = this_distance;
                    calculate_line_normal(p1, p2, normal);
                }
            }
            if (this.intersectLineSegment(p2, p3, intersect)) {
                intersected = true;
                this_distance = intersect.subtract(this.start).length();
                if (this_distance < distance) {
                    final_intersect.x = intersect.x;
                    final_intersect.y = intersect.y;
                    distance = this_distance;
                    calculate_line_normal(p2, p3, normal);
                }
            }
            if (this.intersectLineSegment(p3, p1, intersect)) {
                intersected = true;
                this_distance = intersect.subtract(this.start).length();
                if (this_distance < distance) {
                    final_intersect.x = intersect.x;
                    final_intersect.y = intersect.y;
                    distance = this_distance;
                    calculate_line_normal(p3, p1, normal);
                }
            }
            if (intersected) {
                intersection.x = final_intersect.x;
                intersection.y = final_intersect.y;
                if (normal_out) {
                    normal_out.x = normal.x;
                    normal_out.y = normal.y;
                }
            }
            return intersected;
        };
    }), {} ],
    250: [ (function(require, module, exports) {
        cc.math = cc.math || {};
        cc.math.EPSILON = 1 / 64;
        cc.math.square = function(s) {
            return s * s;
        };
        cc.math.almostEqual = function(lhs, rhs) {
            return lhs + cc.math.EPSILON > rhs && lhs - cc.math.EPSILON < rhs;
        };
    }), {} ],
    251: [ (function(require, module, exports) {
        cc.math.Vec2 = function(x, y) {
            if (void 0 === y) {
                this.x = x.x;
                this.y = x.y;
            } else {
                this.x = x || 0;
                this.y = y || 0;
            }
        };
        var proto = cc.math.Vec2.prototype;
        proto.fill = function(x, y) {
            this.x = x;
            this.y = y;
        };
        proto.length = function() {
            return Math.sqrt(cc.math.square(this.x) + cc.math.square(this.y));
        };
        proto.lengthSq = function() {
            return cc.math.square(this.x) + cc.math.square(this.y);
        };
        proto.normalize = function() {
            var l = 1 / this.length();
            this.x *= l;
            this.y *= l;
            return this;
        };
        cc.math.Vec2.add = function(pOut, pV1, pV2) {
            pOut.x = pV1.x + pV2.x;
            pOut.y = pV1.y + pV2.y;
            return pOut;
        };
        proto.add = function(vec) {
            this.x += vec.x;
            this.y += vec.y;
            return this;
        };
        proto.dot = function(vec) {
            return this.x * vec.x + this.y * vec.y;
        };
        cc.math.Vec2.subtract = function(pOut, pV1, pV2) {
            pOut.x = pV1.x - pV2.x;
            pOut.y = pV1.y - pV2.y;
            return pOut;
        };
        proto.subtract = function(vec) {
            this.x -= vec.x;
            this.y -= vec.y;
            return this;
        };
        proto.transform = function(mat3) {
            var x = this.x, y = this.y;
            this.x = x * mat3.mat[0] + y * mat3.mat[3] + mat3.mat[6];
            this.y = x * mat3.mat[1] + y * mat3.mat[4] + mat3.mat[7];
            return this;
        };
        cc.math.Vec2.scale = function(pOut, pIn, s) {
            pOut.x = pIn.x * s;
            pOut.y = pIn.y * s;
            return pOut;
        };
        proto.scale = function(s) {
            this.x *= s;
            this.y *= s;
            return this;
        };
        proto.equals = function(vec) {
            return this.x < vec.x + cc.math.EPSILON && this.x > vec.x - cc.math.EPSILON && this.y < vec.y + cc.math.EPSILON && this.y > vec.y - cc.math.EPSILON;
        };
    }), {} ],
    252: [ (function(require, module, exports) {
        cc.math.Vec3 = cc.math.Vec3 = function(x, y, z) {
            if (x && void 0 === y) {
                this.x = x.x;
                this.y = x.y;
                this.z = x.z;
            } else {
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
            }
        };
        cc.math.vec3 = function(x, y, z) {
            return new cc.math.Vec3(x, y, z);
        };
        var proto = cc.math.Vec3.prototype;
        proto.fill = function(x, y, z) {
            if (x && void 0 === y) {
                this.x = x.x;
                this.y = x.y;
                this.z = x.z;
            } else {
                this.x = x;
                this.y = y;
                this.z = z;
            }
            return this;
        };
        proto.length = function() {
            return Math.sqrt(cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z));
        };
        proto.lengthSq = function() {
            return cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z);
        };
        proto.normalize = function() {
            var l = 1 / this.length();
            this.x *= l;
            this.y *= l;
            this.z *= l;
            return this;
        };
        proto.cross = function(vec3) {
            var x = this.x, y = this.y, z = this.z;
            this.x = y * vec3.z - z * vec3.y;
            this.y = z * vec3.x - x * vec3.z;
            this.z = x * vec3.y - y * vec3.x;
            return this;
        };
        proto.dot = function(vec) {
            return this.x * vec.x + this.y * vec.y + this.z * vec.z;
        };
        proto.add = function(vec) {
            this.x += vec.x;
            this.y += vec.y;
            this.z += vec.z;
            return this;
        };
        proto.subtract = function(vec) {
            this.x -= vec.x;
            this.y -= vec.y;
            this.z -= vec.z;
            return this;
        };
        proto.transform = function(mat4) {
            var x = this.x, y = this.y, z = this.z, mat = mat4.mat;
            this.x = x * mat[0] + y * mat[4] + z * mat[8] + mat[12];
            this.y = x * mat[1] + y * mat[5] + z * mat[9] + mat[13];
            this.z = x * mat[2] + y * mat[6] + z * mat[10] + mat[14];
            return this;
        };
        proto.transformNormal = function(mat4) {
            var x = this.x, y = this.y, z = this.z, mat = mat4.mat;
            this.x = x * mat[0] + y * mat[4] + z * mat[8];
            this.y = x * mat[1] + y * mat[5] + z * mat[9];
            this.z = x * mat[2] + y * mat[6] + z * mat[10];
            return this;
        };
        proto.transformCoord = function(mat4) {
            var v = new cc.math.Vec4(this.x, this.y, this.z, 1);
            v.transform(mat4);
            this.x = v.x / v.w;
            this.y = v.y / v.w;
            this.z = v.z / v.w;
            return this;
        };
        proto.scale = function(scale) {
            this.x *= scale;
            this.y *= scale;
            this.z *= scale;
            return this;
        };
        proto.equals = function(vec) {
            var EPSILON = cc.math.EPSILON;
            return this.x < vec.x + EPSILON && this.x > vec.x - EPSILON && this.y < vec.y + EPSILON && this.y > vec.y - EPSILON && this.z < vec.z + EPSILON && this.z > vec.z - EPSILON;
        };
        proto.inverseTransform = function(mat4) {
            var mat = mat4.mat;
            var v1 = new cc.math.Vec3(this.x - mat[12], this.y - mat[13], this.z - mat[14]);
            this.x = v1.x * mat[0] + v1.y * mat[1] + v1.z * mat[2];
            this.y = v1.x * mat[4] + v1.y * mat[5] + v1.z * mat[6];
            this.z = v1.x * mat[8] + v1.y * mat[9] + v1.z * mat[10];
            return this;
        };
        proto.inverseTransformNormal = function(mat4) {
            var x = this.x, y = this.y, z = this.z, mat = mat4.mat;
            this.x = x * mat[0] + y * mat[1] + z * mat[2];
            this.y = x * mat[4] + y * mat[5] + z * mat[6];
            this.z = x * mat[8] + y * mat[9] + z * mat[10];
            return this;
        };
        proto.assignFrom = function(vec) {
            if (!vec) {
                return this;
            }
            this.x = vec.x;
            this.y = vec.y;
            this.z = vec.z;
            return this;
        };
        cc.math.Vec3.zero = function(vec) {
            vec.x = vec.y = vec.z = 0;
            return vec;
        };
        proto.toTypeArray = function() {
            var tyArr = new Float32Array(3);
            tyArr[0] = this.x;
            tyArr[1] = this.y;
            tyArr[2] = this.z;
            return tyArr;
        };
    }), {} ],
    253: [ (function(require, module, exports) {
        cc.math.Vec4 = function(x, y, z, w) {
            if (x && void 0 === y) {
                this.x = x.x;
                this.y = x.y;
                this.z = x.z;
                this.w = x.w;
            } else {
                this.x = x || 0;
                this.y = y || 0;
                this.z = z || 0;
                this.w = w || 0;
            }
        };
        var proto = cc.math.Vec4.prototype;
        proto.fill = function(x, y, z, w) {
            if (x && void 0 === y) {
                this.x = x.x;
                this.y = x.y;
                this.z = x.z;
                this.w = x.w;
            } else {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
        };
        proto.add = function(vec) {
            if (!vec) {
                return this;
            }
            this.x += vec.x;
            this.y += vec.y;
            this.z += vec.z;
            this.w += vec.w;
            return this;
        };
        proto.dot = function(vec) {
            return this.x * vec.x + this.y * vec.y + this.z * vec.z + this.w * vec.w;
        };
        proto.length = function() {
            return Math.sqrt(cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z) + cc.math.square(this.w));
        };
        proto.lengthSq = function() {
            return cc.math.square(this.x) + cc.math.square(this.y) + cc.math.square(this.z) + cc.math.square(this.w);
        };
        proto.lerp = function(vec, t) {
            return this;
        };
        proto.normalize = function() {
            var l = 1 / this.length();
            this.x *= l;
            this.y *= l;
            this.z *= l;
            this.w *= l;
            return this;
        };
        proto.scale = function(scale) {
            this.normalize();
            this.x *= scale;
            this.y *= scale;
            this.z *= scale;
            this.w *= scale;
            return this;
        };
        proto.subtract = function(vec) {
            this.x -= vec.x;
            this.y -= vec.y;
            this.z -= vec.z;
            this.w -= vec.w;
        };
        proto.transform = function(mat4) {
            var x = this.x, y = this.y, z = this.z, w = this.w, mat = mat4.mat;
            this.x = x * mat[0] + y * mat[4] + z * mat[8] + w * mat[12];
            this.y = x * mat[1] + y * mat[5] + z * mat[9] + w * mat[13];
            this.z = x * mat[2] + y * mat[6] + z * mat[10] + w * mat[14];
            this.w = x * mat[3] + y * mat[7] + z * mat[11] + w * mat[15];
            return this;
        };
        cc.math.Vec4.transformArray = function(vecArray, mat4) {
            var retArray = [];
            for (var i = 0; i < vecArray.length; i++) {
                var selVec = new cc.math.Vec4(vecArray[i]);
                selVec.transform(mat4);
                retArray.push(selVec);
            }
            return retArray;
        };
        proto.equals = function(vec) {
            var EPSILON = cc.math.EPSILON;
            return this.x < vec.x + EPSILON && this.x > vec.x - EPSILON && this.y < vec.y + EPSILON && this.y > vec.y - EPSILON && this.z < vec.z + EPSILON && this.z > vec.z - EPSILON && this.w < vec.w + EPSILON && this.w > vec.w - EPSILON;
        };
        proto.assignFrom = function(vec) {
            this.x = vec.x;
            this.y = vec.y;
            this.z = vec.z;
            this.w = vec.w;
            return this;
        };
        proto.toTypeArray = function() {
            var tyArr = new Float32Array(4);
            tyArr[0] = this.x;
            tyArr[1] = this.y;
            tyArr[2] = this.z;
            tyArr[3] = this.w;
            return tyArr;
        };
    }), {} ],
    254: [ (function(require, module, exports) {
        require("./CCSGMotionStreak.js");
        require("./CCSGMotionStreakWebGLRenderCmd.js");
        var MotionStreak = cc.Class({
            name: "cc.MotionStreak",
            extends: cc.Component,
            editor: false,
            ctor: function() {
                this._root = null;
                this._motionStreak = null;
            },
            properties: {
                preview: {
                    default: false,
                    editorOnly: true,
                    notify: false,
                    animatable: false
                },
                _fadeTime: 1,
                fadeTime: {
                    get: function() {
                        return this._fadeTime;
                    },
                    set: function(value) {
                        this._fadeTime = value;
                        this._motionStreak && this._motionStreak.setFadeTime(value);
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.motionStreak.fadeTime"
                },
                _minSeg: 1,
                minSeg: {
                    get: function() {
                        return this._minSeg;
                    },
                    set: function(value) {
                        this._minSeg = value;
                        this._motionStreak && this._motionStreak.setMinSeg(value);
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.motionStreak.minSeg"
                },
                _stroke: 64,
                stroke: {
                    get: function() {
                        return this._stroke;
                    },
                    set: function(value) {
                        this._stroke = value;
                        this._motionStreak && this._motionStreak.setStroke(value);
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.motionStreak.stroke"
                },
                _texture: {
                    default: "",
                    url: cc.Texture2D
                },
                texture: {
                    get: function() {
                        return this._texture;
                    },
                    set: function(value) {
                        this._texture = value;
                        if (this._motionStreak) {
                            cc.js.isString(value) && (value = cc.textureCache.addImage(value));
                            this._motionStreak.setTexture(value);
                        }
                    },
                    url: cc.Texture2D,
                    animatable: false,
                    tooltip: "i18n:COMPONENT.motionStreak.texture"
                },
                _color: cc.Color.WHITE,
                color: {
                    get: function() {
                        return this._color;
                    },
                    set: function(value) {
                        this._color = value;
                        this._motionStreak && this._motionStreak.tintWithColor(value);
                    },
                    tooltip: "i18n:COMPONENT.motionStreak.color"
                },
                _fastMode: false,
                fastMode: {
                    get: function() {
                        return this._fastMode;
                    },
                    set: function(value) {
                        this._fastMode = value;
                        this._motionStreak && this._motionStreak.setFastMode(value);
                    },
                    animatable: false,
                    tooltip: "i18n:COMPONENT.motionStreak.fastMode"
                }
            },
            onFocusInEditor: false,
            onLostFocusInEditor: false,
            reset: function() {
                this._motionStreak.reset();
            },
            __preload: function() {
                if (cc._renderType !== cc.game.RENDER_TYPE_WEBGL && true) {
                    cc.warnID(5900);
                    return;
                }
                this._root = new _ccsg.Node();
                var motionStreak = new _ccsg.MotionStreak();
                motionStreak.initWithFade(this._fadeTime, this._minSeg, this._stroke, this.node.color, this._texture || null);
                motionStreak.setFastMode(this._fastMode);
                this._root.addChild(motionStreak);
                var sgNode = this.node._sgNode;
                sgNode && sgNode.addChild(this._root, -10);
                this._motionStreak = motionStreak;
            },
            onEnable: function() {
                this.node.on("position-changed", this._onNodePositionChanged, this);
            },
            onDisable: function() {
                this.node.off("position-changed", this._onNodePositionChanged, this);
            },
            _onNodePositionChanged: function() {
                if (this._motionStreak) {
                    var node = this.node;
                    var worldMt = node.getNodeToWorldTransform();
                    var tx = worldMt.tx - (node.width / 2 + node.anchorX * node.width);
                    var ty = worldMt.ty - (node.height / 2 + node.anchorY * node.height);
                    this._root.setPosition(-tx, -ty);
                    this._motionStreak.setPosition(tx, ty);
                }
            }
        });
        cc.MotionStreak = module.exports = MotionStreak;
    }), {
        "./CCSGMotionStreak.js": 255,
        "./CCSGMotionStreakWebGLRenderCmd.js": 256
    } ],
    255: [ (function(require, module, exports) {
        function vertexLineToPolygon(points, stroke, vertices, offset, nuPoints) {
            nuPoints += offset;
            if (nuPoints <= 1) {
                return;
            }
            stroke *= .5;
            var idx;
            var nuPointsMinus = nuPoints - 1;
            for (var i = offset; i < nuPoints; i++) {
                idx = 2 * i;
                var p1 = cc.p(points[2 * i], points[2 * i + 1]);
                var perpVector;
                if (0 === i) {
                    perpVector = cc.pPerp(cc.pNormalize(cc.pSub(p1, cc.p(points[2 * (i + 1)], points[2 * (i + 1) + 1]))));
                } else {
                    if (i === nuPointsMinus) {
                        perpVector = cc.pPerp(cc.pNormalize(cc.pSub(cc.p(points[2 * (i - 1)], points[2 * (i - 1) + 1]), p1)));
                    } else {
                        var p0 = cc.p(points[2 * (i - 1)], points[2 * (i - 1) + 1]);
                        var p2 = cc.p(points[2 * (i + 1)], points[2 * (i + 1) + 1]);
                        var p2p1 = cc.pNormalize(cc.pSub(p2, p1));
                        var p0p1 = cc.pNormalize(cc.pSub(p0, p1));
                        var angle = Math.acos(cc.pDot(p2p1, p0p1));
                        perpVector = angle < cc.degreesToRadians(70) ? cc.pPerp(cc.pNormalize(cc.pMidpoint(p2p1, p0p1))) : angle < cc.degreesToRadians(170) ? cc.pNormalize(cc.pMidpoint(p2p1, p0p1)) : cc.pPerp(cc.pNormalize(cc.pSub(p2, p0)));
                    }
                }
                perpVector = cc.pMult(perpVector, stroke);
                vertices[2 * idx] = p1.x + perpVector.x;
                vertices[2 * idx + 1] = p1.y + perpVector.y;
                vertices[2 * (idx + 1)] = p1.x - perpVector.x;
                vertices[2 * (idx + 1) + 1] = p1.y - perpVector.y;
            }
            offset = 0 === offset ? 0 : offset - 1;
            for (i = offset; i < nuPointsMinus; i++) {
                idx = 2 * i;
                var idx1 = idx + 2;
                var v1 = cc.v2(vertices[2 * idx], vertices[2 * idx + 1]);
                var v2 = cc.v2(vertices[2 * (idx + 1)], vertices[2 * (idx + 1) + 1]);
                var v3 = cc.v2(vertices[2 * idx1], vertices[2 * idx1 + 1]);
                var v4 = cc.v2(vertices[2 * (idx1 + 1)], vertices[2 * (idx1 + 1) + 1]);
                var fixVertexResult = vertexLineIntersect(v1.x, v1.y, v4.x, v4.y, v2.x, v2.y, v3.x, v3.y);
                var isSuccess = !fixVertexResult.isSuccess;
                isSuccess || (fixVertexResult.value < 0 || fixVertexResult.value > 1) && (isSuccess = true);
                if (isSuccess) {
                    vertices[2 * idx1] = v4.x;
                    vertices[2 * idx1 + 1] = v4.y;
                    vertices[2 * (idx1 + 1)] = v3.x;
                    vertices[2 * (idx1 + 1) + 1] = v3.y;
                }
            }
        }
        function vertexLineIntersect(Ax, Ay, Bx, By, Cx, Cy, Dx, Dy) {
            var distAB, theCos, theSin, newX;
            if (Ax === Bx && Ay === By || Cx === Dx && Cy === Dy) {
                return {
                    isSuccess: false,
                    value: 0
                };
            }
            Bx -= Ax;
            By -= Ay;
            Cx -= Ax;
            Cy -= Ay;
            Dx -= Ax;
            Dy -= Ay;
            distAB = Math.sqrt(Bx * Bx + By * By);
            theCos = Bx / distAB;
            theSin = By / distAB;
            newX = Cx * theCos + Cy * theSin;
            Cy = Cy * theCos - Cx * theSin;
            Cx = newX;
            newX = Dx * theCos + Dy * theSin;
            Dy = Dy * theCos - Dx * theSin;
            Dx = newX;
            if (Cy === Dy) {
                return {
                    isSuccess: false,
                    value: 0
                };
            }
            var t = (Dx + (Cx - Dx) * Dy / (Dy - Cy)) / distAB;
            return {
                isSuccess: true,
                value: t
            };
        }
        function vertexListIsClockwise(verts) {
            for (var i = 0, len = verts.length; i < len; i++) {
                var a = verts[i];
                var b = verts[(i + 1) % len];
                var c = verts[(i + 2) % len];
                if (cc.pCross(cc.pSub(b, a), cc.pSub(c, b)) > 0) {
                    return false;
                }
            }
            return true;
        }
        _ccsg.MotionStreak = _ccsg.Node.extend({
            texture: null,
            fastMode: false,
            startingPositionInitialized: false,
            _blendFunc: null,
            _stroke: 0,
            _fadeDelta: 0,
            _minSeg: 0,
            _maxPoints: 0,
            _nuPoints: 0,
            _previousNuPoints: 0,
            _pointVertexes: null,
            _pointState: null,
            _vertices: null,
            _colorPointer: null,
            _texCoords: null,
            _verticesBuffer: null,
            _colorPointerBuffer: null,
            _texCoordsBuffer: null,
            _className: "MotionStreak",
            ctor: function(fade, minSeg, stroke, color, texture) {
                _ccsg.Node.prototype.ctor.call(this);
                this._positionR = cc.p(0, 0);
                this._blendFunc = new cc.BlendFunc(cc.SRC_ALPHA, cc.ONE_MINUS_SRC_ALPHA);
                this.fastMode = false;
                this.startingPositionInitialized = false;
                this.texture = null;
                this._stroke = 0;
                this._fadeDelta = 0;
                this._minSeg = 0;
                this._maxPoints = 0;
                this._nuPoints = 0;
                this._previousNuPoints = 0;
                this._pointVertexes = null;
                this._pointState = null;
                this._vertices = null;
                this._colorPointer = null;
                this._texCoords = null;
                this._verticesBuffer = null;
                this._colorPointerBuffer = null;
                this._texCoordsBuffer = null;
                void 0 !== texture && this.initWithFade(fade, minSeg, stroke, color, texture);
            },
            initWithFade: function(fade, minSeg, stroke, color, texture) {
                cc.js.isString(texture) && (texture = cc.textureCache.addImage(texture));
                this.anchorX = 0;
                this.anchorY = 0;
                this.ignoreAnchor = true;
                this.startingPositionInitialized = false;
                this.fastMode = true;
                this._stroke = stroke;
                this.setMinSeg(minSeg);
                this.setFadeTime(fade);
                this._blendFunc.src = gl.SRC_ALPHA;
                this._blendFunc.dst = gl.ONE_MINUS_SRC_ALPHA;
                this.setTexture(texture);
                this.color = color;
                this.scheduleUpdate();
                return true;
            },
            getTexture: function() {
                return this.texture;
            },
            setTexture: function(texture) {
                this.texture !== texture && (this.texture = texture);
            },
            getBlendFunc: function() {
                return this._blendFunc;
            },
            setBlendFunc: function(src, dst) {
                if (void 0 === dst) {
                    this._blendFunc = src;
                } else {
                    this._blendFunc.src = src;
                    this._blendFunc.dst = dst;
                }
            },
            getOpacity: function() {
                cc.logID(5901);
                return 0;
            },
            setOpacity: function(opacity) {
                cc.logID(5902);
            },
            setOpacityModifyRGB: function(value) {},
            isOpacityModifyRGB: function() {
                return false;
            },
            getFadeTime: function() {
                return 1 / this._fadeDelta;
            },
            setFadeTime: function(fade) {
                this._fadeDelta = 1 / fade;
                var locMaxPoints = (0 | 60 * fade) + 2;
                this._maxPoints = locMaxPoints;
                this._nuPoints = 0;
                this._pointState = new Float32Array(locMaxPoints);
                this._pointVertexes = new Float32Array(2 * locMaxPoints);
                this._vertices = new Float32Array(4 * locMaxPoints);
                this._texCoords = new Float32Array(4 * locMaxPoints);
                this._colorPointer = new Uint8Array(8 * locMaxPoints);
                this._verticesBuffer = gl.createBuffer();
                this._texCoordsBuffer = gl.createBuffer();
                this._colorPointerBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this._verticesBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, this._texCoordsBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, this._texCoords, gl.DYNAMIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, this._colorPointerBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, this._colorPointer, gl.DYNAMIC_DRAW);
            },
            getMinSeg: function() {
                return this._minSeg;
            },
            setMinSeg: function(minSeg) {
                this._minSeg = minSeg === -1 ? this._stroke / 5 : minSeg;
                this._minSeg *= this._minSeg;
            },
            isFastMode: function() {
                return this.fastMode;
            },
            setFastMode: function(fastMode) {
                this.fastMode = fastMode;
            },
            isStartingPositionInitialized: function() {
                return this.startingPositionInitialized;
            },
            setStartingPositionInitialized: function(startingPositionInitialized) {
                this.startingPositionInitialized = startingPositionInitialized;
            },
            getStroke: function() {
                return this._stroke;
            },
            setStroke: function(stroke) {
                this._stroke = stroke;
            },
            tintWithColor: function(color) {
                this.color = color;
                var locColorPointer = this._colorPointer;
                for (var i = 0, len = 2 * this._nuPoints; i < len; i++) {
                    locColorPointer[4 * i] = color.r;
                    locColorPointer[4 * i + 1] = color.g;
                    locColorPointer[4 * i + 2] = color.b;
                }
            },
            reset: function() {
                this._nuPoints = 0;
            },
            setPosition: function(position, yValue) {
                this.startingPositionInitialized = true;
                if (void 0 === yValue) {
                    this._positionR.x = position.x;
                    this._positionR.y = position.y;
                } else {
                    this._positionR.x = position;
                    this._positionR.y = yValue;
                }
            },
            getPositionX: function() {
                return this._positionR.x;
            },
            setPositionX: function(x) {
                this._positionR.x = x;
                this.startingPositionInitialized || (this.startingPositionInitialized = true);
            },
            getPositionY: function() {
                return this._positionR.y;
            },
            setPositionY: function(y) {
                this._positionR.y = y;
                this.startingPositionInitialized || (this.startingPositionInitialized = true);
            },
            update: function(delta) {
                if (!this.startingPositionInitialized) {
                    return;
                }
                delta *= this._fadeDelta;
                var newIdx, newIdx2, i, i2;
                var mov = 0;
                var locNuPoints = this._nuPoints;
                var locPointState = this._pointState, locPointVertexes = this._pointVertexes, locVertices = this._vertices;
                var locColorPointer = this._colorPointer;
                for (i = 0; i < locNuPoints; i++) {
                    locPointState[i] -= delta;
                    if (locPointState[i] <= 0) {
                        mov++;
                    } else {
                        newIdx = i - mov;
                        if (mov > 0) {
                            locPointState[newIdx] = locPointState[i];
                            locPointVertexes[2 * newIdx] = locPointVertexes[2 * i];
                            locPointVertexes[2 * newIdx + 1] = locPointVertexes[2 * i + 1];
                            i2 = 2 * i;
                            newIdx2 = 2 * newIdx;
                            locVertices[2 * newIdx2] = locVertices[2 * i2];
                            locVertices[2 * newIdx2 + 1] = locVertices[2 * i2 + 1];
                            locVertices[2 * (newIdx2 + 1)] = locVertices[2 * (i2 + 1)];
                            locVertices[2 * (newIdx2 + 1) + 1] = locVertices[2 * (i2 + 1) + 1];
                            i2 *= 4;
                            newIdx2 *= 4;
                            locColorPointer[newIdx2 + 0] = locColorPointer[i2 + 0];
                            locColorPointer[newIdx2 + 1] = locColorPointer[i2 + 1];
                            locColorPointer[newIdx2 + 2] = locColorPointer[i2 + 2];
                            locColorPointer[newIdx2 + 4] = locColorPointer[i2 + 4];
                            locColorPointer[newIdx2 + 5] = locColorPointer[i2 + 5];
                            locColorPointer[newIdx2 + 6] = locColorPointer[i2 + 6];
                        } else {
                            newIdx2 = 8 * newIdx;
                        }
                        var op = 255 * locPointState[newIdx];
                        locColorPointer[newIdx2 + 3] = op;
                        locColorPointer[newIdx2 + 7] = op;
                    }
                }
                locNuPoints -= mov;
                var appendNewPoint = true;
                if (locNuPoints >= this._maxPoints) {
                    appendNewPoint = false;
                } else {
                    if (locNuPoints > 0) {
                        var locPoint1 = cc.p(locPointVertexes[2 * (locNuPoints - 1)], locPointVertexes[2 * (locNuPoints - 1) + 1]);
                        var a1 = cc.pDistanceSQ(locPoint1, this._positionR) < this._minSeg;
                        var locPoint2 = cc.p(locPointVertexes[2 * (locNuPoints - 2)], locPointVertexes[2 * (locNuPoints - 2) + 1]);
                        var a2 = 1 !== locNuPoints && cc.pDistanceSQ(locPoint2, this._positionR) < 2 * this._minSeg;
                        (a1 || a2) && (appendNewPoint = false);
                    }
                }
                if (appendNewPoint) {
                    locPointVertexes[2 * locNuPoints] = this._positionR.x;
                    locPointVertexes[2 * locNuPoints + 1] = this._positionR.y;
                    locPointState[locNuPoints] = 1;
                    var offset = 8 * locNuPoints;
                    var locDisplayedColor = this.getDisplayedColor();
                    locColorPointer[offset] = locDisplayedColor.r;
                    locColorPointer[offset + 1] = locDisplayedColor.g;
                    locColorPointer[offset + 2] = locDisplayedColor.b;
                    locColorPointer[offset + 4] = locDisplayedColor.r;
                    locColorPointer[offset + 5] = locDisplayedColor.g;
                    locColorPointer[offset + 6] = locDisplayedColor.b;
                    locColorPointer[offset + 3] = 255;
                    locColorPointer[offset + 7] = 255;
                    locNuPoints > 0 && this.fastMode && (locNuPoints > 1 ? vertexLineToPolygon(locPointVertexes, this._stroke, this._vertices, locNuPoints, 1) : vertexLineToPolygon(locPointVertexes, this._stroke, this._vertices, 0, 2));
                    locNuPoints++;
                }
                this.fastMode || vertexLineToPolygon(locPointVertexes, this._stroke, this._vertices, 0, locNuPoints);
                if (locNuPoints && this._previousNuPoints !== locNuPoints) {
                    var texDelta = 1 / locNuPoints;
                    var locTexCoords = this._texCoords;
                    for (i = 0; i < locNuPoints; i++) {
                        locTexCoords[4 * i] = 0;
                        locTexCoords[4 * i + 1] = texDelta * i;
                        locTexCoords[2 * (2 * i + 1)] = 1;
                        locTexCoords[2 * (2 * i + 1) + 1] = texDelta * i;
                    }
                    this._previousNuPoints = locNuPoints;
                }
                this._nuPoints = locNuPoints;
            },
            _createRenderCmd: function() {
                return cc._renderType === cc.game.RENDER_TYPE_WEBGL ? new _ccsg.MotionStreak.WebGLRenderCmd(this) : null;
            }
        });
        var motionStreakPro = _ccsg.MotionStreak.prototype;
        Object.defineProperty(motionStreakPro, "x", {
            get: motionStreakPro.getPositionX,
            set: motionStreakPro.setPositionX
        });
        Object.defineProperty(motionStreakPro, "y", {
            get: motionStreakPro.getPositionY,
            set: motionStreakPro.setPositionY
        });
    }), {} ],
    256: [ (function(require, module, exports) {
        _ccsg.MotionStreak.WebGLRenderCmd = function(renderableObject) {
            this._rootCtor(renderableObject);
            this._needDraw = true;
            this._matrix = new cc.math.Matrix4();
            this._matrix.identity();
            this._shaderProgram = cc.shaderCache.programForKey(cc.macro.SHADER_POSITION_TEXTURECOLOR);
        };
        _ccsg.MotionStreak.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
        _ccsg.MotionStreak.WebGLRenderCmd.prototype.constructor = _ccsg.Sprite.WebGLRenderCmd;
        _ccsg.MotionStreak.WebGLRenderCmd.prototype.rendering = function(ctx) {
            var node = this._node;
            if (node._nuPoints <= 1) {
                return;
            }
            if (node.texture && node.texture.isLoaded()) {
                ctx = ctx || cc._renderContext;
                this._updateDisplayColor();
                var wt = this._worldTransform, mat = this._matrix.mat;
                mat[0] = wt.a;
                mat[4] = wt.c;
                mat[12] = wt.tx;
                mat[1] = wt.b;
                mat[5] = wt.d;
                mat[13] = wt.ty;
                this._shaderProgram.use();
                this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix);
                cc.gl.blendFunc(node._blendFunc.src, node._blendFunc.dst);
                cc.gl.bindTexture2DN(0, node.texture);
                ctx.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_POSITION);
                ctx.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_COLOR);
                ctx.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_TEX_COORDS);
                ctx.bindBuffer(ctx.ARRAY_BUFFER, node._verticesBuffer);
                ctx.bufferData(ctx.ARRAY_BUFFER, node._vertices, ctx.DYNAMIC_DRAW);
                ctx.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_POSITION, 2, ctx.FLOAT, false, 0, 0);
                ctx.bindBuffer(ctx.ARRAY_BUFFER, node._texCoordsBuffer);
                ctx.bufferData(ctx.ARRAY_BUFFER, node._texCoords, ctx.DYNAMIC_DRAW);
                ctx.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_TEX_COORDS, 2, ctx.FLOAT, false, 0, 0);
                ctx.bindBuffer(ctx.ARRAY_BUFFER, node._colorPointerBuffer);
                ctx.bufferData(ctx.ARRAY_BUFFER, node._colorPointer, ctx.DYNAMIC_DRAW);
                ctx.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_COLOR, 4, ctx.UNSIGNED_BYTE, true, 0, 0);
                ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 2 * node._nuPoints);
                cc.g_NumberOfDraws++;
            }
        };
    }), {} ],
    257: [ (function(require, module, exports) {
        var PNGReader = cc._Class.extend({
            ctor: function(data) {
                var chunkSize, colors, delayDen, delayNum, frame, i, index, key, section, ccshort, text, _i, _j, _ref;
                this.data = data;
                this.pos = 8;
                this.palette = [];
                this.imgData = [];
                this.transparency = {};
                this.animation = null;
                this.text = {};
                frame = null;
                while (true) {
                    chunkSize = this.readUInt32();
                    section = function() {
                        var _i, _results;
                        _results = [];
                        for (i = _i = 0; _i < 4; i = ++_i) {
                            _results.push(String.fromCharCode(this.data[this.pos++]));
                        }
                        return _results;
                    }.call(this).join("");
                    switch (section) {
                      case "IHDR":
                        this.width = this.readUInt32();
                        this.height = this.readUInt32();
                        this.bits = this.data[this.pos++];
                        this.colorType = this.data[this.pos++];
                        this.compressionMethod = this.data[this.pos++];
                        this.filterMethod = this.data[this.pos++];
                        this.interlaceMethod = this.data[this.pos++];
                        break;

                      case "acTL":
                        this.animation = {
                            numFrames: this.readUInt32(),
                            numPlays: this.readUInt32() || 1 / 0,
                            frames: []
                        };
                        break;

                      case "PLTE":
                        this.palette = this.read(chunkSize);
                        break;

                      case "fcTL":
                        frame && this.animation.frames.push(frame);
                        this.pos += 4;
                        frame = {
                            width: this.readUInt32(),
                            height: this.readUInt32(),
                            xOffset: this.readUInt32(),
                            yOffset: this.readUInt32()
                        };
                        delayNum = this.readUInt16();
                        delayDen = this.readUInt16() || 100;
                        frame.delay = 1e3 * delayNum / delayDen;
                        frame.disposeOp = this.data[this.pos++];
                        frame.blendOp = this.data[this.pos++];
                        frame.data = [];
                        break;

                      case "IDAT":
                      case "fdAT":
                        if ("fdAT" === section) {
                            this.pos += 4;
                            chunkSize -= 4;
                        }
                        data = (null != frame ? frame.data : void 0) || this.imgData;
                        for (i = _i = 0; 0 <= chunkSize ? _i < chunkSize : _i > chunkSize; i = 0 <= chunkSize ? ++_i : --_i) {
                            data.push(this.data[this.pos++]);
                        }
                        break;

                      case "tRNS":
                        this.transparency = {};
                        switch (this.colorType) {
                          case 3:
                            this.transparency.indexed = this.read(chunkSize);
                            ccshort = 255 - this.transparency.indexed.length;
                            if (ccshort > 0) {
                                for (i = _j = 0; 0 <= ccshort ? _j < ccshort : _j > ccshort; i = 0 <= ccshort ? ++_j : --_j) {
                                    this.transparency.indexed.push(255);
                                }
                            }
                            break;

                          case 0:
                            this.transparency.grayscale = this.read(chunkSize)[0];
                            break;

                          case 2:
                            this.transparency.rgb = this.read(chunkSize);
                        }
                        break;

                      case "tEXt":
                        text = this.read(chunkSize);
                        index = text.indexOf(0);
                        key = String.fromCharCode.apply(String, text.slice(0, index));
                        this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
                        break;

                      case "IEND":
                        frame && this.animation.frames.push(frame);
                        this.colors = function() {
                            switch (this.colorType) {
                              case 0:
                              case 3:
                              case 4:
                                return 1;

                              case 2:
                              case 6:
                                return 3;
                            }
                        }.call(this);
                        this.hasAlphaChannel = 4 === (_ref = this.colorType) || 6 === _ref;
                        colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
                        this.pixelBitlength = this.bits * colors;
                        this.colorSpace = function() {
                            switch (this.colors) {
                              case 1:
                                return "DeviceGray";

                              case 3:
                                return "DeviceRGB";
                            }
                        }.call(this);
                        Uint8Array != Array && (this.imgData = new Uint8Array(this.imgData));
                        return;

                      default:
                        this.pos += chunkSize;
                    }
                    this.pos += 4;
                    if (this.pos > this.data.length) {
                        throw new Error("Incomplete or corrupt PNG file");
                    }
                }
            },
            read: function(bytes) {
                var i, _i, _results;
                _results = [];
                for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {
                    _results.push(this.data[this.pos++]);
                }
                return _results;
            },
            readUInt32: function() {
                var b1, b2, b3, b4;
                b1 = this.data[this.pos++] << 24;
                b2 = this.data[this.pos++] << 16;
                b3 = this.data[this.pos++] << 8;
                b4 = this.data[this.pos++];
                return b1 | b2 | b3 | b4;
            },
            readUInt16: function() {
                var b1, b2;
                b1 = this.data[this.pos++] << 8;
                b2 = this.data[this.pos++];
                return b1 | b2;
            },
            decodePixels: function(data) {
                var ccbyte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;
                null == data && (data = this.imgData);
                if (0 === data.length) {
                    return new Uint8Array(0);
                }
                var inflate = new Zlib.Inflate(data, {
                    index: 0,
                    verify: false
                });
                data = inflate.decompress();
                pixelBytes = this.pixelBitlength / 8;
                scanlineLength = pixelBytes * this.width;
                pixels = new Uint8Array(scanlineLength * this.height);
                length = data.length;
                row = 0;
                pos = 0;
                c = 0;
                while (pos < length) {
                    switch (data[pos++]) {
                      case 0:
                        for (i = _i = 0; _i < scanlineLength; i = _i += 1) {
                            pixels[c++] = data[pos++];
                        }
                        break;

                      case 1:
                        for (i = _j = 0; _j < scanlineLength; i = _j += 1) {
                            ccbyte = data[pos++];
                            left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                            pixels[c++] = (ccbyte + left) % 256;
                        }
                        break;

                      case 2:
                        for (i = _k = 0; _k < scanlineLength; i = _k += 1) {
                            ccbyte = data[pos++];
                            col = (i - i % pixelBytes) / pixelBytes;
                            upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                            pixels[c++] = (upper + ccbyte) % 256;
                        }
                        break;

                      case 3:
                        for (i = _l = 0; _l < scanlineLength; i = _l += 1) {
                            ccbyte = data[pos++];
                            col = (i - i % pixelBytes) / pixelBytes;
                            left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                            upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                            pixels[c++] = (ccbyte + Math.floor((left + upper) / 2)) % 256;
                        }
                        break;

                      case 4:
                        for (i = _m = 0; _m < scanlineLength; i = _m += 1) {
                            ccbyte = data[pos++];
                            col = (i - i % pixelBytes) / pixelBytes;
                            left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                            if (0 === row) {
                                upper = upperLeft = 0;
                            } else {
                                upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                                upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];
                            }
                            p = left + upper - upperLeft;
                            pa = Math.abs(p - left);
                            pb = Math.abs(p - upper);
                            pc = Math.abs(p - upperLeft);
                            paeth = pa <= pb && pa <= pc ? left : pb <= pc ? upper : upperLeft;
                            pixels[c++] = (ccbyte + paeth) % 256;
                        }
                        break;

                      default:
                        throw new Error("Invalid filter algorithm: " + data[pos - 1]);
                    }
                    row++;
                }
                return pixels;
            },
            copyToImageData: function(imageData, pixels) {
                var alpha, colors, data, i, input, j, k, length, palette, v, _ref;
                colors = this.colors;
                palette = null;
                alpha = this.hasAlphaChannel;
                if (this.palette.length) {
                    palette = null != (_ref = this._decodedPalette) ? _ref : this._decodedPalette = this.decodePalette();
                    colors = 4;
                    alpha = true;
                }
                data = imageData.data || imageData;
                length = data.length;
                input = palette || pixels;
                i = j = 0;
                if (1 === colors) {
                    while (i < length) {
                        k = palette ? 4 * pixels[i / 4] : j;
                        v = input[k++];
                        data[i++] = v;
                        data[i++] = v;
                        data[i++] = v;
                        data[i++] = alpha ? input[k++] : 255;
                        j = k;
                    }
                } else {
                    while (i < length) {
                        k = palette ? 4 * pixels[i / 4] : j;
                        data[i++] = input[k++];
                        data[i++] = input[k++];
                        data[i++] = input[k++];
                        data[i++] = alpha ? input[k++] : 255;
                        j = k;
                    }
                }
            },
            decodePalette: function() {
                var c, i, palette, pos, ret, transparency, _i, _ref, _ref1;
                palette = this.palette;
                transparency = this.transparency.indexed || [];
                ret = new Uint8Array((transparency.length || 0) + palette.length);
                pos = 0;
                c = 0;
                for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {
                    ret[pos++] = palette[i];
                    ret[pos++] = palette[i + 1];
                    ret[pos++] = palette[i + 2];
                    ret[pos++] = null != (_ref1 = transparency[c++]) ? _ref1 : 255;
                }
                return ret;
            },
            render: function(canvas) {
                var ctx, data;
                canvas.width = this.width;
                canvas.height = this.height;
                ctx = canvas.getContext("2d");
                data = ctx.createImageData(this.width, this.height);
                this.copyToImageData(data, this.decodePixels());
                return ctx.putImageData(data, 0, 0);
            }
        });
        module.exports = PNGReader;
    }), {} ],
    258: [ (function(require, module, exports) {
        var ParticleAsset = cc.Class({
            name: "cc.ParticleAsset",
            extends: cc.RawAsset
        });
        cc.ParticleAsset = module.exports = ParticleAsset;
    }), {} ],
    259: [ (function(require, module, exports) {
        cc.ParticleBatchNode = _ccsg.Node.extend({
            textureAtlas: null,
            _blendFunc: null,
            _className: "ParticleBatchNode",
            ctor: function(fileImage, capacity) {
                _ccsg.Node.prototype.ctor.call(this);
                this._blendFunc = {
                    src: cc.macro.BLEND_SRC,
                    dst: cc.macro.BLEND_DST
                };
                cc.js.isString(fileImage) ? this.init(fileImage, capacity) : fileImage instanceof cc.Texture2D && this.initWithTexture(fileImage, capacity);
            },
            _createRenderCmd: function() {
                return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.ParticleBatchNode.CanvasRenderCmd(this) : new cc.ParticleBatchNode.WebGLRenderCmd(this);
            },
            initWithTexture: function(texture, capacity) {
                this.textureAtlas = new cc.TextureAtlas();
                this.textureAtlas.initWithTexture(texture, capacity);
                this._children.length = 0;
                this._renderCmd._initWithTexture();
                return true;
            },
            initWithFile: function(fileImage, capacity) {
                var tex = cc.textureCache.addImage(fileImage);
                return this.initWithTexture(tex, capacity);
            },
            init: function(fileImage, capacity) {
                var tex = cc.textureCache.addImage(fileImage);
                return this.initWithTexture(tex, capacity);
            },
            visit: function(parent) {
                var cmd = this._renderCmd, parentCmd = parent ? parent._renderCmd : null;
                if (!this._visible) {
                    cmd._propagateFlagsDown(parentCmd);
                    return;
                }
                cmd.visit(parentCmd);
                cc.renderer.pushRenderCommand(cmd);
                cmd._dirtyFlag = 0;
            },
            addChild: function(child, zOrder, tag) {
                if (!child) {
                    throw new Error("cc.ParticleBatchNode.addChild() : child should be non-null");
                }
                if (!(child instanceof _ccsg.ParticleSystem)) {
                    throw new Error("cc.ParticleBatchNode.addChild() : only supports _ccsg.ParticleSystem as children");
                }
                zOrder = null == zOrder ? child.zIndex : zOrder;
                tag = null == tag ? child.tag : tag;
                if (child.getTexture() !== this.textureAtlas.texture) {
                    throw new Error("_ccsg.ParticleSystem.addChild() : the child is not using the same texture id");
                }
                var childBlendFunc = child.getBlendFunc();
                if (0 === this._children.length) {
                    this.setBlendFunc(childBlendFunc);
                } else {
                    if (childBlendFunc.src !== this._blendFunc.src || childBlendFunc.dst !== this._blendFunc.dst) {
                        cc.logID(6002);
                        return;
                    }
                }
                var pos = this._addChildHelper(child, zOrder, tag);
                var atlasIndex = 0;
                if (0 !== pos) {
                    var p = this._children[pos - 1];
                    atlasIndex = p.getAtlasIndex() + p.getTotalParticles();
                } else {
                    atlasIndex = 0;
                }
                this.insertChild(child, atlasIndex);
                child.setBatchNode(this);
            },
            insertChild: function(pSystem, index) {
                var totalParticles = pSystem.getTotalParticles();
                var locTextureAtlas = this.textureAtlas;
                var totalQuads = locTextureAtlas.totalQuads;
                pSystem.setAtlasIndex(index);
                if (totalQuads + totalParticles > locTextureAtlas.getCapacity()) {
                    this._increaseAtlasCapacityTo(totalQuads + totalParticles);
                    locTextureAtlas.fillWithEmptyQuadsFromIndex(locTextureAtlas.getCapacity() - totalParticles, totalParticles);
                }
                pSystem.getAtlasIndex() + totalParticles !== totalQuads && locTextureAtlas.moveQuadsFromIndex(index, index + totalParticles);
                locTextureAtlas.increaseTotalQuadsWith(totalParticles);
                this._updateAllAtlasIndexes();
            },
            removeChild: function(child, cleanup) {
                if (null == child) {
                    return;
                }
                if (!(child instanceof _ccsg.ParticleSystem)) {
                    throw new Error("cc.ParticleBatchNode.removeChild(): only supports _ccsg.ParticleSystem as children");
                }
                if (this._children.indexOf(child) === -1) {
                    cc.logID(6003);
                    return;
                }
                _ccsg.Node.prototype.removeChild.call(this, child, cleanup);
                var locTextureAtlas = this.textureAtlas;
                locTextureAtlas.removeQuadsAtIndex(child.getAtlasIndex(), child.getTotalParticles());
                locTextureAtlas.fillWithEmptyQuadsFromIndex(locTextureAtlas.totalQuads, child.getTotalParticles());
                child.setBatchNode(null);
                this._updateAllAtlasIndexes();
            },
            reorderChild: function(child, zOrder) {
                if (!child) {
                    throw new Error("cc.ParticleBatchNode.reorderChild(): child should be non-null");
                }
                if (!(child instanceof _ccsg.ParticleSystem)) {
                    throw new Error("cc.ParticleBatchNode.reorderChild(): only supports cc.QuadParticleSystems as children");
                }
                if (this._children.indexOf(child) === -1) {
                    cc.logID(6004);
                    return;
                }
                if (zOrder === child.zIndex) {
                    return;
                }
                if (this._children.length > 1) {
                    var getIndexes = this._getCurrentIndex(child, zOrder);
                    if (getIndexes.oldIndex !== getIndexes.newIndex) {
                        this._children.splice(getIndexes.oldIndex, 1);
                        this._children.splice(getIndexes.newIndex, 0, child);
                        var oldAtlasIndex = child.getAtlasIndex();
                        this._updateAllAtlasIndexes();
                        var newAtlasIndex = 0;
                        var locChildren = this._children;
                        for (var i = 0; i < locChildren.length; i++) {
                            var pNode = locChildren[i];
                            if (pNode === child) {
                                newAtlasIndex = child.getAtlasIndex();
                                break;
                            }
                        }
                        this.textureAtlas.moveQuadsFromIndex(oldAtlasIndex, child.getTotalParticles(), newAtlasIndex);
                        child.updateWithNoTime();
                    }
                }
                child._setLocalZOrder(zOrder);
            },
            removeChildAtIndex: function(index, doCleanup) {
                this.removeChild(this._children[i], doCleanup);
            },
            removeAllChildren: function(doCleanup) {
                var locChildren = this._children;
                for (var i = 0; i < locChildren.length; i++) {
                    locChildren[i].setBatchNode(null);
                }
                _ccsg.Node.prototype.removeAllChildren.call(this, doCleanup);
                this.textureAtlas.removeAllQuads();
            },
            disableParticle: function(particleIndex) {
                var quad = this.textureAtlas.quads[particleIndex];
                quad.br.vertices.x = quad.br.vertices.y = quad.tr.vertices.x = quad.tr.vertices.y = quad.tl.vertices.x = quad.tl.vertices.y = quad.bl.vertices.x = quad.bl.vertices.y = 0;
                this.textureAtlas._setDirty(true);
            },
            getTexture: function() {
                return this.textureAtlas.texture;
            },
            setTexture: function(texture) {
                this.textureAtlas.texture = texture;
                var locBlendFunc = this._blendFunc;
                if (texture && !texture.hasPremultipliedAlpha() && locBlendFunc.src === cc.macro.BLEND_SRC && locBlendFunc.dst === cc.macro.BLEND_DST) {
                    locBlendFunc.src = cc.macro.SRC_ALPHA;
                    locBlendFunc.dst = cc.macro.ONE_MINUS_SRC_ALPHA;
                }
            },
            setBlendFunc: function(src, dst) {
                if (void 0 === dst) {
                    this._blendFunc.src = src.src;
                    this._blendFunc.dst = src.dst;
                } else {
                    this._blendFunc.src = src;
                    this._blendFunc.src = dst;
                }
            },
            getBlendFunc: function() {
                return new cc.BlendFunc(this._blendFunc.src, this._blendFunc.dst);
            },
            _updateAllAtlasIndexes: function() {
                var index = 0;
                var locChildren = this._children;
                for (var i = 0; i < locChildren.length; i++) {
                    var child = locChildren[i];
                    child.setAtlasIndex(index);
                    index += child.getTotalParticles();
                }
            },
            _increaseAtlasCapacityTo: function(quantity) {
                cc.logID(6006, this.textureAtlas.getCapacity(), quantity);
                this.textureAtlas.resizeCapacity(quantity) || cc.logID(6005);
            },
            _searchNewPositionInChildrenForZ: function(z) {
                var locChildren = this._children;
                var count = locChildren.length;
                for (var i = 0; i < count; i++) {
                    if (locChildren[i].zIndex > z) {
                        return i;
                    }
                }
                return count;
            },
            _getCurrentIndex: function(child, z) {
                var foundCurrentIdx = false;
                var foundNewIdx = false;
                var newIndex = 0;
                var oldIndex = 0;
                var minusOne = 0, locChildren = this._children;
                var count = locChildren.length;
                for (var i = 0; i < count; i++) {
                    var pNode = locChildren[i];
                    if (pNode.zIndex > z && !foundNewIdx) {
                        newIndex = i;
                        foundNewIdx = true;
                        if (foundCurrentIdx && foundNewIdx) {
                            break;
                        }
                    }
                    if (child === pNode) {
                        oldIndex = i;
                        foundCurrentIdx = true;
                        foundNewIdx || (minusOne = -1);
                        if (foundCurrentIdx && foundNewIdx) {
                            break;
                        }
                    }
                }
                foundNewIdx || (newIndex = count);
                newIndex += minusOne;
                return {
                    newIndex: newIndex,
                    oldIndex: oldIndex
                };
            },
            _addChildHelper: function(child, z, aTag) {
                if (!child) {
                    throw new Error("cc.ParticleBatchNode._addChildHelper(): child should be non-null");
                }
                if (child.parent) {
                    cc.logID(6007);
                    return null;
                }
                this._children || (this._children = []);
                var pos = this._searchNewPositionInChildrenForZ(z);
                this._children.splice(pos, 0, child);
                child.tag = aTag;
                child._setLocalZOrder(z);
                child.parent = this;
                if (this._running) {
                    child.performRecursive(_ccsg.Node.performType.onEnter);
                    child.performRecursive(_ccsg.Node.performType.onEnterTransitionDidFinish);
                }
                return pos;
            },
            _updateBlendFunc: function() {
                if (!this.textureAtlas.texture.hasPremultipliedAlpha()) {
                    this._blendFunc.src = cc.macro.SRC_ALPHA;
                    this._blendFunc.dst = cc.macro.ONE_MINUS_SRC_ALPHA;
                }
            },
            getTextureAtlas: function() {
                return this.textureAtlas;
            },
            setTextureAtlas: function(textureAtlas) {
                this.textureAtlas = textureAtlas;
            }
        });
        var _p = cc.ParticleBatchNode.prototype;
        _p.texture;
        cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
    }), {} ],
    260: [ (function(require, module, exports) {
        cc.ParticleBatchNode.CanvasRenderCmd = function(renderable) {
            this._rootCtor(renderable);
            this._needDraw = false;
        };
        var proto = cc.ParticleBatchNode.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
        proto.constructor = cc.ParticleBatchNode.CanvasRenderCmd;
        proto._initWithTexture = function() {};
    }), {} ],
    261: [ (function(require, module, exports) {
        cc.ParticleBatchNode.WebGLRenderCmd = function(renderable) {
            this._rootCtor(renderable);
            this._needDraw = true;
            this._matrix = new cc.math.Matrix4();
            this._matrix.identity();
        };
        var proto = cc.ParticleBatchNode.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
        proto.constructor = cc.ParticleBatchNode.WebGLRenderCmd;
        proto.rendering = function(ctx) {
            var _t = this._node;
            if (0 === _t.textureAtlas.totalQuads) {
                return;
            }
            var wt = this._worldTransform, mat = this._matrix.mat;
            mat[0] = wt.a;
            mat[4] = wt.c;
            mat[12] = wt.tx;
            mat[1] = wt.b;
            mat[5] = wt.d;
            mat[13] = wt.ty;
            this._shaderProgram.use();
            this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix);
            cc.gl.blendFuncForParticle(_t._blendFunc.src, _t._blendFunc.dst);
            _t.textureAtlas.drawQuads();
        };
        proto._initWithTexture = function() {
            this._shaderProgram = cc.shaderCache.programForKey(cc.macro.SHADER_POSITION_TEXTURECOLOR);
        };
    }), {} ],
    262: [ (function(require, module, exports) {
        require("./CCSGParticleSystem.js");
        require("./CCSGParticleSystemCanvasRenderCmd.js");
        require("./CCSGParticleSystemWebGLRenderCmd.js");
        require("./CCParticleBatchNode.js");
        require("./CCParticleBatchNodeCanvasRenderCmd.js");
        require("./CCParticleBatchNodeWebGLRenderCmd.js");
        var BlendFactor = cc.BlendFunc.BlendFactor;
        var EmitterMode = cc.Enum({
            GRAVITY: 0,
            RADIUS: 1
        });
        var PositionType = cc.Enum({
            FREE: 0,
            RELATIVE: 1,
            GROUPED: 2
        });
        var properties = {
            preview: {
                default: true,
                editorOnly: true,
                notify: false,
                animatable: false,
                tooltip: "i18n:COMPONENT.particle_system.preview"
            },
            _custom: false,
            custom: {
                get: function() {
                    return this._custom;
                },
                set: function(value) {
                    if (this._custom !== value) {
                        this._custom = value;
                        value ? this._applyCustoms() : this._applyFile();
                    }
                },
                animatable: false,
                tooltip: "i18n:COMPONENT.particle_system.custom"
            },
            _file: {
                default: "",
                url: cc.ParticleAsset
            },
            file: {
                get: function() {
                    return this._file;
                },
                set: function(value, force) {
                    if (this._file !== value || false) {
                        this._file = value;
                        value ? this._applyFile() : this.custom = true;
                    }
                },
                animatable: false,
                url: cc.ParticleAsset,
                tooltip: "i18n:COMPONENT.particle_system.file"
            },
            _texture: {
                default: "",
                url: cc.Texture2D
            },
            texture: {
                get: function() {
                    return this._texture;
                },
                set: function(value) {
                    this._texture = value;
                    this._sgNode.texture = value ? cc.textureCache.addImage(value) : null;
                    !value && this._file && this._applyFile();
                },
                url: cc.Texture2D,
                tooltip: "i18n:COMPONENT.particle_system.texture"
            },
            particleCount: {
                get: function() {
                    return this._sgNode.particleCount;
                },
                set: function(value) {
                    this._sgNode.particleCount = value;
                },
                visible: false,
                tooltip: "i18n:COMPONENT.particle_system.particleCount"
            },
            _srcBlendFactor: BlendFactor.SRC_ALPHA,
            srcBlendFactor: {
                get: function() {
                    return this._srcBlendFactor;
                },
                set: function(value) {
                    this._srcBlendFactor = value;
                    this._blendFunc.src = value;
                    this._sgNode.setBlendFunc(this._blendFunc);
                },
                animatable: false,
                type: BlendFactor,
                tooltip: "i18n:COMPONENT.particle_system.srcBlendFactor"
            },
            _dstBlendFactor: BlendFactor.ONE_MINUS_SRC_ALPHA,
            dstBlendFactor: {
                get: function() {
                    return this._dstBlendFactor;
                },
                set: function(value) {
                    this._dstBlendFactor = value;
                    this._blendFunc.dst = value;
                    this._sgNode.setBlendFunc(this._blendFunc);
                },
                animatable: false,
                type: BlendFactor,
                tooltip: "i18n:COMPONENT.particle_system.dstBlendFactor"
            },
            playOnLoad: true,
            _autoRemoveOnFinish: false,
            autoRemoveOnFinish: {
                get: function() {
                    return this._autoRemoveOnFinish;
                },
                set: function(value) {
                    if (this._autoRemoveOnFinish !== value) {
                        this._autoRemoveOnFinish = value;
                        this._applyAutoRemove();
                    }
                },
                animatable: false,
                tooltip: "i18n:COMPONENT.particle_system.autoRemoveOnFinish"
            },
            active: {
                get: function() {
                    return !!this._sgNode && this._sgNode.isActive();
                },
                visible: false
            }
        };
        var CustomProps = (function() {
            var DefaultValues = {
                totalParticles: 150,
                duration: -1,
                emissionRate: 10,
                life: 1,
                lifeVar: 0,
                startColor: cc.Color.WHITE,
                startColorVar: cc.Color.BLACK,
                endColor: cc.color(255, 255, 255, 0),
                endColorVar: cc.color(0, 0, 0, 0),
                angle: 90,
                angleVar: 20,
                startSize: 50,
                startSizeVar: 0,
                endSize: 0,
                endSizeVar: 0,
                startSpin: 0,
                startSpinVar: 0,
                endSpin: 0,
                endSpinVar: 0,
                sourcePos: cc.p(0, 0),
                posVar: cc.p(0, 0),
                positionType: PositionType.FREE,
                emitterMode: EmitterMode.GRAVITY,
                gravity: cc.p(0, 0),
                speed: 180,
                speedVar: 50,
                tangentialAccel: 80,
                tangentialAccelVar: 0,
                radialAccel: 0,
                radialAccelVar: 0,
                rotationIsDir: false,
                startRadius: 0,
                startRadiusVar: 0,
                endRadius: 0,
                endRadiusVar: 0,
                rotatePerS: 0,
                rotatePerSVar: 0
            };
            var props = Object.keys(DefaultValues);
            for (var i = 0; i < props.length; ++i) {
                var prop = props[i];
                (function(prop, defaultValue) {
                    var internalProp = "_" + prop;
                    properties[internalProp] = defaultValue;
                    var type = defaultValue.constructor;
                    var propDef = properties[prop] = {};
                    if (cc.isChildClassOf(type, cc.ValueType)) {
                        propDef.get = function() {
                            return new type(this[internalProp]);
                        };
                        propDef.type = type;
                    } else {
                        propDef.get = function() {
                            return this[internalProp];
                        };
                    }
                    cc.isChildClassOf(type, cc.ValueType) ? propDef.set = function(value) {
                        this[internalProp] = new type(value);
                        this._sgNode[prop] = value;
                    } : propDef.set = function(value) {
                        this[internalProp] = value;
                        this._sgNode[prop] = value;
                    };
                })(prop, DefaultValues[prop]);
            }
            return props;
        })();
        properties.positionType.type = PositionType;
        properties.emitterMode.type = EmitterMode;
        var ParticleSystem = cc.Class({
            name: "cc.ParticleSystem",
            extends: cc._RendererUnderSG,
            editor: false,
            ctor: function() {
                this._previewTimer = null;
                this._focused = false;
                this._willStart = false;
                this._blendFunc = new cc.BlendFunc(0, 0);
                this._originOnExit = null;
            },
            properties: properties,
            statics: {
                DURATION_INFINITY: -1,
                START_SIZE_EQUAL_TO_END_SIZE: -1,
                START_RADIUS_EQUAL_TO_END_RADIUS: -1,
                EmitterMode: EmitterMode,
                PositionType: PositionType
            },
            __preload: function() {
                this._super();
                this.playOnLoad && this.resetSystem();
                this._applyAutoRemove();
            },
            onDestroy: function() {
                this._autoRemoveOnFinish && (this.autoRemoveOnFinish = false);
                this._super();
            },
            onFocusInEditor: false,
            onLostFocusInEditor: false,
            _createSgNode: function() {
                return new _ccsg.ParticleSystem();
            },
            _initSgNode: function() {
                var sgNode = this._sgNode;
                if (this._file) {
                    if (this._custom) {
                        var missCustomTexture = !this._texture;
                        missCustomTexture ? this._applyFile() : this._applyCustoms();
                    } else {
                        this._applyFile();
                    }
                } else {
                    this._custom && this._applyCustoms();
                }
                sgNode.stopSystem();
            },
            addParticle: function() {
                return this._sgNode.addParticle();
            },
            stopSystem: function() {
                this._sgNode.stopSystem();
            },
            resetSystem: function() {
                this._sgNode.resetSystem();
            },
            isFull: function() {
                return this.particleCount >= this._totalParticles;
            },
            setDisplayFrame: function(spriteFrame) {
                if (!spriteFrame) {
                    return;
                }
                var texture = spriteFrame.getTexture();
                texture && (this._texture = texture.url);
                this._sgNode.setDisplayFrame(spriteFrame);
            },
            setTextureWithRect: function(texture, rect) {
                texture instanceof cc.Texture2D && (this._texture = texture.url);
                this._sgNode.setTextureWithRect(texture, rect);
            },
            _applyFile: function() {
                var file = this._file;
                if (file) {
                    var self = this;
                    cc.loader.load(file, (function(err, content) {
                        if (err || !content) {
                            throw err || new Error("Unkown error");
                        }
                        if (!self.isValid) {
                            return;
                        }
                        var sgNode = self._sgNode;
                        sgNode.particleCount = 0;
                        var active = sgNode.isActive();
                        sgNode.initWithFile(file);
                        content.textureUuid && cc.AssetLibrary.queryAssetInfo(content.textureUuid, (function(err, url, raw) {
                            if (err) {
                                cc.error(err);
                                return;
                            }
                            self.texture = url;
                        }));
                        content.emissionRate && (self.emissionRate = content.emissionRate);
                        sgNode.setPosition(0, 0);
                        active || sgNode.stopSystem();
                        self._applyAutoRemove();
                        self._custom && self._applyCustoms();
                    }));
                }
            },
            _applyCustoms: function() {
                var sgNode = this._sgNode;
                var active = sgNode.isActive();
                for (var i = 0; i < CustomProps.length; i++) {
                    var prop = CustomProps[i];
                    sgNode[prop] = this["_" + prop];
                }
                this._blendFunc.src = this._srcBlendFactor;
                this._blendFunc.dst = this._dstBlendFactor;
                sgNode.setBlendFunc(this._blendFunc);
                this._texture && (sgNode.texture = cc.textureCache.addImage(this._texture));
                active || sgNode.stopSystem();
                this._applyAutoRemove();
            },
            _applyAutoRemove: function() {
                var sgNode = this._sgNode;
                var autoRemove = this._autoRemoveOnFinish;
                sgNode.autoRemoveOnFinish = autoRemove;
                if (autoRemove) {
                    if (this._originOnExit) {
                        return;
                    }
                    this._originOnExit = sgNode.onExit;
                    var self = this;
                    sgNode.onExit = function() {
                        self._originOnExit.call(this);
                        self.node.destroy();
                    };
                } else {
                    if (this._originOnExit) {
                        sgNode.onExit = this._originOnExit;
                        this._originOnExit = null;
                    }
                }
            }
        });
        cc.ParticleSystem = module.exports = ParticleSystem;
    }), {
        "./CCParticleBatchNode.js": 259,
        "./CCParticleBatchNodeCanvasRenderCmd.js": 260,
        "./CCParticleBatchNodeWebGLRenderCmd.js": 261,
        "./CCSGParticleSystem.js": 263,
        "./CCSGParticleSystemCanvasRenderCmd.js": 264,
        "./CCSGParticleSystemWebGLRenderCmd.js": 265
    } ],
    263: [ (function(require, module, exports) {
        var PNGReader = require("./CCPNGReader");
        var tiffReader = require("./CCTIFFReader");
        cc.Particle = function(pos, startPos, color, deltaColor, size, deltaSize, rotation, deltaRotation, timeToLive, atlasIndex, modeA, modeB) {
            this.pos = pos || cc.v2(0, 0);
            this.startPos = startPos || cc.v2(0, 0);
            this.color = color || cc.color(0, 0, 0, 255);
            this.deltaColor = deltaColor || {
                r: 0,
                g: 0,
                b: 0,
                a: 255
            };
            this.size = size || 0;
            this.deltaSize = deltaSize || 0;
            this.rotation = rotation || 0;
            this.deltaRotation = deltaRotation || 0;
            this.timeToLive = timeToLive || 0;
            this.atlasIndex = atlasIndex || 0;
            this.modeA = modeA ? modeA : new cc.Particle.ModeA();
            this.modeB = modeB ? modeB : new cc.Particle.ModeB();
            this.isChangeColor = false;
            this.drawPos = cc.p(0, 0);
        };
        cc.Particle.ModeA = function(dir, radialAccel, tangentialAccel) {
            this.dir = dir ? dir : cc.p(0, 0);
            this.radialAccel = radialAccel || 0;
            this.tangentialAccel = tangentialAccel || 0;
        };
        cc.Particle.ModeB = function(angle, degreesPerSecond, radius, deltaRadius) {
            this.angle = angle || 0;
            this.degreesPerSecond = degreesPerSecond || 0;
            this.radius = radius || 0;
            this.deltaRadius = deltaRadius || 0;
        };
        cc.Particle.TemporaryPoints = [ cc.p(), cc.p(), cc.p(), cc.p() ];
        _ccsg.ParticleSystem = _ccsg.Node.extend({
            _className: "ParticleSystem",
            _plistFile: "",
            _elapsed: 0,
            _dontTint: false,
            modeA: null,
            modeB: null,
            _pointZeroForParticle: cc.p(0, 0),
            _particles: null,
            _emitCounter: 0,
            _particleIdx: 0,
            _batchNode: null,
            atlasIndex: 0,
            _transformSystemDirty: false,
            _allocatedParticles: 0,
            _isActive: false,
            particleCount: 0,
            duration: 0,
            _sourcePosition: null,
            _posVar: null,
            life: 0,
            lifeVar: 0,
            angle: 0,
            angleVar: 0,
            startSize: 0,
            startSizeVar: 0,
            endSize: 0,
            endSizeVar: 0,
            _startColor: null,
            _startColorVar: null,
            _endColor: null,
            _endColorVar: null,
            startSpin: 0,
            startSpinVar: 0,
            endSpin: 0,
            endSpinVar: 0,
            emissionRate: 0,
            _totalParticles: 0,
            _texture: null,
            _blendFunc: null,
            _opacityModifyRGB: false,
            positionType: null,
            autoRemoveOnFinish: false,
            emitterMode: 0,
            _textureLoaded: null,
            ctor: function(plistFile) {
                _ccsg.Node.prototype.ctor.call(this);
                this.emitterMode = _ccsg.ParticleSystem.Mode.GRAVITY;
                this.modeA = new _ccsg.ParticleSystem.ModeA();
                this.modeB = new _ccsg.ParticleSystem.ModeB();
                this._blendFunc = {
                    src: cc.macro.BLEND_SRC,
                    dst: cc.macro.BLEND_DST
                };
                this._particles = [];
                this._sourcePosition = cc.p(0, 0);
                this._posVar = cc.p(0, 0);
                this._startColor = cc.color(255, 255, 255, 255);
                this._startColorVar = cc.color(255, 255, 255, 255);
                this._endColor = cc.color(255, 255, 255, 255);
                this._endColorVar = cc.color(255, 255, 255, 255);
                this._plistFile = "";
                this._elapsed = 0;
                this._dontTint = false;
                this._pointZeroForParticle = cc.p(0, 0);
                this._emitCounter = 0;
                this._particleIdx = 0;
                this._batchNode = null;
                this.atlasIndex = 0;
                this._transformSystemDirty = false;
                this._allocatedParticles = 0;
                this._isActive = false;
                this.particleCount = 0;
                this.duration = 0;
                this.life = 0;
                this.lifeVar = 0;
                this.angle = 0;
                this.angleVar = 0;
                this.startSize = 0;
                this.startSizeVar = 0;
                this.endSize = 0;
                this.endSizeVar = 0;
                this.startSpin = 0;
                this.startSpinVar = 0;
                this.endSpin = 0;
                this.endSpinVar = 0;
                this.emissionRate = 0;
                this._totalParticles = 0;
                this._texture = null;
                this._opacityModifyRGB = false;
                this.positionType = _ccsg.ParticleSystem.Type.FREE;
                this.autoRemoveOnFinish = false;
                this._textureLoaded = true;
                if (!plistFile || cc.js.isNumber(plistFile)) {
                    var ton = plistFile || 100;
                    this.setDrawMode(_ccsg.ParticleSystem.TEXTURE_MODE);
                    this.initWithTotalParticles(ton);
                } else {
                    "string" === typeof plistFile ? this.initWithFile(plistFile) : "object" === typeof plistFile && this.initWithDictionary(plistFile, "");
                }
            },
            _createRenderCmd: function() {
                return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new _ccsg.ParticleSystem.CanvasRenderCmd(this) : new _ccsg.ParticleSystem.WebGLRenderCmd(this);
            },
            ignoreColor: function(ignore) {
                this._dontTint = ignore;
            },
            initTexCoordsWithRect: function(pointRect) {
                this._renderCmd.initTexCoordsWithRect(pointRect);
            },
            getBatchNode: function() {
                return this._batchNode;
            },
            setBatchNode: function(batchNode) {
                this._renderCmd.setBatchNode(batchNode);
            },
            getAtlasIndex: function() {
                return this.atlasIndex;
            },
            setAtlasIndex: function(atlasIndex) {
                this.atlasIndex = atlasIndex;
            },
            getDrawMode: function() {
                return this._renderCmd.getDrawMode();
            },
            setDrawMode: function(drawMode) {
                this._renderCmd.setDrawMode(drawMode);
            },
            getShapeType: function() {
                return this._renderCmd.getShapeType();
            },
            setShapeType: function(shapeType) {
                this._renderCmd.setShapeType(shapeType);
            },
            isActive: function() {
                return this._isActive;
            },
            getParticleCount: function() {
                return this.particleCount;
            },
            setParticleCount: function(particleCount) {
                this.particleCount = particleCount;
            },
            getDuration: function() {
                return this.duration;
            },
            setDuration: function(duration) {
                this.duration = duration;
            },
            getSourcePosition: function() {
                return {
                    x: this._sourcePosition.x,
                    y: this._sourcePosition.y
                };
            },
            setSourcePosition: function(sourcePosition) {
                this._sourcePosition.x = sourcePosition.x;
                this._sourcePosition.y = sourcePosition.y;
            },
            getPosVar: function() {
                return {
                    x: this._posVar.x,
                    y: this._posVar.y
                };
            },
            setPosVar: function(posVar) {
                this._posVar.x = posVar.x;
                this._posVar.y = posVar.y;
            },
            getLife: function() {
                return this.life;
            },
            setLife: function(life) {
                this.life = life;
            },
            getLifeVar: function() {
                return this.lifeVar;
            },
            setLifeVar: function(lifeVar) {
                this.lifeVar = lifeVar;
            },
            getAngle: function() {
                return this.angle;
            },
            setAngle: function(angle) {
                this.angle = angle;
            },
            getAngleVar: function() {
                return this.angleVar;
            },
            setAngleVar: function(angleVar) {
                this.angleVar = angleVar;
            },
            getGravity: function() {
                var locGravity = this.modeA.gravity;
                return cc.p(locGravity.x, locGravity.y);
            },
            setGravity: function(gravity) {
                this.modeA.gravity = gravity;
            },
            getSpeed: function() {
                return this.modeA.speed;
            },
            setSpeed: function(speed) {
                this.modeA.speed = speed;
            },
            getSpeedVar: function() {
                return this.modeA.speedVar;
            },
            setSpeedVar: function(speedVar) {
                this.modeA.speedVar = speedVar;
            },
            getTangentialAccel: function() {
                return this.modeA.tangentialAccel;
            },
            setTangentialAccel: function(tangentialAccel) {
                this.modeA.tangentialAccel = tangentialAccel;
            },
            getTangentialAccelVar: function() {
                return this.modeA.tangentialAccelVar;
            },
            setTangentialAccelVar: function(tangentialAccelVar) {
                this.modeA.tangentialAccelVar = tangentialAccelVar;
            },
            getRadialAccel: function() {
                return this.modeA.radialAccel;
            },
            setRadialAccel: function(radialAccel) {
                this.modeA.radialAccel = radialAccel;
            },
            getRadialAccelVar: function() {
                return this.modeA.radialAccelVar;
            },
            setRadialAccelVar: function(radialAccelVar) {
                this.modeA.radialAccelVar = radialAccelVar;
            },
            getRotationIsDir: function() {
                return this.modeA.rotationIsDir;
            },
            setRotationIsDir: function(t) {
                this.modeA.rotationIsDir = t;
            },
            getStartRadius: function() {
                return this.modeB.startRadius;
            },
            setStartRadius: function(startRadius) {
                this.modeB.startRadius = startRadius;
            },
            getStartRadiusVar: function() {
                return this.modeB.startRadiusVar;
            },
            setStartRadiusVar: function(startRadiusVar) {
                this.modeB.startRadiusVar = startRadiusVar;
            },
            getEndRadius: function() {
                return this.modeB.endRadius;
            },
            setEndRadius: function(endRadius) {
                this.modeB.endRadius = endRadius;
            },
            getEndRadiusVar: function() {
                return this.modeB.endRadiusVar;
            },
            setEndRadiusVar: function(endRadiusVar) {
                this.modeB.endRadiusVar = endRadiusVar;
            },
            getRotatePerSecond: function() {
                return this.modeB.rotatePerSecond;
            },
            setRotatePerSecond: function(degrees) {
                this.modeB.rotatePerSecond = degrees;
            },
            getRotatePerSecondVar: function() {
                return this.modeB.rotatePerSecondVar;
            },
            setRotatePerSecondVar: function(degrees) {
                this.modeB.rotatePerSecondVar = degrees;
            },
            setScale: function(scale, scaleY) {
                this._transformSystemDirty = true;
                _ccsg.Node.prototype.setScale.call(this, scale, scaleY);
            },
            setRotation: function(newRotation) {
                this._transformSystemDirty = true;
                _ccsg.Node.prototype.setRotation.call(this, newRotation);
            },
            setScaleX: function(newScaleX) {
                this._transformSystemDirty = true;
                _ccsg.Node.prototype.setScaleX.call(this, newScaleX);
            },
            setScaleY: function(newScaleY) {
                this._transformSystemDirty = true;
                _ccsg.Node.prototype.setScaleY.call(this, newScaleY);
            },
            getStartSize: function() {
                return this.startSize;
            },
            setStartSize: function(startSize) {
                this.startSize = startSize;
            },
            getStartSizeVar: function() {
                return this.startSizeVar;
            },
            setStartSizeVar: function(startSizeVar) {
                this.startSizeVar = startSizeVar;
            },
            getEndSize: function() {
                return this.endSize;
            },
            setEndSize: function(endSize) {
                this.endSize = endSize;
            },
            getEndSizeVar: function() {
                return this.endSizeVar;
            },
            setEndSizeVar: function(endSizeVar) {
                this.endSizeVar = endSizeVar;
            },
            getStartColor: function() {
                return cc.color(this._startColor.r, this._startColor.g, this._startColor.b, this._startColor.a);
            },
            setStartColor: function(startColor) {
                this._startColor.fromColor(startColor);
            },
            getStartColorVar: function() {
                return cc.color(this._startColorVar.r, this._startColorVar.g, this._startColorVar.b, this._startColorVar.a);
            },
            setStartColorVar: function(startColorVar) {
                this._startColorVar.fromColor(startColorVar);
            },
            getEndColor: function() {
                return cc.color(this._endColor.r, this._endColor.g, this._endColor.b, this._endColor.a);
            },
            setEndColor: function(endColor) {
                this._endColor.fromColor(endColor);
            },
            getEndColorVar: function() {
                return cc.color(this._endColorVar.r, this._endColorVar.g, this._endColorVar.b, this._endColorVar.a);
            },
            setEndColorVar: function(endColorVar) {
                this._endColorVar.fromColor(endColorVar);
            },
            getStartSpin: function() {
                return this.startSpin;
            },
            setStartSpin: function(startSpin) {
                this.startSpin = startSpin;
            },
            getStartSpinVar: function() {
                return this.startSpinVar;
            },
            setStartSpinVar: function(startSpinVar) {
                this.startSpinVar = startSpinVar;
            },
            getEndSpin: function() {
                return this.endSpin;
            },
            setEndSpin: function(endSpin) {
                this.endSpin = endSpin;
            },
            getEndSpinVar: function() {
                return this.endSpinVar;
            },
            setEndSpinVar: function(endSpinVar) {
                this.endSpinVar = endSpinVar;
            },
            getEmissionRate: function() {
                return this.emissionRate;
            },
            setEmissionRate: function(emissionRate) {
                this.emissionRate = emissionRate;
            },
            getTotalParticles: function() {
                return this._totalParticles;
            },
            setTotalParticles: function(tp) {
                this._renderCmd.setTotalParticles(tp);
            },
            getTexture: function() {
                return this._texture;
            },
            setTexture: function(texture) {
                if (!texture) {
                    return;
                }
                if (texture.isLoaded()) {
                    this.setTextureWithRect(texture, cc.rect(0, 0, texture.width, texture.height));
                } else {
                    this._textureLoaded = false;
                    texture.once("load", (function(event) {
                        this._textureLoaded = true;
                        this.setTextureWithRect(texture, cc.rect(0, 0, texture.width, texture.height));
                    }), this);
                }
            },
            getBlendFunc: function() {
                return this._blendFunc;
            },
            setBlendFunc: function(src, dst) {
                if (void 0 === dst) {
                    if (this._blendFunc !== src) {
                        this._blendFunc = src;
                        this._updateBlendFunc();
                    }
                } else {
                    if (this._blendFunc.src !== src || this._blendFunc.dst !== dst) {
                        this._blendFunc = {
                            src: src,
                            dst: dst
                        };
                        this._updateBlendFunc();
                    }
                }
            },
            isOpacityModifyRGB: function() {
                return this._opacityModifyRGB;
            },
            setOpacityModifyRGB: function(newValue) {
                this._opacityModifyRGB = newValue;
            },
            isBlendAdditive: function() {
                return this._blendFunc.src === cc.macro.SRC_ALPHA && this._blendFunc.dst === cc.macro.ONE || this._blendFunc.src === cc.macro.ONE && this._blendFunc.dst === cc.macro.ONE;
            },
            setBlendAdditive: function(isBlendAdditive) {
                var locBlendFunc = this._blendFunc;
                if (isBlendAdditive) {
                    locBlendFunc.src = cc.macro.SRC_ALPHA;
                    locBlendFunc.dst = cc.macro.ONE;
                } else {
                    this._renderCmd._setBlendAdditive();
                }
            },
            getPositionType: function() {
                return this.positionType;
            },
            setPositionType: function(positionType) {
                this.positionType = positionType;
            },
            isAutoRemoveOnFinish: function() {
                return this.autoRemoveOnFinish;
            },
            setAutoRemoveOnFinish: function(isAutoRemoveOnFinish) {
                this.autoRemoveOnFinish = isAutoRemoveOnFinish;
            },
            getEmitterMode: function() {
                return this.emitterMode;
            },
            setEmitterMode: function(emitterMode) {
                this.emitterMode = emitterMode;
            },
            init: function() {
                return this.initWithTotalParticles(150);
            },
            initWithFile: function(plistFile) {
                this._plistFile = plistFile;
                var dict = cc.loader.getRes(plistFile);
                if (!dict) {
                    cc.logID(6008);
                    return false;
                }
                return this.initWithDictionary(dict, "");
            },
            getBoundingBoxToWorld: function() {
                return cc.rect(0, 0, cc._canvas.width, cc._canvas.height);
            },
            initWithDictionary: function(dictionary, dirname) {
                var ret = false;
                var buffer = null;
                var image = null;
                var locValueForKey = this._valueForKey;
                var maxParticles = parseInt(locValueForKey("maxParticles", dictionary));
                if (this.initWithTotalParticles(maxParticles)) {
                    this.angle = parseFloat(locValueForKey("angle", dictionary));
                    this.angleVar = parseFloat(locValueForKey("angleVariance", dictionary));
                    this.duration = parseFloat(locValueForKey("duration", dictionary));
                    this._blendFunc.src = parseInt(locValueForKey("blendFuncSource", dictionary));
                    this._blendFunc.dst = parseInt(locValueForKey("blendFuncDestination", dictionary));
                    var locStartColor = this._startColor;
                    locStartColor.r = 255 * parseFloat(locValueForKey("startColorRed", dictionary));
                    locStartColor.g = 255 * parseFloat(locValueForKey("startColorGreen", dictionary));
                    locStartColor.b = 255 * parseFloat(locValueForKey("startColorBlue", dictionary));
                    locStartColor.a = 255 * parseFloat(locValueForKey("startColorAlpha", dictionary));
                    var locStartColorVar = this._startColorVar;
                    locStartColorVar.r = 255 * parseFloat(locValueForKey("startColorVarianceRed", dictionary));
                    locStartColorVar.g = 255 * parseFloat(locValueForKey("startColorVarianceGreen", dictionary));
                    locStartColorVar.b = 255 * parseFloat(locValueForKey("startColorVarianceBlue", dictionary));
                    locStartColorVar.a = 255 * parseFloat(locValueForKey("startColorVarianceAlpha", dictionary));
                    var locEndColor = this._endColor;
                    locEndColor.r = 255 * parseFloat(locValueForKey("finishColorRed", dictionary));
                    locEndColor.g = 255 * parseFloat(locValueForKey("finishColorGreen", dictionary));
                    locEndColor.b = 255 * parseFloat(locValueForKey("finishColorBlue", dictionary));
                    locEndColor.a = 255 * parseFloat(locValueForKey("finishColorAlpha", dictionary));
                    var locEndColorVar = this._endColorVar;
                    locEndColorVar.r = 255 * parseFloat(locValueForKey("finishColorVarianceRed", dictionary));
                    locEndColorVar.g = 255 * parseFloat(locValueForKey("finishColorVarianceGreen", dictionary));
                    locEndColorVar.b = 255 * parseFloat(locValueForKey("finishColorVarianceBlue", dictionary));
                    locEndColorVar.a = 255 * parseFloat(locValueForKey("finishColorVarianceAlpha", dictionary));
                    this.startSize = parseFloat(locValueForKey("startParticleSize", dictionary));
                    this.startSizeVar = parseFloat(locValueForKey("startParticleSizeVariance", dictionary));
                    this.endSize = parseFloat(locValueForKey("finishParticleSize", dictionary));
                    this.endSizeVar = parseFloat(locValueForKey("finishParticleSizeVariance", dictionary));
                    this.setPosition(parseFloat(locValueForKey("sourcePositionx", dictionary)), parseFloat(locValueForKey("sourcePositiony", dictionary)));
                    this._posVar.x = parseFloat(locValueForKey("sourcePositionVariancex", dictionary));
                    this._posVar.y = parseFloat(locValueForKey("sourcePositionVariancey", dictionary));
                    this.startSpin = parseFloat(locValueForKey("rotationStart", dictionary));
                    this.startSpinVar = parseFloat(locValueForKey("rotationStartVariance", dictionary));
                    this.endSpin = parseFloat(locValueForKey("rotationEnd", dictionary));
                    this.endSpinVar = parseFloat(locValueForKey("rotationEndVariance", dictionary));
                    this.emitterMode = parseInt(locValueForKey("emitterType", dictionary));
                    if (this.emitterMode === _ccsg.ParticleSystem.Mode.GRAVITY) {
                        var locModeA = this.modeA;
                        locModeA.gravity.x = parseFloat(locValueForKey("gravityx", dictionary));
                        locModeA.gravity.y = parseFloat(locValueForKey("gravityy", dictionary));
                        locModeA.speed = parseFloat(locValueForKey("speed", dictionary));
                        locModeA.speedVar = parseFloat(locValueForKey("speedVariance", dictionary));
                        var pszTmp = locValueForKey("radialAcceleration", dictionary);
                        locModeA.radialAccel = pszTmp ? parseFloat(pszTmp) : 0;
                        pszTmp = locValueForKey("radialAccelVariance", dictionary);
                        locModeA.radialAccelVar = pszTmp ? parseFloat(pszTmp) : 0;
                        pszTmp = locValueForKey("tangentialAcceleration", dictionary);
                        locModeA.tangentialAccel = pszTmp ? parseFloat(pszTmp) : 0;
                        pszTmp = locValueForKey("tangentialAccelVariance", dictionary);
                        locModeA.tangentialAccelVar = pszTmp ? parseFloat(pszTmp) : 0;
                        var locRotationIsDir = locValueForKey("rotationIsDir", dictionary);
                        if (null !== locRotationIsDir) {
                            locRotationIsDir = locRotationIsDir.toString().toLowerCase();
                            locModeA.rotationIsDir = "true" === locRotationIsDir || "1" === locRotationIsDir;
                        } else {
                            locModeA.rotationIsDir = false;
                        }
                    } else {
                        if (this.emitterMode !== _ccsg.ParticleSystem.Mode.RADIUS) {
                            cc.logID(6009);
                            return false;
                        }
                        var locModeB = this.modeB;
                        locModeB.startRadius = parseFloat(locValueForKey("maxRadius", dictionary));
                        locModeB.startRadiusVar = parseFloat(locValueForKey("maxRadiusVariance", dictionary));
                        locModeB.endRadius = parseFloat(locValueForKey("minRadius", dictionary));
                        locModeB.endRadiusVar = 0;
                        locModeB.rotatePerSecond = parseFloat(locValueForKey("rotatePerSecond", dictionary));
                        locModeB.rotatePerSecondVar = parseFloat(locValueForKey("rotatePerSecondVariance", dictionary));
                    }
                    this.life = parseFloat(locValueForKey("particleLifespan", dictionary));
                    this.lifeVar = parseFloat(locValueForKey("particleLifespanVariance", dictionary));
                    this.emissionRate = this._totalParticles / this.life;
                    if (!this._batchNode) {
                        this._opacityModifyRGB = false;
                        var textureName = locValueForKey("textureFileName", dictionary);
                        var imgPath = cc.path.changeBasename(this._plistFile, textureName);
                        var tex = cc.textureCache.getTextureForKey(imgPath);
                        if (tex) {
                            this.setTexture(tex);
                        } else {
                            var textureData = locValueForKey("textureImageData", dictionary);
                            if (textureData && 0 !== textureData.length) {
                                buffer = cc.Codec.unzipBase64AsArray(textureData, 1);
                                if (!buffer) {
                                    cc.logID(6010);
                                    return false;
                                }
                                var imageFormat = cc.getImageFormatByData(buffer);
                                if (imageFormat !== cc.ImageFormat.TIFF && imageFormat !== cc.ImageFormat.PNG) {
                                    cc.logID(6011);
                                    return false;
                                }
                                var canvasObj = document.createElement("canvas");
                                if (imageFormat === cc.ImageFormat.PNG) {
                                    var myPngObj = new PNGReader(buffer);
                                    myPngObj.render(canvasObj);
                                } else {
                                    tiffReader.parseTIFF(buffer, canvasObj);
                                }
                                cc.textureCache.cacheImage(imgPath, canvasObj);
                                var addTexture = cc.textureCache.getTextureForKey(imgPath);
                                addTexture || cc.logID(6012);
                                this.setTexture(addTexture);
                            } else {
                                tex = cc.textureCache.addImage(imgPath);
                                if (!tex) {
                                    return false;
                                }
                                this.setTexture(tex);
                            }
                        }
                    }
                    ret = true;
                }
                return ret;
            },
            initWithTotalParticles: function(numberOfParticles) {
                this._totalParticles = numberOfParticles;
                var i, locParticles = this._particles;
                locParticles.length = 0;
                for (i = 0; i < numberOfParticles; i++) {
                    locParticles[i] = new cc.Particle();
                }
                if (!locParticles) {
                    cc.logID(6013);
                    return false;
                }
                this._allocatedParticles = numberOfParticles;
                if (this._batchNode) {
                    for (i = 0; i < this._totalParticles; i++) {
                        locParticles[i].atlasIndex = i;
                    }
                }
                this._isActive = true;
                this._blendFunc.src = cc.macro.BLEND_SRC;
                this._blendFunc.dst = cc.macro.BLEND_DST;
                this.positionType = _ccsg.ParticleSystem.Type.FREE;
                this.emitterMode = _ccsg.ParticleSystem.Mode.GRAVITY;
                this.autoRemoveOnFinish = false;
                this._transformSystemDirty = false;
                this.scheduleUpdateWithPriority(1);
                this._renderCmd._initWithTotalParticles(numberOfParticles);
                return true;
            },
            destroyParticleSystem: function() {
                this.unscheduleUpdate();
            },
            addParticle: function() {
                if (this.isFull()) {
                    return false;
                }
                var particle = this._renderCmd.addParticle();
                this.initParticle(particle);
                ++this.particleCount;
                return true;
            },
            initParticle: function(particle) {
                var locRandomMinus11 = cc.randomMinus1To1;
                particle.timeToLive = this.life + this.lifeVar * locRandomMinus11();
                particle.timeToLive = Math.max(0, particle.timeToLive);
                particle.pos.x = this._sourcePosition.x + this._posVar.x * locRandomMinus11();
                particle.pos.y = this._sourcePosition.y + this._posVar.y * locRandomMinus11();
                var start, end;
                var locStartColor = this._startColor, locStartColorVar = this._startColorVar;
                var locEndColor = this._endColor, locEndColorVar = this._endColorVar;
                start = {
                    r: cc.clampf(locStartColor.r + locStartColorVar.r * locRandomMinus11(), 0, 255),
                    g: cc.clampf(locStartColor.g + locStartColorVar.g * locRandomMinus11(), 0, 255),
                    b: cc.clampf(locStartColor.b + locStartColorVar.b * locRandomMinus11(), 0, 255),
                    a: cc.clampf(locStartColor.a + locStartColorVar.a * locRandomMinus11(), 0, 255)
                };
                end = {
                    r: cc.clampf(locEndColor.r + locEndColorVar.r * locRandomMinus11(), 0, 255),
                    g: cc.clampf(locEndColor.g + locEndColorVar.g * locRandomMinus11(), 0, 255),
                    b: cc.clampf(locEndColor.b + locEndColorVar.b * locRandomMinus11(), 0, 255),
                    a: cc.clampf(locEndColor.a + locEndColorVar.a * locRandomMinus11(), 0, 255)
                };
                particle.color = start;
                var locParticleDeltaColor = particle.deltaColor, locParticleTimeToLive = particle.timeToLive;
                locParticleDeltaColor.r = (end.r - start.r) / locParticleTimeToLive;
                locParticleDeltaColor.g = (end.g - start.g) / locParticleTimeToLive;
                locParticleDeltaColor.b = (end.b - start.b) / locParticleTimeToLive;
                locParticleDeltaColor.a = (end.a - start.a) / locParticleTimeToLive;
                var startS = this.startSize + this.startSizeVar * locRandomMinus11();
                startS = Math.max(0, startS);
                particle.size = startS;
                if (this.endSize === _ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE) {
                    particle.deltaSize = 0;
                } else {
                    var endS = this.endSize + this.endSizeVar * locRandomMinus11();
                    endS = Math.max(0, endS);
                    particle.deltaSize = (endS - startS) / locParticleTimeToLive;
                }
                var startA = this.startSpin + this.startSpinVar * locRandomMinus11();
                var endA = this.endSpin + this.endSpinVar * locRandomMinus11();
                particle.rotation = startA;
                particle.deltaRotation = (endA - startA) / locParticleTimeToLive;
                if (this.positionType === _ccsg.ParticleSystem.Type.FREE) {
                    particle.startPos = this.convertToWorldSpace(this._pointZeroForParticle);
                } else {
                    if (this.positionType === _ccsg.ParticleSystem.Type.RELATIVE) {
                        particle.startPos.x = this._position.x;
                        particle.startPos.y = this._position.y;
                    }
                }
                var a = cc.degreesToRadians(this.angle + this.angleVar * locRandomMinus11());
                if (this.emitterMode === _ccsg.ParticleSystem.Mode.GRAVITY) {
                    var locModeA = this.modeA, locParticleModeA = particle.modeA;
                    var s = locModeA.speed + locModeA.speedVar * locRandomMinus11();
                    locParticleModeA.dir.x = Math.cos(a);
                    locParticleModeA.dir.y = Math.sin(a);
                    cc.pMultIn(locParticleModeA.dir, s);
                    locParticleModeA.radialAccel = locModeA.radialAccel + locModeA.radialAccelVar * locRandomMinus11();
                    locParticleModeA.tangentialAccel = locModeA.tangentialAccel + locModeA.tangentialAccelVar * locRandomMinus11();
                    locModeA.rotationIsDir && (particle.rotation = -cc.radiansToDegrees(cc.pToAngle(locParticleModeA.dir)));
                } else {
                    var locModeB = this.modeB, locParitlceModeB = particle.modeB;
                    var startRadius = locModeB.startRadius + locModeB.startRadiusVar * locRandomMinus11();
                    var endRadius = locModeB.endRadius + locModeB.endRadiusVar * locRandomMinus11();
                    locParitlceModeB.radius = startRadius;
                    locParitlceModeB.deltaRadius = locModeB.endRadius === _ccsg.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (endRadius - startRadius) / locParticleTimeToLive;
                    locParitlceModeB.angle = a;
                    locParitlceModeB.degreesPerSecond = cc.degreesToRadians(locModeB.rotatePerSecond + locModeB.rotatePerSecondVar * locRandomMinus11());
                }
            },
            stopSystem: function() {
                this._isActive = false;
                this._elapsed = this.duration;
                this._emitCounter = 0;
            },
            resetSystem: function() {
                this._isActive = true;
                this._elapsed = 0;
                var locParticles = this._particles;
                for (this._particleIdx = 0; this._particleIdx < this.particleCount; ++this._particleIdx) {
                    locParticles[this._particleIdx].timeToLive = 0;
                }
            },
            isFull: function() {
                return this.particleCount >= this._totalParticles;
            },
            updateQuadWithParticle: function(particle, newPosition) {
                this._renderCmd.updateQuadWithParticle(particle, newPosition);
            },
            postStep: function() {
                this._renderCmd.postStep();
            },
            update: function(dt) {
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
                if (this._isActive && this.emissionRate) {
                    var rate = 1 / this.emissionRate;
                    this.particleCount < this._totalParticles && (this._emitCounter += dt);
                    while (this.particleCount < this._totalParticles && this._emitCounter > rate) {
                        this.addParticle();
                        this._emitCounter -= rate;
                    }
                    this._elapsed += dt;
                    this.duration !== -1 && this.duration < this._elapsed && this.stopSystem();
                }
                this._particleIdx = 0;
                var worldToNodeTransform = this.getWorldToNodeTransform();
                var currentPosition = cc.Particle.TemporaryPoints[0];
                if (this.positionType === _ccsg.ParticleSystem.Type.FREE) {
                    cc.pIn(currentPosition, this.convertToWorldSpace(this._pointZeroForParticle));
                } else {
                    if (this.positionType === _ccsg.ParticleSystem.Type.RELATIVE) {
                        currentPosition.x = this._position.x;
                        currentPosition.y = this._position.y;
                    }
                }
                if (this._visible) {
                    var tpa = cc.Particle.TemporaryPoints[1], tpb = cc.Particle.TemporaryPoints[2], tpc = cc.Particle.TemporaryPoints[3];
                    var locParticles = this._particles;
                    while (this._particleIdx < this.particleCount) {
                        cc.pZeroIn(tpa);
                        cc.pZeroIn(tpb);
                        cc.pZeroIn(tpc);
                        var selParticle = locParticles[this._particleIdx];
                        selParticle.timeToLive -= dt;
                        if (selParticle.timeToLive > 0) {
                            if (this.emitterMode === _ccsg.ParticleSystem.Mode.GRAVITY) {
                                var tmp = tpc, radial = tpa, tangential = tpb;
                                if (selParticle.pos.x || selParticle.pos.y) {
                                    cc.pIn(radial, selParticle.pos);
                                    cc.pNormalizeIn(radial);
                                } else {
                                    cc.pZeroIn(radial);
                                }
                                cc.pIn(tangential, radial);
                                cc.pMultIn(radial, selParticle.modeA.radialAccel);
                                var newy = tangential.x;
                                tangential.x = -tangential.y;
                                tangential.y = newy;
                                cc.pMultIn(tangential, selParticle.modeA.tangentialAccel);
                                cc.pIn(tmp, radial);
                                cc.pAddIn(tmp, tangential);
                                cc.pAddIn(tmp, this.modeA.gravity);
                                cc.pMultIn(tmp, dt);
                                cc.pAddIn(selParticle.modeA.dir, tmp);
                                cc.pIn(tmp, selParticle.modeA.dir);
                                cc.pMultIn(tmp, dt);
                                cc.pAddIn(selParticle.pos, tmp);
                            } else {
                                var selModeB = selParticle.modeB;
                                selModeB.angle += selModeB.degreesPerSecond * dt;
                                selModeB.radius += selModeB.deltaRadius * dt;
                                selParticle.pos.x = -Math.cos(selModeB.angle) * selModeB.radius;
                                selParticle.pos.y = -Math.sin(selModeB.angle) * selModeB.radius;
                            }
                            this._renderCmd._updateDeltaColor(selParticle, dt);
                            selParticle.size += selParticle.deltaSize * dt;
                            selParticle.size = Math.max(0, selParticle.size);
                            selParticle.rotation += selParticle.deltaRotation * dt;
                            var newPos = tpa;
                            if (this.positionType === _ccsg.ParticleSystem.Type.FREE || this.positionType === _ccsg.ParticleSystem.Type.RELATIVE) {
                                var diff = tpb, localStartPos = tpc;
                                cc._pointApplyAffineTransformIn(currentPosition, worldToNodeTransform, diff);
                                cc._pointApplyAffineTransformIn(selParticle.startPos, worldToNodeTransform, localStartPos);
                                cc.pSubIn(diff, localStartPos);
                                cc.pIn(newPos, selParticle.pos);
                                cc.pSubIn(newPos, diff);
                            } else {
                                cc.pIn(newPos, selParticle.pos);
                            }
                            if (this._batchNode) {
                                newPos.x += this._position.x;
                                newPos.y += this._position.y;
                            }
                            this._renderCmd.updateParticlePosition(selParticle, newPos);
                            ++this._particleIdx;
                        } else {
                            var currentIndex = selParticle.atlasIndex;
                            if (this._particleIdx !== this.particleCount - 1) {
                                var deadParticle = locParticles[this._particleIdx];
                                locParticles[this._particleIdx] = locParticles[this.particleCount - 1];
                                locParticles[this.particleCount - 1] = deadParticle;
                            }
                            if (this._batchNode) {
                                this._batchNode.disableParticle(this.atlasIndex + currentIndex);
                                locParticles[this.particleCount - 1].atlasIndex = currentIndex;
                            }
                            --this.particleCount;
                            if (0 === this.particleCount && this.autoRemoveOnFinish) {
                                this.unscheduleUpdate();
                                this._parent.removeChild(this, true);
                                this._renderCmd.updateLocalBB && this._renderCmd.updateLocalBB();
                                return;
                            }
                        }
                    }
                    this._renderCmd.updateLocalBB && this._renderCmd.updateLocalBB();
                    this._transformSystemDirty = false;
                }
                this._batchNode || this.postStep();
            },
            updateWithNoTime: function() {
                this.update(0);
            },
            _valueForKey: function(key, dict) {
                if (dict) {
                    var pString = dict[key];
                    return null != pString ? pString : "";
                }
                return "";
            },
            _updateBlendFunc: function() {
                if (this._batchNode) {
                    cc.logID(6014);
                    return;
                }
                var locTexture = this._texture;
                if (locTexture && locTexture instanceof cc.Texture2D) {
                    this._opacityModifyRGB = false;
                    var locBlendFunc = this._blendFunc;
                    if (locBlendFunc.src === cc.macro.BLEND_SRC && locBlendFunc.dst === cc.macro.BLEND_DST) {
                        if (locTexture.hasPremultipliedAlpha()) {
                            this._opacityModifyRGB = true;
                        } else {
                            locBlendFunc.src = cc.macro.SRC_ALPHA;
                            locBlendFunc.dst = cc.macro.ONE_MINUS_SRC_ALPHA;
                        }
                    }
                }
            },
            clone: function() {
                var retParticle = new _ccsg.ParticleSystem();
                if (retParticle.initWithTotalParticles(this.getTotalParticles())) {
                    retParticle.setAngle(this.getAngle());
                    retParticle.setAngleVar(this.getAngleVar());
                    retParticle.setDuration(this.getDuration());
                    var blend = this.getBlendFunc();
                    retParticle.setBlendFunc(blend.src, blend.dst);
                    retParticle.setStartColor(this.getStartColor());
                    retParticle.setStartColorVar(this.getStartColorVar());
                    retParticle.setEndColor(this.getEndColor());
                    retParticle.setEndColorVar(this.getEndColorVar());
                    retParticle.setStartSize(this.getStartSize());
                    retParticle.setStartSizeVar(this.getStartSizeVar());
                    retParticle.setEndSize(this.getEndSize());
                    retParticle.setEndSizeVar(this.getEndSizeVar());
                    retParticle.setPosition(cc.p(this.x, this.y));
                    retParticle.setPosVar(cc.p(this.getPosVar().x, this.getPosVar().y));
                    retParticle.setPositionType(this.getPositionType());
                    retParticle.setStartSpin(this.getStartSpin() || 0);
                    retParticle.setStartSpinVar(this.getStartSpinVar() || 0);
                    retParticle.setEndSpin(this.getEndSpin() || 0);
                    retParticle.setEndSpinVar(this.getEndSpinVar() || 0);
                    retParticle.setEmitterMode(this.getEmitterMode());
                    if (this.getEmitterMode() === _ccsg.ParticleSystem.Mode.GRAVITY) {
                        var gra = this.getGravity();
                        retParticle.setGravity(cc.p(gra.x, gra.y));
                        retParticle.setSpeed(this.getSpeed());
                        retParticle.setSpeedVar(this.getSpeedVar());
                        retParticle.setRadialAccel(this.getRadialAccel());
                        retParticle.setRadialAccelVar(this.getRadialAccelVar());
                        retParticle.setTangentialAccel(this.getTangentialAccel());
                        retParticle.setTangentialAccelVar(this.getTangentialAccelVar());
                    } else {
                        if (this.getEmitterMode() === _ccsg.ParticleSystem.Mode.RADIUS) {
                            retParticle.setStartRadius(this.getStartRadius());
                            retParticle.setStartRadiusVar(this.getStartRadiusVar());
                            retParticle.setEndRadius(this.getEndRadius());
                            retParticle.setEndRadiusVar(this.getEndRadiusVar());
                            retParticle.setRotatePerSecond(this.getRotatePerSecond());
                            retParticle.setRotatePerSecondVar(this.getRotatePerSecondVar());
                        }
                    }
                    retParticle.setLife(this.getLife());
                    retParticle.setLifeVar(this.getLifeVar());
                    retParticle.setEmissionRate(this.getEmissionRate());
                    if (!this.getBatchNode()) {
                        retParticle.setOpacityModifyRGB(this.isOpacityModifyRGB());
                        var texture = this.getTexture();
                        if (texture) {
                            var size = texture.getContentSize();
                            retParticle.setTextureWithRect(texture, cc.rect(0, 0, size.width, size.height));
                        }
                    }
                }
                return retParticle;
            },
            setDisplayFrame: function(spriteFrame) {
                if (!spriteFrame) {
                    return;
                }
                var locOffset = spriteFrame.getOffset();
                0 === locOffset.x && 0 === locOffset.y || cc.logID(6015);
                var texture = spriteFrame.getTexture(), locTexture = this._texture;
                locTexture !== texture && this.setTexture(texture);
            },
            setTextureWithRect: function(texture, rect) {
                var locTexture = this._texture;
                if (locTexture !== texture) {
                    this._texture = texture;
                    this._updateBlendFunc();
                }
                this.initTexCoordsWithRect(rect);
            },
            listenBackToForeground: function(obj) {}
        });
        var _p = _ccsg.ParticleSystem.prototype;
        _p.opacityModifyRGB;
        cc.defineGetterSetter(_p, "opacityModifyRGB", _p.isOpacityModifyRGB, _p.setOpacityModifyRGB);
        _p.batchNode;
        cc.defineGetterSetter(_p, "batchNode", _p.getBatchNode, _p.setBatchNode);
        _p.drawMode;
        cc.defineGetterSetter(_p, "drawMode", _p.getDrawMode, _p.setDrawMode);
        _p.shapeType;
        cc.defineGetterSetter(_p, "shapeType", _p.getShapeType, _p.setShapeType);
        _p.active;
        cc.defineGetterSetter(_p, "active", _p.isActive);
        _p.sourcePos;
        cc.defineGetterSetter(_p, "sourcePos", _p.getSourcePosition, _p.setSourcePosition);
        _p.posVar;
        cc.defineGetterSetter(_p, "posVar", _p.getPosVar, _p.setPosVar);
        _p.gravity;
        cc.defineGetterSetter(_p, "gravity", _p.getGravity, _p.setGravity);
        _p.speed;
        cc.defineGetterSetter(_p, "speed", _p.getSpeed, _p.setSpeed);
        _p.speedVar;
        cc.defineGetterSetter(_p, "speedVar", _p.getSpeedVar, _p.setSpeedVar);
        _p.tangentialAccel;
        cc.defineGetterSetter(_p, "tangentialAccel", _p.getTangentialAccel, _p.setTangentialAccel);
        _p.tangentialAccelVar;
        cc.defineGetterSetter(_p, "tangentialAccelVar", _p.getTangentialAccelVar, _p.setTangentialAccelVar);
        _p.radialAccel;
        cc.defineGetterSetter(_p, "radialAccel", _p.getRadialAccel, _p.setRadialAccel);
        _p.radialAccelVar;
        cc.defineGetterSetter(_p, "radialAccelVar", _p.getRadialAccelVar, _p.setRadialAccelVar);
        _p.rotationIsDir;
        cc.defineGetterSetter(_p, "rotationIsDir", _p.getRotationIsDir, _p.setRotationIsDir);
        _p.startRadius;
        cc.defineGetterSetter(_p, "startRadius", _p.getStartRadius, _p.setStartRadius);
        _p.startRadiusVar;
        cc.defineGetterSetter(_p, "startRadiusVar", _p.getStartRadiusVar, _p.setStartRadiusVar);
        _p.endRadius;
        cc.defineGetterSetter(_p, "endRadius", _p.getEndRadius, _p.setEndRadius);
        _p.endRadiusVar;
        cc.defineGetterSetter(_p, "endRadiusVar", _p.getEndRadiusVar, _p.setEndRadiusVar);
        _p.rotatePerS;
        cc.defineGetterSetter(_p, "rotatePerS", _p.getRotatePerSecond, _p.setRotatePerSecond);
        _p.rotatePerSVar;
        cc.defineGetterSetter(_p, "rotatePerSVar", _p.getRotatePerSecondVar, _p.setRotatePerSecondVar);
        _p.startColor;
        cc.defineGetterSetter(_p, "startColor", _p.getStartColor, _p.setStartColor);
        _p.startColorVar;
        cc.defineGetterSetter(_p, "startColorVar", _p.getStartColorVar, _p.setStartColorVar);
        _p.endColor;
        cc.defineGetterSetter(_p, "endColor", _p.getEndColor, _p.setEndColor);
        _p.endColorVar;
        cc.defineGetterSetter(_p, "endColorVar", _p.getEndColorVar, _p.setEndColorVar);
        _p.totalParticles;
        cc.defineGetterSetter(_p, "totalParticles", _p.getTotalParticles, _p.setTotalParticles);
        _p.texture;
        cc.defineGetterSetter(_p, "texture", _p.getTexture, _p.setTexture);
        _ccsg.ParticleSystem.ModeA = function(gravity, speed, speedVar, tangentialAccel, tangentialAccelVar, radialAccel, radialAccelVar, rotationIsDir) {
            this.gravity = gravity ? gravity : cc.p(0, 0);
            this.speed = speed || 0;
            this.speedVar = speedVar || 0;
            this.tangentialAccel = tangentialAccel || 0;
            this.tangentialAccelVar = tangentialAccelVar || 0;
            this.radialAccel = radialAccel || 0;
            this.radialAccelVar = radialAccelVar || 0;
            this.rotationIsDir = rotationIsDir || false;
        };
        _ccsg.ParticleSystem.ModeB = function(startRadius, startRadiusVar, endRadius, endRadiusVar, rotatePerSecond, rotatePerSecondVar) {
            this.startRadius = startRadius || 0;
            this.startRadiusVar = startRadiusVar || 0;
            this.endRadius = endRadius || 0;
            this.endRadiusVar = endRadiusVar || 0;
            this.rotatePerSecond = rotatePerSecond || 0;
            this.rotatePerSecondVar = rotatePerSecondVar || 0;
        };
        _ccsg.ParticleSystem.SHAPE_MODE = 0;
        _ccsg.ParticleSystem.TEXTURE_MODE = 1;
        _ccsg.ParticleSystem.STAR_SHAPE = 0;
        _ccsg.ParticleSystem.BALL_SHAPE = 1;
        _ccsg.ParticleSystem.DURATION_INFINITY = -1;
        _ccsg.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE = -1;
        _ccsg.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS = -1;
        _ccsg.ParticleSystem.Mode = cc.Enum({
            GRAVITY: 0,
            RADIUS: 1
        });
        _ccsg.ParticleSystem.Type = cc.Enum({
            FREE: 0,
            RELATIVE: 1,
            GROUPED: 2
        });
    }), {
        "./CCPNGReader": 257,
        "./CCTIFFReader": 266
    } ],
    264: [ (function(require, module, exports) {
        _ccsg.ParticleSystem.CanvasRenderCmd = function(renderable) {
            this._rootCtor(renderable);
            this._needDraw = true;
            this._drawMode = _ccsg.ParticleSystem.TEXTURE_MODE;
            this._shapeType = _ccsg.ParticleSystem.BALL_SHAPE;
            this._pointRect = cc.rect(0, 0, 0, 0);
            this._localRegion = new cc.Region();
            this._tintCache = null;
        };
        var proto = _ccsg.ParticleSystem.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
        proto.constructor = _ccsg.ParticleSystem.CanvasRenderCmd;
        proto.getDrawMode = function() {
            return this._drawMode;
        };
        proto.setDrawMode = function(drawMode) {
            this._drawMode = drawMode;
        };
        proto.getShapeType = function() {
            return this._shapeType;
        };
        proto.setShapeType = function(shapeType) {
            this._shapeType = shapeType;
        };
        proto.setBatchNode = function(batchNode) {
            this._batchNode !== batchNode && (this._node._batchNode = batchNode);
        };
        proto.updateQuadWithParticle = function(particle, newPosition) {};
        proto.updateParticlePosition = function(particle, position) {
            cc.pIn(particle.drawPos, position);
        };
        var particleRegion = new cc.Region();
        var localBB = new cc.Rect();
        proto.updateLocalBB = function() {
            var region = this._localRegion;
            var particles = this._node._particles;
            region.setEmpty();
            for (var index = particles.length - 1; index >= 0; --index) {
                var particle = particles[index];
                var pos = particle.drawPos;
                var size = 1.415 * particle.size;
                particleRegion.setTo(pos.x - size, pos.y - size, pos.x + size, pos.y + size);
                region.union(particleRegion);
            }
            localBB.x = region._minX;
            localBB.y = region._minY;
            localBB.width = region._maxX - region._minX;
            localBB.height = region._maxY - region._minY;
        };
        proto.getLocalBB = function() {
            return localBB;
        };
        proto.updateStatus = function() {
            this.originUpdateStatus();
            this._updateCurrentRegions();
            this._regionFlag = _ccsg.Node.CanvasRenderCmd.RegionStatus.DirtyDouble;
            this._dirtyFlag &= ~_ccsg.Node._dirtyFlags.contentDirty;
        };
        proto.rendering = function(ctx, scaleX, scaleY) {
            var wrapper = ctx || cc._renderContext, context = wrapper.getContext(), node = this._node, pointRect = this._pointRect;
            wrapper.setTransform(this._worldTransform, scaleX, scaleY);
            wrapper.save();
            node.isBlendAdditive() ? context.globalCompositeOperation = "lighter" : context.globalCompositeOperation = "source-over";
            var i, particle, lpx, alpha;
            var particleCount = this._node.particleCount, particles = this._node._particles;
            if (node.drawMode !== _ccsg.ParticleSystem.SHAPE_MODE && node._texture) {
                if (!node._texture._textureLoaded) {
                    wrapper.restore();
                    return;
                }
                var element = node._texture.getHtmlElementObj();
                if (!element.width || !element.height) {
                    wrapper.restore();
                    return;
                }
                var drawElement = element;
                for (i = 0; i < particleCount; i++) {
                    particle = particles[i];
                    lpx = 0 | .5 * particle.size;
                    alpha = particle.color.a / 255;
                    if (0 === alpha) {
                        continue;
                    }
                    context.globalAlpha = alpha;
                    context.save();
                    context.translate(0 | particle.drawPos.x, -(0 | particle.drawPos.y));
                    var size = 4 * Math.floor(particle.size / 4);
                    var w = pointRect.width;
                    var h = pointRect.height;
                    context.scale(Math.max(1 / w * size, 1e-6), Math.max(1 / h * size, 1e-6));
                    particle.rotation && context.rotate(cc.degreesToRadians(particle.rotation));
                    drawElement = particle.isChangeColor ? this._changeTextureColor(node._texture, particle.color, this._pointRect) : element;
                    context.drawImage(drawElement, -(0 | w / 2), -(0 | h / 2));
                    context.restore();
                }
            } else {
                var drawTool = cc._drawingUtil;
                for (i = 0; i < particleCount; i++) {
                    particle = particles[i];
                    lpx = 0 | .5 * particle.size;
                    alpha = particle.color.a / 255;
                    if (0 === alpha) {
                        continue;
                    }
                    context.globalAlpha = alpha;
                    context.save();
                    context.translate(0 | particle.drawPos.x, -(0 | particle.drawPos.y));
                    if (node.shapeType === _ccsg.ParticleSystem.STAR_SHAPE) {
                        particle.rotation && context.rotate(cc.degreesToRadians(particle.rotation));
                        drawTool.drawStar(wrapper, lpx, particle.color);
                    } else {
                        drawTool.drawColorBall(wrapper, lpx, particle.color);
                    }
                    context.restore();
                }
            }
            wrapper.restore();
            cc.g_NumberOfDraws++;
        };
        proto._changeTextureColor = function(texture, color, rect) {
            this._tintCache || (this._tintCache = document.createElement("canvas"));
            var tintCache = this._tintCache;
            var textureContentSize = texture.getContentSize();
            tintCache.width = textureContentSize.width;
            tintCache.height = textureContentSize.height;
            return texture._generateColorTexture(color.r, color.g, color.b, rect, tintCache);
        };
        proto.initTexCoordsWithRect = function(pointRect) {
            this._pointRect = pointRect;
        };
        proto.setTotalParticles = function(tp) {
            this._node._totalParticles = tp < 200 ? tp : 200;
        };
        proto.addParticle = function() {
            var node = this._node, particles = node._particles, particle;
            if (node.particleCount < particles.length) {
                particle = particles[node.particleCount];
            } else {
                particle = new cc.Particle();
                particles.push(particle);
            }
            return particle;
        };
        proto._setupVBO = function() {};
        proto._allocMemory = function() {
            return true;
        };
        proto.postStep = function() {};
        proto._setBlendAdditive = function() {
            var locBlendFunc = this._node._blendFunc;
            locBlendFunc.src = cc.macro.BLEND_SRC;
            locBlendFunc.dst = cc.macro.BLEND_DST;
        };
        proto._initWithTotalParticles = function(totalParticles) {};
        proto._updateDeltaColor = function(selParticle, dt) {
            if (!this._node._dontTint) {
                selParticle.color.r += selParticle.deltaColor.r * dt;
                selParticle.color.g += selParticle.deltaColor.g * dt;
                selParticle.color.b += selParticle.deltaColor.b * dt;
                selParticle.color.a += selParticle.deltaColor.a * dt;
                selParticle.isChangeColor = true;
            }
        };
    }), {} ],
    265: [ (function(require, module, exports) {
        _ccsg.ParticleSystem.WebGLRenderCmd = function(renderable) {
            this._rootCtor(renderable);
            this._needDraw = true;
            this._matrix = new cc.math.Matrix4();
            this._matrix.identity();
            this._buffersVBO = [ 0, 0 ];
            this._quads = [];
            this._indices = [];
            this._quadsArrayBuffer = null;
        };
        var proto = _ccsg.ParticleSystem.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
        proto.constructor = _ccsg.ParticleSystem.WebGLRenderCmd;
        proto.getDrawMode = function() {};
        proto.setDrawMode = function(drawMode) {};
        proto.getShapeType = function() {};
        proto.setShapeType = function(shapeType) {};
        proto.setBatchNode = function(batchNode) {
            var node = this._node;
            if (node._batchNode !== batchNode) {
                var oldBatch = node._batchNode;
                node._batchNode = batchNode;
                if (batchNode) {
                    var locParticles = node._particles;
                    for (var i = 0; i < node._totalParticles; i++) {
                        locParticles[i].atlasIndex = i;
                    }
                }
                if (batchNode) {
                    if (!oldBatch) {
                        node._batchNode.textureAtlas._copyQuadsToTextureAtlas(this._quads, node.atlasIndex);
                        cc._renderContext.deleteBuffer(this._buffersVBO[1]);
                    }
                } else {
                    this._allocMemory();
                    this.initIndices(node._totalParticles);
                    node.setTexture(oldBatch.getTexture());
                    this._setupVBO();
                }
            }
        };
        proto.initIndices = function(totalParticles) {
            var locIndices = this._indices;
            for (var i = 0, len = totalParticles; i < len; ++i) {
                var i6 = 6 * i;
                var i4 = 4 * i;
                locIndices[i6 + 0] = i4 + 0;
                locIndices[i6 + 1] = i4 + 1;
                locIndices[i6 + 2] = i4 + 2;
                locIndices[i6 + 5] = i4 + 1;
                locIndices[i6 + 4] = i4 + 2;
                locIndices[i6 + 3] = i4 + 3;
            }
        };
        proto.isDifferentTexture = function(texture1, texture2) {
            return texture1 === texture2;
        };
        proto.updateParticlePosition = function(particle, position) {
            this.updateQuadWithParticle(particle, position);
        };
        proto.updateQuadWithParticle = function(particle, newPosition) {
            var quad = null, node = this._node;
            if (node._batchNode) {
                var batchQuads = node._batchNode.textureAtlas.quads;
                quad = batchQuads[node.atlasIndex + particle.atlasIndex];
                node._batchNode.textureAtlas.dirty = true;
            } else {
                quad = this._quads[node._particleIdx];
            }
            var r, g, b, a;
            if (node._opacityModifyRGB) {
                r = 0 | particle.color.r * particle.color.a / 255;
                g = 0 | particle.color.g * particle.color.a / 255;
                b = 0 | particle.color.b * particle.color.a / 255;
            } else {
                r = 0 | particle.color.r;
                g = 0 | particle.color.g;
                b = 0 | particle.color.b;
            }
            a = 0 | particle.color.a;
            var blColors = quad.bl.colors, brColors = quad.br.colors, tlColors = quad.tl.colors, trColors = quad.tr.colors;
            blColors.r = brColors.r = tlColors.r = trColors.r = r;
            blColors.g = brColors.g = tlColors.g = trColors.g = g;
            blColors.b = brColors.b = tlColors.b = trColors.b = b;
            blColors.a = brColors.a = tlColors.a = trColors.a = a;
            var size_2 = particle.size / 2;
            if (particle.rotation) {
                var x1 = -size_2, y1 = -size_2;
                var x2 = size_2, y2 = size_2;
                var x = newPosition.x, y = newPosition.y;
                var rad = -cc.degreesToRadians(particle.rotation);
                var cr = Math.cos(rad), sr = Math.sin(rad);
                var ax = x1 * cr - y1 * sr + x;
                var ay = x1 * sr + y1 * cr + y;
                var bx = x2 * cr - y1 * sr + x;
                var by = x2 * sr + y1 * cr + y;
                var cx = x2 * cr - y2 * sr + x;
                var cy = x2 * sr + y2 * cr + y;
                var dx = x1 * cr - y2 * sr + x;
                var dy = x1 * sr + y2 * cr + y;
                quad.bl.vertices.x = ax;
                quad.bl.vertices.y = ay;
                quad.br.vertices.x = bx;
                quad.br.vertices.y = by;
                quad.tl.vertices.x = dx;
                quad.tl.vertices.y = dy;
                quad.tr.vertices.x = cx;
                quad.tr.vertices.y = cy;
            } else {
                quad.bl.vertices.x = newPosition.x - size_2;
                quad.bl.vertices.y = newPosition.y - size_2;
                quad.br.vertices.x = newPosition.x + size_2;
                quad.br.vertices.y = newPosition.y - size_2;
                quad.tl.vertices.x = newPosition.x - size_2;
                quad.tl.vertices.y = newPosition.y + size_2;
                quad.tr.vertices.x = newPosition.x + size_2;
                quad.tr.vertices.y = newPosition.y + size_2;
            }
        };
        proto.rendering = function(ctx) {
            var node = this._node;
            if (!node._texture) {
                return;
            }
            var gl = ctx || cc._renderContext;
            var wt = this._worldTransform, mat = this._matrix.mat;
            mat[0] = wt.a;
            mat[4] = wt.c;
            mat[12] = wt.tx;
            mat[1] = wt.b;
            mat[5] = wt.d;
            mat[13] = wt.ty;
            this._shaderProgram.use();
            this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix);
            cc.gl.bindTexture2DN(0, node._texture);
            cc.gl.blendFuncForParticle(node._blendFunc.src, node._blendFunc.dst);
            gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_POSITION);
            gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_COLOR);
            gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_TEX_COORDS);
            gl.bindBuffer(gl.ARRAY_BUFFER, this._buffersVBO[0]);
            gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_POSITION, 3, gl.FLOAT, false, 24, 0);
            gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, 24, 12);
            gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, 24, 16);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
            gl.drawElements(gl.TRIANGLES, 6 * node._particleIdx, gl.UNSIGNED_SHORT, 0);
        };
        proto.initTexCoordsWithRect = function(pointRect) {
            var node = this._node;
            var texture = node.texture;
            var wide = pointRect.width;
            var high = pointRect.height;
            if (texture) {
                wide = texture.getPixelWidth();
                high = texture.getPixelHeight();
            }
            var left, bottom, right, top;
            if (cc.macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL) {
                left = (2 * pointRect.x + 1) / (2 * wide);
                bottom = (2 * pointRect.y + 1) / (2 * high);
                right = left + (2 * pointRect.width - 2) / (2 * wide);
                top = bottom + (2 * pointRect.height - 2) / (2 * high);
            } else {
                left = pointRect.x / wide;
                bottom = pointRect.y / high;
                right = left + pointRect.width / wide;
                top = bottom + pointRect.height / high;
            }
            var temp = top;
            top = bottom;
            bottom = temp;
            var quads;
            var start = 0, end = 0;
            if (node._batchNode) {
                quads = node._batchNode.textureAtlas.quads;
                start = node.atlasIndex;
                end = node.atlasIndex + node._totalParticles;
            } else {
                quads = this._quads;
                start = 0;
                end = node._totalParticles;
            }
            for (var i = start; i < end; i++) {
                quads[i] || (quads[i] = cc.V3F_C4B_T2F_QuadZero());
                var selQuad = quads[i];
                selQuad.bl.texCoords.u = left;
                selQuad.bl.texCoords.v = bottom;
                selQuad.br.texCoords.u = right;
                selQuad.br.texCoords.v = bottom;
                selQuad.tl.texCoords.u = left;
                selQuad.tl.texCoords.v = top;
                selQuad.tr.texCoords.u = right;
                selQuad.tr.texCoords.v = top;
            }
        };
        proto.setTotalParticles = function(tp) {
            var node = this._node;
            if (tp > node._allocatedParticles) {
                var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
                this._indices = new Uint16Array(6 * tp);
                var locQuadsArrayBuffer = new ArrayBuffer(tp * quadSize);
                var locParticles = node._particles;
                locParticles.length = 0;
                var locQuads = this._quads;
                locQuads.length = 0;
                for (var j = 0; j < tp; j++) {
                    locParticles[j] = new cc.Particle();
                    locQuads[j] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, locQuadsArrayBuffer, j * quadSize);
                }
                node._allocatedParticles = tp;
                node._totalParticles = tp;
                if (node._batchNode) {
                    for (var i = 0; i < tp; i++) {
                        locParticles[i].atlasIndex = i;
                    }
                }
                this._quadsArrayBuffer = locQuadsArrayBuffer;
                this.initIndices(tp);
                this._setupVBO();
                node._texture && this.initTexCoordsWithRect(cc.rect(0, 0, node._texture.width, node._texture.height));
            } else {
                node._totalParticles = tp;
            }
            node.resetSystem();
        };
        proto.addParticle = function() {
            var node = this._node, particles = node._particles;
            return particles[node.particleCount];
        };
        proto._setupVBO = function() {
            var node = this;
            var gl = cc._renderContext;
            this._buffersVBO[0] = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this._buffersVBO[0]);
            gl.bufferData(gl.ARRAY_BUFFER, this._quadsArrayBuffer, gl.DYNAMIC_DRAW);
            this._buffersVBO[1] = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._buffersVBO[1]);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indices, gl.STATIC_DRAW);
        };
        proto._allocMemory = function() {
            var node = this._node;
            if (node._batchNode) {
                cc.logID(6016);
                return false;
            }
            var quadSize = cc.V3F_C4B_T2F_Quad.BYTES_PER_ELEMENT;
            var totalParticles = node._totalParticles;
            var locQuads = this._quads;
            locQuads.length = 0;
            this._indices = new Uint16Array(6 * totalParticles);
            var locQuadsArrayBuffer = new ArrayBuffer(quadSize * totalParticles);
            for (var i = 0; i < totalParticles; i++) {
                locQuads[i] = new cc.V3F_C4B_T2F_Quad(null, null, null, null, locQuadsArrayBuffer, i * quadSize);
            }
            if (!locQuads || !this._indices) {
                cc.logID(6013);
                return false;
            }
            this._quadsArrayBuffer = locQuadsArrayBuffer;
            return true;
        };
        proto.postStep = function() {
            var gl = cc._renderContext;
            gl.bindBuffer(gl.ARRAY_BUFFER, this._buffersVBO[0]);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._quadsArrayBuffer);
        };
        proto._setBlendAdditive = function() {
            var locBlendFunc = this._node._blendFunc;
            if (this._texture && !this._texture.hasPremultipliedAlpha()) {
                locBlendFunc.src = cc.macro.SRC_ALPHA;
                locBlendFunc.dst = cc.macro.ONE_MINUS_SRC_ALPHA;
            } else {
                locBlendFunc.src = cc.macro.BLEND_SRC;
                locBlendFunc.dst = cc.macro.BLEND_DST;
            }
        };
        proto._initWithTotalParticles = function(totalParticles) {
            if (!this._allocMemory()) {
                return false;
            }
            this.initIndices(totalParticles);
            this._setupVBO();
            this._shaderProgram = cc.shaderCache.programForKey(cc.macro.SHADER_POSITION_TEXTURECOLOR);
        };
        proto._updateDeltaColor = function(selParticle, dt) {
            selParticle.color.r += selParticle.deltaColor.r * dt;
            selParticle.color.g += selParticle.deltaColor.g * dt;
            selParticle.color.b += selParticle.deltaColor.b * dt;
            selParticle.color.a += selParticle.deltaColor.a * dt;
            selParticle.isChangeColor = true;
        };
    }), {} ],
    266: [ (function(require, module, exports) {
        var tiffReader = {
            _littleEndian: false,
            _tiffData: null,
            _fileDirectories: [],
            getUint8: function(offset) {
                return this._tiffData[offset];
            },
            getUint16: function(offset) {
                return this._littleEndian ? this._tiffData[offset + 1] << 8 | this._tiffData[offset] : this._tiffData[offset] << 8 | this._tiffData[offset + 1];
            },
            getUint32: function(offset) {
                var a = this._tiffData;
                return this._littleEndian ? a[offset + 3] << 24 | a[offset + 2] << 16 | a[offset + 1] << 8 | a[offset] : a[offset] << 24 | a[offset + 1] << 16 | a[offset + 2] << 8 | a[offset + 3];
            },
            checkLittleEndian: function() {
                var BOM = this.getUint16(0);
                if (18761 === BOM) {
                    this.littleEndian = true;
                } else {
                    if (19789 !== BOM) {
                        console.log(BOM);
                        throw TypeError("Invalid byte order value.");
                    }
                    this.littleEndian = false;
                }
                return this.littleEndian;
            },
            hasTowel: function() {
                if (42 !== this.getUint16(2)) {
                    throw RangeError("You forgot your towel!");
                }
                return true;
            },
            getFieldTypeName: function(fieldType) {
                var typeNames = this.fieldTypeNames;
                if (fieldType in typeNames) {
                    return typeNames[fieldType];
                }
                return null;
            },
            getFieldTagName: function(fieldTag) {
                var tagNames = this.fieldTagNames;
                if (fieldTag in tagNames) {
                    return tagNames[fieldTag];
                }
                console.log("Unknown Field Tag:", fieldTag);
                return "Tag" + fieldTag;
            },
            getFieldTypeLength: function(fieldTypeName) {
                if ([ "BYTE", "ASCII", "SBYTE", "UNDEFINED" ].indexOf(fieldTypeName) !== -1) {
                    return 1;
                }
                if ([ "SHORT", "SSHORT" ].indexOf(fieldTypeName) !== -1) {
                    return 2;
                }
                if ([ "LONG", "SLONG", "FLOAT" ].indexOf(fieldTypeName) !== -1) {
                    return 4;
                }
                if ([ "RATIONAL", "SRATIONAL", "DOUBLE" ].indexOf(fieldTypeName) !== -1) {
                    return 8;
                }
                return null;
            },
            getFieldValues: function(fieldTagName, fieldTypeName, typeCount, valueOffset) {
                var fieldValues = [];
                var fieldTypeLength = this.getFieldTypeLength(fieldTypeName);
                var fieldValueSize = fieldTypeLength * typeCount;
                if (fieldValueSize <= 4) {
                    false === this.littleEndian ? fieldValues.push(valueOffset >>> 8 * (4 - fieldTypeLength)) : fieldValues.push(valueOffset);
                } else {
                    for (var i = 0; i < typeCount; i++) {
                        var indexOffset = fieldTypeLength * i;
                        if (fieldTypeLength >= 8) {
                            if ([ "RATIONAL", "SRATIONAL" ].indexOf(fieldTypeName) !== -1) {
                                fieldValues.push(this.getUint32(valueOffset + indexOffset));
                                fieldValues.push(this.getUint32(valueOffset + indexOffset + 4));
                            } else {
                                cc.logID(8e3);
                            }
                        } else {
                            fieldValues.push(this.getBytes(fieldTypeLength, valueOffset + indexOffset));
                        }
                    }
                }
                "ASCII" === fieldTypeName && fieldValues.forEach((function(e, i, a) {
                    a[i] = String.fromCharCode(e);
                }));
                return fieldValues;
            },
            getBytes: function(numBytes, offset) {
                if (numBytes <= 0) {
                    cc.logID(8001);
                } else {
                    if (numBytes <= 1) {
                        return this.getUint8(offset);
                    }
                    if (numBytes <= 2) {
                        return this.getUint16(offset);
                    }
                    if (numBytes <= 3) {
                        return this.getUint32(offset) >>> 8;
                    }
                    if (numBytes <= 4) {
                        return this.getUint32(offset);
                    }
                    cc.logID(8002);
                }
            },
            getBits: function(numBits, byteOffset, bitOffset) {
                bitOffset = bitOffset || 0;
                var extraBytes = Math.floor(bitOffset / 8);
                var newByteOffset = byteOffset + extraBytes;
                var totalBits = bitOffset + numBits;
                var shiftRight = 32 - numBits;
                var shiftLeft, rawBits;
                if (totalBits <= 0) {
                    console.log("No bits requested");
                } else {
                    if (totalBits <= 8) {
                        shiftLeft = 24 + bitOffset;
                        rawBits = this.getUint8(newByteOffset);
                    } else {
                        if (totalBits <= 16) {
                            shiftLeft = 16 + bitOffset;
                            rawBits = this.getUint16(newByteOffset);
                        } else {
                            if (totalBits <= 32) {
                                shiftLeft = bitOffset;
                                rawBits = this.getUint32(newByteOffset);
                            } else {
                                console.log("Too many bits requested");
                            }
                        }
                    }
                }
                return {
                    bits: rawBits << shiftLeft >>> shiftRight,
                    byteOffset: newByteOffset + Math.floor(totalBits / 8),
                    bitOffset: totalBits % 8
                };
            },
            parseFileDirectory: function(byteOffset) {
                var numDirEntries = this.getUint16(byteOffset);
                var tiffFields = [];
                for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, 
                entryCount++) {
                    var fieldTag = this.getUint16(i);
                    var fieldType = this.getUint16(i + 2);
                    var typeCount = this.getUint32(i + 4);
                    var valueOffset = this.getUint32(i + 8);
                    var fieldTagName = this.getFieldTagName(fieldTag);
                    var fieldTypeName = this.getFieldTypeName(fieldType);
                    var fieldValues = this.getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);
                    tiffFields[fieldTagName] = {
                        type: fieldTypeName,
                        values: fieldValues
                    };
                }
                this._fileDirectories.push(tiffFields);
                var nextIFDByteOffset = this.getUint32(i);
                0 !== nextIFDByteOffset && this.parseFileDirectory(nextIFDByteOffset);
            },
            clampColorSample: function(colorSample, bitsPerSample) {
                var multiplier = Math.pow(2, 8 - bitsPerSample);
                return Math.floor(colorSample * multiplier + (multiplier - 1));
            },
            parseTIFF: function(tiffData, canvas) {
                canvas = canvas || document.createElement("canvas");
                this._tiffData = tiffData;
                this.canvas = canvas;
                this.checkLittleEndian();
                if (!this.hasTowel()) {
                    return;
                }
                var firstIFDByteOffset = this.getUint32(4);
                this._fileDirectories.length = 0;
                this.parseFileDirectory(firstIFDByteOffset);
                var fileDirectory = this._fileDirectories[0];
                var imageWidth = fileDirectory["ImageWidth"].values[0];
                var imageLength = fileDirectory["ImageLength"].values[0];
                this.canvas.width = imageWidth;
                this.canvas.height = imageLength;
                var strips = [];
                var compression = fileDirectory["Compression"] ? fileDirectory["Compression"].values[0] : 1;
                var samplesPerPixel = fileDirectory["SamplesPerPixel"].values[0];
                var sampleProperties = [];
                var bitsPerPixel = 0;
                var hasBytesPerPixel = false;
                fileDirectory["BitsPerSample"].values.forEach((function(bitsPerSample, i, bitsPerSampleValues) {
                    sampleProperties[i] = {
                        bitsPerSample: bitsPerSample,
                        hasBytesPerSample: false,
                        bytesPerSample: void 0
                    };
                    if (bitsPerSample % 8 === 0) {
                        sampleProperties[i].hasBytesPerSample = true;
                        sampleProperties[i].bytesPerSample = bitsPerSample / 8;
                    }
                    bitsPerPixel += bitsPerSample;
                }), this);
                if (bitsPerPixel % 8 === 0) {
                    hasBytesPerPixel = true;
                    var bytesPerPixel = bitsPerPixel / 8;
                }
                var stripOffsetValues = fileDirectory["StripOffsets"].values;
                var numStripOffsetValues = stripOffsetValues.length;
                if (fileDirectory["StripByteCounts"]) {
                    var stripByteCountValues = fileDirectory["StripByteCounts"].values;
                } else {
                    cc.logID(8003);
                    if (1 !== numStripOffsetValues) {
                        throw Error("Cannot recover from missing StripByteCounts");
                    }
                    var stripByteCountValues = [ Math.ceil(imageWidth * imageLength * bitsPerPixel / 8) ];
                }
                for (var i = 0; i < numStripOffsetValues; i++) {
                    var stripOffset = stripOffsetValues[i];
                    strips[i] = [];
                    var stripByteCount = stripByteCountValues[i];
                    for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {
                        switch (compression) {
                          case 1:
                            for (var m = 0, pixel = []; m < samplesPerPixel; m++) {
                                if (!sampleProperties[m].hasBytesPerSample) {
                                    var sampleInfo = this.getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);
                                    pixel.push(sampleInfo.bits);
                                    byteOffset = sampleInfo.byteOffset - stripOffset;
                                    bitOffset = sampleInfo.bitOffset;
                                    throw RangeError("Cannot handle sub-byte bits per sample");
                                }
                                var sampleOffset = sampleProperties[m].bytesPerSample * m;
                                pixel.push(this.getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));
                            }
                            strips[i].push(pixel);
                            if (!hasBytesPerPixel) {
                                jIncrement = 0;
                                throw RangeError("Cannot handle sub-byte bits per pixel");
                            }
                            jIncrement = bytesPerPixel;
                            break;

                          case 2:
                            break;

                          case 3:
                            break;

                          case 4:
                            break;

                          case 5:
                            break;

                          case 6:
                            break;

                          case 7:
                            break;

                          case 32773:
                            if (getHeader) {
                                getHeader = false;
                                var blockLength = 1;
                                var iterations = 1;
                                var header = this.getInt8(stripOffset + byteOffset);
                                header >= 0 && header <= 127 ? blockLength = header + 1 : header >= -127 && header <= -1 ? iterations = -header + 1 : getHeader = true;
                            } else {
                                var currentByte = this.getUint8(stripOffset + byteOffset);
                                for (var m = 0; m < iterations; m++) {
                                    if (!sampleProperties[sample].hasBytesPerSample) {
                                        throw RangeError("Cannot handle sub-byte bits per sample");
                                    }
                                    currentSample = currentSample << 8 * numBytes | currentByte;
                                    numBytes++;
                                    if (numBytes === sampleProperties[sample].bytesPerSample) {
                                        pixel.push(currentSample);
                                        currentSample = numBytes = 0;
                                        sample++;
                                    }
                                    if (sample === samplesPerPixel) {
                                        strips[i].push(pixel);
                                        pixel = [];
                                        sample = 0;
                                    }
                                }
                                blockLength--;
                                0 === blockLength && (getHeader = true);
                            }
                            jIncrement = 1;
                        }
                    }
                }
                if (canvas.getContext) {
                    var ctx = this.canvas.getContext("2d");
                    ctx.fillStyle = "rgba(255, 255, 255, 0)";
                    var rowsPerStrip = fileDirectory["RowsPerStrip"] ? fileDirectory["RowsPerStrip"].values[0] : imageLength;
                    var numStrips = strips.length;
                    var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;
                    var rowsInLastStrip = 0 === imageLengthModRowsPerStrip ? rowsPerStrip : imageLengthModRowsPerStrip;
                    var numRowsInStrip = rowsPerStrip;
                    var numRowsInPreviousStrip = 0;
                    var photometricInterpretation = fileDirectory["PhotometricInterpretation"].values[0];
                    var extraSamplesValues = [];
                    var numExtraSamples = 0;
                    if (fileDirectory["ExtraSamples"]) {
                        extraSamplesValues = fileDirectory["ExtraSamples"].values;
                        numExtraSamples = extraSamplesValues.length;
                    }
                    if (fileDirectory["ColorMap"]) {
                        var colorMapValues = fileDirectory["ColorMap"].values;
                        var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);
                    }
                    for (var i = 0; i < numStrips; i++) {
                        i + 1 === numStrips && (numRowsInStrip = rowsInLastStrip);
                        var numPixels = strips[i].length;
                        var yPadding = numRowsInPreviousStrip * i;
                        for (var y = 0, j = 0; y < numRowsInStrip, j < numPixels; y++) {
                            for (var x = 0; x < imageWidth; x++, j++) {
                                var pixelSamples = strips[i][j];
                                var red = 0;
                                var green = 0;
                                var blue = 0;
                                var opacity = 1;
                                if (numExtraSamples > 0) {
                                    for (var k = 0; k < numExtraSamples; k++) {
                                        if (1 === extraSamplesValues[k] || 2 === extraSamplesValues[k]) {
                                            opacity = pixelSamples[3 + k] / 256;
                                            break;
                                        }
                                    }
                                }
                                switch (photometricInterpretation) {
                                  case 0:
                                    if (sampleProperties[0].hasBytesPerSample) {
                                        var invertValue = Math.pow(16, 2 * sampleProperties[0].bytesPerSample);
                                    }
                                    pixelSamples.forEach((function(sample, index, samples) {
                                        samples[index] = invertValue - sample;
                                    }));

                                  case 1:
                                    red = green = blue = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                                    break;

                                  case 2:
                                    red = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                                    green = this.clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);
                                    blue = this.clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);
                                    break;

                                  case 3:
                                    if (void 0 === colorMapValues) {
                                        throw Error("Palette image missing color map");
                                    }
                                    var colorMapIndex = pixelSamples[0];
                                    red = this.clampColorSample(colorMapValues[colorMapIndex], 16);
                                    green = this.clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);
                                    blue = this.clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);
                                    break;

                                  default:
                                    throw RangeError("Unknown Photometric Interpretation:", photometricInterpretation);
                                }
                                ctx.fillStyle = "rgba(" + red + ", " + green + ", " + blue + ", " + opacity + ")";
                                ctx.fillRect(x, yPadding + y, 1, 1);
                            }
                        }
                        numRowsInPreviousStrip = numRowsInStrip;
                    }
                }
                return this.canvas;
            },
            fieldTagNames: {
                315: "Artist",
                258: "BitsPerSample",
                265: "CellLength",
                264: "CellWidth",
                320: "ColorMap",
                259: "Compression",
                33432: "Copyright",
                306: "DateTime",
                338: "ExtraSamples",
                266: "FillOrder",
                289: "FreeByteCounts",
                288: "FreeOffsets",
                291: "GrayResponseCurve",
                290: "GrayResponseUnit",
                316: "HostComputer",
                270: "ImageDescription",
                257: "ImageLength",
                256: "ImageWidth",
                271: "Make",
                281: "MaxSampleValue",
                280: "MinSampleValue",
                272: "Model",
                254: "NewSubfileType",
                274: "Orientation",
                262: "PhotometricInterpretation",
                284: "PlanarConfiguration",
                296: "ResolutionUnit",
                278: "RowsPerStrip",
                277: "SamplesPerPixel",
                305: "Software",
                279: "StripByteCounts",
                273: "StripOffsets",
                255: "SubfileType",
                263: "Threshholding",
                282: "XResolution",
                283: "YResolution",
                326: "BadFaxLines",
                327: "CleanFaxData",
                343: "ClipPath",
                328: "ConsecutiveBadFaxLines",
                433: "Decode",
                434: "DefaultImageColor",
                269: "DocumentName",
                336: "DotRange",
                321: "HalftoneHints",
                346: "Indexed",
                347: "JPEGTables",
                285: "PageName",
                297: "PageNumber",
                317: "Predictor",
                319: "PrimaryChromaticities",
                532: "ReferenceBlackWhite",
                339: "SampleFormat",
                559: "StripRowCounts",
                330: "SubIFDs",
                292: "T4Options",
                293: "T6Options",
                325: "TileByteCounts",
                323: "TileLength",
                324: "TileOffsets",
                322: "TileWidth",
                301: "TransferFunction",
                318: "WhitePoint",
                344: "XClipPathUnits",
                286: "XPosition",
                529: "YCbCrCoefficients",
                531: "YCbCrPositioning",
                530: "YCbCrSubSampling",
                345: "YClipPathUnits",
                287: "YPosition",
                37378: "ApertureValue",
                40961: "ColorSpace",
                36868: "DateTimeDigitized",
                36867: "DateTimeOriginal",
                34665: "Exif IFD",
                36864: "ExifVersion",
                33434: "ExposureTime",
                41728: "FileSource",
                37385: "Flash",
                40960: "FlashpixVersion",
                33437: "FNumber",
                42016: "ImageUniqueID",
                37384: "LightSource",
                37500: "MakerNote",
                37377: "ShutterSpeedValue",
                37510: "UserComment",
                33723: "IPTC",
                34675: "ICC Profile",
                700: "XMP",
                42112: "GDAL_METADATA",
                42113: "GDAL_NODATA",
                34377: "Photoshop"
            },
            fieldTypeNames: {
                1: "BYTE",
                2: "ASCII",
                3: "SHORT",
                4: "LONG",
                5: "RATIONAL",
                6: "SBYTE",
                7: "UNDEFINED",
                8: "SSHORT",
                9: "SLONG",
                10: "SRATIONAL",
                11: "FLOAT",
                12: "DOUBLE"
            }
        };
        module.exports = tiffReader;
    }), {} ],
    267: [ (function(require, module, exports) {
        cc.RenderTexture = _ccsg.Node.extend({
            sprite: null,
            clearFlags: 0,
            clearDepthVal: 0,
            autoDraw: false,
            _texture: null,
            _pixelFormat: 0,
            clearStencilVal: 0,
            _clearColor: null,
            _className: "RenderTexture",
            ctor: function(width, height, format, depthStencilFormat) {
                _ccsg.Node.prototype.ctor.call(this);
                this._cascadeColorEnabled = true;
                this._cascadeOpacityEnabled = true;
                this._pixelFormat = cc.Texture2D.PIXEL_FORMAT_RGBA8888;
                this._clearColor = new cc.Color(0, 0, 0, 255);
                if (void 0 !== width && void 0 !== height) {
                    format = format || cc.Texture2D.PIXEL_FORMAT_RGBA8888;
                    depthStencilFormat = depthStencilFormat || 0;
                    this.initWithWidthAndHeight(width, height, format, depthStencilFormat);
                }
                this.setAnchorPoint(0, 0);
            },
            _createRenderCmd: function() {
                return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new cc.RenderTexture.CanvasRenderCmd(this) : new cc.RenderTexture.WebGLRenderCmd(this);
            },
            visit: function(parent) {
                var cmd = this._renderCmd, parentCmd = parent ? parent._renderCmd : null;
                if (!this._visible) {
                    cmd._propagateFlagsDown(parentCmd);
                    return;
                }
                var renderer = cc.renderer;
                cmd.visit(parentCmd);
                renderer.pushRenderCommand(cmd);
                this.sprite.visit(this);
                cmd._dirtyFlag = 0;
            },
            cleanup: function() {
                _ccsg.Node.prototype.onExit.call(this);
                this._renderCmd.cleanup();
            },
            getSprite: function() {
                return this.sprite;
            },
            setSprite: function(sprite) {
                this.sprite = sprite;
            },
            setVirtualViewport: function(rtBegin, fullRect, fullViewport) {
                this._renderCmd.setVirtualViewport(rtBegin, fullRect, fullViewport);
            },
            initWithWidthAndHeight: function(width, height, format, depthStencilFormat) {
                return this._renderCmd.initWithWidthAndHeight(width, height, format, depthStencilFormat);
            },
            begin: function() {
                cc.renderer._turnToCacheMode(this.__instanceId);
                this._renderCmd.begin();
            },
            beginWithClear: function(r, g, b, a, depthValue, stencilValue) {
                var gl = cc._renderContext;
                depthValue = depthValue || gl.COLOR_BUFFER_BIT;
                stencilValue = stencilValue || gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT;
                this._beginWithClear(r, g, b, a, depthValue, stencilValue, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            },
            _beginWithClear: function(r, g, b, a, depthValue, stencilValue, flags) {
                this.begin();
                this._renderCmd._beginWithClear(r, g, b, a, depthValue, stencilValue, flags);
            },
            end: function() {
                this._renderCmd.end();
            },
            clear: function(r, g, b, a) {
                this.beginWithClear(r, g, b, a);
                this.end();
            },
            clearRect: function(x, y, width, height) {
                this._renderCmd.clearRect(x, y, width, height);
            },
            clearDepth: function(depthValue) {
                this._renderCmd.clearDepth(depthValue);
            },
            clearStencil: function(stencilValue) {
                this._renderCmd.clearStencil(stencilValue);
            },
            getClearFlags: function() {
                return this.clearFlags;
            },
            setClearFlags: function(clearFlags) {
                this.clearFlags = clearFlags;
            },
            getClearColor: function() {
                return this._clearColor;
            },
            setClearColor: function(clearColor) {
                var locClearColor = this._clearColor;
                locClearColor.r = clearColor.r;
                locClearColor.g = clearColor.g;
                locClearColor.b = clearColor.b;
                locClearColor.a = clearColor.a;
                this._renderCmd.updateClearColor(clearColor);
            },
            getClearDepth: function() {
                return this.clearDepthVal;
            },
            setClearDepth: function(clearDepth) {
                this.clearDepthVal = clearDepth;
            },
            getClearStencil: function() {
                return this.clearStencilVal;
            },
            setClearStencil: function(clearStencil) {
                this.clearStencilVal = clearStencil;
            },
            isAutoDraw: function() {
                return this.autoDraw;
            },
            setAutoDraw: function(autoDraw) {
                this.autoDraw = autoDraw;
            },
            saveToFile: function(filePath, format) {
                cc.log("saveToFile isn't supported on Cocos2d-Html5");
            },
            newCCImage: function(flipImage) {
                cc.log("saveToFile isn't supported on cocos2d-html5");
                return null;
            },
            listenToBackground: function(obj) {},
            listenToForeground: function(obj) {}
        });
        var _p = cc.RenderTexture.prototype;
        _p.clearColorVal;
        cc.defineGetterSetter(_p, "clearColorVal", _p.getClearColor, _p.setClearColor);
        cc.RenderTexture.create = function(width, height, format, depthStencilFormat) {
            return new cc.RenderTexture(width, height, format, depthStencilFormat);
        };
    }), {} ],
    268: [ (function(require, module, exports) {
        cc.RenderTexture.CanvasRenderCmd = function(renderableObject) {
            this._rootCtor(renderableObject);
            this._needDraw = false;
            this._clearColorStr = "rgba(255,255,255,1)";
            this._cacheCanvas = document.createElement("canvas");
            this._cacheContext = new cc.CanvasContextWrapper(this._cacheCanvas.getContext("2d"));
        };
        var proto = cc.RenderTexture.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
        proto.constructor = cc.RenderTexture.CanvasRenderCmd;
        proto.cleanup = function() {
            this._cacheContext = null;
            this._cacheCanvas = null;
        };
        proto.clearStencil = function(stencilValue) {};
        proto.setVirtualViewport = function(rtBegin, fullRect, fullViewport) {};
        proto.updateClearColor = function(clearColor) {
            this._clearColorStr = "rgba(" + (0 | clearColor.r) + "," + (0 | clearColor.g) + "," + (0 | clearColor.b) + "," + clearColor.a / 255 + ")";
        };
        proto.initWithWidthAndHeight = function(width, height, format, depthStencilFormat) {
            var node = this._node;
            var locCacheCanvas = this._cacheCanvas;
            locCacheCanvas.width = 0 | width;
            locCacheCanvas.height = 0 | height;
            var texture = new cc.Texture2D();
            texture.initWithElement(locCacheCanvas);
            texture.handleLoadedTexture();
            var locSprite = node.sprite = new _ccsg.Sprite(texture);
            locSprite.setBlendFunc(cc.macro.ONE, cc.macro.ONE_MINUS_SRC_ALPHA);
            node.autoDraw = false;
            node.addChild(locSprite);
            return true;
        };
        proto.begin = function() {};
        proto._beginWithClear = function(r, g, b, a, depthValue, stencilValue, flags) {
            r = r || 0;
            g = g || 0;
            b = b || 0;
            a = isNaN(a) ? 255 : a;
            var context = this._cacheContext.getContext();
            var locCanvas = this._cacheCanvas;
            context.setTransform(1, 0, 0, 1, 0, 0);
            this._cacheContext.setFillStyle("rgba(" + (0 | r) + "," + (0 | g) + "," + (0 | b) + "," + a / 255 + ")");
            context.clearRect(0, 0, locCanvas.width, locCanvas.height);
            context.fillRect(0, 0, locCanvas.width, locCanvas.height);
        };
        proto.end = function() {
            var node = this._node;
            cc.renderer._renderingToCacheCanvas(this._cacheContext, node.__instanceId);
            var spriteRenderCmd = node.sprite._renderCmd;
            spriteRenderCmd._notifyRegionStatus && spriteRenderCmd._notifyRegionStatus(_ccsg.Node.CanvasRenderCmd.RegionStatus.Dirty);
        };
        proto.clearRect = function(x, y, width, height) {
            this._cacheContext.clearRect(x, y, width, -height);
        };
        proto.clearDepth = function(depthValue) {
            cc.log("clearDepth isn't supported on Cocos2d-Html5");
        };
    }), {} ],
    269: [ (function(require, module, exports) {
        var misc = require("../core/utils/misc");
        cc.RenderTexture.WebGLRenderCmd = function(renderableObject) {
            this._rootCtor(renderableObject);
            this._needDraw = true;
            this._fBO = null;
            this._oldFBO = null;
            this._textureCopy = null;
            this._depthRenderBuffer = null;
            this._rtTextureRect = new cc.Rect();
            this._fullRect = new cc.Rect();
            this._fullViewport = new cc.Rect();
        };
        var proto = cc.RenderTexture.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
        proto.constructor = cc.RenderTexture.WebGLRenderCmd;
        proto.setVirtualViewport = function(rtBegin, fullRect, fullViewport) {
            this._rtTextureRect.x = rtBegin.x;
            this._rtTextureRect.y = rtBegin.y;
            this._fullRect = fullRect;
            this._fullViewport = fullViewport;
        };
        proto.needDraw = function() {
            return this._needDraw && this._node.autoDraw;
        };
        proto.rendering = function(ctx) {
            var gl = ctx || cc._renderContext;
            var node = this._node;
            if (node.autoDraw) {
                node.begin();
                var locClearFlags = node.clearFlags;
                if (locClearFlags) {
                    var oldClearColor = [ 0, 0, 0, 0 ];
                    var oldDepthClearValue = 0;
                    var oldStencilClearValue = 0;
                    if (locClearFlags & gl.COLOR_BUFFER_BIT) {
                        oldClearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
                        gl.clearColor(node._clearColor.r / 255, node._clearColor.g / 255, node._clearColor.b / 255, node._clearColor.a / 255);
                    }
                    if (locClearFlags & gl.DEPTH_BUFFER_BIT) {
                        oldDepthClearValue = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
                        gl.clearDepth(node.clearDepthVal);
                    }
                    if (locClearFlags & gl.STENCIL_BUFFER_BIT) {
                        oldStencilClearValue = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
                        gl.clearStencil(node.clearStencilVal);
                    }
                    gl.clear(locClearFlags);
                    locClearFlags & gl.COLOR_BUFFER_BIT && gl.clearColor(oldClearColor[0], oldClearColor[1], oldClearColor[2], oldClearColor[3]);
                    locClearFlags & gl.DEPTH_BUFFER_BIT && gl.clearDepth(oldDepthClearValue);
                    locClearFlags & gl.STENCIL_BUFFER_BIT && gl.clearStencil(oldStencilClearValue);
                }
                node.sortAllChildren();
                var locChildren = node._children;
                for (var i = 0; i < locChildren.length; i++) {
                    var getChild = locChildren[i];
                    getChild !== node.sprite && getChild.visit(node.sprite);
                }
                node.end();
            }
        };
        proto.clearStencil = function(stencilValue) {
            var gl = cc._renderContext;
            var stencilClearValue = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
            gl.clearStencil(stencilValue);
            gl.clear(gl.STENCIL_BUFFER_BIT);
            gl.clearStencil(stencilClearValue);
        };
        proto.cleanup = function() {
            var node = this._node;
            this._textureCopy = null;
            var gl = cc._renderContext;
            gl.deleteFramebuffer(this._fBO);
            this._depthRenderBuffer && gl.deleteRenderbuffer(this._depthRenderBuffer);
        };
        proto.updateClearColor = function(clearColor) {};
        proto.initWithWidthAndHeight = function(width, height, format, depthStencilFormat) {
            var node = this._node;
            format === cc.Texture2D.PIXEL_FORMAT_A8 && cc.log("cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;");
            var gl = cc._renderContext;
            this._fullRect = new cc.Rect(0, 0, width, height);
            this._fullViewport = new cc.Rect(0, 0, width, height);
            width |= 0;
            height |= 0;
            this._oldFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);
            var powW, powH;
            if (cc.configuration.supportsNPOT()) {
                powW = width;
                powH = height;
            } else {
                powW = misc.NextPOT(width);
                powH = misc.NextPOT(height);
            }
            var dataLen = powW * powH * 4;
            var data = new Uint8Array(dataLen);
            for (var i = 0; i < powW * powH * 4; i++) {
                data[i] = 0;
            }
            this._pixelFormat = format;
            var locTexture = node._texture = new cc.Texture2D();
            if (!node._texture) {
                return false;
            }
            locTexture.initWithData(data, node._pixelFormat, powW, powH, cc.size(width, height));
            var oldRBO = gl.getParameter(gl.RENDERBUFFER_BINDING);
            if (cc.configuration.checkForGLExtension("GL_QCOM")) {
                this._textureCopy = new cc.Texture2D();
                if (!this._textureCopy) {
                    return false;
                }
                this._textureCopy.initWithData(data, node._pixelFormat, powW, powH, cc.size(width, height));
            }
            this._fBO = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fBO);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, locTexture._webTextureObj, 0);
            if (0 !== depthStencilFormat) {
                this._depthRenderBuffer = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, this._depthRenderBuffer);
                gl.renderbufferStorage(gl.RENDERBUFFER, depthStencilFormat, powW, powH);
                depthStencilFormat === gl.DEPTH_STENCIL ? gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._depthRenderBuffer) : depthStencilFormat === gl.STENCIL_INDEX || depthStencilFormat === gl.STENCIL_INDEX8 ? gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._depthRenderBuffer) : depthStencilFormat === gl.DEPTH_COMPONENT16 && gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._depthRenderBuffer);
            }
            gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE && cc.log("Could not attach texture to the framebuffer");
            locTexture.setAliasTexParameters();
            var locSprite = node.sprite = new _ccsg.Sprite(locTexture);
            locSprite.scaleY = -1;
            locSprite.setBlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            gl.bindRenderbuffer(gl.RENDERBUFFER, oldRBO);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._oldFBO);
            node.autoDraw = false;
            node.addChild(locSprite);
            return true;
        };
        proto.begin = function() {
            var node = this._node;
            cc.math.glMatrixMode(cc.math.KM_GL_PROJECTION);
            cc.math.glPushMatrix();
            cc.math.glMatrixMode(cc.math.KM_GL_MODELVIEW);
            cc.math.glPushMatrix();
            var gl = cc._renderContext;
            var director = cc.director;
            director.setProjection(director.getProjection());
            var texSize = node._texture.getContentSizeInPixels();
            var size = cc.director.getWinSizeInPixels();
            var widthRatio = size.width / texSize.width;
            var heightRatio = size.height / texSize.height;
            var orthoMatrix = cc.math.Matrix4.createOrthographicProjection(-1 / widthRatio, 1 / widthRatio, -1 / heightRatio, 1 / heightRatio, -1, 1);
            cc.math.glMultMatrix(orthoMatrix);
            var viewport = new cc.Rect(0, 0, 0, 0);
            viewport.width = this._fullViewport.width;
            viewport.height = this._fullViewport.height;
            var viewPortRectWidthRatio = viewport.width / this._fullRect.width;
            var viewPortRectHeightRatio = viewport.height / this._fullRect.height;
            viewport.x = (this._fullRect.x - this._rtTextureRect.x) * viewPortRectWidthRatio;
            viewport.y = (this._fullRect.y - this._rtTextureRect.y) * viewPortRectHeightRatio;
            gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
            this._oldFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fBO);
            if (cc.configuration.checkForGLExtension("GL_QCOM")) {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._textureCopy._webTextureObj, 0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, node._texture._webTextureObj, 0);
            }
        };
        proto._beginWithClear = function(r, g, b, a, depthValue, stencilValue, flags) {
            r /= 255;
            g /= 255;
            b /= 255;
            a /= 255;
            var gl = cc._renderContext;
            var clearColor = [ 0, 0, 0, 0 ];
            var depthClearValue = 0;
            var stencilClearValue = 0;
            if (flags & gl.COLOR_BUFFER_BIT) {
                clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
                gl.clearColor(r, g, b, a);
            }
            if (flags & gl.DEPTH_BUFFER_BIT) {
                depthClearValue = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
                gl.clearDepth(depthValue);
            }
            if (flags & gl.STENCIL_BUFFER_BIT) {
                stencilClearValue = gl.getParameter(gl.STENCIL_CLEAR_VALUE);
                gl.clearStencil(stencilValue);
            }
            gl.clear(flags);
            flags & gl.COLOR_BUFFER_BIT && gl.clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
            flags & gl.DEPTH_BUFFER_BIT && gl.clearDepth(depthClearValue);
            flags & gl.STENCIL_BUFFER_BIT && gl.clearStencil(stencilClearValue);
        };
        proto.end = function() {
            var node = this._node;
            cc.renderer._renderingToBuffer(node.__instanceId);
            var gl = cc._renderContext;
            var director = cc.director;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._oldFBO);
            director.setViewport();
            cc.math.glMatrixMode(cc.math.KM_GL_PROJECTION);
            cc.math.glPopMatrix();
            cc.math.glMatrixMode(cc.math.KM_GL_MODELVIEW);
            cc.math.glPopMatrix();
        };
        proto.clearRect = function(x, y, width, height) {};
        proto.clearDepth = function(depthValue) {
            var node = this._node;
            node.begin();
            var gl = cc._renderContext;
            var depthClearValue = gl.getParameter(gl.DEPTH_CLEAR_VALUE);
            gl.clearDepth(depthValue);
            gl.clear(gl.DEPTH_BUFFER_BIT);
            gl.clearDepth(depthClearValue);
            node.end();
        };
    }), {
        "../core/utils/misc": 223
    } ],
    270: [ (function(require, module, exports) {
        var macro = cc.macro;
        var math = cc.math;
        cc.GLProgram = cc._Class.extend({
            _updateUniformLocation: function(location) {
                if (!location) {
                    return false;
                }
                var updated;
                var element = this._hashForUniforms[location];
                if (element) {
                    updated = false;
                    var count = arguments.length - 1;
                    for (var i = 0; i < count; ++i) {
                        if (arguments[i + 1] !== element[i]) {
                            element[i] = arguments[i + 1];
                            updated = true;
                        }
                    }
                } else {
                    element = [ arguments[1], arguments[2], arguments[3], arguments[4] ];
                    this._hashForUniforms[location] = element;
                    updated = true;
                }
                return updated;
            },
            _description: function() {
                return "<CCGLProgram = " + this.toString() + " | Program = " + this._programObj.toString() + ", VertexShader = " + this._vertShader.toString() + ", FragmentShader = " + this._fragShader.toString() + ">";
            },
            _compileShader: function(shader, type, source) {
                if (!source || !shader) {
                    return false;
                }
                var preStr = cc.GLProgram._isHighpSupported() ? "precision highp float;\n" : "precision mediump float;\n";
                source = preStr + "uniform mat4 CC_PMatrix;\nuniform mat4 CC_MVMatrix;\nuniform mat4 CC_MVPMatrix;\nuniform vec4 CC_Time;\nuniform vec4 CC_SinTime;\nuniform vec4 CC_CosTime;\nuniform vec4 CC_Random01;\nuniform sampler2D CC_Texture0;\n//CC INCLUDES END\n" + source;
                this._glContext.shaderSource(shader, source);
                this._glContext.compileShader(shader);
                var status = this._glContext.getShaderParameter(shader, this._glContext.COMPILE_STATUS);
                if (!status) {
                    cc.logID(8100, this._glContext.getShaderSource(shader));
                    type === this._glContext.VERTEX_SHADER ? cc.log("cocos2d: \n" + this.vertexShaderLog()) : cc.log("cocos2d: \n" + this.fragmentShaderLog());
                }
                return true === status;
            },
            ctor: function(vShaderFileName, fShaderFileName, glContext) {
                this._uniforms = {};
                this._hashForUniforms = {};
                this._glContext = glContext || cc._renderContext;
                this._programObj = null;
                this._vertShader = null;
                this._fragShader = null;
                this._usesTime = false;
                this._projectionUpdated = -1;
                vShaderFileName && fShaderFileName && this.init(vShaderFileName, fShaderFileName);
            },
            destroyProgram: function() {
                this._vertShader = null;
                this._fragShader = null;
                this._uniforms = null;
                this._hashForUniforms = null;
                this._glContext.deleteProgram(this._programObj);
            },
            initWithVertexShaderByteArray: function(vertShaderStr, fragShaderStr) {
                var locGL = this._glContext;
                this._programObj = locGL.createProgram();
                this._projectionUpdated = -1;
                this._vertShader = null;
                this._fragShader = null;
                if (vertShaderStr) {
                    this._vertShader = locGL.createShader(locGL.VERTEX_SHADER);
                    this._compileShader(this._vertShader, locGL.VERTEX_SHADER, vertShaderStr) || cc.logID(8101);
                }
                if (fragShaderStr) {
                    this._fragShader = locGL.createShader(locGL.FRAGMENT_SHADER);
                    this._compileShader(this._fragShader, locGL.FRAGMENT_SHADER, fragShaderStr) || cc.logID(8102);
                }
                this._vertShader && locGL.attachShader(this._programObj, this._vertShader);
                cc.checkGLErrorDebug();
                this._fragShader && locGL.attachShader(this._programObj, this._fragShader);
                for (var key in this._hashForUniforms) {
                    delete this._hashForUniforms[key];
                }
                cc.checkGLErrorDebug();
                return true;
            },
            initWithString: function(vertShaderStr, fragShaderStr) {
                return this.initWithVertexShaderByteArray(vertShaderStr, fragShaderStr);
            },
            initWithVertexShaderFilename: function(vShaderFilename, fShaderFileName) {
                var vertexSource = cc.loader.getRes(vShaderFilename);
                if (!vertexSource) {
                    throw new Error("Please load the resource firset : " + vShaderFilename);
                }
                var fragmentSource = cc.loader.getRes(fShaderFileName);
                if (!fragmentSource) {
                    throw new Error("Please load the resource firset : " + fShaderFileName);
                }
                return this.initWithVertexShaderByteArray(vertexSource, fragmentSource);
            },
            init: function(vShaderFilename, fShaderFileName) {
                return this.initWithVertexShaderFilename(vShaderFilename, fShaderFileName);
            },
            addAttribute: function(attributeName, index) {
                this._glContext.bindAttribLocation(this._programObj, index, attributeName);
            },
            link: function() {
                if (!this._programObj) {
                    cc.logID(8103);
                    return false;
                }
                this._glContext.linkProgram(this._programObj);
                this._vertShader && this._glContext.deleteShader(this._vertShader);
                this._fragShader && this._glContext.deleteShader(this._fragShader);
                this._vertShader = null;
                this._fragShader = null;
                if (cc.game.config[cc.game.CONFIG_KEY.debugMode]) {
                    var status = this._glContext.getProgramParameter(this._programObj, this._glContext.LINK_STATUS);
                    if (!status) {
                        cc.logID(8104, this._glContext.getProgramInfoLog(this._programObj));
                        cc.gl.deleteProgram(this._programObj);
                        this._programObj = null;
                        return false;
                    }
                }
                return true;
            },
            use: function() {
                cc.gl.useProgram(this._programObj);
            },
            updateUniforms: function() {
                this._uniforms[macro.UNIFORM_PMATRIX] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_PMATRIX_S);
                this._uniforms[macro.UNIFORM_MVMATRIX] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_MVMATRIX_S);
                this._uniforms[macro.UNIFORM_MVPMATRIX] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_MVPMATRIX_S);
                this._uniforms[macro.UNIFORM_TIME] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_TIME_S);
                this._uniforms[macro.UNIFORM_SINTIME] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_SINTIME_S);
                this._uniforms[macro.UNIFORM_COSTIME] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_COSTIME_S);
                this._usesTime = null != this._uniforms[macro.UNIFORM_TIME] || null != this._uniforms[macro.UNIFORM_SINTIME] || null != this._uniforms[macro.UNIFORM_COSTIME];
                this._uniforms[macro.UNIFORM_RANDOM01] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_RANDOM01_S);
                this._uniforms[macro.UNIFORM_SAMPLER] = this._glContext.getUniformLocation(this._programObj, macro.UNIFORM_SAMPLER_S);
                this.use();
                this.setUniformLocationWith1i(this._uniforms[macro.UNIFORM_SAMPLER], 0);
            },
            _addUniformLocation: function(name) {
                var location = this._glContext.getUniformLocation(this._programObj, name);
                this._uniforms[name] = location;
            },
            getUniformLocationForName: function(name) {
                if (!name) {
                    throw new Error("cc.GLProgram.getUniformLocationForName(): uniform name should be non-null");
                }
                if (!this._programObj) {
                    throw new Error("cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized");
                }
                var location = this._uniforms[name] || this._glContext.getUniformLocation(this._programObj, name);
                return location;
            },
            getUniformMVPMatrix: function() {
                return this._uniforms[macro.UNIFORM_MVPMATRIX];
            },
            getUniformSampler: function() {
                return this._uniforms[macro.UNIFORM_SAMPLER];
            },
            setUniformLocationWith1i: function(location, i1) {
                var gl = this._glContext;
                if ("string" === typeof location) {
                    var updated = this._updateUniformLocation(location, i1);
                    if (updated) {
                        var locObj = this.getUniformLocationForName(location);
                        gl.uniform1i(locObj, i1);
                    }
                } else {
                    gl.uniform1i(location, i1);
                }
            },
            setUniformLocationWith2i: function(location, i1, i2) {
                var gl = this._glContext;
                if ("string" === typeof location) {
                    var updated = this._updateUniformLocation(location, i1, i2);
                    if (updated) {
                        var locObj = this.getUniformLocationForName(location);
                        gl.uniform2i(locObj, i1, i2);
                    }
                } else {
                    gl.uniform2i(location, i1, i2);
                }
            },
            setUniformLocationWith3i: function(location, i1, i2, i3) {
                var gl = this._glContext;
                if ("string" === typeof location) {
                    var updated = this._updateUniformLocation(location, i1, i2, i3);
                    if (updated) {
                        var locObj = this.getUniformLocationForName(location);
                        gl.uniform3i(locObj, i1, i2, i3);
                    }
                } else {
                    gl.uniform3i(location, i1, i2, i3);
                }
            },
            setUniformLocationWith4i: function(location, i1, i2, i3, i4) {
                var gl = this._glContext;
                if ("string" === typeof location) {
                    var updated = this._updateUniformLocation(location, i1, i2, i3, i4);
                    if (updated) {
                        var locObj = this.getUniformLocationForName(location);
                        gl.uniform4i(locObj, i1, i2, i3, i4);
                    }
                } else {
                    gl.uniform4i(location, i1, i2, i3, i4);
                }
            },
            setUniformLocationWith2iv: function(location, intArray) {
                var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
                this._glContext.uniform2iv(locObj, intArray);
            },
            setUniformLocationWith3iv: function(location, intArray) {
                var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
                this._glContext.uniform3iv(locObj, intArray);
            },
            setUniformLocationWith4iv: function(location, intArray) {
                var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
                this._glContext.uniform4iv(locObj, intArray);
            },
            setUniformLocationI32: function(location, i1) {
                this.setUniformLocationWith1i(location, i1);
            },
            setUniformLocationWith1f: function(location, f1) {
                var gl = this._glContext;
                if ("string" === typeof location) {
                    var updated = this._updateUniformLocation(location, f1);
                    if (updated) {
                        var locObj = this.getUniformLocationForName(location);
                        gl.uniform1f(locObj, f1);
                    }
                } else {
                    gl.uniform1f(location, f1);
                }
            },
            setUniformLocationWith2f: function(location, f1, f2) {
                var gl = this._glContext;
                if ("string" === typeof location) {
                    var updated = this._updateUniformLocation(location, f1, f2);
                    if (updated) {
                        var locObj = this.getUniformLocationForName(location);
                        gl.uniform2f(locObj, f1, f2);
                    }
                } else {
                    gl.uniform2f(location, f1, f2);
                }
            },
            setUniformLocationWith3f: function(location, f1, f2, f3) {
                var gl = this._glContext;
                if ("string" === typeof location) {
                    var updated = this._updateUniformLocation(location, f1, f2, f3);
                    if (updated) {
                        var locObj = this.getUniformLocationForName(location);
                        gl.uniform3f(locObj, f1, f2, f3);
                    }
                } else {
                    gl.uniform3f(location, f1, f2, f3);
                }
            },
            setUniformLocationWith4f: function(location, f1, f2, f3, f4) {
                var gl = this._glContext;
                if ("string" === typeof location) {
                    var updated = this._updateUniformLocation(location, f1, f2, f3, f4);
                    if (updated) {
                        var locObj = this.getUniformLocationForName(location);
                        gl.uniform4f(locObj, f1, f2, f3, f4);
                    }
                } else {
                    gl.uniform4f(location, f1, f2, f3, f4);
                }
            },
            setUniformLocationWith2fv: function(location, floatArray) {
                var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
                this._glContext.uniform2fv(locObj, floatArray);
            },
            setUniformLocationWith3fv: function(location, floatArray) {
                var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
                this._glContext.uniform3fv(locObj, floatArray);
            },
            setUniformLocationWith4fv: function(location, floatArray) {
                var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
                this._glContext.uniform4fv(locObj, floatArray);
            },
            setUniformLocationWithMatrix3fv: function(location, matrixArray) {
                var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
                this._glContext.uniformMatrix3fv(locObj, false, matrixArray);
            },
            setUniformLocationWithMatrix4fv: function(location, matrixArray) {
                var locObj = "string" === typeof location ? this.getUniformLocationForName(location) : location;
                this._glContext.uniformMatrix4fv(locObj, false, matrixArray);
            },
            setUniformLocationF32: function(p1, p2, p3, p4, p5) {
                "use strict";
                switch (arguments.length) {
                  case 0:
                  case 1:
                    return;

                  case 2:
                    this.setUniformLocationWith1f(p1, p2);
                    break;

                  case 3:
                    this.setUniformLocationWith2f(p1, p2, p3);
                    break;

                  case 4:
                    this.setUniformLocationWith3f(p1, p2, p3, p4);
                    break;

                  case 5:
                    this.setUniformLocationWith4f(p1, p2, p3, p4, p5);
                }
            },
            setUniformsForBuiltins: function() {
                var matrixP = new math.Matrix4();
                var matrixMV = new math.Matrix4();
                var matrixMVP = new math.Matrix4();
                math.glGetMatrix(math.KM_GL_PROJECTION, matrixP);
                math.glGetMatrix(math.KM_GL_MODELVIEW, matrixMV);
                math.mat4Multiply(matrixMVP, matrixP, matrixMV);
                this.setUniformLocationWithMatrix4fv(this._uniforms[macro.UNIFORM_PMATRIX], matrixP.mat, 1);
                this.setUniformLocationWithMatrix4fv(this._uniforms[macro.UNIFORM_MVMATRIX], matrixMV.mat, 1);
                this.setUniformLocationWithMatrix4fv(this._uniforms[macro.UNIFORM_MVPMATRIX], matrixMVP.mat, 1);
                if (this._usesTime) {
                    var director = cc.director;
                    var time = director.getTotalFrames() * director.getAnimationInterval();
                    this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_TIME], time / 10, time, 2 * time, 4 * time);
                    this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_SINTIME], time / 8, time / 4, time / 2, Math.sin(time));
                    this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_COSTIME], time / 8, time / 4, time / 2, Math.cos(time));
                }
                this._uniforms[macro.UNIFORM_RANDOM01] !== -1 && this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random());
            },
            _setUniformsForBuiltinsForRenderer: function(node) {
                if (!node || !node._renderCmd) {
                    return;
                }
                var matrixP = new math.Matrix4();
                var matrixMVP = new math.Matrix4();
                math.glGetMatrix(math.KM_GL_PROJECTION, matrixP);
                math.mat4Multiply(matrixMVP, matrixP, node._renderCmd._stackMatrix);
                this.setUniformLocationWithMatrix4fv(this._uniforms[macro.UNIFORM_PMATRIX], matrixP.mat, 1);
                this.setUniformLocationWithMatrix4fv(this._uniforms[macro.UNIFORM_MVMATRIX], node._renderCmd._stackMatrix.mat, 1);
                this.setUniformLocationWithMatrix4fv(this._uniforms[macro.UNIFORM_MVPMATRIX], matrixMVP.mat, 1);
                if (this._usesTime) {
                    var director = cc.director;
                    var time = director.getTotalFrames() * director.getAnimationInterval();
                    this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_TIME], time / 10, time, 2 * time, 4 * time);
                    this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_SINTIME], time / 8, time / 4, time / 2, Math.sin(time));
                    this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_COSTIME], time / 8, time / 4, time / 2, Math.cos(time));
                }
                this._uniforms[macro.UNIFORM_RANDOM01] !== -1 && this.setUniformLocationWith4f(this._uniforms[macro.UNIFORM_RANDOM01], Math.random(), Math.random(), Math.random(), Math.random());
            },
            setUniformForModelViewProjectionMatrix: function() {
                this._glContext.uniformMatrix4fv(this._uniforms[macro.UNIFORM_MVPMATRIX], false, math.getMat4MultiplyValue(math.projection_matrix_stack.top, math.modelview_matrix_stack.top));
            },
            setUniformForModelViewProjectionMatrixWithMat4: function(swapMat4) {
                math.mat4Multiply(swapMat4, math.projection_matrix_stack.top, math.modelview_matrix_stack.top);
                this._glContext.uniformMatrix4fv(this._uniforms[macro.UNIFORM_MVPMATRIX], false, swapMat4.mat);
            },
            setUniformForModelViewAndProjectionMatrixWithMat4: function() {
                this._glContext.uniformMatrix4fv(this._uniforms[macro.UNIFORM_MVMATRIX], false, math.modelview_matrix_stack.top.mat);
                this._glContext.uniformMatrix4fv(this._uniforms[macro.UNIFORM_PMATRIX], false, math.projection_matrix_stack.top.mat);
            },
            _setUniformForMVPMatrixWithMat4: function(modelViewMatrix) {
                if (!modelViewMatrix) {
                    throw new Error("modelView matrix is undefined.");
                }
                this._glContext.uniformMatrix4fv(this._uniforms[macro.UNIFORM_MVMATRIX], false, modelViewMatrix.mat);
                this._glContext.uniformMatrix4fv(this._uniforms[macro.UNIFORM_PMATRIX], false, math.projection_matrix_stack.top.mat);
            },
            _updateProjectionUniform: function() {
                var stack = math.projection_matrix_stack;
                if (stack.lastUpdated !== this._projectionUpdated) {
                    this._glContext.uniformMatrix4fv(this._uniforms[macro.UNIFORM_PMATRIX], false, stack.top.mat);
                    this._projectionUpdated = stack.lastUpdated;
                }
            },
            vertexShaderLog: function() {
                return this._glContext.getShaderInfoLog(this._vertShader);
            },
            getVertexShaderLog: function() {
                return this._glContext.getShaderInfoLog(this._vertShader);
            },
            getFragmentShaderLog: function() {
                return this._glContext.getShaderInfoLog(this._vertShader);
            },
            fragmentShaderLog: function() {
                return this._glContext.getShaderInfoLog(this._fragShader);
            },
            programLog: function() {
                return this._glContext.getProgramInfoLog(this._programObj);
            },
            getProgramLog: function() {
                return this._glContext.getProgramInfoLog(this._programObj);
            },
            reset: function() {
                this._vertShader = null;
                this._fragShader = null;
                this._uniforms.length = 0;
                this._glContext.deleteProgram(this._programObj);
                this._programObj = null;
                for (var key in this._hashForUniforms) {
                    this._hashForUniforms[key].length = 0;
                    delete this._hashForUniforms[key];
                }
            },
            getProgram: function() {
                return this._programObj;
            },
            retain: function() {},
            release: function() {}
        });
        cc.GLProgram._highpSupported = null;
        cc.GLProgram._isHighpSupported = function() {
            var ctx = cc._renderContext;
            if (ctx.getShaderPrecisionFormat && null == cc.GLProgram._highpSupported) {
                var highp = ctx.getShaderPrecisionFormat(ctx.FRAGMENT_SHADER, ctx.HIGH_FLOAT);
                cc.GLProgram._highpSupported = 0 !== highp.precision;
            }
            return cc.GLProgram._highpSupported;
        };
    }), {} ],
    271: [ (function(require, module, exports) {
        var _currentProjectionMatrix = -1;
        var macro = cc.macro;
        var ENABLE_GL_STATE_CACHE = macro.ENABLE_GL_STATE_CACHE;
        var MAX_ACTIVETEXTURE = 0, _currentShaderProgram = 0, _currentBoundTexture = null, _blendingSource = 0, _blendingDest = 0, _GLServerState = 0, _uVAO = 0;
        if (ENABLE_GL_STATE_CACHE) {
            MAX_ACTIVETEXTURE = 16;
            _currentShaderProgram = -1;
            _currentBoundTexture = [ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 ];
            _blendingSource = -1;
            _blendingDest = -1;
            _GLServerState = 0;
            macro.TEXTURE_ATLAS_USE_VAO && (_uVAO = 0);
        }
        cc.gl = {};
        cc.gl.invalidateStateCache = function() {
            cc.math.glFreeAll();
            _currentProjectionMatrix = -1;
            if (ENABLE_GL_STATE_CACHE) {
                _currentShaderProgram = -1;
                for (var i = 0; i < MAX_ACTIVETEXTURE; i++) {
                    _currentBoundTexture[i] = -1;
                }
                _blendingSource = -1;
                _blendingDest = -1;
                _GLServerState = 0;
            }
        };
        cc.gl.useProgram = ENABLE_GL_STATE_CACHE ? function(program) {
            if (program !== _currentShaderProgram) {
                _currentShaderProgram = program;
                cc._renderContext.useProgram(program);
            }
        } : function(program) {
            cc._renderContext.useProgram(program);
        };
        cc.gl.deleteProgram = function(program) {
            ENABLE_GL_STATE_CACHE && program === _currentShaderProgram && (_currentShaderProgram = -1);
            gl.deleteProgram(program);
        };
        cc.gl.setBlending = function(sfactor, dfactor) {
            var ctx = cc._renderContext;
            if (sfactor === ctx.ONE && dfactor === ctx.ZERO) {
                ctx.disable(ctx.BLEND);
            } else {
                ctx.enable(ctx.BLEND);
                cc._renderContext.blendFunc(sfactor, dfactor);
            }
        };
        cc.gl.blendFunc = ENABLE_GL_STATE_CACHE ? function(sfactor, dfactor) {
            if (sfactor !== _blendingSource || dfactor !== _blendingDest) {
                _blendingSource = sfactor;
                _blendingDest = dfactor;
                cc.gl.setBlending(sfactor, dfactor);
            }
        } : cc.gl.setBlending;
        cc.gl.blendFuncForParticle = function(sfactor, dfactor) {
            if (sfactor !== _blendingSource || dfactor !== _blendingDest) {
                _blendingSource = sfactor;
                _blendingDest = dfactor;
                var ctx = cc._renderContext;
                if (sfactor === ctx.ONE && dfactor === ctx.ZERO) {
                    ctx.disable(ctx.BLEND);
                } else {
                    ctx.enable(ctx.BLEND);
                    ctx.blendFuncSeparate(ctx.SRC_ALPHA, dfactor, sfactor, dfactor);
                }
            }
        };
        cc.gl.blendResetToCache = function() {
            var ctx = cc._renderContext;
            ctx.blendEquation(ctx.FUNC_ADD);
            ENABLE_GL_STATE_CACHE ? cc.gl.setBlending(_blendingSource, _blendingDest) : cc.gl.setBlending(ctx.BLEND_SRC, ctx.BLEND_DST);
        };
        cc.gl.setProjectionMatrixDirty = function() {
            _currentProjectionMatrix = -1;
        };
        cc.gl.bindTexture2D = function(textureId) {
            cc.gl.bindTexture2DN(0, textureId);
        };
        cc.gl.bindTexture2DN = ENABLE_GL_STATE_CACHE ? function(textureUnit, textureId) {
            if (_currentBoundTexture[textureUnit] === textureId) {
                return;
            }
            _currentBoundTexture[textureUnit] = textureId;
            var ctx = cc._renderContext;
            ctx.activeTexture(ctx.TEXTURE0 + textureUnit);
            textureId ? ctx.bindTexture(ctx.TEXTURE_2D, textureId._webTextureObj) : ctx.bindTexture(ctx.TEXTURE_2D, null);
        } : function(textureUnit, textureId) {
            var ctx = cc._renderContext;
            ctx.activeTexture(ctx.TEXTURE0 + textureUnit);
            textureId ? ctx.bindTexture(ctx.TEXTURE_2D, textureId._webTextureObj) : ctx.bindTexture(ctx.TEXTURE_2D, null);
        };
        cc.gl.deleteTexture2D = function(textureId) {
            cc.gl.deleteTexture2DN(0, textureId);
        };
        cc.gl.deleteTexture2DN = function(textureUnit, textureId) {
            ENABLE_GL_STATE_CACHE && textureId === _currentBoundTexture[textureUnit] && (_currentBoundTexture[textureUnit] = -1);
            cc._renderContext.deleteTexture(textureId._webTextureObj);
        };
        cc.gl.bindVAO = function(vaoId) {
            if (!macro.TEXTURE_ATLAS_USE_VAO) {
                return;
            }
            ENABLE_GL_STATE_CACHE && _uVAO !== vaoId && (_uVAO = vaoId);
        };
        cc.gl.enable = function(flags) {
            ENABLE_GL_STATE_CACHE;
        };
    }), {} ],
    272: [ (function(require, module, exports) {
        var shaders = cc.PresetShaders;
        var macro = cc.macro;
        cc.shaderCache = {
            TYPE_POSITION_TEXTURECOLOR: 0,
            TYPE_POSITION_TEXTURECOLOR_ALPHATEST: 1,
            TYPE_POSITION_COLOR: 2,
            TYPE_POSITION_TEXTURE: 3,
            TYPE_POSITION_TEXTURE_UCOLOR: 4,
            TYPE_POSITION_TEXTURE_A8COLOR: 5,
            TYPE_POSITION_UCOLOR: 6,
            TYPE_POSITION_LENGTH_TEXTURECOLOR: 7,
            TYPE_SPRITE_POSITION_TEXTURECOLOR: 8,
            TYPE_SPRITE_POSITION_TEXTURECOLOR_ALPHATEST: 9,
            TYPE_SPRITE_POSITION_COLOR: 10,
            TYPE_MAX: 10,
            _programs: {},
            _init: function() {
                this.loadDefaultShaders();
                return true;
            },
            _loadDefaultShader: function(program, type) {
                switch (type) {
                  case macro.SHADER_POSITION_TEXTURECOLOR:
                    program.initWithVertexShaderByteArray(shaders.POSITION_TEXTURE_COLOR_VERT, shaders.POSITION_TEXTURE_COLOR_FRAG);
                    program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
                    program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
                    program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
                    break;

                  case macro.SHADER_SPRITE_POSITION_TEXTURECOLOR:
                    program.initWithVertexShaderByteArray(shaders.SPRITE_POSITION_TEXTURE_COLOR_VERT, shaders.POSITION_TEXTURE_COLOR_FRAG);
                    program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
                    program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
                    program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
                    break;

                  case macro.SHADER_POSITION_TEXTURECOLORALPHATEST:
                    program.initWithVertexShaderByteArray(shaders.POSITION_TEXTURE_COLOR_VERT, shaders.POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
                    program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
                    program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
                    program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
                    break;

                  case macro.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST:
                    program.initWithVertexShaderByteArray(shaders.SPRITE_POSITION_TEXTURE_COLOR_VERT, shaders.POSITION_TEXTURE_COLOR_ALPHATEST_FRAG);
                    program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
                    program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
                    program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
                    break;

                  case macro.SHADER_POSITION_COLOR:
                    program.initWithVertexShaderByteArray(shaders.POSITION_COLOR_VERT, shaders.POSITION_COLOR_FRAG);
                    program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
                    program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
                    break;

                  case macro.SHADER_SPRITE_POSITION_COLOR:
                    program.initWithVertexShaderByteArray(shaders.SPRITE_POSITION_COLOR_VERT, shaders.POSITION_COLOR_FRAG);
                    program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
                    program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
                    break;

                  case macro.SHADER_POSITION_TEXTURE:
                    program.initWithVertexShaderByteArray(shaders.POSITION_TEXTURE_VERT, shaders.POSITION_TEXTURE_FRAG);
                    program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
                    program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
                    break;

                  case macro.SHADER_POSITION_TEXTURE_UCOLOR:
                    program.initWithVertexShaderByteArray(shaders.POSITION_TEXTURE_UCOLOR_VERT, shaders.POSITION_TEXTURE_UCOLOR_FRAG);
                    program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
                    program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
                    break;

                  case macro.SHADER_POSITION_TEXTUREA8COLOR:
                    program.initWithVertexShaderByteArray(shaders.POSITION_TEXTURE_A8COLOR_VERT, shaders.POSITION_TEXTURE_A8COLOR_FRAG);
                    program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
                    program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
                    program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
                    break;

                  case macro.SHADER_POSITION_UCOLOR:
                    program.initWithVertexShaderByteArray(shaders.POSITION_UCOLOR_VERT, shaders.POSITION_UCOLOR_FRAG);
                    program.addAttribute("aVertex", macro.VERTEX_ATTRIB_POSITION);
                    break;

                  case macro.SHADER_POSITION_LENGTHTEXTURECOLOR:
                    program.initWithVertexShaderByteArray(shaders.POSITION_COLOR_LENGTH_TEXTURE_VERT, shaders.POSITION_COLOR_LENGTH_TEXTURE_FRAG);
                    program.addAttribute(macro.ATTRIBUTE_NAME_POSITION, macro.VERTEX_ATTRIB_POSITION);
                    program.addAttribute(macro.ATTRIBUTE_NAME_TEX_COORD, macro.VERTEX_ATTRIB_TEX_COORDS);
                    program.addAttribute(macro.ATTRIBUTE_NAME_COLOR, macro.VERTEX_ATTRIB_COLOR);
                    break;

                  default:
                    cc.logID(8105);
                    return;
                }
                program.link();
                program.updateUniforms();
            },
            _reloadShader: function(type) {
                var program = this.programForKey(type);
                program.reset();
                this._loadDefaultShader(program, type);
            },
            loadDefaultShaders: function() {},
            reloadDefaultShaders: function() {
                this._reloadShader(macro.SHADER_POSITION_TEXTURECOLOR);
                this._reloadShader(macro.SHADER_SPRITE_POSITION_TEXTURECOLOR);
                this._reloadShader(macro.SHADER_POSITION_TEXTURECOLORALPHATEST);
                this._reloadShader(macro.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST);
                this._reloadShader(macro.SHADER_POSITION_COLOR);
                this._reloadShader(macro.SHADER_POSITION_TEXTURE);
                this._reloadShader(macro.SHADER_POSITION_TEXTURE_UCOLOR);
                this._reloadShader(macro.SHADER_POSITION_TEXTUREA8COLOR);
                this._reloadShader(macro.SHADER_POSITION_UCOLOR);
            },
            programForKey: function(key) {
                if (!this._programs[key]) {
                    var program = new cc.GLProgram();
                    this._loadDefaultShader(program, key);
                    this._programs[key] = program;
                }
                return this._programs[key];
            },
            getProgram: function(shaderName) {
                return this.programForKey(shaderName);
            },
            addProgram: function(program, key) {
                this._programs[key] = program;
            }
        };
    }), {} ],
    273: [ (function(require, module, exports) {
        cc.PresetShaders = {
            POSITION_UCOLOR_FRAG: "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()\n{\ngl_FragColor = v_fragmentColor;\n}",
            POSITION_UCOLOR_VERT: "attribute vec4 a_position;\nuniform vec4 u_color;\nuniform float u_pointSize;\nvarying lowp vec4 v_fragmentColor;\nvoid main(void)\n{\ngl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;\ngl_PointSize = u_pointSize;\nv_fragmentColor = u_color;\n}",
            POSITION_COLOR_FRAG: "precision lowp float;\nvarying vec4 v_fragmentColor;\nvoid main()\n{\ngl_FragColor = v_fragmentColor;\n}",
            POSITION_COLOR_VERT: "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\ngl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;\nv_fragmentColor = a_color;\n}",
            SPRITE_POSITION_COLOR_VERT: "attribute vec4 a_position;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvoid main()\n{\ngl_Position = CC_PMatrix * a_position;\nv_fragmentColor = a_color;\n}",
            POSITION_COLOR_LENGTH_TEXTURE_FRAG: "//#extension GL_OES_standard_derivatives : enable\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()\n{\n//#if defined GL_OES_standard_derivatives\n//gl_FragColor=v_color*smoothstep(0.0, length(fwidth(v_texcoord)), 1.0-length(v_texcoord));\n//#else\ngl_FragColor = v_color * step(0.0, 1.0 - length(v_texcoord));\n//#endif\n}",
            POSITION_COLOR_LENGTH_TEXTURE_VERT: "attribute mediump vec4 a_position;\nattribute mediump vec2 a_texcoord;\nattribute mediump vec4 a_color;\nvarying mediump vec4 v_color;\nvarying mediump vec2 v_texcoord;\nvoid main()\n{\nv_color = a_color;\nv_texcoord = a_texcoord;\ngl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;\n}",
            POSITION_TEXTURE_FRAG: "precision lowp float;\nvarying vec2 v_texCoord;\nvoid main()\n{\ngl_FragColor = texture2D(CC_Texture0, v_texCoord);\n}",
            POSITION_TEXTURE_VERT: "attribute vec4 a_position;\nattribute vec2 a_texCoord;\nvarying mediump vec2 v_texCoord;\nvoid main()\n{\ngl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;\nv_texCoord = a_texCoord;\n}",
            POSITION_TEXTURE_UCOLOR_FRAG: "precision lowp float;\nuniform vec4 u_color;\nvarying vec2 v_texCoord;\nvoid main()\n{\ngl_FragColor=texture2D(CC_Texture0, v_texCoord) * u_color;\n}",
            POSITION_TEXTURE_UCOLOR_VERT: "attribute vec4 a_position;\nattribute vec2 a_texCoord;\nvarying mediump vec2 v_texCoord;\nvoid main()\n{\ngl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;\nv_texCoord = a_texCoord;\n}",
            POSITION_TEXTURE_A8COLOR_FRAG: "precision lowp float;\nvarying vec4 v_fragmentColor;\nvarying vec2 v_texCoord;\nvoid main()\n{\ngl_FragColor = vec4(v_fragmentColor.rgb,\nv_fragmentColor.a * texture2D(CC_Texture0, v_texCoord).a);\n}",
            POSITION_TEXTURE_A8COLOR_VERT: "attribute vec4 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvarying mediump vec2 v_texCoord;\nvoid main()\n{\ngl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;\nv_fragmentColor = a_color;\nv_texCoord = a_texCoord;\n}",
            POSITION_TEXTURE_COLOR_FRAG: "precision lowp float;\nvarying vec4 v_fragmentColor;\nvarying vec2 v_texCoord;\nvoid main()\n{\ngl_FragColor = v_fragmentColor * texture2D(CC_Texture0, v_texCoord);\n}",
            POSITION_TEXTURE_COLOR_VERT: "attribute vec4 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvarying mediump vec2 v_texCoord;\nvoid main()\n{\ngl_Position = (CC_PMatrix * CC_MVMatrix) * a_position;\nv_fragmentColor = a_color;\nv_texCoord = a_texCoord;\n}",
            SPRITE_POSITION_TEXTURE_COLOR_VERT: "attribute vec4 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying lowp vec4 v_fragmentColor;\nvarying mediump vec2 v_texCoord;\nvoid main()\n{\ngl_Position = CC_PMatrix * a_position;\nv_fragmentColor = a_color;\nv_texCoord = a_texCoord;\n}",
            POSITION_TEXTURE_COLOR_ALPHATEST_FRAG: "precision lowp float;\nvarying vec4 v_fragmentColor;\nvarying vec2 v_texCoord;\nuniform float CC_alpha_value;\nvoid main()\n{\nvec4 texColor=texture2D(CC_Texture0, v_texCoord);\nif(texColor.a <= CC_alpha_value)\n discard; \ngl_FragColor=texColor*v_fragmentColor;\n}",
            EX_SWITCHMASK_FRAG: "precision lowp float;\nvarying vec4 v_fragmentColor;\nvarying vec2 v_texCoord;\nuniform sampler2D u_texture;\nuniform sampler2D u_mask;\nvoid main()\n{\nvec4 texColorc=texture2D(u_texture, v_texCoord);\nvec4 maskColor=texture2D(u_mask, v_texCoord);\nvec4 finalColor=vec4(texColor.r, texColor.g, texColor.b, maskColor.a*texColor.a);\ngl_FragColor=v_fragmentColor*finalColor;\n}"
        };
    }), {} ],
    274: [ (function(require, module, exports) {
        require("./CCShaders");
        require("./CCShaderCache");
        require("./CCGLProgram");
        require("./CCGLStateCache");
    }), {
        "./CCGLProgram": 270,
        "./CCGLStateCache": 271,
        "./CCShaderCache": 272,
        "./CCShaders": 273
    } ],
    275: [ (function(require, module, exports) {
        var __t = function(v) {
            return {
                u: v.x,
                v: v.y
            };
        };
        cc.DrawNode = _ccsg.Node.extend({
            _buffer: null,
            _blendFunc: null,
            _lineWidth: 1,
            _drawColor: null,
            getBlendFunc: function() {
                return this._blendFunc;
            },
            setBlendFunc: function(blendFunc, dst) {
                if (void 0 === dst) {
                    this._blendFunc.src = blendFunc.src;
                    this._blendFunc.dst = blendFunc.dst;
                } else {
                    this._blendFunc.src = blendFunc;
                    this._blendFunc.dst = dst;
                }
            },
            setLineWidth: function(width) {
                this._lineWidth = width;
            },
            getLineWidth: function() {
                return this._lineWidth;
            },
            setDrawColor: function(color) {
                var locDrawColor = this._drawColor;
                locDrawColor.r = color.r;
                locDrawColor.g = color.g;
                locDrawColor.b = color.b;
                locDrawColor.a = null == color.a ? 255 : color.a;
            },
            getDrawColor: function() {
                return cc.color(this._drawColor.r, this._drawColor.g, this._drawColor.b, this._drawColor.a);
            }
        });
        cc.DrawNode.TYPE_DOT = 0;
        cc.DrawNode.TYPE_SEGMENT = 1;
        cc.DrawNode.TYPE_POLY = 2;
        cc.game.once(cc.game.EVENT_RENDERER_INITED, (function() {
            var proto = cc.DrawNode.prototype;
            if (cc._renderType === cc.game.RENDER_TYPE_CANVAS) {
                cc._DrawNodeElement = function(type, verts, fillColor, lineWidth, lineColor, lineCap, isClosePolygon, isFill, isStroke) {
                    var _t = this;
                    _t.type = type;
                    _t.verts = verts || null;
                    _t.fillColor = fillColor || null;
                    _t.lineWidth = lineWidth || 0;
                    _t.lineColor = lineColor || null;
                    _t.lineCap = lineCap || "butt";
                    _t.isClosePolygon = isClosePolygon || false;
                    _t.isFill = isFill || false;
                    _t.isStroke = isStroke || false;
                };
                proto._className = "DrawNodeCanvas";
                proto.ctor = function() {
                    _ccsg.Node.prototype.ctor.call(this);
                    var locCmd = this._renderCmd;
                    locCmd._buffer = this._buffer = [];
                    locCmd._drawColor = this._drawColor = cc.color(255, 255, 255, 255);
                    locCmd._blendFunc = this._blendFunc = new cc.BlendFunc(cc.macro.SRC_ALPHA, cc.macro.ONE_MINUS_SRC_ALPHA);
                    this.init();
                };
                proto.drawRect = function(origin, destination, fillColor, lineWidth, lineColor) {
                    lineWidth = null == lineWidth ? this._lineWidth : lineWidth;
                    lineColor = lineColor || this.getDrawColor();
                    null == lineColor.a && (lineColor.a = 255);
                    var vertices = [ origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y) ];
                    var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
                    element.verts = vertices;
                    element.lineWidth = lineWidth;
                    element.lineColor = lineColor;
                    element.isClosePolygon = true;
                    element.isStroke = true;
                    element.lineCap = "butt";
                    element.fillColor = fillColor;
                    if (fillColor) {
                        null == fillColor.a && (fillColor.a = 255);
                        element.isFill = true;
                    }
                    this._buffer.push(element);
                };
                proto.drawCircle = function(center, radius, angle, segments, drawLineToCenter, lineWidth, color) {
                    lineWidth = lineWidth || this._lineWidth;
                    color = color || this.getDrawColor();
                    null == color.a && (color.a = 255);
                    var coef = 2 * Math.PI / segments;
                    var vertices = [];
                    for (var i = 0; i <= segments; i++) {
                        var rads = i * coef;
                        var j = radius * Math.cos(rads + angle) + center.x;
                        var k = radius * Math.sin(rads + angle) + center.y;
                        vertices.push(cc.p(j, k));
                    }
                    drawLineToCenter && vertices.push(cc.p(center.x, center.y));
                    var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
                    element.verts = vertices;
                    element.lineWidth = lineWidth;
                    element.lineColor = color;
                    element.isClosePolygon = true;
                    element.isStroke = true;
                    this._buffer.push(element);
                };
                proto.drawQuadBezier = function(origin, control, destination, segments, lineWidth, color) {
                    lineWidth = lineWidth || this._lineWidth;
                    color = color || this.getDrawColor();
                    null == color.a && (color.a = 255);
                    var vertices = [], t = 0;
                    for (var i = 0; i < segments; i++) {
                        var x = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
                        var y = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
                        vertices.push(cc.p(x, y));
                        t += 1 / segments;
                    }
                    vertices.push(cc.p(destination.x, destination.y));
                    var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
                    element.verts = vertices;
                    element.lineWidth = lineWidth;
                    element.lineColor = color;
                    element.isStroke = true;
                    element.lineCap = "round";
                    this._buffer.push(element);
                };
                proto.drawCubicBezier = function(origin, control1, control2, destination, segments, lineWidth, color) {
                    lineWidth = lineWidth || this._lineWidth;
                    color = color || this.getDrawColor();
                    null == color.a && (color.a = 255);
                    var vertices = [], t = 0;
                    for (var i = 0; i < segments; i++) {
                        var x = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
                        var y = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
                        vertices.push(cc.p(x, y));
                        t += 1 / segments;
                    }
                    vertices.push(cc.p(destination.x, destination.y));
                    var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
                    element.verts = vertices;
                    element.lineWidth = lineWidth;
                    element.lineColor = color;
                    element.isStroke = true;
                    element.lineCap = "round";
                    this._buffer.push(element);
                };
                proto.drawCatmullRom = function(points, segments, lineWidth, color) {
                    this.drawCardinalSpline(points, .5, segments, lineWidth, color);
                };
                proto.drawCardinalSpline = function(config, tension, segments, lineWidth, color) {
                    lineWidth = lineWidth || this._lineWidth;
                    color = color || this.getDrawColor();
                    null == color.a && (color.a = 255);
                    var vertices = [], p, lt, deltaT = 1 / config.length;
                    for (var i = 0; i < segments + 1; i++) {
                        var dt = i / segments;
                        if (1 === dt) {
                            p = config.length - 1;
                            lt = 1;
                        } else {
                            p = 0 | dt / deltaT;
                            lt = (dt - deltaT * p) / deltaT;
                        }
                        var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p - 0), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
                        vertices.push(newPos);
                    }
                    var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
                    element.verts = vertices;
                    element.lineWidth = lineWidth;
                    element.lineColor = color;
                    element.isStroke = true;
                    element.lineCap = "round";
                    this._buffer.push(element);
                };
                proto.drawDot = function(pos, radius, color) {
                    color = color || this.getDrawColor();
                    null == color.a && (color.a = 255);
                    var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_DOT);
                    element.verts = [ pos ];
                    element.lineWidth = radius;
                    element.fillColor = color;
                    this._buffer.push(element);
                };
                proto.drawDots = function(points, radius, color) {
                    if (!points || 0 == points.length) {
                        return;
                    }
                    color = color || this.getDrawColor();
                    null == color.a && (color.a = 255);
                    for (var i = 0, len = points.length; i < len; i++) {
                        this.drawDot(points[i], radius, color);
                    }
                };
                proto.drawSegment = function(from, to, lineWidth, color) {
                    lineWidth = lineWidth || this._lineWidth;
                    color = color || this.getDrawColor();
                    null == color.a && (color.a = 255);
                    var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
                    element.verts = [ from, to ];
                    element.lineWidth = 2 * lineWidth;
                    element.lineColor = color;
                    element.isStroke = true;
                    element.lineCap = "round";
                    this._buffer.push(element);
                };
                proto.drawPoly_ = function(verts, fillColor, lineWidth, color, notClosePoly) {
                    lineWidth = null == lineWidth ? this._lineWidth : lineWidth;
                    color = color || this.getDrawColor();
                    null == color.a && (color.a = 255);
                    var element = new cc._DrawNodeElement(cc.DrawNode.TYPE_POLY);
                    element.verts = verts;
                    element.fillColor = fillColor;
                    element.lineWidth = lineWidth;
                    element.lineColor = color;
                    element.isClosePolygon = !notClosePoly;
                    element.isStroke = true;
                    element.lineCap = "round";
                    fillColor && (element.isFill = true);
                    this._buffer.push(element);
                };
                proto.drawPoly = function(verts, fillColor, lineWidth, color, notClosePoly) {
                    var vertsCopy = [];
                    for (var i = 0; i < verts.length; i++) {
                        vertsCopy.push(cc.p(verts[i].x, verts[i].y));
                    }
                    return this.drawPoly_(vertsCopy, fillColor, lineWidth, color, notClosePoly);
                };
                proto.clear = function() {
                    this._buffer.length = 0;
                };
                proto._createRenderCmd = function() {
                    return new cc.DrawNode.CanvasRenderCmd(this);
                };
            } else {
                if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                    proto._bufferCapacity = 0;
                    proto._trianglesArrayBuffer = null;
                    proto._trianglesWebBuffer = null;
                    proto._trianglesReader = null;
                    proto._dirty = false;
                    proto._className = "DrawNodeWebGL";
                    proto.ctor = function() {
                        _ccsg.Node.prototype.ctor.call(this);
                        this._buffer = [];
                        this._blendFunc = new cc.BlendFunc(cc.macro.SRC_ALPHA, cc.macro.ONE_MINUS_SRC_ALPHA);
                        this._drawColor = cc.color(255, 255, 255, 255);
                        this.init();
                    };
                    proto.init = function() {
                        if (_ccsg.Node.prototype.init.call(this)) {
                            this.shaderProgram = cc.shaderCache.programForKey(cc.macro.SHADER_POSITION_LENGTHTEXTURECOLOR);
                            this._ensureCapacity(64);
                            this._trianglesWebBuffer = cc._renderContext.createBuffer();
                            this._dirty = true;
                            return true;
                        }
                        return false;
                    };
                    proto.drawRect = function(origin, destination, fillColor, lineWidth, lineColor) {
                        lineWidth = null == lineWidth ? this._lineWidth : lineWidth;
                        lineColor = lineColor || this.getDrawColor();
                        null == lineColor.a && (lineColor.a = 255);
                        var vertices = [ origin, cc.p(destination.x, origin.y), destination, cc.p(origin.x, destination.y) ];
                        null == fillColor ? this._drawSegments(vertices, lineWidth, lineColor, true) : this.drawPoly(vertices, fillColor, lineWidth, lineColor);
                    };
                    proto.drawCircle = function(center, radius, angle, segments, drawLineToCenter, lineWidth, color) {
                        lineWidth = lineWidth || this._lineWidth;
                        color = color || this.getDrawColor();
                        null == color.a && (color.a = 255);
                        var coef = 2 * Math.PI / segments, vertices = [], i, len;
                        for (i = 0; i <= segments; i++) {
                            var rads = i * coef;
                            var j = radius * Math.cos(rads + angle) + center.x;
                            var k = radius * Math.sin(rads + angle) + center.y;
                            vertices.push(cc.p(j, k));
                        }
                        drawLineToCenter && vertices.push(cc.p(center.x, center.y));
                        lineWidth *= .5;
                        for (i = 0, len = vertices.length; i < len - 1; i++) {
                            this.drawSegment(vertices[i], vertices[i + 1], lineWidth, color);
                        }
                    };
                    proto.drawQuadBezier = function(origin, control, destination, segments, lineWidth, color) {
                        lineWidth = lineWidth || this._lineWidth;
                        color = color || this.getDrawColor();
                        null == color.a && (color.a = 255);
                        var vertices = [], t = 0;
                        for (var i = 0; i < segments; i++) {
                            var x = Math.pow(1 - t, 2) * origin.x + 2 * (1 - t) * t * control.x + t * t * destination.x;
                            var y = Math.pow(1 - t, 2) * origin.y + 2 * (1 - t) * t * control.y + t * t * destination.y;
                            vertices.push(cc.p(x, y));
                            t += 1 / segments;
                        }
                        vertices.push(cc.p(destination.x, destination.y));
                        this._drawSegments(vertices, lineWidth, color, false);
                    };
                    proto.drawCubicBezier = function(origin, control1, control2, destination, segments, lineWidth, color) {
                        lineWidth = lineWidth || this._lineWidth;
                        color = color || this.getDrawColor();
                        null == color.a && (color.a = 255);
                        var vertices = [], t = 0;
                        for (var i = 0; i < segments; i++) {
                            var x = Math.pow(1 - t, 3) * origin.x + 3 * Math.pow(1 - t, 2) * t * control1.x + 3 * (1 - t) * t * t * control2.x + t * t * t * destination.x;
                            var y = Math.pow(1 - t, 3) * origin.y + 3 * Math.pow(1 - t, 2) * t * control1.y + 3 * (1 - t) * t * t * control2.y + t * t * t * destination.y;
                            vertices.push(cc.p(x, y));
                            t += 1 / segments;
                        }
                        vertices.push(cc.p(destination.x, destination.y));
                        this._drawSegments(vertices, lineWidth, color, false);
                    };
                    proto.drawCatmullRom = function(points, segments, lineWidth, color) {
                        this.drawCardinalSpline(points, .5, segments, lineWidth, color);
                    };
                    proto.drawCardinalSpline = function(config, tension, segments, lineWidth, color) {
                        lineWidth = lineWidth || this._lineWidth;
                        color = color || this.getDrawColor();
                        null == color.a && (color.a = 255);
                        var vertices = [], p, lt, deltaT = 1 / config.length;
                        for (var i = 0; i < segments + 1; i++) {
                            var dt = i / segments;
                            if (1 === dt) {
                                p = config.length - 1;
                                lt = 1;
                            } else {
                                p = 0 | dt / deltaT;
                                lt = (dt - deltaT * p) / deltaT;
                            }
                            var newPos = cc.cardinalSplineAt(cc.getControlPointAt(config, p - 1), cc.getControlPointAt(config, p - 0), cc.getControlPointAt(config, p + 1), cc.getControlPointAt(config, p + 2), tension, lt);
                            vertices.push(newPos);
                        }
                        lineWidth *= .5;
                        for (var j = 0, len = vertices.length; j < len - 1; j++) {
                            this.drawSegment(vertices[j], vertices[j + 1], lineWidth, color);
                        }
                    };
                    proto._render = function() {
                        var gl = cc._renderContext;
                        gl.bindBuffer(gl.ARRAY_BUFFER, this._trianglesWebBuffer);
                        if (this._dirty) {
                            gl.bufferData(gl.ARRAY_BUFFER, this._trianglesArrayBuffer, gl.STREAM_DRAW);
                            this._dirty = false;
                        }
                        var triangleSize = cc.V2F_C4B_T2F.BYTES_PER_ELEMENT;
                        gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_POSITION);
                        gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_COLOR);
                        gl.enableVertexAttribArray(cc.macro.VERTEX_ATTRIB_TEX_COORDS);
                        gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_POSITION, 2, gl.FLOAT, false, triangleSize, 0);
                        gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_COLOR, 4, gl.UNSIGNED_BYTE, true, triangleSize, 8);
                        gl.vertexAttribPointer(cc.macro.VERTEX_ATTRIB_TEX_COORDS, 2, gl.FLOAT, false, triangleSize, 12);
                        gl.drawArrays(gl.TRIANGLES, 0, 3 * this._buffer.length);
                        cc.incrementGLDraws(1);
                    };
                    proto._ensureCapacity = function(count) {
                        var _t = this;
                        var locBuffer = _t._buffer;
                        if (locBuffer.length + count > _t._bufferCapacity) {
                            var TriangleLength = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT;
                            _t._bufferCapacity += Math.max(_t._bufferCapacity, count);
                            if (null == locBuffer || 0 === locBuffer.length) {
                                _t._buffer = [];
                                _t._trianglesArrayBuffer = new ArrayBuffer(TriangleLength * _t._bufferCapacity);
                                _t._trianglesReader = new Uint8Array(_t._trianglesArrayBuffer);
                            } else {
                                var newTriangles = [];
                                var newArrayBuffer = new ArrayBuffer(TriangleLength * _t._bufferCapacity);
                                for (var i = 0; i < locBuffer.length; i++) {
                                    newTriangles[i] = new cc.V2F_C4B_T2F_Triangle(locBuffer[i].a, locBuffer[i].b, locBuffer[i].c, newArrayBuffer, i * TriangleLength);
                                }
                                _t._trianglesReader = new Uint8Array(newArrayBuffer);
                                _t._trianglesArrayBuffer = newArrayBuffer;
                                _t._buffer = newTriangles;
                            }
                        }
                    };
                    proto.drawDot = function(pos, radius, color) {
                        color = color || this.getDrawColor();
                        null == color.a && (color.a = 255);
                        var c4bColor = {
                            r: 0 | color.r,
                            g: 0 | color.g,
                            b: 0 | color.b,
                            a: 0 | color.a
                        };
                        var a = {
                            vertices: {
                                x: pos.x - radius,
                                y: pos.y - radius
                            },
                            colors: c4bColor,
                            texCoords: {
                                u: -1,
                                v: -1
                            }
                        };
                        var b = {
                            vertices: {
                                x: pos.x - radius,
                                y: pos.y + radius
                            },
                            colors: c4bColor,
                            texCoords: {
                                u: -1,
                                v: 1
                            }
                        };
                        var c = {
                            vertices: {
                                x: pos.x + radius,
                                y: pos.y + radius
                            },
                            colors: c4bColor,
                            texCoords: {
                                u: 1,
                                v: 1
                            }
                        };
                        var d = {
                            vertices: {
                                x: pos.x + radius,
                                y: pos.y - radius
                            },
                            colors: c4bColor,
                            texCoords: {
                                u: 1,
                                v: -1
                            }
                        };
                        this._ensureCapacity(6);
                        this._buffer.push(new cc.V2F_C4B_T2F_Triangle(a, b, c, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
                        this._buffer.push(new cc.V2F_C4B_T2F_Triangle(a, c, d, this._trianglesArrayBuffer, this._buffer.length * cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT));
                        this._dirty = true;
                    };
                    proto.drawDots = function(points, radius, color) {
                        if (!points || 0 === points.length) {
                            return;
                        }
                        color = color || this.getDrawColor();
                        null == color.a && (color.a = 255);
                        for (var i = 0, len = points.length; i < len; i++) {
                            this.drawDot(points[i], radius, color);
                        }
                    };
                    proto.drawSegment = function(from, to, radius, color) {
                        color = color || this.getDrawColor();
                        null == color.a && (color.a = 255);
                        radius = radius || .5 * this._lineWidth;
                        var vertexCount = 18;
                        this._ensureCapacity(vertexCount);
                        var c4bColor = {
                            r: 0 | color.r,
                            g: 0 | color.g,
                            b: 0 | color.b,
                            a: 0 | color.a
                        };
                        var a = cc.v2(from), b = cc.v2(to);
                        var n = cc.pNormalize(cc.pPerp(cc.pSub(b, a))), t = cc.pPerp(n);
                        var nw = cc.pMult(n, radius), tw = cc.pMult(t, radius);
                        var v0 = cc.pSub(b, cc.pAdd(nw, tw));
                        var v1 = cc.pAdd(b, cc.pSub(nw, tw));
                        var v2 = cc.pSub(b, nw);
                        var v3 = cc.pAdd(b, nw);
                        var v4 = cc.pSub(a, nw);
                        var v5 = cc.pAdd(a, nw);
                        var v6 = cc.pSub(a, cc.pSub(nw, tw));
                        var v7 = cc.pAdd(a, cc.pAdd(nw, tw));
                        var TriangleLength = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, triangleBuffer = this._trianglesArrayBuffer, locBuffer = this._buffer;
                        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                            vertices: v0,
                            colors: c4bColor,
                            texCoords: __t(cc.pNeg(cc.pAdd(n, t)))
                        }, {
                            vertices: v1,
                            colors: c4bColor,
                            texCoords: __t(cc.pSub(n, t))
                        }, {
                            vertices: v2,
                            colors: c4bColor,
                            texCoords: __t(cc.pNeg(n))
                        }, triangleBuffer, locBuffer.length * TriangleLength));
                        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                            vertices: v3,
                            colors: c4bColor,
                            texCoords: __t(n)
                        }, {
                            vertices: v1,
                            colors: c4bColor,
                            texCoords: __t(cc.pSub(n, t))
                        }, {
                            vertices: v2,
                            colors: c4bColor,
                            texCoords: __t(cc.pNeg(n))
                        }, triangleBuffer, locBuffer.length * TriangleLength));
                        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                            vertices: v3,
                            colors: c4bColor,
                            texCoords: __t(n)
                        }, {
                            vertices: v4,
                            colors: c4bColor,
                            texCoords: __t(cc.pNeg(n))
                        }, {
                            vertices: v2,
                            colors: c4bColor,
                            texCoords: __t(cc.pNeg(n))
                        }, triangleBuffer, locBuffer.length * TriangleLength));
                        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                            vertices: v3,
                            colors: c4bColor,
                            texCoords: __t(n)
                        }, {
                            vertices: v4,
                            colors: c4bColor,
                            texCoords: __t(cc.pNeg(n))
                        }, {
                            vertices: v5,
                            colors: c4bColor,
                            texCoords: __t(n)
                        }, triangleBuffer, locBuffer.length * TriangleLength));
                        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                            vertices: v6,
                            colors: c4bColor,
                            texCoords: __t(cc.pSub(t, n))
                        }, {
                            vertices: v4,
                            colors: c4bColor,
                            texCoords: __t(cc.pNeg(n))
                        }, {
                            vertices: v5,
                            colors: c4bColor,
                            texCoords: __t(n)
                        }, triangleBuffer, locBuffer.length * TriangleLength));
                        locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                            vertices: v6,
                            colors: c4bColor,
                            texCoords: __t(cc.pSub(t, n))
                        }, {
                            vertices: v7,
                            colors: c4bColor,
                            texCoords: __t(cc.pAdd(n, t))
                        }, {
                            vertices: v5,
                            colors: c4bColor,
                            texCoords: __t(n)
                        }, triangleBuffer, locBuffer.length * TriangleLength));
                        this._dirty = true;
                    };
                    proto.drawPoly = function(verts, fillColor, borderWidth, borderColor, notClosePoly) {
                        if (null == fillColor) {
                            this._drawSegments(verts, borderWidth, borderColor, !notClosePoly);
                            return;
                        }
                        null == fillColor.a && (fillColor.a = 255);
                        null == borderColor.a && (borderColor.a = 255);
                        borderWidth = null == borderWidth ? this._lineWidth : borderWidth;
                        borderWidth *= .5;
                        var c4bFillColor = {
                            r: 0 | fillColor.r,
                            g: 0 | fillColor.g,
                            b: 0 | fillColor.b,
                            a: 0 | fillColor.a
                        };
                        var c4bBorderColor = {
                            r: 0 | borderColor.r,
                            g: 0 | borderColor.g,
                            b: 0 | borderColor.b,
                            a: 0 | borderColor.a
                        };
                        var extrude = [], i, v0, v1, v2, count = verts.length;
                        for (i = 0; i < count; i++) {
                            v0 = cc.v2(verts[(i - 1 + count) % count]);
                            v1 = cc.v2(verts[i]);
                            v2 = cc.v2(verts[(i + 1) % count]);
                            var n1 = cc.pNormalize(cc.pPerp(cc.pSub(v1, v0)));
                            var n2 = cc.pNormalize(cc.pPerp(cc.pSub(v2, v1)));
                            var offset = cc.pMult(cc.pAdd(n1, n2), 1 / (cc.pDot(n1, n2) + 1));
                            extrude[i] = {
                                offset: offset,
                                n: n2
                            };
                        }
                        var outline = borderWidth > 0, triangleCount = 3 * count - 2, vertexCount = 3 * triangleCount;
                        this._ensureCapacity(vertexCount);
                        var triangleBytesLen = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, trianglesBuffer = this._trianglesArrayBuffer;
                        var locBuffer = this._buffer;
                        var inset = false == outline ? .5 : 0;
                        for (i = 0; i < count - 2; i++) {
                            v0 = cc.pSub(cc.v2(verts[0]), cc.pMult(extrude[0].offset, inset));
                            v1 = cc.pSub(cc.v2(verts[i + 1]), cc.pMult(extrude[i + 1].offset, inset));
                            v2 = cc.pSub(cc.v2(verts[i + 2]), cc.pMult(extrude[i + 2].offset, inset));
                            locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                vertices: v0,
                                colors: c4bFillColor,
                                texCoords: __t(cc.v2())
                            }, {
                                vertices: v1,
                                colors: c4bFillColor,
                                texCoords: __t(cc.v2())
                            }, {
                                vertices: v2,
                                colors: c4bFillColor,
                                texCoords: __t(cc.v2())
                            }, trianglesBuffer, locBuffer.length * triangleBytesLen));
                        }
                        for (i = 0; i < count; i++) {
                            var j = (i + 1) % count;
                            v0 = cc.v2(verts[i]);
                            v1 = cc.v2(verts[j]);
                            var n0 = extrude[i].n;
                            var offset0 = extrude[i].offset;
                            var offset1 = extrude[j].offset;
                            var inner0 = outline ? cc.pSub(v0, cc.pMult(offset0, borderWidth)) : cc.pSub(v0, cc.pMult(offset0, .5));
                            var inner1 = outline ? cc.pSub(v1, cc.pMult(offset1, borderWidth)) : cc.pSub(v1, cc.pMult(offset1, .5));
                            var outer0 = outline ? cc.pAdd(v0, cc.pMult(offset0, borderWidth)) : cc.pAdd(v0, cc.pMult(offset0, .5));
                            var outer1 = outline ? cc.pAdd(v1, cc.pMult(offset1, borderWidth)) : cc.pAdd(v1, cc.pMult(offset1, .5));
                            if (outline) {
                                locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                    vertices: inner0,
                                    colors: c4bBorderColor,
                                    texCoords: __t(cc.pNeg(n0))
                                }, {
                                    vertices: inner1,
                                    colors: c4bBorderColor,
                                    texCoords: __t(cc.pNeg(n0))
                                }, {
                                    vertices: outer1,
                                    colors: c4bBorderColor,
                                    texCoords: __t(n0)
                                }, trianglesBuffer, locBuffer.length * triangleBytesLen));
                                locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                    vertices: inner0,
                                    colors: c4bBorderColor,
                                    texCoords: __t(cc.pNeg(n0))
                                }, {
                                    vertices: outer0,
                                    colors: c4bBorderColor,
                                    texCoords: __t(n0)
                                }, {
                                    vertices: outer1,
                                    colors: c4bBorderColor,
                                    texCoords: __t(n0)
                                }, trianglesBuffer, locBuffer.length * triangleBytesLen));
                            } else {
                                locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                    vertices: inner0,
                                    colors: c4bFillColor,
                                    texCoords: __t(cc.v2())
                                }, {
                                    vertices: inner1,
                                    colors: c4bFillColor,
                                    texCoords: __t(cc.v2())
                                }, {
                                    vertices: outer1,
                                    colors: c4bFillColor,
                                    texCoords: __t(n0)
                                }, trianglesBuffer, locBuffer.length * triangleBytesLen));
                                locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                    vertices: inner0,
                                    colors: c4bFillColor,
                                    texCoords: __t(cc.v2())
                                }, {
                                    vertices: outer0,
                                    colors: c4bFillColor,
                                    texCoords: __t(n0)
                                }, {
                                    vertices: outer1,
                                    colors: c4bFillColor,
                                    texCoords: __t(n0)
                                }, trianglesBuffer, locBuffer.length * triangleBytesLen));
                            }
                        }
                        extrude = null;
                        this._dirty = true;
                    };
                    proto._drawSegments = function(verts, borderWidth, borderColor, closePoly) {
                        borderWidth = null == borderWidth ? this._lineWidth : borderWidth;
                        borderColor = borderColor || this._drawColor;
                        null == borderColor.a && (borderColor.a = 255);
                        borderWidth *= .5;
                        if (borderWidth <= 0) {
                            return;
                        }
                        var c4bBorderColor = {
                            r: 0 | borderColor.r,
                            g: 0 | borderColor.g,
                            b: 0 | borderColor.b,
                            a: 0 | borderColor.a
                        };
                        var extrude = [], i, v0, v1, v2, count = verts.length;
                        for (i = 0; i < count; i++) {
                            v0 = cc.v2(verts[(i - 1 + count) % count]);
                            v1 = cc.v2(verts[i]);
                            v2 = cc.v2(verts[(i + 1) % count]);
                            var n1 = cc.pNormalize(cc.pPerp(cc.pSub(v1, v0)));
                            var n2 = cc.pNormalize(cc.pPerp(cc.pSub(v2, v1)));
                            var offset = cc.pMult(cc.pAdd(n1, n2), 1 / (cc.pDot(n1, n2) + 1));
                            extrude[i] = {
                                offset: offset,
                                n: n2
                            };
                        }
                        var triangleCount = 3 * count - 2, vertexCount = 3 * triangleCount;
                        this._ensureCapacity(vertexCount);
                        var triangleBytesLen = cc.V2F_C4B_T2F_Triangle.BYTES_PER_ELEMENT, trianglesBuffer = this._trianglesArrayBuffer;
                        var locBuffer = this._buffer;
                        var len = closePoly ? count : count - 1;
                        for (i = 0; i < len; i++) {
                            var j = (i + 1) % count;
                            v0 = cc.v2(verts[i]);
                            v1 = cc.v2(verts[j]);
                            var n0 = extrude[i].n;
                            var offset0 = extrude[i].offset;
                            var offset1 = extrude[j].offset;
                            var inner0 = cc.pSub(v0, cc.pMult(offset0, borderWidth));
                            var inner1 = cc.pSub(v1, cc.pMult(offset1, borderWidth));
                            var outer0 = cc.pAdd(v0, cc.pMult(offset0, borderWidth));
                            var outer1 = cc.pAdd(v1, cc.pMult(offset1, borderWidth));
                            locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                vertices: inner0,
                                colors: c4bBorderColor,
                                texCoords: __t(cc.pNeg(n0))
                            }, {
                                vertices: inner1,
                                colors: c4bBorderColor,
                                texCoords: __t(cc.pNeg(n0))
                            }, {
                                vertices: outer1,
                                colors: c4bBorderColor,
                                texCoords: __t(n0)
                            }, trianglesBuffer, locBuffer.length * triangleBytesLen));
                            locBuffer.push(new cc.V2F_C4B_T2F_Triangle({
                                vertices: inner0,
                                colors: c4bBorderColor,
                                texCoords: __t(cc.pNeg(n0))
                            }, {
                                vertices: outer0,
                                colors: c4bBorderColor,
                                texCoords: __t(n0)
                            }, {
                                vertices: outer1,
                                colors: c4bBorderColor,
                                texCoords: __t(n0)
                            }, trianglesBuffer, locBuffer.length * triangleBytesLen));
                        }
                        extrude = null;
                        this._dirty = true;
                    };
                    proto.clear = function() {
                        this._buffer.length = 0;
                        this._dirty = true;
                    };
                    proto._createRenderCmd = function() {
                        return new cc.DrawNode.WebGLRenderCmd(this);
                    };
                }
            }
        }));
    }), {} ],
    276: [ (function(require, module, exports) {
        cc.DrawNode.CanvasRenderCmd = function(renderableObject) {
            this._rootCtor(renderableObject);
            this._needDraw = true;
            this._buffer = null;
            this._drawColor = null;
            this._blendFunc = null;
        };
        var proto = cc.DrawNode.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
        proto.constructor = cc.DrawNode.CanvasRenderCmd;
        proto.rendering = function(ctx, scaleX, scaleY) {
            var wrapper = ctx || cc._renderContext, context = wrapper.getContext(), node = this._node;
            var alpha = node._displayedOpacity / 255;
            if (0 === alpha) {
                return;
            }
            wrapper.setTransform(this._worldTransform, scaleX, scaleY);
            wrapper.setGlobalAlpha(alpha);
            this._blendFunc && this._blendFunc.src === cc.macro.SRC_ALPHA && this._blendFunc.dst === cc.macro.ONE && wrapper.setCompositeOperation("lighter");
            var locBuffer = this._buffer;
            for (var i = 0, len = locBuffer.length; i < len; i++) {
                var element = locBuffer[i];
                switch (element.type) {
                  case cc.DrawNode.TYPE_DOT:
                    this._drawDot(wrapper, element, scaleX, scaleY);
                    break;

                  case cc.DrawNode.TYPE_SEGMENT:
                    this._drawSegment(wrapper, element, scaleX, scaleY);
                    break;

                  case cc.DrawNode.TYPE_POLY:
                    this._drawPoly(wrapper, element, scaleX, scaleY);
                }
            }
        };
        proto._drawDot = function(wrapper, element, scaleX, scaleY) {
            var locColor = element.fillColor, locPos = element.verts[0], locRadius = element.lineWidth;
            var ctx = wrapper.getContext();
            wrapper.setFillStyle("rgba(" + (0 | locColor.r) + "," + (0 | locColor.g) + "," + (0 | locColor.b) + "," + locColor.a / 255 + ")");
            ctx.beginPath();
            ctx.arc(locPos.x, -locPos.y, locRadius, 0, 2 * Math.PI, false);
            ctx.closePath();
            ctx.fill();
        };
        proto._drawSegment = function(wrapper, element, scaleX, scaleY) {
            var locColor = element.lineColor;
            var locFrom = element.verts[0], locTo = element.verts[1];
            var locLineWidth = element.lineWidth, locLineCap = element.lineCap;
            var ctx = wrapper.getContext();
            wrapper.setStrokeStyle("rgba(" + (0 | locColor.r) + "," + (0 | locColor.g) + "," + (0 | locColor.b) + "," + locColor.a / 255 + ")");
            ctx.lineWidth = locLineWidth * scaleX;
            ctx.beginPath();
            ctx.lineCap = locLineCap;
            ctx.moveTo(locFrom.x, -locFrom.y);
            ctx.lineTo(locTo.x, -locTo.y);
            ctx.stroke();
        };
        proto._drawPoly = function(wrapper, element, scaleX, scaleY) {
            var locVertices = element.verts, locLineCap = element.lineCap;
            if (null == locVertices) {
                return;
            }
            var locFillColor = element.fillColor, locLineWidth = element.lineWidth;
            var locLineColor = element.lineColor, locIsClosePolygon = element.isClosePolygon;
            var locIsFill = element.isFill, locIsStroke = element.isStroke;
            var ctx = wrapper.getContext();
            var firstPoint = locVertices[0];
            ctx.lineCap = locLineCap;
            locFillColor && wrapper.setFillStyle("rgba(" + (0 | locFillColor.r) + "," + (0 | locFillColor.g) + "," + (0 | locFillColor.b) + "," + locFillColor.a / 255 + ")");
            locLineWidth && (ctx.lineWidth = locLineWidth * scaleX);
            locLineColor && wrapper.setStrokeStyle("rgba(" + (0 | locLineColor.r) + "," + (0 | locLineColor.g) + "," + (0 | locLineColor.b) + "," + locLineColor.a / 255 + ")");
            ctx.beginPath();
            ctx.moveTo(firstPoint.x, -firstPoint.y);
            for (var i = 1, len = locVertices.length; i < len; i++) {
                ctx.lineTo(locVertices[i].x, -locVertices[i].y);
            }
            locIsClosePolygon && ctx.closePath();
            locIsFill && ctx.fill();
            locIsStroke && ctx.stroke();
        };
    }), {} ],
    277: [ (function(require, module, exports) {
        cc.DrawNode.WebGLRenderCmd = function(renderableObject) {
            this._rootCtor(renderableObject);
            this._needDraw = true;
            this._matrix = new cc.math.Matrix4();
            this._matrix.identity();
        };
        cc.DrawNode.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
        cc.DrawNode.WebGLRenderCmd.prototype.constructor = cc.DrawNode.WebGLRenderCmd;
        cc.DrawNode.WebGLRenderCmd.prototype.rendering = function(ctx) {
            var node = this._node;
            if (node._buffer.length > 0) {
                var wt = this._worldTransform, mat = this._matrix.mat;
                mat[0] = wt.a;
                mat[4] = wt.c;
                mat[12] = wt.tx;
                mat[1] = wt.b;
                mat[5] = wt.d;
                mat[13] = wt.ty;
                cc.gl.blendFunc(node._blendFunc.src, node._blendFunc.dst);
                this._shaderProgram.use();
                this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix);
                node._render();
            }
        };
    }), {} ],
    278: [ (function(require, module, exports) {
        _ccsg.TMXLayer = _ccsg.Node.extend({
            tiles: null,
            tileset: null,
            layerOrientation: null,
            properties: null,
            layerName: "",
            _texture: null,
            _textures: null,
            _texGrids: null,
            _spriteTiles: null,
            _layerSize: null,
            _mapTileSize: null,
            _opacity: 255,
            _minGID: null,
            _maxGID: null,
            _vertexZvalue: null,
            _useAutomaticVertexZ: null,
            _reusedTile: null,
            _atlasIndexArray: null,
            _contentScaleFactor: null,
            _staggerAxis: null,
            _staggerIndex: null,
            _hexSideLength: 0,
            _className: "TMXLayer",
            ctor: function(tilesetInfo, layerInfo, mapInfo) {
                cc.SpriteBatchNode.prototype.ctor.call(this);
                this._descendants = [];
                this._layerSize = cc.size(0, 0);
                this._mapTileSize = cc.size(0, 0);
                this._spriteTiles = {};
                this._staggerAxis = cc.TiledMap.StaggerAxis.STAGGERAXIS_Y;
                this._staggerIndex = cc.TiledMap.StaggerIndex.STAGGERINDEX_EVEN;
                void 0 !== mapInfo && this.initWithTilesetInfo(tilesetInfo, layerInfo, mapInfo);
            },
            _createRenderCmd: function() {
                return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new _ccsg.TMXLayer.CanvasRenderCmd(this) : new _ccsg.TMXLayer.WebGLRenderCmd(this);
            },
            _fillTextureGrids: function(tileset, texId) {
                var tex = this._textures[texId];
                if (!tex.isLoaded()) {
                    tex.once("load", (function() {
                        this._fillTextureGrids(tileset, texId);
                    }), this);
                    return;
                }
                if (!tileset.imageSize.width || !tileset.imageSize.height) {
                    tileset.imageSize.width = tex.width;
                    tileset.imageSize.height = tex.height;
                }
                var tw = tileset._tileSize.width, th = tileset._tileSize.height, imageW = tex._contentSize.width, imageH = tex._contentSize.height, spacing = tileset.spacing, margin = tileset.margin, cols = Math.floor((imageW - 2 * margin + spacing) / (tw + spacing)), rows = Math.floor((imageH - 2 * margin + spacing) / (th + spacing)), count = rows * cols, gid = tileset.firstGid, maxGid = tileset.firstGid + count, grids = this._texGrids, grid = null, override = !!grids[gid], texelCorrect = cc.macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL ? .5 : 0;
                for (;gid < maxGid; ++gid) {
                    override && !grids[gid] && (override = false);
                    if (!override && grids[gid]) {
                        break;
                    }
                    grid = {
                        texId: texId,
                        x: 0,
                        y: 0,
                        width: tw,
                        height: th,
                        t: 0,
                        l: 0,
                        r: 0,
                        b: 0
                    };
                    tileset.rectForGID(gid, grid);
                    grid.x += texelCorrect;
                    grid.y += texelCorrect;
                    grid.width -= 2 * texelCorrect;
                    grid.height -= 2 * texelCorrect;
                    grid.t = grid.y / imageH;
                    grid.l = grid.x / imageW;
                    grid.r = (grid.x + grid.width) / imageW;
                    grid.b = (grid.y + grid.height) / imageH;
                    grids[gid] = grid;
                }
            },
            initWithTilesetInfo: function(tilesetInfo, layerInfo, mapInfo) {
                var size = layerInfo._layerSize;
                this.layerName = layerInfo.name;
                this.tiles = layerInfo._tiles;
                this.properties = layerInfo.properties;
                this._layerSize = size;
                this._minGID = layerInfo._minGID;
                this._maxGID = layerInfo._maxGID;
                this._opacity = layerInfo._opacity;
                this._staggerAxis = mapInfo.getStaggerAxis();
                this._staggerIndex = mapInfo.getStaggerIndex();
                this._hexSideLength = mapInfo.getHexSideLength();
                this.tileset = tilesetInfo;
                this.layerOrientation = mapInfo.orientation;
                this._mapTileSize = mapInfo.getTileSize();
                var tilesets = mapInfo._tilesets;
                if (tilesets) {
                    var i, len = tilesets.length, tileset, tex;
                    this._textures = new Array(len);
                    this._texGrids = [];
                    for (i = 0; i < len; ++i) {
                        tileset = tilesets[i];
                        tex = cc.textureCache.addImage(tileset.sourceImage);
                        tex.setAliasTexParameters();
                        this._textures[i] = tex;
                        this._fillTextureGrids(tileset, i);
                        tileset === tilesetInfo && (this._texture = tex);
                    }
                }
                var offset = this._calculateLayerOffset(layerInfo.offset);
                this.setPosition(offset);
                this._parseInternalProperties();
                if (this.layerOrientation === cc.TiledMap.Orientation.HEX) {
                    var width = 0, height = 0;
                    if (this._staggerAxis === cc.TiledMap.StaggerAxis.STAGGERAXIS_X) {
                        height = mapInfo._tileSize.height * (this._layerSize.height + .5);
                        width = (mapInfo._tileSize.width + this._hexSideLength) * Math.floor(this._layerSize.width / 2) + mapInfo._tileSize.width * (this._layerSize.width % 2);
                    } else {
                        width = mapInfo._tileSize.width * (this._layerSize.width + .5);
                        height = (mapInfo._tileSize.height + this._hexSideLength) * Math.floor(this._layerSize.height / 2) + mapInfo._tileSize.height * (this._layerSize.height % 2);
                    }
                    this.setContentSize(width, height);
                } else {
                    this.setContentSize(this._layerSize.width * this._mapTileSize.width, this._layerSize.height * this._mapTileSize.height);
                }
                this._useAutomaticVertexZ = false;
                this._vertexZvalue = 0;
                return true;
            },
            visit: function(parent) {
                var cmd = this._renderCmd, parentCmd = parent ? parent._renderCmd : null;
                if (!this._visible) {
                    cmd._propagateFlagsDown(parentCmd);
                    return;
                }
                var renderer = cc.renderer;
                cmd.visit(parentCmd);
                var i, children = this._children, len = children.length, child, isCanvas = cc._renderType === cc.game.RENDER_TYPE_CANVAS, spTiles = this._spriteTiles;
                if (len > 0) {
                    this._reorderChildDirty && this.sortAllChildren();
                    for (i = 0; i < len; i++) {
                        child = children[i];
                        if (!(child._localZOrder < 0)) {
                            break;
                        }
                        child.visit(this);
                    }
                    renderer.pushRenderCommand(cmd);
                    for (;i < len; i++) {
                        child = children[i];
                        if (isCanvas && 0 === child._localZOrder && spTiles[child.tag]) {
                            if (isNaN(child._customZ)) {
                                child._vertexZ = renderer.assignedZ;
                                renderer.assignedZ += renderer.assignedZStep;
                            }
                            child._renderCmd.updateStatus();
                            continue;
                        }
                        child.visit(this);
                    }
                } else {
                    renderer.pushRenderCommand(cmd);
                }
                cmd._dirtyFlag = 0;
            },
            getLayerSize: function() {
                return cc.size(this._layerSize.width, this._layerSize.height);
            },
            setLayerSize: function(Var) {
                this._layerSize.width = Var.width;
                this._layerSize.height = Var.height;
            },
            _getLayerWidth: function() {
                return this._layerSize.width;
            },
            _setLayerWidth: function(width) {
                this._layerSize.width = width;
            },
            _getLayerHeight: function() {
                return this._layerSize.height;
            },
            _setLayerHeight: function(height) {
                this._layerSize.height = height;
            },
            getMapTileSize: function() {
                return cc.size(this._mapTileSize.width, this._mapTileSize.height);
            },
            setMapTileSize: function(Var) {
                this._mapTileSize.width = Var.width;
                this._mapTileSize.height = Var.height;
            },
            _getTileWidth: function() {
                return this._mapTileSize.width;
            },
            _setTileWidth: function(width) {
                this._mapTileSize.width = width;
            },
            _getTileHeight: function() {
                return this._mapTileSize.height;
            },
            _setTileHeight: function(height) {
                this._mapTileSize.height = height;
            },
            getTiles: function() {
                return this.tiles;
            },
            setTiles: function(Var) {
                this.tiles = Var;
            },
            getTileSet: function() {
                return this.tileset;
            },
            setTileSet: function(Var) {
                this.tileset = Var;
            },
            getLayerOrientation: function() {
                return this.layerOrientation;
            },
            setLayerOrientation: function(Var) {
                this.layerOrientation = Var;
            },
            getProperties: function() {
                return this.properties;
            },
            setProperties: function(Var) {
                this.properties = Var;
            },
            getProperty: function(propertyName) {
                return this.properties[propertyName];
            },
            getLayerName: function() {
                return this.layerName;
            },
            setLayerName: function(layerName) {
                this.layerName = layerName;
            },
            releaseMap: function() {
                this._spriteTiles = {};
            },
            getTileAt: function(pos, y) {
                if (void 0 === pos) {
                    throw new Error("_ccsg.TMXLayer.getTileAt(): pos should be non-null");
                }
                var x = pos;
                if (void 0 === y) {
                    x = pos.x;
                    y = pos.y;
                }
                if (x >= this._layerSize.width || y >= this._layerSize.height || x < 0 || y < 0) {
                    throw new Error("_ccsg.TMXLayer.getTileAt(): invalid position");
                }
                if (!this.tiles) {
                    cc.logID(7204);
                    return null;
                }
                var tile = null, gid = this.getTileGIDAt(x, y);
                if (0 === gid) {
                    return tile;
                }
                var z = Math.floor(x) + Math.floor(y) * this._layerSize.width;
                tile = this._spriteTiles[z];
                if (!tile) {
                    var rect = this._texGrids[gid];
                    var tex = this._textures[rect.texId];
                    tile = new _ccsg.Sprite(tex, rect);
                    tile.setPosition(this.getPositionAt(x, y));
                    var vertexZ = this._vertexZForPos(x, y);
                    tile.setVertexZ(vertexZ);
                    tile.setAnchorPoint(0, 0);
                    tile.setOpacity(this._opacity);
                    this.addChild(tile, vertexZ, z);
                }
                return tile;
            },
            getTileGIDAt: function(pos, y) {
                if (void 0 === pos) {
                    throw new Error("_ccsg.TMXLayer.getTileGIDAt(): pos should be non-null");
                }
                var x = pos;
                if (void 0 === y) {
                    x = pos.x;
                    y = pos.y;
                }
                if (x >= this._layerSize.width || y >= this._layerSize.height || x < 0 || y < 0) {
                    throw new Error("_ccsg.TMXLayer.getTileGIDAt(): invalid position");
                }
                if (!this.tiles) {
                    cc.logID(7205);
                    return null;
                }
                var idx = Math.floor(x) + Math.floor(y) * this._layerSize.width;
                var tile = this.tiles[idx];
                return (tile & cc.TiledMap.TileFlag.FLIPPED_MASK) >>> 0;
            },
            setTileGID: function(gid, posOrX, flagsOrY, flags) {
                if (void 0 === posOrX) {
                    throw new Error("_ccsg.TMXLayer.setTileGID(): pos should be non-null");
                }
                var pos;
                if (void 0 === flags && posOrX instanceof cc.Vec2) {
                    pos = posOrX;
                    flags = flagsOrY;
                } else {
                    pos = cc.p(posOrX, flagsOrY);
                }
                pos.x = Math.floor(pos.x);
                pos.y = Math.floor(pos.y);
                if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0) {
                    throw new Error("_ccsg.TMXLayer.setTileGID(): invalid position");
                }
                if (!this.tiles) {
                    cc.logID(7206);
                    return;
                }
                if (0 !== gid && gid < this.tileset.firstGid) {
                    cc.logID(7207, gid);
                    return;
                }
                flags = flags || 0;
                var currentFlags = this.getTileFlagsAt(pos);
                var currentGID = this.getTileGIDAt(pos);
                if (currentGID !== gid || currentFlags !== flags) {
                    var gidAndFlags = (gid | flags) >>> 0;
                    if (0 === gid) {
                        this.removeTileAt(pos);
                    } else {
                        if (0 === currentGID) {
                            this._updateTileForGID(gidAndFlags, pos);
                        } else {
                            var z = pos.x + pos.y * this._layerSize.width;
                            var sprite = this.getChildByTag(z);
                            if (sprite) {
                                var rect = this._texGrids[gid];
                                var tex = this._textures[rect.texId];
                                sprite.setTexture(tex);
                                sprite.setTextureRect(rect, false);
                                null != flags && this._setupTileSprite(sprite, pos, gidAndFlags);
                                this.tiles[z] = gidAndFlags;
                            } else {
                                this._updateTileForGID(gidAndFlags, pos);
                            }
                        }
                    }
                }
            },
            addChild: function(child, localZOrder, tag) {
                _ccsg.Node.prototype.addChild.call(this, child, localZOrder, tag);
                if (void 0 !== tag) {
                    this._spriteTiles[tag] = child;
                    child._vertexZ = this._vertexZ + cc.renderer.assignedZStep * tag / this.tiles.length;
                }
            },
            removeChild: function(child, cleanup) {
                this._spriteTiles[child.tag] && (this._spriteTiles[child.tag] = null);
                _ccsg.Node.prototype.removeChild.call(this, child, cleanup);
            },
            getTileFlagsAt: function(pos, y) {
                if (!pos) {
                    throw new Error("_ccsg.TMXLayer.getTileFlagsAt(): pos should be non-null");
                }
                void 0 !== y && (pos = cc.p(pos, y));
                if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0) {
                    throw new Error("_ccsg.TMXLayer.getTileFlagsAt(): invalid position");
                }
                if (!this.tiles) {
                    cc.logID(7208);
                    return null;
                }
                var idx = Math.floor(pos.x) + Math.floor(pos.y) * this._layerSize.width;
                var tile = this.tiles[idx];
                return (tile & cc.TiledMap.TileFlag.FLIPPED_ALL) >>> 0;
            },
            removeTileAt: function(pos, y) {
                if (!pos) {
                    throw new Error("_ccsg.TMXLayer.removeTileAt(): pos should be non-null");
                }
                void 0 !== y && (pos = cc.p(pos, y));
                if (pos.x >= this._layerSize.width || pos.y >= this._layerSize.height || pos.x < 0 || pos.y < 0) {
                    throw new Error("_ccsg.TMXLayer.removeTileAt(): invalid position");
                }
                if (!this.tiles) {
                    cc.logID(7209);
                    return;
                }
                var gid = this.getTileGIDAt(pos);
                if (0 !== gid) {
                    var z = Math.floor(pos.x) + Math.floor(pos.y) * this._layerSize.width;
                    this.tiles[z] = 0;
                    var sprite = this._spriteTiles[z];
                    sprite && this.removeChild(sprite, true);
                }
            },
            getPositionAt: function(pos, y) {
                void 0 !== y && (pos = cc.p(pos, y));
                pos.x = Math.floor(pos.x);
                pos.y = Math.floor(pos.y);
                var ret = cc.p(0, 0);
                switch (this.layerOrientation) {
                  case cc.TiledMap.Orientation.ORTHO:
                    ret = this._positionForOrthoAt(pos);
                    break;

                  case cc.TiledMap.Orientation.ISO:
                    ret = this._positionForIsoAt(pos);
                    break;

                  case cc.TiledMap.Orientation.HEX:
                    ret = this._positionForHexAt(pos);
                }
                return ret;
            },
            _positionForIsoAt: function(pos) {
                return cc.p(this._mapTileSize.width / 2 * (this._layerSize.width + pos.x - pos.y - 1), this._mapTileSize.height / 2 * (2 * this._layerSize.height - pos.x - pos.y - 2));
            },
            _positionForOrthoAt: function(pos) {
                return cc.p(pos.x * this._mapTileSize.width, (this._layerSize.height - pos.y - 1) * this._mapTileSize.height);
            },
            _positionForHexAt: function(pos) {
                var xy = cc.p(0, 0);
                var offset = this.tileset.tileOffset;
                var odd_even = this._staggerIndex === cc.TiledMap.StaggerIndex.STAGGERINDEX_ODD ? 1 : -1;
                switch (this._staggerAxis) {
                  case cc.TiledMap.StaggerAxis.STAGGERAXIS_Y:
                    var diffX = 0;
                    pos.y % 2 === 1 && (diffX = this._mapTileSize.width / 2 * odd_even);
                    xy = cc.p(pos.x * this._mapTileSize.width + diffX + offset.x, (this._layerSize.height - pos.y - 1) * (this._mapTileSize.height - (this._mapTileSize.height - this._hexSideLength) / 2) - offset.y);
                    break;

                  case cc.TiledMap.StaggerAxis.STAGGERAXIS_X:
                    var diffY = 0;
                    pos.x % 2 === 1 && (diffY = this._mapTileSize.height / 2 * -odd_even);
                    xy = cc.p(pos.x * (this._mapTileSize.width - (this._mapTileSize.width - this._hexSideLength) / 2) + offset.x, (this._layerSize.height - pos.y - 1) * this._mapTileSize.height + diffY - offset.y);
                }
                return xy;
            },
            _calculateLayerOffset: function(pos) {
                var ret = cc.p(0, 0);
                switch (this.layerOrientation) {
                  case cc.TiledMap.Orientation.ORTHO:
                    ret = cc.p(pos.x * this._mapTileSize.width, -pos.y * this._mapTileSize.height);
                    break;

                  case cc.TiledMap.Orientation.ISO:
                    ret = cc.p(this._mapTileSize.width / 2 * (pos.x - pos.y), this._mapTileSize.height / 2 * (-pos.x - pos.y));
                    break;

                  case cc.TiledMap.Orientation.HEX:
                    if (this._staggerAxis === cc.TiledMap.StaggerAxis.STAGGERAXIS_Y) {
                        var diffX = this._staggerIndex === cc.TiledMap.StaggerIndex.STAGGERINDEX_EVEN ? this._mapTileSize.width / 2 : 0;
                        ret = cc.p(pos.x * this._mapTileSize.width + diffX, -pos.y * (this._mapTileSize.height - (this._mapTileSize.width - this._hexSideLength) / 2));
                    } else {
                        if (this._staggerAxis === cc.TiledMap.StaggerAxis.STAGGERAXIS_X) {
                            var diffY = this._staggerIndex === cc.TiledMap.StaggerIndex.STAGGERINDEX_ODD ? this._mapTileSize.height / 2 : 0;
                            ret = cc.p(pos.x * (this._mapTileSize.width - (this._mapTileSize.width - this._hexSideLength) / 2), -pos.y * this._mapTileSize.height + diffY);
                        }
                    }
                }
                return ret;
            },
            _updateTileForGID: function(gid, pos) {
                if (!this._texGrids[gid]) {
                    return;
                }
                var idx = 0 | pos.x + pos.y * this._layerSize.width;
                idx < this.tiles.length && (this.tiles[idx] = gid);
            },
            _parseInternalProperties: function() {
                var vertexz = this.getProperty("cc_vertexz");
                if (vertexz) {
                    if ("automatic" === vertexz) {
                        this._useAutomaticVertexZ = true;
                        var alphaFuncVal = this.getProperty("cc_alpha_func");
                        var alphaFuncValue = 0;
                        alphaFuncVal && (alphaFuncValue = parseFloat(alphaFuncVal));
                        if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                            this.shaderProgram = cc.shaderCache.programForKey(cc.macro.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST);
                            this.shaderProgram.use();
                            this.shaderProgram.setUniformLocationWith1f(cc.UNIFORM_ALPHA_TEST_VALUE_S, alphaFuncValue);
                        }
                    } else {
                        this._vertexZvalue = parseInt(vertexz, 10);
                    }
                }
            },
            _setupTileSprite: function(sprite, pos, gid) {
                var posInPixel = this.getPositionAt(pos);
                sprite.setPosition(posInPixel);
                sprite.setVertexZ(this._vertexZForPos(pos));
                sprite.setAnchorPoint(0, 0);
                sprite.setOpacity(this._opacity);
                sprite.setFlippedX(false);
                sprite.setFlippedY(false);
                sprite.setRotation(0);
                if ((gid & cc.TiledMap.TileFlag.DIAGONAL) >>> 0) {
                    sprite.setAnchorPoint(.5, .5);
                    sprite.setPosition(posInPixel.x + sprite.width / 2, posInPixel.y + sprite.height / 2);
                    var flag = (gid & (cc.TiledMap.TileFlag.HORIZONTAL | cc.TiledMap.TileFlag.VERTICAL) >>> 0) >>> 0;
                    if (flag === cc.TiledMap.TileFlag.HORIZONTAL) {
                        sprite.setRotation(90);
                    } else {
                        if (flag === cc.TiledMap.TileFlag.VERTICAL) {
                            sprite.setRotation(270);
                        } else {
                            if (flag === (cc.TiledMap.TileFlag.VERTICAL | cc.TiledMap.TileFlag.HORIZONTAL) >>> 0) {
                                sprite.setRotation(90);
                                sprite.setFlippedX(true);
                            } else {
                                sprite.setRotation(270);
                                sprite.setFlippedX(true);
                            }
                        }
                    }
                } else {
                    (gid & cc.TiledMap.TileFlag.HORIZONTAL) >>> 0 && sprite.setFlippedX(true);
                    (gid & cc.TiledMap.TileFlag.VERTICAL) >>> 0 && sprite.setFlippedY(true);
                }
            },
            _vertexZForPos: function(x, y) {
                if (void 0 === y) {
                    y = x.y;
                    x = x.x;
                }
                var ret = 0;
                var maxVal = 0;
                if (this._useAutomaticVertexZ) {
                    switch (this.layerOrientation) {
                      case cc.TiledMap.Orientation.ISO:
                        maxVal = this._layerSize.width + this._layerSize.height;
                        ret = -(maxVal - (x + y));
                        break;

                      case cc.TiledMap.Orientation.ORTHO:
                        ret = -(this._layerSize.height - y);
                        break;

                      case cc.TiledMap.Orientation.HEX:
                        cc.logID(7210);
                        break;

                      default:
                        cc.logID(7211);
                    }
                } else {
                    ret = this._vertexZvalue;
                }
                return ret;
            }
        });
    }), {} ],
    279: [ (function(require, module, exports) {
        _ccsg.TMXObject = cc.Class({
            properties: {
                sgNode: null,
                offset: cc.p(0, 0),
                gid: 0,
                name: "",
                type: null,
                id: 0,
                objectVisible: true,
                objectSize: cc.size(0, 0),
                objectRotation: 0,
                _properties: null,
                _groupSize: cc.size(0, 0)
            },
            initWithInfo: function(objInfo, mapInfo, groupSize, color) {
                this.setProperties(objInfo);
                this.setObjectName(objInfo.name);
                this.id = objInfo.id;
                this.gid = objInfo.gid;
                this.type = objInfo.type;
                this.offset = cc.p(objInfo.x, objInfo.y);
                this.objectSize = cc.size(objInfo.width, objInfo.height);
                this.objectVisible = objInfo.visible;
                this.objectRotation = objInfo.rotation;
                this._groupSize = groupSize;
                this.type === cc.TiledMap.TMXObjectType.IMAGE ? this.sgNode = new _ccsg.TMXObjectImage(this, mapInfo) : this.sgNode = new _ccsg.TMXObjectShape(this, mapInfo, color);
            },
            getObjectName: function() {
                return this.name;
            },
            getProperty: function(propName) {
                return this._properties[propName];
            },
            getProperties: function() {
                return this._properties;
            },
            setObjectName: function(name) {
                this.name = name;
            },
            setProperties: function(props) {
                this._properties = props;
            }
        });
        _ccsg.TMXObjectImage = _ccsg.Sprite.extend({
            _container: null,
            ctor: function(container, mapInfo) {
                _ccsg.Sprite.prototype.ctor.call(this);
                this._container = container;
                this.initWithMapInfo(mapInfo);
            },
            initWithMapInfo: function(mapInfo) {
                if (!this._container.gid) {
                    return false;
                }
                var useTileset;
                var tilesets = mapInfo.getTilesets();
                for (var i = tilesets.length - 1; i >= 0; i--) {
                    var tileset = tilesets[i];
                    if ((this._container.gid & cc.TiledMap.TileFlag.FLIPPED_MASK) >>> 0 >= tileset.firstGid) {
                        useTileset = tileset;
                        break;
                    }
                }
                if (!useTileset) {
                    return false;
                }
                this.setVisible(this._container.objectVisible);
                var texture = cc.textureCache.addImage(cc.path._normalize(tileset.sourceImage));
                this._initWithTileset(texture, useTileset);
                this._initPosWithMapInfo(mapInfo);
                this.setRotation(this._container.objectRotation);
                (this._container.gid & cc.TiledMap.TileFlag.HORIZONTAL) >>> 0 && this.setFlippedX(true);
                (this._container.gid & cc.TiledMap.TileFlag.VERTICAL) >>> 0 && this.setFlippedY(true);
                return true;
            },
            _initWithTileset: function(texture, tileset) {
                if (!texture.isLoaded()) {
                    texture.once("load", (function() {
                        this._initWithTileset(texture, tileset);
                    }), this);
                    return;
                }
                tileset.imageSize.width = texture.width;
                tileset.imageSize.height = texture.height;
                var rect = tileset.rectForGID(this._container.gid);
                this.initWithTexture(texture, rect);
                this.setScaleX(this._container.objectSize.width / rect.size.width);
                this.setScaleY(this._container.objectSize.height / rect.size.height);
            },
            _initPosWithMapInfo: function(mapInfo) {
                var mapOri = mapInfo.getOrientation();
                switch (mapOri) {
                  case cc.TiledMap.Orientation.ORTHO:
                  case cc.TiledMap.Orientation.HEX:
                    this.setAnchorPoint(cc.p(0, 0));
                    this.setPosition(this._container.offset.x, this._container._groupSize.height - this._container.offset.y);
                    break;

                  case cc.TiledMap.Orientation.ISO:
                    this.setAnchorPoint(cc.p(.5, 0));
                    var posIdx = cc.p(this._container.offset.x / mapInfo._tileSize.height, this._container.offset.y / mapInfo._tileSize.height);
                    var pos = cc.p(mapInfo._tileSize.width / 2 * (mapInfo._mapSize.width + posIdx.x - posIdx.y), mapInfo._tileSize.height / 2 * (2 * mapInfo._mapSize.height - posIdx.x - posIdx.y));
                    this.setPosition(pos);
                }
            }
        });
        _ccsg.TMXObjectShape = cc.DrawNode.extend({
            _container: null,
            _color: cc.Color.WHITE,
            _mapOrientation: 0,
            _mapInfo: null,
            ctor: function(container, mapInfo, color) {
                cc.DrawNode.prototype.ctor.call(this);
                this.setLineWidth(1);
                this._container = container;
                this._color = color;
                this._mapInfo = mapInfo;
                this._mapOrientation = mapInfo.getOrientation();
                this._initShape();
            },
            _initShape: function() {
                var originPos;
                if (cc.TiledMap.Orientation.ISO !== this._mapOrientation) {
                    var startPos = cc.p(0, this._container._groupSize.height);
                    originPos = cc.p(startPos.x + this._container.offset.x, startPos.y - this._container.offset.y);
                } else {
                    originPos = this._getPosByOffset(cc.p(0, 0));
                }
                this.setPosition(originPos);
                this.setRotation(this._container.objectRotation);
                switch (this._container.type) {
                  case cc.TiledMap.TMXObjectType.RECT:
                    this._drawRect();
                    break;

                  case cc.TiledMap.TMXObjectType.ELLIPSE:
                    this._drawEllipse();
                    break;

                  case cc.TiledMap.TMXObjectType.POLYGON:
                    this._drawPoly(originPos, true);
                    break;

                  case cc.TiledMap.TMXObjectType.POLYLINE:
                    this._drawPoly(originPos, false);
                }
                this.setVisible(this._container.objectVisible);
            },
            _getPosByOffset: function(offset) {
                var mapSize = this._mapInfo.getMapSize();
                var tileSize = this._mapInfo.getTileSize();
                var posIdx = cc.p((this._container.offset.x + offset.x) / tileSize.width * 2, (this._container.offset.y + offset.y) / tileSize.height);
                return cc.p(tileSize.width / 2 * (mapSize.width + posIdx.x - posIdx.y), tileSize.height / 2 * (2 * mapSize.height - posIdx.x - posIdx.y));
            },
            _drawRect: function() {
                if (cc.TiledMap.Orientation.ISO !== this._mapOrientation) {
                    var objSize = this._container.objectSize;
                    if (objSize.equals(cc.Size.ZERO)) {
                        objSize = cc.size(20, 20);
                        this.setAnchorPoint(cc.p(.5, .5));
                    } else {
                        this.setAnchorPoint(cc.p(0, 1));
                    }
                    var bl = cc.p(0, 0);
                    var tr = cc.p(objSize.width, objSize.height);
                    this.drawRect(bl, tr, null, this.getLineWidth(), this._color);
                    this.setContentSize(objSize);
                } else {
                    if (this._container.objectSize.equals(cc.Size.ZERO)) {
                        return;
                    }
                    var pos1 = this._getPosByOffset(cc.p(0, 0));
                    var pos2 = this._getPosByOffset(cc.p(this._container.objectSize.width, 0));
                    var pos3 = this._getPosByOffset(cc.p(this._container.objectSize.width, this._container.objectSize.height));
                    var pos4 = this._getPosByOffset(cc.p(0, this._container.objectSize.height));
                    var width = pos2.x - pos4.x, height = pos1.y - pos3.y;
                    this.setContentSize(cc.size(width, height));
                    this.setAnchorPoint(cc.p((pos1.x - pos4.x) / width, 1));
                    var origin = cc.p(pos4.x, pos3.y);
                    pos1.subSelf(origin);
                    pos2.subSelf(origin);
                    pos3.subSelf(origin);
                    pos4.subSelf(origin);
                    if (this._container.objectSize.width > 0) {
                        this.drawSegment(pos1, pos2, this.getLineWidth(), this._color);
                        this.drawSegment(pos3, pos4, this.getLineWidth(), this._color);
                    }
                    if (this._container.objectSize.height > 0) {
                        this.drawSegment(pos1, pos4, this.getLineWidth(), this._color);
                        this.drawSegment(pos3, pos2, this.getLineWidth(), this._color);
                    }
                }
            },
            _drawEllipse: function() {
                var scaleX = 1, scaleY = 1, radius = 0;
                var center = cc.p(0, 0);
                var ellipseNode = null;
                if (cc.TiledMap.Orientation.ISO !== this._mapOrientation) {
                    var objSize = this._container.objectSize;
                    if (objSize.equals(cc.Size.ZERO)) {
                        objSize = cc.size(20, 20);
                        this.setAnchorPoint(cc.p(.5, .5));
                    } else {
                        this.setAnchorPoint(cc.p(0, 1));
                    }
                    center = cc.p(objSize.width / 2, objSize.height / 2);
                    if (objSize.width > objSize.height) {
                        scaleX = objSize.width / objSize.height;
                        radius = objSize.height / 2;
                    } else {
                        scaleY = objSize.height / objSize.width;
                        radius = objSize.width / 2;
                    }
                    ellipseNode = this;
                    this.setContentSize(objSize);
                } else {
                    if (this._container.objectSize.equals(cc.Size.ZERO)) {
                        return;
                    }
                    var pos1 = this._getPosByOffset(cc.p(0, 0));
                    var pos2 = this._getPosByOffset(cc.p(this._container.objectSize.width, 0));
                    var pos3 = this._getPosByOffset(cc.p(this._container.objectSize.width, this._container.objectSize.height));
                    var pos4 = this._getPosByOffset(cc.p(0, this._container.objectSize.height));
                    var width = pos2.x - pos4.x, height = pos1.y - pos3.y;
                    this.setContentSize(cc.size(width, height));
                    this.setAnchorPoint(cc.p((pos1.x - pos4.x) / width, 1));
                    var origin = cc.p(pos4.x, pos3.y);
                    pos1.subSelf(origin);
                    pos2.subSelf(origin);
                    pos3.subSelf(origin);
                    pos4.subSelf(origin);
                    if (this._container.objectSize.width > 0) {
                        this.drawSegment(pos1, pos2, this.getLineWidth(), this._color);
                        this.drawSegment(pos3, pos4, this.getLineWidth(), this._color);
                    }
                    if (this._container.objectSize.height > 0) {
                        this.drawSegment(pos1, pos4, this.getLineWidth(), this._color);
                        this.drawSegment(pos3, pos2, this.getLineWidth(), this._color);
                    }
                    center = this._getPosByOffset(cc.p(this._container.objectSize.width / 2, this._container.objectSize.height / 2));
                    center.subSelf(origin);
                    ellipseNode = new cc.DrawNode();
                    ellipseNode.setLineWidth(this.getLineWidth());
                    ellipseNode.setContentSize(cc.size(width, height));
                    ellipseNode.setAnchorPoint(cc.p(.5, .5));
                    ellipseNode.setPosition(center);
                    this.addChild(ellipseNode);
                    if (this._container.objectSize.width > this._container.objectSize.height) {
                        scaleX = this._container.objectSize.width / this._container.objectSize.height;
                        radius = this._container.objectSize.height / 2;
                    } else {
                        scaleY = this._container.objectSize.height / this._container.objectSize.width;
                        radius = this._container.objectSize.width / 2;
                    }
                    var tileSize = this._mapInfo.getTileSize();
                    var rotateDegree = Math.atan(tileSize.width / tileSize.height);
                    radius /= Math.sin(rotateDegree);
                    ellipseNode.setRotationX(cc.radiansToDegrees(rotateDegree));
                    ellipseNode.setRotationY(90 - cc.radiansToDegrees(rotateDegree));
                }
                ellipseNode.drawCircle(center, radius, 0, 50, false, this.getLineWidth(), this._color);
                ellipseNode.setScaleX(scaleX);
                ellipseNode.setScaleY(scaleY);
            },
            _drawPoly: function(originPos, isPolygon) {
                var pointsData;
                var objectInfo = this._container.getProperties();
                pointsData = isPolygon ? objectInfo.points : objectInfo.polylinePoints;
                var points = [];
                var minX = 0, minY = 0, maxX = 0, maxY = 0;
                for (var i = 0, n = pointsData.length; i < n; i++) {
                    var pointData = pointsData[i];
                    points.push(cc.p(pointData.x, pointData.y));
                    minX = Math.min(minX, pointData.x);
                    minY = Math.min(minY, pointData.y);
                    maxX = Math.max(maxX, pointData.x);
                    maxY = Math.max(maxY, pointData.y);
                }
                var width = 0, height = 0;
                if (cc.TiledMap.Orientation.ISO !== this._mapOrientation) {
                    width = maxX - minX, height = maxY - minY;
                    this.setAnchorPoint(cc.p(-minX / width, maxY / height));
                    for (var j = 0; j < points.length; j++) {
                        points[j] = cc.p(points[j].x - minX, -points[j].y + maxY);
                    }
                } else {
                    var bl = this._getPosByOffset(cc.p(minX, maxY));
                    var tr = this._getPosByOffset(cc.p(maxX, minY));
                    var origin = this._getPosByOffset(cc.p(0, 0));
                    width = tr.x - bl.x, height = tr.y - bl.y;
                    this.setAnchorPoint(cc.p((origin.x - bl.x) / width, (origin.y - bl.y) / height));
                    for (var idx = 0; idx < points.length; idx++) {
                        var tempPoint = this._getPosByOffset(points[idx]);
                        points[idx] = cc.p(tempPoint.x - bl.x, tempPoint.y - bl.y);
                    }
                }
                this.setContentSize(cc.size(width, height));
                this.drawPoly(points, null, this.getLineWidth(), this._color, !isPolygon);
            }
        });
    }), {} ],
    280: [ (function(require, module, exports) {
        _ccsg.TMXObjectGroup = _ccsg.Node.extend({
            properties: null,
            groupName: "",
            _positionOffset: null,
            _mapInfo: null,
            _objects: [],
            ctor: function(groupInfo, mapInfo) {
                _ccsg.Node.prototype.ctor.call(this);
                this._initGroup(groupInfo, mapInfo);
            },
            _initGroup: function(groupInfo, mapInfo) {
                this.groupName = groupInfo.name;
                this._positionOffset = groupInfo.offset;
                this._mapInfo = mapInfo;
                this.properties = groupInfo.getProperties();
                var mapSize = mapInfo._mapSize;
                var tileSize = mapInfo._tileSize;
                if (mapInfo.orientation === cc.TiledMap.Orientation.HEX) {
                    var width = 0, height = 0;
                    if (mapInfo.getStaggerAxis() === cc.TiledMap.StaggerAxis.STAGGERAXIS_X) {
                        height = tileSize.height * (mapSize.height + .5);
                        width = (tileSize.width + mapInfo.getHexSideLength()) * Math.floor(mapSize.width / 2) + tileSize.width * (mapSize.width % 2);
                    } else {
                        width = tileSize.width * (mapSize.width + .5);
                        height = (tileSize.height + mapInfo.getHexSideLength()) * Math.floor(mapSize.height / 2) + tileSize.height * (mapSize.height % 2);
                    }
                    this.setContentSize(width, height);
                } else {
                    this.setContentSize(mapSize.width * tileSize.width, mapSize.height * tileSize.height);
                }
                this.setAnchorPoint(cc.p(0, 0));
                this.setPosition(this._positionOffset.x, -this._positionOffset.y);
                this.setVisible(groupInfo.visible);
                var objects = [];
                groupInfo._objects instanceof Array && (objects = groupInfo._objects);
                this._objects = [];
                for (var i = 0, n = objects.length; i < n; i++) {
                    var objInfo = objects[i];
                    var object = new _ccsg.TMXObject();
                    object.initWithInfo(objInfo, mapInfo, this.getContentSize(), groupInfo._color);
                    this._objects.push(object);
                    if (object.sgNode) {
                        object.sgNode.setOpacity(groupInfo._opacity);
                        this.addChild(object.sgNode, i, i);
                    }
                }
            },
            getPositionOffset: function() {
                return cc.p(this._positionOffset);
            },
            setPositionOffset: function(offset) {
                this._positionOffset.x = offset.x;
                this._positionOffset.y = offset.y;
            },
            getProperties: function() {
                return this.properties;
            },
            setProperties: function(Var) {
                this.properties = Var;
            },
            getGroupName: function() {
                return this.groupName;
            },
            setGroupName: function(groupName) {
                this.groupName = groupName;
            },
            propertyNamed: function(propertyName) {
                return this.properties[propertyName];
            },
            objectNamed: function(objectName) {
                return this.getObject(objectName);
            },
            getObject: function(objectName) {
                for (var i = 0, len = this._objects.length; i < len; i++) {
                    var obj = this._objects[i];
                    if (obj && obj.getObjectName() === objectName) {
                        return obj;
                    }
                }
                return null;
            },
            getObjects: function() {
                return this._objects;
            }
        });
    }), {} ],
    281: [ (function(require, module, exports) {
        require("./CCSGTMXObject.js");
        require("./CCTMXXMLParser.js");
        _ccsg.TMXTiledMap = _ccsg.Node.extend({
            properties: null,
            mapOrientation: null,
            _mapSize: null,
            _tileSize: null,
            _tileProperties: null,
            _className: "TMXTiledMap",
            ctor: function(tmxFile, resourcePath) {
                _ccsg.Node.prototype.ctor.call(this);
                this._mapSize = cc.size(0, 0);
                this._tileSize = cc.size(0, 0);
                void 0 !== resourcePath ? this.initWithXML(tmxFile, resourcePath) : void 0 !== tmxFile && this.initWithTMXFile(tmxFile);
            },
            getMapSize: function() {
                return cc.size(this._mapSize.width, this._mapSize.height);
            },
            setMapSize: function(Var) {
                this._mapSize.width = Var.width;
                this._mapSize.height = Var.height;
            },
            _getMapWidth: function() {
                return this._mapSize.width;
            },
            _setMapWidth: function(width) {
                this._mapSize.width = width;
            },
            _getMapHeight: function() {
                return this._mapSize.height;
            },
            _setMapHeight: function(height) {
                this._mapSize.height = height;
            },
            getTileSize: function() {
                return cc.size(this._tileSize.width, this._tileSize.height);
            },
            setTileSize: function(Var) {
                this._tileSize.width = Var.width;
                this._tileSize.height = Var.height;
            },
            _getTileWidth: function() {
                return this._tileSize.width;
            },
            _setTileWidth: function(width) {
                this._tileSize.width = width;
            },
            _getTileHeight: function() {
                return this._tileSize.height;
            },
            _setTileHeight: function(height) {
                this._tileSize.height = height;
            },
            getMapOrientation: function() {
                return this.mapOrientation;
            },
            setMapOrientation: function(Var) {
                this.mapOrientation = Var;
            },
            getObjectGroups: function() {
                var retArr = [], locChildren = this._children;
                for (var i = 0, len = locChildren.length; i < len; i++) {
                    var group = locChildren[i];
                    group && group instanceof _ccsg.TMXObjectGroup && retArr.push(group);
                }
                return retArr;
            },
            getProperties: function() {
                return this.properties;
            },
            setProperties: function(Var) {
                this.properties = Var;
            },
            initWithTMXFile: function(tmxFile) {
                if (!tmxFile || 0 === tmxFile.length) {
                    return false;
                }
                this.width = 0;
                this.height = 0;
                var mapInfo = new cc.TMXMapInfo(tmxFile);
                if (!mapInfo) {
                    return false;
                }
                var locTilesets = mapInfo.getTilesets();
                locTilesets && 0 !== locTilesets.length || cc.logID(7212);
                this._buildWithMapInfo(mapInfo);
                return true;
            },
            initWithXML: function(tmxString, resourcePath) {
                this.width = 0;
                this.height = 0;
                var mapInfo = new cc.TMXMapInfo(tmxString, resourcePath);
                var locTilesets = mapInfo.getTilesets();
                locTilesets && 0 !== locTilesets.length || cc.logID(7213);
                this._buildWithMapInfo(mapInfo);
                return true;
            },
            _buildWithMapInfo: function(mapInfo) {
                this._mapSize = mapInfo.getMapSize();
                this._tileSize = mapInfo.getTileSize();
                this.mapOrientation = mapInfo.orientation;
                this.properties = mapInfo.properties;
                this._tileProperties = mapInfo.getTileProperties();
                var oldChildren = this._children;
                var childCount = oldChildren.length;
                for (var j = childCount - 1; j >= 0; j--) {
                    var childNode = oldChildren[j];
                    childNode && (childNode instanceof _ccsg.TMXLayer || childNode instanceof _ccsg.TMXObjectGroup) && this.removeChild(childNode);
                }
                var idx = 0;
                var children = mapInfo.getAllChildren();
                if (children && children.length > 0) {
                    for (var i = 0, len = children.length; i < len; i++) {
                        var childInfo = children[i];
                        var child;
                        if (childInfo instanceof cc.TMXLayerInfo && childInfo.visible) {
                            child = this._parseLayer(childInfo, mapInfo);
                            this.addChild(child, idx, idx);
                            this.width = Math.max(this.width, child.width);
                            this.height = Math.max(this.height, child.height);
                            idx++;
                        }
                        if (childInfo instanceof cc.TMXObjectGroupInfo) {
                            child = new _ccsg.TMXObjectGroup(childInfo, mapInfo);
                            this.addChild(child, idx, idx);
                            idx++;
                        }
                    }
                }
            },
            allLayers: function() {
                var retArr = [], locChildren = this._children;
                for (var i = 0, len = locChildren.length; i < len; i++) {
                    var layer = locChildren[i];
                    layer && layer instanceof _ccsg.TMXLayer && retArr.push(layer);
                }
                return retArr;
            },
            getLayer: function(layerName) {
                if (!layerName || 0 === layerName.length) {
                    throw new Error("_ccsg.TMXTiledMap.getLayer(): layerName should be non-null or non-empty string.");
                }
                var locChildren = this._children;
                for (var i = 0; i < locChildren.length; i++) {
                    var layer = locChildren[i];
                    if (layer && layer instanceof _ccsg.TMXLayer && layer.layerName === layerName) {
                        return layer;
                    }
                }
                return null;
            },
            getObjectGroup: function(groupName) {
                if (!groupName || 0 === groupName.length) {
                    throw new Error("_ccsg.TMXTiledMap.getObjectGroup(): groupName should be non-null or non-empty string.");
                }
                var locChildren = this._children;
                for (var i = 0; i < locChildren.length; i++) {
                    var group = locChildren[i];
                    if (group && group instanceof _ccsg.TMXObjectGroup && group.groupName === groupName) {
                        return group;
                    }
                }
                return null;
            },
            getProperty: function(propertyName) {
                return this.properties[propertyName.toString()];
            },
            propertiesForGID: function(GID) {
                cc.logID(7214);
                return this.getPropertiesForGID[GID];
            },
            getPropertiesForGID: function(GID) {
                return this._tileProperties[GID];
            },
            _parseLayer: function(layerInfo, mapInfo) {
                var tileset = this._tilesetForLayer(layerInfo, mapInfo);
                var layer = new _ccsg.TMXLayer(tileset, layerInfo, mapInfo);
                layerInfo.ownTiles = false;
                return layer;
            },
            _tilesetForLayer: function(layerInfo, mapInfo) {
                var size = layerInfo._layerSize;
                var tilesets = mapInfo.getTilesets();
                if (tilesets) {
                    for (var i = tilesets.length - 1; i >= 0; i--) {
                        var tileset = tilesets[i];
                        if (tileset) {
                            for (var y = 0; y < size.height; y++) {
                                for (var x = 0; x < size.width; x++) {
                                    var pos = x + size.width * y;
                                    var gid = layerInfo._tiles[pos];
                                    if (0 !== gid && (gid & cc.TiledMap.TileFlag.FLIPPED_MASK) >>> 0 >= tileset.firstGid) {
                                        return tileset;
                                    }
                                }
                            }
                        }
                    }
                }
                cc.logID(7215, layerInfo.name);
                return null;
            }
        });
        var _p = _ccsg.TMXTiledMap.prototype;
        _p.mapWidth;
        cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
        _p.mapHeight;
        cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
        _p.tileWidth;
        cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
        _p.tileHeight;
        cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
    }), {
        "./CCSGTMXObject.js": 279,
        "./CCTMXXMLParser.js": 284
    } ],
    282: [ (function(require, module, exports) {
        var Orientation = null;
        var TileFlag = null;
        var FLIPPED_MASK = null;
        var StaggerAxis = null;
        var StaggerIndex = null;
        _ccsg.TMXLayer.CanvasRenderCmd = function(renderable) {
            this._rootCtor(renderable);
            this._needDraw = true;
            if (!Orientation) {
                Orientation = cc.TiledMap.Orientation;
                TileFlag = cc.TiledMap.TileFlag;
                FLIPPED_MASK = TileFlag.FLIPPED_MASK;
                StaggerAxis = cc.TiledMap.StaggerAxis;
                StaggerIndex = cc.TiledMap.StaggerIndex;
            }
        };
        var proto = _ccsg.TMXLayer.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
        proto.constructor = _ccsg.TMXLayer.CanvasRenderCmd;
        proto.rendering = function(ctx, scaleX, scaleY) {
            var node = this._node, hasRotation = node._rotationX || node._rotationY, layerOrientation = node.layerOrientation, tiles = node.tiles, alpha = node._opacity / 255;
            if (!tiles || alpha <= 0) {
                return;
            }
            var maptw = node._mapTileSize.width, mapth = node._mapTileSize.height, tilew = node.tileset._tileSize.width / cc.director._contentScaleFactor, tileh = node.tileset._tileSize.height / cc.director._contentScaleFactor, extw = tilew - maptw, exth = tileh - mapth, winw = cc.winSize.width, winh = cc.winSize.height, rows = node._layerSize.height, cols = node._layerSize.width, grids = node._texGrids, spTiles = node._spriteTiles, wt = this._worldTransform, ox = node._position.x, oy = node._position.y, a = wt.a, b = wt.b, c = wt.c, d = wt.d, mapx = ox * a + oy * c + wt.tx, mapy = ox * b + oy * d + wt.ty;
            var wrapper = ctx || cc._renderContext, context = wrapper.getContext();
            var startCol = 0, startRow = 0, maxCol = cols, maxRow = rows;
            if (cc.macro.ENABLE_TILEDMAP_CULLING && !hasRotation && layerOrientation === Orientation.ORTHO) {
                startCol = Math.floor(-(mapx - extw * a) / (maptw * a));
                startRow = Math.floor((mapy - exth * d + mapth * rows * d - winh) / (mapth * d));
                maxCol = Math.ceil((winw - mapx + extw * a) / (maptw * a));
                maxRow = rows - Math.floor(-(mapy + exth * d) / (mapth * d));
                startCol < 0 && (startCol = 0);
                startRow < 0 && (startRow = 0);
                maxCol > cols && (maxCol = cols);
                maxRow > rows && (maxRow = rows);
            }
            var i, row, col, colOffset = startRow * cols, z, gid, grid, tex, cmd, top, left, bottom, right, dw = tilew, dh = tileh, w = tilew * a, h = tileh * d, gt, gl, gb, gr, flippedX = false, flippedY = false;
            z = colOffset + startCol;
            for (i in spTiles) {
                if (i < z && spTiles[i]) {
                    cmd = spTiles[i]._renderCmd;
                    0 === spTiles[i]._localZOrder && !!cmd.rendering && spTiles[i]._visible && cmd.rendering(ctx, scaleX, scaleY);
                } else {
                    if (i >= z) {
                        break;
                    }
                }
            }
            wrapper.setTransform(wt, scaleX, scaleY);
            wrapper.setGlobalAlpha(alpha);
            var axis, tileOffset, odd_even, diffX1, diffY1;
            if (layerOrientation === Orientation.HEX) {
                var index = node._staggerIndex, hexSideLength = node._hexSideLength;
                axis = node._staggerAxis;
                tileOffset = node.tileset.tileOffset;
                odd_even = index === StaggerIndex.STAGGERINDEX_ODD ? 1 : -1;
                diffX1 = axis === StaggerAxis.STAGGERAXIS_X ? (maptw - hexSideLength) / 2 : 0;
                diffY1 = axis === StaggerAxis.STAGGERAXIS_Y ? (mapth - hexSideLength) / 2 : 0;
            }
            for (row = startRow; row < maxRow; ++row) {
                for (col = startCol; col < maxCol; ++col) {
                    z = colOffset + col;
                    if (spTiles[z]) {
                        cmd = spTiles[z]._renderCmd;
                        if (0 === spTiles[z]._localZOrder && !!cmd.rendering && spTiles[z]._visible) {
                            cmd.rendering(ctx, scaleX, scaleY);
                            wrapper.setTransform(wt, scaleX, scaleY);
                            wrapper.setGlobalAlpha(alpha);
                        }
                        continue;
                    }
                    gid = node.tiles[z];
                    grid = grids[(gid & FLIPPED_MASK) >>> 0];
                    if (!grid) {
                        continue;
                    }
                    tex = node._textures[grid.texId];
                    if (!tex || !tex._htmlElementObj) {
                        continue;
                    }
                    switch (layerOrientation) {
                      case Orientation.ORTHO:
                        left = col * maptw;
                        bottom = -(rows - row - 1) * mapth;
                        break;

                      case Orientation.ISO:
                        left = maptw / 2 * (cols + col - row - 1);
                        bottom = -mapth / 2 * (2 * rows - col - row - 2);
                        break;

                      case Orientation.HEX:
                        var diffX2 = axis === StaggerAxis.STAGGERAXIS_Y && row % 2 === 1 ? maptw / 2 * odd_even : 0;
                        left = col * (maptw - diffX1) + diffX2 + tileOffset.x;
                        var diffY2 = axis === StaggerAxis.STAGGERAXIS_X && col % 2 === 1 ? mapth / 2 * -odd_even : 0;
                        bottom = -(rows - row - 1) * (mapth - diffY1) - diffY2 + tileOffset.y;
                    }
                    right = left + tilew;
                    top = bottom - tileh;
                    if (!hasRotation && layerOrientation === Orientation.ISO) {
                        gb = -mapy + bottom * d;
                        if (gb < -winh - h) {
                            col += Math.floor(2 * (-winh - gb) / h) - 1;
                            continue;
                        }
                        gr = mapx + right * a;
                        if (gr < -w) {
                            col += Math.floor(2 * -gr / w) - 1;
                            continue;
                        }
                        gl = mapx + left * a;
                        gt = -mapy + top * d;
                        if (gl > winw || gt > 0) {
                            col = maxCol;
                            continue;
                        }
                    }
                    if (gid > TileFlag.DIAGONAL) {
                        flippedX = (gid & TileFlag.HORIZONTAL) >>> 0;
                        flippedY = (gid & TileFlag.VERTICAL) >>> 0;
                    }
                    if (flippedX) {
                        left = -right;
                        context.scale(-1, 1);
                    }
                    if (flippedY) {
                        top = -bottom;
                        context.scale(1, -1);
                    }
                    context.drawImage(tex._htmlElementObj, grid.x, grid.y, grid.width, grid.height, left, top, dw, dh);
                    flippedX && context.scale(-1, 1);
                    flippedY && context.scale(1, -1);
                    cc.g_NumberOfDraws++;
                }
                colOffset += cols;
            }
            for (i in spTiles) {
                if (i > z && spTiles[i]) {
                    cmd = spTiles[i]._renderCmd;
                    0 === spTiles[i]._localZOrder && !!cmd.rendering && spTiles[i]._visible && cmd.rendering(ctx, scaleX, scaleY);
                }
            }
        };
    }), {} ],
    283: [ (function(require, module, exports) {
        var Orientation = null;
        var TileFlag = null;
        var FLIPPED_MASK = null;
        var StaggerAxis = null;
        var StaggerIndex = null;
        _ccsg.TMXLayer.WebGLRenderCmd = function(renderableObject) {
            this._rootCtor(renderableObject);
            this._needDraw = true;
            this._vertices = [ {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            }, {
                x: 0,
                y: 0
            } ];
            this._color = new Uint32Array(1);
            this._shaderProgram = cc.shaderCache.programForKey(cc.macro.SHADER_SPRITE_POSITION_TEXTURECOLORALPHATEST);
            var radian = 90 * Math.PI / 180;
            this._sin90 = Math.sin(radian);
            this._cos90 = Math.cos(radian);
            radian *= 3;
            this._sin270 = Math.sin(radian);
            this._cos270 = Math.cos(radian);
            if (!Orientation) {
                Orientation = cc.TiledMap.Orientation;
                TileFlag = cc.TiledMap.TileFlag;
                FLIPPED_MASK = TileFlag.FLIPPED_MASK;
                StaggerAxis = cc.TiledMap.StaggerAxis;
                StaggerIndex = cc.TiledMap.StaggerIndex;
            }
        };
        var proto = _ccsg.TMXLayer.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
        proto.constructor = _ccsg.TMXLayer.WebGLRenderCmd;
        proto.uploadData = function(f32buffer, ui32buffer, vertexDataOffset) {
            var node = this._node, hasRotation = node._rotationX || node._rotationY, layerOrientation = node.layerOrientation, tiles = node.tiles;
            if (!tiles) {
                return 0;
            }
            var maptw = node._mapTileSize.width, mapth = node._mapTileSize.height, tilew = node.tileset._tileSize.width / cc.director._contentScaleFactor, tileh = node.tileset._tileSize.height / cc.director._contentScaleFactor, extw = tilew - maptw, exth = tileh - mapth, winw = cc.winSize.width, winh = cc.winSize.height, rows = node._layerSize.height, cols = node._layerSize.width, grids = node._texGrids, spTiles = node._spriteTiles, wt = this._worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty, ox = node._position.x, oy = node._position.y, mapx = ox * a + oy * c + tx, mapy = ox * b + oy * d + ty;
            var opacity = node._opacity, cr = this._displayedColor.r, cg = this._displayedColor.g, cb = this._displayedColor.b;
            if (node._opacityModifyRGB) {
                var ca = opacity / 255;
                cr *= ca;
                cg *= ca;
                cb *= ca;
            }
            this._color[0] = opacity << 24 | cb << 16 | cg << 8 | cr;
            var startCol = 0, startRow = 0, maxCol = cols, maxRow = rows;
            if (cc.macro.ENABLE_TILEDMAP_CULLING && !hasRotation && layerOrientation === Orientation.ORTHO) {
                startCol = Math.floor(-(mapx - extw * a) / (maptw * a));
                startRow = Math.floor((mapy - exth * d + mapth * rows * d - winh) / (mapth * d));
                maxCol = Math.ceil((winw - mapx + extw * a) / (maptw * a));
                maxRow = rows - Math.floor(-(mapy + exth * d) / (mapth * d));
                startCol < 0 && (startCol = 0);
                startRow < 0 && (startRow = 0);
                maxCol > cols && (maxCol = cols);
                maxRow > rows && (maxRow = rows);
            }
            var row, col, offset = vertexDataOffset, colOffset = startRow * cols, z, gid, grid, i, top, left, bottom, right, w = tilew * a, h = tileh * d, gt, gl, gb, gr, wa = a, wb = b, wc = c, wd = d, wtx = tx, wty = ty, flagged = false, flippedX = false, flippedY = false, vertices = this._vertices, axis, tileOffset, diffX1, diffY1, odd_even;
            if (layerOrientation === Orientation.HEX) {
                var index = node._staggerIndex, hexSideLength = node._hexSideLength;
                axis = node._staggerAxis;
                tileOffset = node.tileset.tileOffset;
                odd_even = index === StaggerIndex.STAGGERINDEX_ODD ? 1 : -1;
                diffX1 = axis === StaggerAxis.STAGGERAXIS_X ? (maptw - hexSideLength) / 2 : 0;
                diffY1 = axis === StaggerAxis.STAGGERAXIS_Y ? (mapth - hexSideLength) / 2 : 0;
            }
            for (row = startRow; row < maxRow; ++row) {
                for (col = startCol; col < maxCol; ++col) {
                    if (offset + 24 > f32buffer.length) {
                        cc.renderer._increaseBatchingSize((offset - vertexDataOffset) / 6, cc.renderer.VertexType.QUAD);
                        cc.renderer._batchRendering();
                        vertexDataOffset = 0;
                        offset = 0;
                    }
                    z = colOffset + col;
                    if (spTiles[z]) {
                        continue;
                    }
                    gid = node.tiles[z];
                    grid = grids[(gid & FLIPPED_MASK) >>> 0];
                    if (!grid) {
                        continue;
                    }
                    switch (layerOrientation) {
                      case Orientation.ORTHO:
                        left = col * maptw;
                        bottom = (rows - row - 1) * mapth;
                        z = node._vertexZ + cc.renderer.assignedZStep * z / tiles.length;
                        break;

                      case Orientation.ISO:
                        left = maptw / 2 * (cols + col - row - 1);
                        bottom = mapth / 2 * (2 * rows - col - row - 2);
                        z = node._vertexZ + cc.renderer.assignedZStep * (node.height - bottom) / node.height;
                        break;

                      case Orientation.HEX:
                        var diffX2 = axis === StaggerAxis.STAGGERAXIS_Y && row % 2 === 1 ? maptw / 2 * odd_even : 0;
                        left = col * (maptw - diffX1) + diffX2 + tileOffset.x;
                        var diffY2 = axis === StaggerAxis.STAGGERAXIS_X && col % 2 === 1 ? mapth / 2 * -odd_even : 0;
                        bottom = (rows - row - 1) * (mapth - diffY1) + diffY2 - tileOffset.y;
                        z = node._vertexZ + cc.renderer.assignedZStep * (node.height - bottom) / node.height;
                    }
                    right = left + tilew;
                    top = bottom + tileh;
                    if (!hasRotation && layerOrientation === Orientation.ISO) {
                        gb = mapy + bottom * d;
                        if (gb > winh + h) {
                            col += Math.floor(2 * (gb - winh) / h) - 1;
                            continue;
                        }
                        gr = mapx + right * a;
                        if (gr < -w) {
                            col += Math.floor(2 * -gr / w) - 1;
                            continue;
                        }
                        gl = mapx + left * a;
                        gt = mapy + top * d;
                        if (gl > winw || gt < 0) {
                            col = maxCol;
                            continue;
                        }
                    }
                    if (gid > TileFlag.DIAGONAL) {
                        flagged = true;
                        flippedX = (gid & TileFlag.HORIZONTAL) >>> 0;
                        flippedY = (gid & TileFlag.VERTICAL) >>> 0;
                    }
                    vertices[0].x = left * wa + top * wc + wtx;
                    vertices[0].y = left * wb + top * wd + wty;
                    vertices[1].x = left * wa + bottom * wc + wtx;
                    vertices[1].y = left * wb + bottom * wd + wty;
                    vertices[2].x = right * wa + top * wc + wtx;
                    vertices[2].y = right * wb + top * wd + wty;
                    vertices[3].x = right * wa + bottom * wc + wtx;
                    vertices[3].y = right * wb + bottom * wd + wty;
                    for (i = 0; i < 4; ++i) {
                        f32buffer[offset] = vertices[i].x;
                        f32buffer[offset + 1] = vertices[i].y;
                        f32buffer[offset + 2] = z;
                        ui32buffer[offset + 3] = this._color[0];
                        switch (i) {
                          case 0:
                            f32buffer[offset + 4] = flippedX ? grid.r : grid.l;
                            f32buffer[offset + 5] = flippedY ? grid.b : grid.t;
                            break;

                          case 1:
                            f32buffer[offset + 4] = flippedX ? grid.r : grid.l;
                            f32buffer[offset + 5] = flippedY ? grid.t : grid.b;
                            break;

                          case 2:
                            f32buffer[offset + 4] = flippedX ? grid.l : grid.r;
                            f32buffer[offset + 5] = flippedY ? grid.b : grid.t;
                            break;

                          case 3:
                            f32buffer[offset + 4] = flippedX ? grid.l : grid.r;
                            f32buffer[offset + 5] = flippedY ? grid.t : grid.b;
                        }
                        offset += 6;
                    }
                    if (flagged) {
                        wa = a;
                        wb = b;
                        wc = c;
                        wd = d;
                        wtx = tx;
                        wty = ty;
                        flippedX = false;
                        flippedY = false;
                        flagged = false;
                    }
                }
                colOffset += cols;
            }
            return (offset - vertexDataOffset) / 6;
        };
    }), {} ],
    284: [ (function(require, module, exports) {
        function uint8ArrayToUint32Array(uint8Arr) {
            if (uint8Arr.length % 4 !== 0) {
                return null;
            }
            var arrLen = uint8Arr.length / 4;
            var retArr = window.Uint32Array ? new Uint32Array(arrLen) : [];
            for (var i = 0; i < arrLen; i++) {
                var offset = 4 * i;
                retArr[i] = uint8Arr[offset] + 256 * uint8Arr[offset + 1] + 65536 * uint8Arr[offset + 2] + uint8Arr[offset + 3] * (1 << 24);
            }
            return retArr;
        }
        cc.TMXLayerInfo = cc._Class.extend({
            ctor: function() {
                this.properties = {};
                this.name = "";
                this._layerSize = null;
                this._tiles = [];
                this.visible = true;
                this._opacity = 0;
                this.ownTiles = true;
                this._minGID = 1e5;
                this._maxGID = 0;
                this.offset = cc.p(0, 0);
            },
            getProperties: function() {
                return this.properties;
            },
            setProperties: function(value) {
                this.properties = value;
            }
        });
        cc.TMXObjectGroupInfo = cc._Class.extend({
            ctor: function() {
                this.properties = {};
                this.name = "";
                this._objects = [];
                this.visible = true;
                this._opacity = 0;
                this._color = new cc.Color(255, 255, 255, 255);
                this.offset = cc.p(0, 0);
                this._draworder = "topdown";
            },
            getProperties: function() {
                return this.properties;
            },
            setProperties: function(value) {
                this.properties = value;
            }
        });
        cc.TMXTilesetInfo = cc._Class.extend({
            ctor: function() {
                this.name = "";
                this.firstGid = 0;
                this.spacing = 0;
                this.margin = 0;
                this.sourceImage = "";
                this.imageSize = cc.size(0, 0);
                this.tileOffset = cc.p(0, 0);
                this._tileSize = cc.size(0, 0);
            },
            rectForGID: function(gid, result) {
                var rect = result || cc.rect(0, 0, 0, 0);
                rect.width = this._tileSize.width;
                rect.height = this._tileSize.height;
                gid &= cc.TiledMap.TileFlag.FLIPPED_MASK;
                gid -= parseInt(this.firstGid, 10);
                var max_x = parseInt((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing), 10);
                rect.x = parseInt(gid % max_x * (this._tileSize.width + this.spacing) + this.margin, 10);
                rect.y = parseInt(parseInt(gid / max_x, 10) * (this._tileSize.height + this.spacing) + this.margin, 10);
                return rect;
            }
        });
        cc.TMXMapInfo = cc.SAXParser.extend({
            properties: null,
            orientation: null,
            parentElement: null,
            parentGID: null,
            layerAttrs: 0,
            storingCharacters: false,
            tmxFileName: null,
            currentString: null,
            _objectGroups: null,
            _allChildren: null,
            _mapSize: null,
            _tileSize: null,
            _layers: null,
            _tilesets: null,
            _tileProperties: null,
            _resources: "",
            _staggerAxis: null,
            _staggerIndex: null,
            _hexSideLength: 0,
            ctor: function(tmxFile, resourcePath) {
                cc.SAXParser.prototype.ctor.apply(this);
                this._mapSize = cc.size(0, 0);
                this._tileSize = cc.size(0, 0);
                this._layers = [];
                this._tilesets = [];
                this._objectGroups = [];
                this._allChildren = [];
                this.properties = [];
                this._tileProperties = {};
                void 0 !== resourcePath ? this.initWithXML(tmxFile, resourcePath) : void 0 !== tmxFile && this.initWithTMXFile(tmxFile);
            },
            getOrientation: function() {
                return this.orientation;
            },
            setOrientation: function(value) {
                this.orientation = value;
            },
            getStaggerAxis: function() {
                return this._staggerAxis;
            },
            setStaggerAxis: function(value) {
                this._staggerAxis = value;
            },
            getStaggerIndex: function() {
                return this._staggerIndex;
            },
            setStaggerIndex: function(value) {
                this._staggerIndex = value;
            },
            getHexSideLength: function() {
                return this._hexSideLength;
            },
            setHexSideLength: function(value) {
                this._hexSideLength = value;
            },
            getMapSize: function() {
                return cc.size(this._mapSize.width, this._mapSize.height);
            },
            setMapSize: function(value) {
                this._mapSize.width = value.width;
                this._mapSize.height = value.height;
            },
            _getMapWidth: function() {
                return this._mapSize.width;
            },
            _setMapWidth: function(width) {
                this._mapSize.width = width;
            },
            _getMapHeight: function() {
                return this._mapSize.height;
            },
            _setMapHeight: function(height) {
                this._mapSize.height = height;
            },
            getTileSize: function() {
                return cc.size(this._tileSize.width, this._tileSize.height);
            },
            setTileSize: function(value) {
                this._tileSize.width = value.width;
                this._tileSize.height = value.height;
            },
            _getTileWidth: function() {
                return this._tileSize.width;
            },
            _setTileWidth: function(width) {
                this._tileSize.width = width;
            },
            _getTileHeight: function() {
                return this._tileSize.height;
            },
            _setTileHeight: function(height) {
                this._tileSize.height = height;
            },
            getLayers: function() {
                return this._layers;
            },
            setLayers: function(value) {
                this._allChildren.push(value);
                this._layers.push(value);
            },
            getTilesets: function() {
                return this._tilesets;
            },
            setTilesets: function(value) {
                this._tilesets.push(value);
            },
            getObjectGroups: function() {
                return this._objectGroups;
            },
            setObjectGroups: function(value) {
                this._allChildren.push(value);
                this._objectGroups.push(value);
            },
            getAllChildren: function() {
                return this._allChildren;
            },
            getParentElement: function() {
                return this.parentElement;
            },
            setParentElement: function(value) {
                this.parentElement = value;
            },
            getParentGID: function() {
                return this.parentGID;
            },
            setParentGID: function(value) {
                this.parentGID = value;
            },
            getLayerAttribs: function() {
                return this.layerAttrs;
            },
            setLayerAttribs: function(value) {
                this.layerAttrs = value;
            },
            getStoringCharacters: function() {
                return this.storingCharacters;
            },
            setStoringCharacters: function(value) {
                this.storingCharacters = value;
            },
            getProperties: function() {
                return this.properties;
            },
            setProperties: function(value) {
                this.properties = value;
            },
            initWithTMXFile: function(tmxFile) {
                this._internalInit(tmxFile, null);
                return this.parseXMLFile(tmxFile);
            },
            initWithXML: function(tmxString, resourcePath) {
                this._internalInit(null, resourcePath);
                return this.parseXMLString(tmxString);
            },
            parseXMLFile: function(tmxFile, isXmlString, tilesetFirstGid) {
                isXmlString = isXmlString || false;
                var xmlStr = isXmlString ? tmxFile : cc.loader.getRes(tmxFile);
                if (!xmlStr) {
                    throw new Error("Please load the resource first : " + tmxFile);
                }
                var mapXML = this._parseXML(xmlStr);
                var i, j;
                var map = mapXML.documentElement;
                var version = map.getAttribute("version");
                var orientationStr = map.getAttribute("orientation");
                var staggerAxisStr = map.getAttribute("staggeraxis");
                var staggerIndexStr = map.getAttribute("staggerindex");
                var hexSideLengthStr = map.getAttribute("hexsidelength");
                if ("map" === map.nodeName) {
                    "1.0" !== version && null !== version && cc.logID(7216, version);
                    "orthogonal" === orientationStr ? this.orientation = cc.TiledMap.Orientation.ORTHO : "isometric" === orientationStr ? this.orientation = cc.TiledMap.Orientation.ISO : "hexagonal" === orientationStr ? this.orientation = cc.TiledMap.Orientation.HEX : null !== orientationStr && cc.logID(7217, orientationStr);
                    "x" === staggerAxisStr ? this.setStaggerAxis(cc.TiledMap.StaggerAxis.STAGGERAXIS_X) : "y" === staggerAxisStr && this.setStaggerAxis(cc.TiledMap.StaggerAxis.STAGGERAXIS_Y);
                    "odd" === staggerIndexStr ? this.setStaggerIndex(cc.TiledMap.StaggerIndex.STAGGERINDEX_ODD) : "even" === staggerIndexStr && this.setStaggerIndex(cc.TiledMap.StaggerIndex.STAGGERINDEX_EVEN);
                    hexSideLengthStr && this.setHexSideLength(parseFloat(hexSideLengthStr));
                    var mapSize = cc.size(0, 0);
                    mapSize.width = parseFloat(map.getAttribute("width"));
                    mapSize.height = parseFloat(map.getAttribute("height"));
                    this.setMapSize(mapSize);
                    mapSize = cc.size(0, 0);
                    mapSize.width = parseFloat(map.getAttribute("tilewidth"));
                    mapSize.height = parseFloat(map.getAttribute("tileheight"));
                    this.setTileSize(mapSize);
                    var propertyArr = map.querySelectorAll("map > properties >  property");
                    if (propertyArr) {
                        var aPropertyDict = {};
                        for (i = 0; i < propertyArr.length; i++) {
                            aPropertyDict[propertyArr[i].getAttribute("name")] = propertyArr[i].getAttribute("value");
                        }
                        this.properties = aPropertyDict;
                    }
                }
                var tilesets = map.getElementsByTagName("tileset");
                if ("map" !== map.nodeName) {
                    tilesets = [];
                    tilesets.push(map);
                }
                for (i = 0; i < tilesets.length; i++) {
                    var selTileset = tilesets[i];
                    var tsxName = selTileset.getAttribute("source");
                    if (tsxName) {
                        var currentFirstGID = parseInt(selTileset.getAttribute("firstgid"));
                        var tsxPath = isXmlString ? cc.path.join(this._resources, tsxName) : cc.path.changeBasename(tmxFile, tsxName);
                        this.parseXMLFile(tsxPath, false, currentFirstGID);
                    } else {
                        var tileset = new cc.TMXTilesetInfo();
                        tileset.name = selTileset.getAttribute("name") || "";
                        tilesetFirstGid ? tileset.firstGid = tilesetFirstGid : tileset.firstGid = parseInt(selTileset.getAttribute("firstgid")) || 0;
                        tileset.spacing = parseInt(selTileset.getAttribute("spacing")) || 0;
                        tileset.margin = parseInt(selTileset.getAttribute("margin")) || 0;
                        var tilesetSize = cc.size(0, 0);
                        tilesetSize.width = parseFloat(selTileset.getAttribute("tilewidth"));
                        tilesetSize.height = parseFloat(selTileset.getAttribute("tileheight"));
                        tileset._tileSize = tilesetSize;
                        var image = selTileset.getElementsByTagName("image")[0];
                        var imagename = image.getAttribute("source");
                        var num = -1;
                        this.tmxFileName && (num = this.tmxFileName.lastIndexOf("/"));
                        if (num !== -1) {
                            var dir = this.tmxFileName.substr(0, num + 1);
                            tileset.sourceImage = dir + imagename;
                        } else {
                            tileset.sourceImage = this._resources + (this._resources ? "/" : "") + imagename;
                        }
                        this.setTilesets(tileset);
                        var offset = selTileset.getElementsByTagName("tileoffset")[0];
                        if (offset) {
                            var offsetX = parseFloat(offset.getAttribute("x"));
                            var offsetY = parseFloat(offset.getAttribute("y"));
                            tileset.tileOffset = cc.p(offsetX, offsetY);
                        }
                        var tiles = selTileset.getElementsByTagName("tile");
                        if (tiles) {
                            for (var tIdx = 0; tIdx < tiles.length; tIdx++) {
                                var t = tiles[tIdx];
                                this.parentGID = parseInt(tileset.firstGid) + parseInt(t.getAttribute("id") || 0);
                                var tp = t.querySelectorAll("properties > property");
                                if (tp) {
                                    var dict = {};
                                    for (j = 0; j < tp.length; j++) {
                                        var name = tp[j].getAttribute("name");
                                        dict[name] = tp[j].getAttribute("value");
                                    }
                                    this._tileProperties[this.parentGID] = dict;
                                }
                            }
                        }
                    }
                }
                var childNodes = map.childNodes;
                for (i = 0; i < childNodes.length; i++) {
                    var childNode = childNodes[i];
                    if (this._shouldIgnoreNode(childNode)) {
                        continue;
                    }
                    if ("layer" === childNode.nodeName) {
                        var layer = this._parseLayer(childNode);
                        this.setLayers(layer);
                    }
                    if ("objectgroup" === childNode.nodeName) {
                        var objectGroup = this._parseObjectGroup(childNode);
                        this.setObjectGroups(objectGroup);
                    }
                }
                return map;
            },
            _shouldIgnoreNode: function(node) {
                return 3 === node.nodeType || 8 === node.nodeType || 4 === node.nodeType;
            },
            _parseLayer: function(selLayer) {
                var data = selLayer.getElementsByTagName("data")[0];
                var layer = new cc.TMXLayerInfo();
                layer.name = selLayer.getAttribute("name");
                var layerSize = cc.size(0, 0);
                layerSize.width = parseFloat(selLayer.getAttribute("width"));
                layerSize.height = parseFloat(selLayer.getAttribute("height"));
                layer._layerSize = layerSize;
                var visible = selLayer.getAttribute("visible");
                layer.visible = !("0" == visible);
                var opacity = selLayer.getAttribute("opacity") || 1;
                opacity ? layer._opacity = parseInt(255 * parseFloat(opacity)) : layer._opacity = 255;
                layer.offset = cc.p(parseFloat(selLayer.getAttribute("x")) || 0, parseFloat(selLayer.getAttribute("y")) || 0);
                var nodeValue = "";
                for (j = 0; j < data.childNodes.length; j++) {
                    nodeValue += data.childNodes[j].nodeValue;
                }
                nodeValue = nodeValue.trim();
                var compression = data.getAttribute("compression");
                var encoding = data.getAttribute("encoding");
                if (compression && "gzip" !== compression && "zlib" !== compression) {
                    cc.logID(7218);
                    return null;
                }
                var tiles;
                switch (compression) {
                  case "gzip":
                    tiles = cc.Codec.unzipBase64AsArray(nodeValue, 4);
                    break;

                  case "zlib":
                    var inflator = new Zlib.Inflate(cc.Codec.Base64.decodeAsArray(nodeValue, 1));
                    tiles = uint8ArrayToUint32Array(inflator.decompress());
                    break;

                  case null:
                  case "":
                    if ("base64" === encoding) {
                        tiles = cc.Codec.Base64.decodeAsArray(nodeValue, 4);
                    } else {
                        if ("csv" === encoding) {
                            tiles = [];
                            var csvTiles = nodeValue.split(",");
                            for (var csvIdx = 0; csvIdx < csvTiles.length; csvIdx++) {
                                tiles.push(parseInt(csvTiles[csvIdx]));
                            }
                        } else {
                            var selDataTiles = data.getElementsByTagName("tile");
                            tiles = [];
                            for (var xmlIdx = 0; xmlIdx < selDataTiles.length; xmlIdx++) {
                                tiles.push(parseInt(selDataTiles[xmlIdx].getAttribute("gid")));
                            }
                        }
                    }
                    break;

                  default:
                    this.layerAttrs === cc.TMXLayerInfo.ATTRIB_NONE && cc.logID(7219);
                }
                tiles && (layer._tiles = new Uint32Array(tiles));
                var layerProps = selLayer.querySelectorAll("properties > property");
                if (layerProps) {
                    var layerProp = {};
                    for (var j = 0; j < layerProps.length; j++) {
                        layerProp[layerProps[j].getAttribute("name")] = layerProps[j].getAttribute("value");
                    }
                    layer.properties = layerProp;
                }
                return layer;
            },
            _parseObjectGroup: function(selGroup) {
                var objectGroup = new cc.TMXObjectGroupInfo();
                objectGroup.name = selGroup.getAttribute("name") || "";
                objectGroup.offset = cc.p(parseFloat(selGroup.getAttribute("offsetx")), parseFloat(selGroup.getAttribute("offsety")));
                var opacity = selGroup.getAttribute("opacity") || 1;
                opacity ? objectGroup._opacity = parseInt(255 * parseFloat(opacity)) : objectGroup._opacity = 255;
                var visible = selGroup.getAttribute("visible");
                visible && 0 === parseInt(visible) && (objectGroup.visible = false);
                var color = selGroup.getAttribute("color");
                color && (objectGroup._color = cc.hexToColor(color));
                var draworder = selGroup.getAttribute("draworder");
                draworder && (objectGroup._draworder = draworder);
                var groupProps = selGroup.querySelectorAll("objectgroup > properties > property");
                if (groupProps) {
                    var parsedProps = {};
                    for (j = 0; j < groupProps.length; j++) {
                        parsedProps[groupProps[j].getAttribute("name")] = groupProps[j].getAttribute("value");
                    }
                    objectGroup.setProperties(parsedProps);
                }
                var objects = selGroup.querySelectorAll("object");
                var getContentScaleFactor = cc.director.getContentScaleFactor();
                if (objects) {
                    for (var j = 0; j < objects.length; j++) {
                        var selObj = objects[j];
                        var objectProp = {};
                        objectProp["id"] = selObj.getAttribute("id") || 0;
                        objectProp["name"] = selObj.getAttribute("name") || "";
                        objectProp["width"] = parseFloat(selObj.getAttribute("width")) || 0;
                        objectProp["height"] = parseFloat(selObj.getAttribute("height")) || 0;
                        objectProp["x"] = (selObj.getAttribute("x") || 0) / getContentScaleFactor;
                        objectProp["y"] = (selObj.getAttribute("y") || 0) / getContentScaleFactor;
                        objectProp["rotation"] = parseFloat(selObj.getAttribute("rotation")) || 0;
                        var docObjProps = selObj.querySelectorAll("properties > property");
                        if (docObjProps) {
                            for (var k = 0; k < docObjProps.length; k++) {
                                objectProp[docObjProps[k].getAttribute("name")] = docObjProps[k].getAttribute("value");
                            }
                        }
                        var visibleAttr = selObj.getAttribute("visible");
                        objectProp["visible"] = !(visibleAttr && 0 === parseInt(visibleAttr));
                        var gid = selObj.getAttribute("gid");
                        if (gid) {
                            objectProp["gid"] = parseInt(gid);
                            objectProp["type"] = cc.TiledMap.TMXObjectType.IMAGE;
                        }
                        var ellipse = selObj.querySelectorAll("ellipse");
                        ellipse && ellipse.length > 0 && (objectProp["type"] = cc.TiledMap.TMXObjectType.ELLIPSE);
                        var polygonProps = selObj.querySelectorAll("polygon");
                        if (polygonProps && polygonProps.length > 0) {
                            objectProp["type"] = cc.TiledMap.TMXObjectType.POLYGON;
                            var selPgPointStr = polygonProps[0].getAttribute("points");
                            selPgPointStr && (objectProp["points"] = this._parsePointsString(selPgPointStr));
                        }
                        var polylineProps = selObj.querySelectorAll("polyline");
                        if (polylineProps && polylineProps.length > 0) {
                            objectProp["type"] = cc.TiledMap.TMXObjectType.POLYLINE;
                            var selPlPointStr = polylineProps[0].getAttribute("points");
                            selPlPointStr && (objectProp["polylinePoints"] = this._parsePointsString(selPlPointStr));
                        }
                        objectProp["type"] || (objectProp["type"] = cc.TiledMap.TMXObjectType.RECT);
                        objectGroup._objects.push(objectProp);
                    }
                }
                return objectGroup;
            },
            _parsePointsString: function(pointsString) {
                if (!pointsString) {
                    return null;
                }
                var points = [];
                var pointsStr = pointsString.split(" ");
                for (var i = 0; i < pointsStr.length; i++) {
                    var selPointStr = pointsStr[i].split(",");
                    points.push({
                        x: parseFloat(selPointStr[0]),
                        y: parseFloat(selPointStr[1])
                    });
                }
                return points;
            },
            parseXMLString: function(xmlString) {
                return this.parseXMLFile(xmlString, true);
            },
            getTileProperties: function() {
                return this._tileProperties;
            },
            setTileProperties: function(tileProperties) {
                this._tileProperties.push(tileProperties);
            },
            getCurrentString: function() {
                return this.currentString;
            },
            setCurrentString: function(currentString) {
                this.currentString = currentString;
            },
            getTMXFileName: function() {
                return this.tmxFileName;
            },
            setTMXFileName: function(fileName) {
                this.tmxFileName = fileName;
            },
            _internalInit: function(tmxFileName, resourcePath) {
                this._tilesets.length = 0;
                this._layers.length = 0;
                this.tmxFileName = tmxFileName;
                resourcePath && (this._resources = resourcePath);
                this._objectGroups.length = 0;
                this._allChildren.length = 0;
                this.properties.length = 0;
                this._tileProperties.length = 0;
                this.currentString = "";
                this.storingCharacters = false;
                this.layerAttrs = cc.TMXLayerInfo.ATTRIB_NONE;
                this.parentElement = cc.TiledMap.NONE;
            }
        });
        var _p = cc.TMXMapInfo.prototype;
        _p.mapWidth;
        cc.defineGetterSetter(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
        _p.mapHeight;
        cc.defineGetterSetter(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
        _p.tileWidth;
        cc.defineGetterSetter(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
        _p.tileHeight;
        cc.defineGetterSetter(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
        cc.TMXMapInfo.create = function(tmxFile, resourcePath) {
            return new cc.TMXMapInfo(tmxFile, resourcePath);
        };
        cc.TMXLayerInfo.ATTRIB_NONE = 1;
        cc.TMXLayerInfo.ATTRIB_BASE64 = 2;
        cc.TMXLayerInfo.ATTRIB_GZIP = 4;
        cc.TMXLayerInfo.ATTRIB_ZLIB = 8;
    }), {} ],
    285: [ (function(require, module, exports) {
        require("./CCSGTMXLayer.js");
        require("./CCTMXLayerCanvasRenderCmd.js");
        require("./CCTMXLayerWebGLRenderCmd.js");
        var TiledLayer = cc.Class({
            name: "cc.TiledLayer",
            extends: cc._SGComponent,
            onEnable: function() {
                this._sgNode && this._sgNode.setVisible(true);
            },
            onDisable: function() {
                this._sgNode && this._sgNode.setVisible(false);
            },
            onDestroy: function() {
                this.node._sizeProvider === this._sgNode && (this.node._sizeProvider = null);
            },
            _initSgNode: function() {
                var sgNode = this._sgNode;
                if (!sgNode) {
                    return;
                }
                this.enabledInHierarchy || sgNode.setVisible(false);
                this._registSizeProvider();
                var node = this.node;
                sgNode.setAnchorPoint(node.getAnchorPoint());
            },
            _replaceSgNode: function(sgNode) {
                if (sgNode === this._sgNode) {
                    return;
                }
                this._removeSgNode();
                this.node._sizeProvider === this._sgNode && (this.node._sizeProvider = null);
                if (sgNode && sgNode instanceof _ccsg.TMXLayer) {
                    this._sgNode = sgNode;
                    this._initSgNode();
                } else {
                    this._sgNode = null;
                }
            },
            getLayerName: function() {
                if (this._sgNode) {
                    return this._sgNode.getLayerName();
                }
                return "";
            },
            setLayerName: function(layerName) {
                this._sgNode && this._sgNode.setLayerName(layerName);
            },
            getProperty: function(propertyName) {
                if (this._sgNode) {
                    return this._sgNode.getProperty(propertyName);
                }
                return null;
            },
            getPositionAt: function(pos, y) {
                if (this._sgNode) {
                    void 0 !== y && (pos = cc.p(pos, y));
                    return this._sgNode.getPositionAt(pos);
                }
                return null;
            },
            removeTileAt: function(pos, y) {
                if (this._sgNode) {
                    void 0 !== y && (pos = cc.p(pos, y));
                    this._sgNode.removeTileAt(pos);
                }
            },
            setTileGID: function(gid, posOrX, flagsOrY, flags) {
                if (this._sgNode) {
                    if (void 0 === posOrX) {
                        throw new Error("_ccsg.TMXLayer.setTileGID(): pos should be non-null");
                    }
                    var pos;
                    if (void 0 === flags && posOrX instanceof cc.Vec2) {
                        pos = posOrX;
                        flags = flagsOrY;
                    } else {
                        pos = cc.p(posOrX, flagsOrY);
                    }
                    this._sgNode.setTileGID(gid, pos, flags);
                }
            },
            getTileGIDAt: function(pos, y) {
                if (this._sgNode) {
                    void 0 !== y && (pos = cc.p(pos, y));
                    return this._sgNode.getTileGIDAt(pos);
                }
                return 0;
            },
            getTileAt: function(pos, y) {
                if (this._sgNode) {
                    void 0 !== y && (pos = cc.p(pos, y));
                    return this._sgNode.getTileAt(pos);
                }
                return null;
            },
            releaseMap: function() {
                this._sgNode && this._sgNode.releaseMap();
            },
            setContentSize: function(size, height) {
                if (this._sgNode) {
                    void 0 !== height && (size = cc.size(size, height));
                    this._sgNode.setContentSize(size);
                }
            },
            getTexture: function() {
                if (this._sgNode) {
                    return this._sgNode.getTexture();
                }
                return null;
            },
            setTexture: function(texture) {
                this._sgNode && this._sgNode.setTexture(texture);
            },
            setTileOpacity: function(opacity) {
                this._sgNode && (this._sgNode._opacity = opacity);
            },
            getLayerSize: function() {
                if (this._sgNode) {
                    return this._sgNode.getLayerSize();
                }
                return cc.size(0, 0);
            },
            setLayerSize: function(layerSize) {
                this._sgNode && this._sgNode.setLayerSize(layerSize);
            },
            getMapTileSize: function() {
                if (this._sgNode) {
                    return this._sgNode.getMapTileSize();
                }
                return cc.size(0, 0);
            },
            setMapTileSize: function(tileSize) {
                this._sgNode && this._sgNode.setMapTileSize(tileSize);
            },
            getTiles: function() {
                if (this._sgNode) {
                    return this._sgNode.getTiles();
                }
                return null;
            },
            setTiles: function(tiles) {
                this._sgNode && this._sgNode.setTiles(tiles);
            },
            getTileSet: function() {
                if (this._sgNode) {
                    return this._sgNode.getTileSet();
                }
                return null;
            },
            setTileSet: function(tileset) {
                this._sgNode && this._sgNode.setTileSet(tileset);
            },
            getLayerOrientation: function() {
                if (this._sgNode) {
                    return this._sgNode.getLayerOrientation();
                }
                return 0;
            },
            setLayerOrientation: function(orientation) {
                this._sgNode && this._sgNode.setLayerOrientation(orientation);
            },
            getProperties: function() {
                if (this._sgNode) {
                    return this._sgNode.getProperties();
                }
                return null;
            },
            setProperties: function(properties) {
                this._sgNode && this._sgNode.setProperties(properties);
            },
            _tryRemoveNode: function() {
                this.node.removeComponent(cc.TiledLayer);
                1 === this.node._components.length && 0 === this.node.getChildren().length && this.node.removeFromParent();
            }
        });
        cc.TiledLayer = module.exports = TiledLayer;
    }), {
        "./CCSGTMXLayer.js": 278,
        "./CCTMXLayerCanvasRenderCmd.js": 282,
        "./CCTMXLayerWebGLRenderCmd.js": 283
    } ],
    286: [ (function(require, module, exports) {
        require("./CCSGTMXTiledMap.js");
        var Orientation = cc.Enum({
            ORTHO: 0,
            HEX: 1,
            ISO: 2
        });
        var Property = cc.Enum({
            NONE: 0,
            MAP: 1,
            LAYER: 2,
            OBJECTGROUP: 3,
            OBJECT: 4,
            TILE: 5
        });
        var TileFlag = cc.Enum({
            HORIZONTAL: 2147483648,
            VERTICAL: 1073741824,
            DIAGONAL: 536870912,
            FLIPPED_ALL: 3758096384,
            FLIPPED_MASK: 536870911
        });
        var StaggerAxis = cc.Enum({
            STAGGERAXIS_X: 0,
            STAGGERAXIS_Y: 1
        });
        var StaggerIndex = cc.Enum({
            STAGGERINDEX_ODD: 0,
            STAGGERINDEX_EVEN: 1
        });
        var TMXObjectType = cc.Enum({
            RECT: 0,
            ELLIPSE: 1,
            POLYGON: 2,
            POLYLINE: 3,
            IMAGE: 4
        });
        var TiledMap = cc.Class({
            name: "cc.TiledMap",
            extends: cc._RendererInSG,
            editor: false,
            statics: {
                Orientation: Orientation,
                Property: Property,
                TileFlag: TileFlag,
                StaggerAxis: StaggerAxis,
                StaggerIndex: StaggerIndex,
                TMXObjectType: TMXObjectType
            },
            properties: {
                _detachedChildren: {
                    default: [],
                    serializable: false
                },
                _tmxFile: {
                    default: null,
                    type: cc.TiledMapAsset
                },
                tmxAsset: {
                    get: function() {
                        return this._tmxFile;
                    },
                    set: function(value, force) {
                        if (this._tmxFile !== value || false) {
                            this._tmxFile = value;
                            this._applyFile();
                        }
                    },
                    type: cc.TiledMapAsset
                }
            },
            getMapSize: function() {
                return this._sgNode.getMapSize();
            },
            setMapSize: function(mapSize) {
                this._sgNode.setMapSize(mapSize);
            },
            getTileSize: function() {
                return this._sgNode.getTileSize();
            },
            setTileSize: function(tileSize) {
                this._sgNode.setTileSize(tileSize);
            },
            getMapOrientation: function() {
                return this._sgNode.getMapOrientation();
            },
            setMapOrientation: function(orientation) {
                this._sgNode.setMapOrientation(orientation);
            },
            getObjectGroups: function() {
                var logicChildren = this.node.children;
                var ret = [];
                for (var i = 0, n = logicChildren.length; i < n; i++) {
                    var child = logicChildren[i];
                    var tmxGroup = child.getComponent(cc.TiledObjectGroup);
                    tmxGroup && ret.push(tmxGroup);
                }
                return ret;
            },
            getProperties: function() {
                return this._sgNode.getProperties();
            },
            setProperties: function(properties) {
                this._sgNode.setProperties(properties);
            },
            initWithTMXFile: function(tmxFile) {
                cc.errorID(7200);
            },
            initWithXML: function(tmxString, resourcePath) {
                cc.errorID(7201);
            },
            allLayers: function() {
                var logicChildren = this.node.children;
                var ret = [];
                for (var i = 0, n = logicChildren.length; i < n; i++) {
                    var child = logicChildren[i];
                    var tmxLayer = child.getComponent(cc.TiledLayer);
                    tmxLayer && ret.push(tmxLayer);
                }
                return ret;
            },
            getLayer: function(layerName) {
                var logicChildren = this.node.children;
                for (var i = 0, n = logicChildren.length; i < n; i++) {
                    var child = logicChildren[i];
                    var tmxLayer = child.getComponent(cc.TiledLayer);
                    if (tmxLayer && tmxLayer.getLayerName() === layerName) {
                        return tmxLayer;
                    }
                }
                return null;
            },
            getObjectGroup: function(groupName) {
                var logicChildren = this.node.children;
                for (var i = 0, n = logicChildren.length; i < n; i++) {
                    var child = logicChildren[i];
                    var tmxGroup = child.getComponent(cc.TiledObjectGroup);
                    if (tmxGroup && tmxGroup.getGroupName() === groupName) {
                        return tmxGroup;
                    }
                }
                return null;
            },
            getProperty: function(propertyName) {
                return this._sgNode.getProperty(propertyName);
            },
            getPropertiesForGID: function(GID) {
                return this._sgNode.getPropertiesForGID(GID);
            },
            onEnable: function() {
                0 === this._detachedChildren.length && this._moveLayersInSgNode(this._sgNode);
                this._super();
                this._tmxFile && this._refreshLayerEntities();
                this.node.on("anchor-changed", this._anchorChanged, this);
                this.node.on("child-added", this._childAdded, this);
                this.node.on("child-reorder", this._syncChildrenOrder, this);
            },
            onDisable: function() {
                this._super();
                this._setLayersEnabled(false);
                var restoredSgNode = this._plainNode;
                this._moveLayersInSgNode(restoredSgNode);
                this.node.off("anchor-changed", this._anchorChanged, this);
                this.node.off("child-added", this._childAdded, this);
                this.node.off("child-reorder", this._syncChildrenOrder, this);
            },
            onDestroy: function() {
                this._super();
                this._removeLayerEntities();
            },
            _createSgNode: function() {
                return new _ccsg.TMXTiledMap();
            },
            _initSgNode: function() {
                this._applyFile();
            },
            _resetSgSize: function() {
                this.node.setContentSize(this._sgNode.getContentSize());
                this._sgNode.setContentSize(0, 0);
            },
            _onMapLoaded: function() {
                this._refreshLayerEntities();
                this._enabled ? this._anchorChanged() : this._moveLayersInSgNode(this._sgNode);
                this._setLayersEnabled(this._enabled);
                this._resetSgSize();
            },
            _setLayersEnabled: function(enabled) {
                var logicChildren = this.node.getChildren();
                for (var i = logicChildren.length - 1; i >= 0; i--) {
                    var child = logicChildren[i];
                    var tmxLayer = child.getComponent(cc.TiledLayer);
                    tmxLayer && (tmxLayer.enabled = enabled);
                }
            },
            _moveLayersInSgNode: function(sgNode) {
                this._detachedChildren.length = 0;
                var children = sgNode.getChildren();
                for (var i = children.length - 1; i >= 0; i--) {
                    var child = children[i];
                    if (child instanceof _ccsg.TMXLayer || child instanceof _ccsg.TMXObjectGroup) {
                        sgNode.removeChild(child);
                        var order = child.getLocalZOrder();
                        this._detachedChildren.push({
                            sgNode: child,
                            zorder: order
                        });
                    }
                }
            },
            _removeLayerEntities: function() {
                var logicChildren = this.node.getChildren();
                for (var i = logicChildren.length - 1; i >= 0; i--) {
                    var child = logicChildren[i];
                    if (!child.isValid) {
                        continue;
                    }
                    var tmxLayer = child.getComponent(cc.TiledLayer);
                    tmxLayer && tmxLayer._tryRemoveNode();
                    var tmxGroup = child.getComponent(cc.TiledObjectGroup);
                    tmxGroup && tmxGroup._tryRemoveNode();
                }
            },
            _refreshLayerEntities: function() {
                var logicChildren = this.node.getChildren();
                var existedLayers = [];
                var existedGroups = [];
                var otherChildrenInfo = [];
                var i, n;
                for (i = 0; i < this._detachedChildren.length; i++) {
                    var info = this._detachedChildren[i];
                    this._sgNode.addChild(info.sgNode, info.zorder, info.zorder);
                }
                this._detachedChildren.length = 0;
                var layerNames = this._sgNode.allLayers().map((function(layer) {
                    return layer.getLayerName();
                }));
                var groupNames = this._sgNode.getObjectGroups().map((function(group) {
                    return group.getGroupName();
                }));
                for (i = logicChildren.length - 1; i >= 0; i--) {
                    var child = logicChildren[i];
                    var tmxLayer = child.getComponent(cc.TiledLayer);
                    var tmxGroup = child.getComponent(cc.TiledObjectGroup);
                    if (tmxLayer) {
                        var layerName = tmxLayer.getLayerName();
                        layerName || (layerName = child._name);
                        if (layerNames.indexOf(layerName) < 0) {
                            tmxLayer._tryRemoveNode();
                        } else {
                            existedLayers.push(child);
                            var newSGLayer = this._sgNode.getLayer(layerName);
                            tmxLayer._replaceSgNode(newSGLayer);
                            tmxLayer.enabled = true;
                        }
                    } else {
                        if (tmxGroup) {
                            var groupName = tmxGroup.getGroupName();
                            groupName || (groupName = child._name);
                            if (groupNames.indexOf(groupName) < 0) {
                                tmxGroup._tryRemoveNode();
                            } else {
                                existedGroups.push(child);
                                var newSGGroup = this._sgNode.getObjectGroup(groupName);
                                tmxGroup._replaceSgNode(newSGGroup);
                                tmxGroup.enabled = newSGGroup.isVisible();
                            }
                        } else {
                            otherChildrenInfo.push({
                                child: child,
                                index: child.getSiblingIndex()
                            });
                        }
                    }
                }
                var existedNames = existedLayers.map((function(node) {
                    var tmxLayer = node.getComponent(cc.TiledLayer);
                    return tmxLayer.getLayerName();
                }));
                for (i = 0, n = layerNames.length; i < n; i++) {
                    var name = layerNames[i];
                    var sgLayer = this._sgNode.getLayer(name);
                    var theIndex = existedNames.indexOf(name);
                    if (theIndex < 0) {
                        var node = this.node.getChildByName(name);
                        var addedLayer = null;
                        if (node && !node.getComponent(cc._SGComponent)) {
                            addedLayer = node.addComponent(cc.TiledLayer);
                        } else {
                            node = new cc.Node(name);
                            this.node.addChild(node);
                            addedLayer = node.addComponent(cc.TiledLayer);
                        }
                        node && addedLayer || cc.errorID(7202);
                        addedLayer._replaceSgNode(sgLayer);
                        node.setSiblingIndex(sgLayer.getLocalZOrder());
                        node.setAnchorPoint(this.node.getAnchorPoint());
                    }
                }
                var existedGroupNames = existedGroups.map((function(node) {
                    var tmxGroup = node.getComponent(cc.TiledObjectGroup);
                    return tmxGroup.getGroupName();
                }));
                for (i = 0, n = groupNames.length; i < n; i++) {
                    name = groupNames[i];
                    var sgGroup = this._sgNode.getObjectGroup(name);
                    theIndex = existedGroupNames.indexOf(name);
                    if (theIndex < 0) {
                        node = this.node.getChildByName(name);
                        var addedGroup = null;
                        if (node && !node.getComponent(cc._SGComponent)) {
                            addedGroup = node.addComponent(cc.TiledObjectGroup);
                        } else {
                            node = new cc.Node(name);
                            this.node.addChild(node);
                            addedGroup = node.addComponent(cc.TiledObjectGroup);
                        }
                        node && addedGroup || cc.errorID(7202);
                        addedGroup._replaceSgNode(sgGroup);
                        node.setSiblingIndex(sgGroup.getLocalZOrder());
                        node.setAnchorPoint(this.node.getAnchorPoint());
                        addedGroup.enabled = sgGroup.isVisible();
                    }
                }
                var curChildren = this.node.getChildren();
                var curLayerNames = [];
                for (i = 0, n = curChildren.length; i < n; i++) {
                    child = curChildren[i];
                    tmxLayer = child.getComponent(cc.TiledLayer);
                    tmxGroup = child.getComponent(cc.TiledObjectGroup);
                    (tmxLayer || tmxGroup) && curLayerNames.push(child._name);
                }
                var sgLayerNames = [];
                var sgLayers = [];
                var sgChildren = this._sgNode.getChildren();
                for (i = 0, n = sgChildren.length; i < n; i++) {
                    child = sgChildren[i];
                    if (child instanceof _ccsg.TMXLayer) {
                        sgLayerNames.push(child.getLayerName());
                        sgLayers.push(child);
                    } else {
                        if (child instanceof _ccsg.TMXObjectGroup) {
                            sgLayerNames.push(child.getGroupName());
                            sgLayers.push(child);
                        }
                    }
                }
                for (i = sgLayerNames.length - 1; i >= 0; i--) {
                    var curName = sgLayerNames[i];
                    var nodeIdx = curLayerNames.indexOf(curName);
                    if (i !== nodeIdx) {
                        var curNode = this.node.getChildByName(curName);
                        curNode.setSiblingIndex(sgLayers[i].getLocalZOrder());
                    }
                }
                for (i = 0, n = otherChildrenInfo.length; i < n; i++) {
                    info = otherChildrenInfo[i];
                    info.child.setSiblingIndex(info.index);
                }
                this._syncChildrenOrder();
            },
            _anchorChanged: function() {
                var children = this.node.children;
                var anchor = this.node.getAnchorPoint();
                for (var i = 0, n = children.length; i < n; i++) {
                    var child = children[i];
                    var hasLayer = child.getComponent(cc.TiledLayer);
                    hasLayer && child.setAnchorPoint(anchor);
                }
            },
            _childAdded: function(event) {
                var node = event.detail;
                if (node) {
                    var tmxLayer = node.getComponent(cc.TiledLayer);
                    var tmxGroup = node.getComponent(cc.TiledObjectGroup);
                    if (!tmxLayer && !tmxGroup) {
                        var childrenCount = this.node.getChildrenCount();
                        node.setSiblingIndex(childrenCount);
                        node._sgNode && node._sgNode.setLocalZOrder(childrenCount);
                    }
                }
            },
            _syncChildrenOrder: function() {
                var logicChildren = this.node.children;
                for (var i = 0, n = logicChildren.length; i < n; i++) {
                    var child = logicChildren[i];
                    var tmxLayer = child.getComponent(cc.TiledLayer);
                    var tmxGroup = child.getComponent(cc.TiledObjectGroup);
                    var zOrderValue = child.getSiblingIndex();
                    tmxLayer && tmxLayer._sgNode && tmxLayer._sgNode.setLocalZOrder(zOrderValue);
                    tmxGroup && tmxGroup._sgNode && tmxGroup._sgNode.setLocalZOrder(zOrderValue);
                    child._sgNode && child._sgNode.setLocalZOrder(zOrderValue);
                }
            },
            _applyFile: function() {
                var sgNode = this._sgNode;
                var file = this._tmxFile;
                var self = this;
                if (file) {
                    var resPath = cc.url._rawAssets + file.tmxFolderPath;
                    resPath = cc.path._setEndWithSep(resPath, false);
                    var ret = sgNode.initWithXML(file.tmxXmlStr, resPath);
                    if (ret) {
                        self._detachedChildren.length = 0;
                        self._onMapLoaded();
                    }
                } else {
                    var layers = sgNode.allLayers();
                    for (var i = 0, n = layers.length; i < n; i++) {
                        sgNode.removeChild(layers[i]);
                    }
                    var groups = sgNode.getObjectGroups();
                    for (i = 0, n = groups.length; i < n; i++) {
                        sgNode.removeChild(groups[i]);
                    }
                    this._detachedChildren.length = 0;
                    self._removeLayerEntities();
                }
            }
        });
        cc.TiledMap = module.exports = TiledMap;
        cc.js.obsolete(cc.TiledMap.prototype, "cc.TiledMap.tmxFile", "tmxAsset", true);
        cc.js.get(cc.TiledMap.prototype, "mapLoaded", (function() {
            cc.errorID(7203);
            return [];
        }), false);
    }), {
        "./CCSGTMXTiledMap.js": 281
    } ],
    287: [ (function(require, module, exports) {
        var TiledMapAsset = cc.Class({
            name: "cc.TiledMapAsset",
            extends: cc.Asset,
            properties: {
                tmxXmlStr: {
                    default: ""
                },
                tmxFolderPath: {
                    default: ""
                },
                textures: {
                    default: [],
                    url: [ cc.Texture2D ]
                },
                tsxFiles: {
                    default: [],
                    url: [ cc.RawAsset ]
                }
            },
            statics: {
                preventDeferredLoadDependents: true
            },
            createNode: false
        });
        cc.TiledMapAsset = TiledMapAsset;
        module.exports = TiledMapAsset;
    }), {} ],
    288: [ (function(require, module, exports) {
        require("./CCSGTMXObjectGroup.js");
        var TiledObjectGroup = cc.Class({
            name: "cc.TiledObjectGroup",
            extends: cc._SGComponent,
            onEnable: function() {
                this._sgNode && this._sgNode.setVisible(true);
            },
            onDisable: function() {
                this._sgNode && this._sgNode.setVisible(false);
            },
            onDestroy: function() {
                this.node._sizeProvider === this._sgNode && (this.node._sizeProvider = null);
            },
            _initSgNode: function() {
                var sgNode = this._sgNode;
                if (!sgNode) {
                    return;
                }
                this._registSizeProvider();
                sgNode.setAnchorPoint(this.node.getAnchorPoint());
            },
            _replaceSgNode: function(sgNode) {
                if (sgNode === this._sgNode) {
                    return;
                }
                this._removeSgNode();
                this.node._sizeProvider === this._sgNode && (this.node._sizeProvider = null);
                if (sgNode && sgNode instanceof _ccsg.TMXObjectGroup) {
                    this._sgNode = sgNode;
                    this._initSgNode();
                } else {
                    this._sgNode = null;
                }
            },
            getPositionOffset: function() {
                if (this._sgNode) {
                    return this._sgNode.getPositionOffset();
                }
                return cc.p(0, 0);
            },
            setPositionOffset: function(offset) {
                this._sgNode && this._sgNode.setPositionOffset(offset);
            },
            getProperties: function() {
                if (this._sgNode) {
                    return this._sgNode.getProperties();
                }
                return null;
            },
            setProperties: function(Var) {
                this._sgNode && this._sgNode.setProperties(Var);
            },
            getGroupName: function() {
                if (this._sgNode) {
                    return this._sgNode.getGroupName();
                }
                return "";
            },
            setGroupName: function(groupName) {
                this._sgNode && this._sgNode.setGroupName(groupName);
            },
            getProperty: function(propertyName) {
                if (this._sgNode) {
                    return this._sgNode.propertyNamed(propertyName);
                }
                return null;
            },
            getObject: function(objectName) {
                if (this._sgNode) {
                    return this._sgNode.getObject(objectName);
                }
                return null;
            },
            getObjects: function() {
                if (this._sgNode) {
                    return this._sgNode.getObjects();
                }
                return [];
            },
            _tryRemoveNode: function() {
                this.node.removeComponent(cc.TiledObjectGroup);
                1 === this.node._components.length && 0 === this.node.getChildren().length && this.node.removeFromParent();
            }
        });
        cc.TiledObjectGroup = module.exports = TiledObjectGroup;
    }), {
        "./CCSGTMXObjectGroup.js": 280
    } ],
    289: [ (function(require, module, exports) {
        require("./cocos2d/core");
        require("./cocos2d/animation");
        require("./cocos2d/particle/CCParticleAsset");
        require("./cocos2d/particle/CCParticleSystem");
        require("./cocos2d/motion-streak/CCMotionStreak");
        require("./cocos2d/tilemap/CCTiledMapAsset");
        if (!cc.runtime) {
            require("./cocos2d/tilemap/CCTiledMap");
            require("./cocos2d/tilemap/CCTiledLayer");
            require("./cocos2d/tilemap/CCTiledObjectGroup");
        }
        require("./cocos2d/core/components/CCStudioComponent");
        require("./extensions/spine");
        cc.runtime || require("./extensions/dragonbones");
        require("./extensions/ccpool/CCNodePool");
        require("./extensions/ccpool/CCPool");
        require("./cocos2d/actions");
        require("./external/chipmunk/chipmunk");
        require("./cocos2d/deprecated");
    }), {
        "./cocos2d/actions": 10,
        "./cocos2d/animation": 19,
        "./cocos2d/core": 124,
        "./cocos2d/core/components/CCStudioComponent": 95,
        "./cocos2d/deprecated": 239,
        "./cocos2d/motion-streak/CCMotionStreak": 254,
        "./cocos2d/particle/CCParticleAsset": 258,
        "./cocos2d/particle/CCParticleSystem": 262,
        "./cocos2d/tilemap/CCTiledLayer": 285,
        "./cocos2d/tilemap/CCTiledMap": 286,
        "./cocos2d/tilemap/CCTiledMapAsset": 287,
        "./cocos2d/tilemap/CCTiledObjectGroup": 288,
        "./extensions/ccpool/CCNodePool": 290,
        "./extensions/ccpool/CCPool": 291,
        "./extensions/dragonbones": 299,
        "./extensions/spine": 308,
        "./external/chipmunk/chipmunk": 311
    } ],
    290: [ (function(require, module, exports) {
        cc.NodePool = function(poolHandlerComp) {
            this.poolHandlerComp = poolHandlerComp;
            this._pool = [];
        };
        cc.NodePool.prototype = {
            constructor: cc.NodePool,
            size: function() {
                return this._pool.length;
            },
            clear: function() {
                var count = this._pool.length;
                for (var i = 0; i < count; ++i) {
                    this._pool[i].destroy();
                }
                this._pool.length = 0;
            },
            put: function(obj) {
                if (obj && this._pool.indexOf(obj) === -1) {
                    obj.removeFromParent(false);
                    var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
                    handler && handler.unuse && handler.unuse();
                    this._pool.push(obj);
                }
            },
            get: function() {
                var last = this._pool.length - 1;
                if (last < 0) {
                    return null;
                }
                var obj = this._pool[last];
                this._pool.length = last;
                var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
                handler && handler.reuse && handler.reuse.apply(handler, arguments);
                return obj;
            }
        };
        module.exports = cc.NodePool;
    }), {} ],
    291: [ (function(require, module, exports) {
        var _args = [];
        cc.pool = {
            _pool: {},
            _releaseCB: function() {
                this.release();
            },
            _autoRelease: function(obj) {
                var running = void 0 !== obj._running && !obj._running;
                cc.director.getScheduler().schedule(this._releaseCB, obj, 0, 0, 0, running);
            },
            putInPool: function(obj) {
                var cid = cc.js._getClassId(obj.constructor);
                if (!cid) {
                    return;
                }
                this._pool[cid] || (this._pool[cid] = []);
                false;
                obj.unuse && obj.unuse();
                this._pool[cid].push(obj);
            },
            hasObject: function(objClass) {
                var cid = cc.js._getClassId(objClass);
                var list = this._pool[cid];
                if (!list || 0 === list.length) {
                    return false;
                }
                return true;
            },
            removeObject: function(obj) {
                var cid = cc.js._getClassId(obj.constructor);
                if (cid) {
                    var list = this._pool[cid];
                    if (list) {
                        for (var i = 0; i < list.length; i++) {
                            if (obj === list[i]) {
                                false;
                                list.splice(i, 1);
                            }
                        }
                    }
                }
            },
            getFromPool: function(objClass) {
                if (this.hasObject(objClass)) {
                    var cid = cc.js._getClassId(objClass);
                    var list = this._pool[cid];
                    _args.length = arguments.length - 1;
                    for (var i = 0; i < _args.length; i++) {
                        _args[i] = arguments[i + 1];
                    }
                    var obj = list.pop();
                    obj.reuse && obj.reuse.apply(obj, _args);
                    false;
                    _args.length = 0;
                    return obj;
                }
            },
            drainAllPools: function() {
                var i;
                var j;
                var obj;
                this._pool = {};
            }
        };
    }), {} ],
    292: [ (function(require, module, exports) {
        var DefaultArmaturesEnum = cc.Enum({
            default: -1
        });
        var DefaultAnimsEnum = cc.Enum({
            "<None>": 0
        });
        function setEnumAttr(obj, propName, enumDef) {
            cc.Class.attr(obj, propName, {
                type: "Enum",
                enumList: cc.Enum.getList(enumDef)
            });
        }
        dragonBones.ArmatureDisplay = cc.Class({
            name: "dragonBones.ArmatureDisplay",
            extends: cc._RendererUnderSG,
            editor: false,
            properties: {
                _factory: {
                    default: null,
                    type: dragonBones.CCFactory,
                    serializable: false
                },
                _dragonBonesData: {
                    default: null,
                    type: dragonBones.DragonBonesData,
                    serializable: false
                },
                dragonAsset: {
                    default: null,
                    type: dragonBones.DragonBonesAsset,
                    notify: function() {
                        this._parseDragonAsset();
                        this._refresh();
                    },
                    tooltip: "i18n:COMPONENT.dragon_bones.dragon_bones_asset"
                },
                dragonAtlasAsset: {
                    default: null,
                    type: dragonBones.DragonBonesAtlasAsset,
                    notify: function() {
                        this._parseDragonAtlasAsset();
                        this._refreshSgNode();
                    },
                    tooltip: "i18n:COMPONENT.dragon_bones.dragon_bones_atlas_asset"
                },
                _armatureName: "",
                armatureName: {
                    get: function() {
                        return this._armatureName;
                    },
                    set: function(value) {
                        this._armatureName = value;
                        var animNames = this.getAnimationNames(this._armatureName);
                        (!this.animationName || animNames.indexOf(this.animationName) < 0) && (this.animationName = "");
                        this._refresh();
                    },
                    visible: false
                },
                _animationName: "",
                animationName: {
                    get: function() {
                        return this._animationName;
                    },
                    set: function(value) {
                        this._animationName = value;
                    },
                    visible: false
                },
                _defaultArmatureIndex: {
                    default: 0,
                    notify: function() {
                        var armatureName = "";
                        if (this.dragonAsset) {
                            var armaturesEnum;
                            this.dragonAsset && (armaturesEnum = this.dragonAsset.getArmatureEnum());
                            if (!armaturesEnum) {
                                return cc.errorID(7400, this.name);
                            }
                            armatureName = armaturesEnum[this._defaultArmatureIndex];
                        }
                        void 0 !== armatureName ? this.armatureName = armatureName : cc.errorID(7401, this.name);
                    },
                    type: DefaultArmaturesEnum,
                    visible: true,
                    editorOnly: true,
                    displayName: "Armature",
                    tooltip: "i18n:COMPONENT.dragon_bones.armature_name"
                },
                _animationIndex: {
                    default: 0,
                    notify: function() {
                        if (0 === this._animationIndex) {
                            this.animationName = "";
                            return;
                        }
                        var animsEnum;
                        this.dragonAsset && (animsEnum = this.dragonAsset.getAnimsEnum(this.armatureName));
                        if (!animsEnum) {
                            return;
                        }
                        var animName = animsEnum[this._animationIndex];
                        void 0 !== animName ? this.animationName = animName : cc.errorID(7402, this.name);
                    },
                    type: DefaultAnimsEnum,
                    visible: true,
                    editorOnly: true,
                    displayName: "Animation",
                    tooltip: "i18n:COMPONENT.dragon_bones.animation_name"
                },
                timeScale: {
                    default: 1,
                    notify: function() {
                        this._sgNode && (this._sgNode.animation().timeScale = this.timeScale);
                    },
                    tooltip: "i18n:COMPONENT.dragon_bones.time_scale"
                },
                playTimes: {
                    default: -1,
                    tooltip: "i18n:COMPONENT.dragon_bones.play_times"
                },
                debugBones: {
                    default: false,
                    notify: function() {
                        this._sgNode && this._sgNode.setDebugBones(this.debugBones);
                    },
                    editorOnly: true,
                    tooltip: "i18n:COMPONENT.dragon_bones.debug_bones"
                }
            },
            ctor: function() {
                this._factory = dragonBones.CCFactory.getFactory();
            },
            __preload: function() {
                this._parseDragonAsset();
                this._parseDragonAtlasAsset();
                this._refresh();
            },
            _createSgNode: function() {
                if (this.dragonAsset && this.dragonAtlasAsset && this.armatureName) {
                    return this._factory.buildArmatureDisplay(this.armatureName, this._dragonBonesData.name);
                }
                return null;
            },
            _initSgNode: function() {
                var sgNode = this._sgNode;
                sgNode.animation().timeScale = this.timeScale;
                this.animationName && this.playAnimation(this.animationName, this.playTimes);
            },
            _parseDragonAsset: function() {
                if (this.dragonAsset) {
                    var jsonObj = JSON.parse(this.dragonAsset.dragonBonesJson);
                    var data = this._factory.getDragonBonesData(jsonObj.name);
                    if (data) {
                        this._dragonBonesData = data;
                        return;
                    }
                    this._dragonBonesData = this._factory.parseDragonBonesData(jsonObj);
                }
            },
            _parseDragonAtlasAsset: function() {
                if (this.dragonAtlasAsset) {
                    var atlasJsonObj = JSON.parse(this.dragonAtlasAsset.atlasJson);
                    var atlasName = atlasJsonObj.name;
                    var existedAtlasData = null;
                    var atlasDataList = this._factory.getTextureAtlasData(atlasName);
                    var texturePath = this.dragonAtlasAsset.texture;
                    if (atlasDataList && atlasDataList.length > 0) {
                        for (var idx in atlasDataList) {
                            var data = atlasDataList[idx];
                            if (data && data.texture && data.texture.url === texturePath) {
                                existedAtlasData = data;
                                break;
                            }
                        }
                    }
                    var texture = cc.textureCache.getTextureForKey(texturePath);
                    existedAtlasData ? existedAtlasData.texture = texture : this._factory.parseTextureAtlasData(atlasJsonObj, texture);
                }
            },
            _refreshSgNode: function() {
                var self = this;
                var listenersBefore = null;
                if (self._sgNode) {
                    listenersBefore = self._sgNode._bubblingListeners;
                    self.node._sizeProvider === self._sgNode && (self.node._sizeProvider = null);
                    self._removeSgNode();
                    self._sgNode = null;
                }
                var sgNode = self._sgNode = self._createSgNode();
                if (sgNode) {
                    self.enabledInHierarchy || sgNode.setVisible(false);
                    listenersBefore && (sgNode._bubblingListeners = listenersBefore);
                    self._initSgNode();
                    self._appendSgNode(sgNode);
                    self._registSizeProvider();
                }
            },
            _refresh: function() {
                this._refreshSgNode();
            },
            _updateAnimEnum: false,
            _updateArmatureEnum: false,
            playAnimation: function(animName, playTimes) {
                if (this._sgNode) {
                    this.playTimes = void 0 === playTimes ? -1 : playTimes;
                    this.animationName = animName;
                    return this._sgNode.animation().play(animName, this.playTimes);
                }
                return null;
            },
            getArmatureNames: function() {
                if (this._dragonBonesData) {
                    return this._dragonBonesData.armatureNames;
                }
                return [];
            },
            getAnimationNames: function(armatureName) {
                var ret = [];
                if (this._dragonBonesData) {
                    var armatureData = this._dragonBonesData.getArmature(armatureName);
                    if (armatureData) {
                        for (var animName in armatureData.animations) {
                            armatureData.animations.hasOwnProperty(animName) && ret.push(animName);
                        }
                    }
                }
                return ret;
            },
            addEventListener: function(eventType, listener, target) {
                this._sgNode && this._sgNode.addEvent(eventType, listener, target);
            },
            removeEventListener: function(eventType, listener, target) {
                this._sgNode && this._sgNode.removeEvent(eventType, listener, target);
            },
            buildArmature: function(armatureName) {
                if (this._factory) {
                    return this._factory.buildArmature(armatureName);
                }
                return null;
            },
            armature: function() {
                if (this._sgNode) {
                    return this._sgNode.armature();
                }
                return null;
            }
        });
    }), {} ],
    293: [ (function(require, module, exports) {
        var EventTarget = require("../../cocos2d/core/event/event-target");
        dragonBones.CCArmatureDisplay = cc.Class({
            name: "dragonBones.CCArmatureDisplay",
            extends: _ccsg.Node,
            mixins: [ EventTarget ],
            _armature: null,
            _debugDrawer: null,
            _onClear: function() {
                this._armature = null;
            },
            _dispatchEvent: function(eventObject) {
                this.emit(eventObject.type, eventObject);
            },
            _debugDraw: function() {
                if (!this._armature) {
                    return;
                }
                if (!this._debugDrawer) {
                    this._debugDrawer = new cc.DrawNode();
                    this.addChild(this._debugDrawer);
                    this._debugDrawer.setDrawColor(cc.color(255, 0, 0, 255));
                    this._debugDrawer.setLineWidth(1);
                }
                this._debugDrawer.clear();
                var bones = this._armature.getBones();
                for (var i = 0, l = bones.length; i < l; ++i) {
                    var bone = bones[i];
                    var boneLength = Math.max(bone.length, 5);
                    var startX = bone.globalTransformMatrix.tx;
                    var startY = -bone.globalTransformMatrix.ty;
                    var endX = startX + bone.globalTransformMatrix.a * boneLength;
                    var endY = startY - bone.globalTransformMatrix.b * boneLength;
                    this._debugDrawer.drawSegment(cc.p(startX, startY), cc.p(endX, endY));
                }
            },
            update: function(passedTime) {
                this._armature && this._armature.advanceTime(passedTime);
            },
            advanceTimeBySelf: function(on) {
                on ? this.scheduleUpdate() : this.unscheduleUpdate();
            },
            hasEvent: function(type) {
                return this.hasEventListener(type, false);
            },
            addEvent: function(type, listener, target) {
                this.on(type, listener, target);
            },
            removeEvent: function(type, listener, target) {
                this.off(type, listener, target);
            },
            dispose: function() {
                if (this._armature) {
                    this.advanceTimeBySelf(false);
                    this._armature.dispose();
                    this._armature = null;
                }
            },
            armature: function() {
                return this._armature;
            },
            animation: function() {
                return this._armature.animation;
            },
            setDebugBones: function(debug) {
                dragonBones.DragonBones.debugDraw = debug;
                debug ? this.armature().advanceTime(0) : this._debugDrawer && this._debugDrawer.clear();
            }
        });
    }), {
        "../../cocos2d/core/event/event-target": 112
    } ],
    294: [ (function(require, module, exports) {
        var BaseObject = dragonBones.BaseObject;
        dragonBones.CCFactory = cc.Class({
            name: "dragonBones.CCFactory",
            extends: dragonBones.BaseFactory,
            buildArmatureDisplay: function(armatureName, dragonBonesName, skinName) {
                var armature = this.buildArmature(armatureName, dragonBonesName, skinName);
                var armatureDisplay = armature ? armature._display : null;
                armatureDisplay && armatureDisplay.advanceTimeBySelf(true);
                return armatureDisplay;
            },
            _generateTextureAtlasData: function(textureAtlasData, texture) {
                textureAtlasData || (textureAtlasData = BaseObject.borrowObject(dragonBones.CCTextureAtlasData));
                textureAtlasData.texture = texture;
                return textureAtlasData;
            },
            _generateArmature: function(dataPackage) {
                var armature = BaseObject.borrowObject(dragonBones.Armature);
                var armatureDisplayContainer = new dragonBones.CCArmatureDisplay();
                armature._armatureData = dataPackage.armature;
                armature._skinData = dataPackage.skin;
                armature._animation = BaseObject.borrowObject(dragonBones.Animation);
                armature._display = armatureDisplayContainer;
                armatureDisplayContainer.setCascadeOpacityEnabled(true);
                armatureDisplayContainer.setCascadeColorEnabled(true);
                armatureDisplayContainer._armature = armature;
                armature._animation._armature = armature;
                armature.animation.animations = dataPackage.armature.animations;
                return armature;
            },
            _generateSlot: function(dataPackage, slotDisplayDataSet) {
                var slot = BaseObject.borrowObject(dragonBones.CCSlot);
                var slotData = slotDisplayDataSet.slot;
                var displayList = [];
                slot.name = slotData.name;
                slot._rawDisplay = new cc.Scale9Sprite();
                slot._rawDisplay.setRenderingType(cc.Scale9Sprite.RenderingType.SIMPLE);
                slot._rawDisplay.setAnchorPoint(cc.p(0, 0));
                slot._meshDisplay = slot._rawDisplay;
                for (var i = 0, l = slotDisplayDataSet.displays.length; i < l; ++i) {
                    var displayData = slotDisplayDataSet.displays[i];
                    switch (displayData.type) {
                      case dragonBones.DisplayType.Image:
                        displayData.texture || (displayData.texture = this._getTextureData(dataPackage.dataName, displayData.name));
                        displayList.push(slot._rawDisplay);
                        break;

                      case dragonBones.DisplayType.Mesh:
                        displayData.texture || (displayData.texture = this._getTextureData(dataPackage.dataName, displayData.name));
                        if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                            slot._meshDisplay.setRenderingType(cc.Scale9Sprite.RenderingType.MESH);
                            displayList.push(slot._meshDisplay);
                        } else {
                            cc.warnID(6200);
                        }
                        break;

                      case dragonBones.DisplayType.Armature:
                        var childArmature = this.buildArmature(displayData.name, dataPackage.dataName);
                        if (childArmature) {
                            if (!slot.inheritAnimation) {
                                var actions = slotData.actions.length > 0 ? slotData.actions : childArmature.armatureData.actions;
                                if (actions.length > 0) {
                                    for (var j = 0, n = actions.length; j < n; ++j) {
                                        childArmature._bufferAction(actions[j]);
                                    }
                                } else {
                                    childArmature.animation.play();
                                }
                            }
                            displayData.armature = childArmature.armatureData;
                        }
                        displayList.push(childArmature);
                        break;

                      default:
                        displayList.push(null);
                    }
                }
                slot._setDisplayList(displayList);
                slot._rawDisplay.setLocalZOrder(slotData.zOrder);
                return slot;
            },
            getTextureDisplay: function(textureName, textureAtlasName) {
                var textureData = this._getTextureData(textureAtlasName, textureName);
                if (textureData) {
                    if (!textureData.texture) {
                        var textureAtlasTexture = textureData.parent.texture;
                        var rect = cc.rect(textureData.region.x, textureData.region.y, textureData.region.width, textureData.region.height);
                        var offset = cc.p(0, 0);
                        var originSize = cc.size(textureData.region.width, textureData.region.height);
                        textureData.texture = new cc.SpriteFrame();
                        textureData.texture.setTexture(textureAtlasTexture, rect, textureData.rotated, offset, originSize);
                    }
                    var ret = new cc.Scale9Sprite();
                    ret.initWithSpriteFrame(textureData.texture);
                    return ret;
                }
                return null;
            }
        });
        dragonBones.CCFactory._factory = null;
        dragonBones.CCFactory.getFactory = function() {
            dragonBones.CCFactory._factory || (dragonBones.CCFactory._factory = new dragonBones.CCFactory());
            return dragonBones.CCFactory._factory;
        };
    }), {} ],
    295: [ (function(require, module, exports) {
        dragonBones.CCSlot = cc.Class({
            name: "dragonBones.CCSlot",
            extends: dragonBones.Slot,
            _renderDisplay: null,
            statics: {
                toString: function() {
                    return "[class dragonBones.CCSlot]";
                }
            },
            _onClear: function() {
                dragonBones.Slot.prototype._onClear.call(this);
                this._renderDisplay = null;
            },
            _onUpdateDisplay: function() {
                this._rawDisplay || (this._rawDisplay = new cc.Scale9Sprite());
                this._renderDisplay = this._display || this._rawDisplay;
            },
            _initDisplay: function(value) {},
            _addDisplay: function() {
                var container = this._armature._display;
                container.addChild(this._renderDisplay);
            },
            _replaceDisplay: function(value) {
                var container = this._armature._display;
                var prevDisplay = value;
                container.addChild(this._renderDisplay, prevDisplay.getLocalZOrder());
                container.removeChild(prevDisplay);
            },
            _removeDisplay: function() {
                this._renderDisplay.removeFromParent();
            },
            _disposeDisplay: function(object) {},
            _updateVisible: function() {
                this._renderDisplay.setVisible(this._parent.visible);
            },
            _updateZOrder: function() {
                if (this._renderDisplay._parent) {
                    this._renderDisplay.setLocalZOrder(this._zOrder);
                } else {
                    var container = this._armature._display;
                    container.addChild(this._renderDisplay, this._zOrder);
                }
            },
            _updateBlendMode: function() {
                if (this._renderDisplay instanceof cc.Scale9Sprite) {
                    switch (this._blendMode) {
                      case 0:
                        break;

                      case 1:
                        var texture = this._renderDisplay._spriteFrame.getTexture();
                        texture && texture.hasPremultipliedAlpha() ? this._renderDisplay.setBlendFunc(cc.BlendFunc.BlendFactor.ONE, cc.BlendFunc.BlendFactor.ONE) : this._renderDisplay.setBlendFunc(cc.BlendFunc.BlendFactor.SRC_ALPHA, cc.BlendFunc.BlendFactor.ONE);
                    }
                } else {
                    if (this._childArmature) {
                        var childSlots = this._childArmature.getSlots();
                        for (var i = 0, l = childSlots.length; i < l; i++) {
                            var slot = childSlots[i];
                            slot._blendMode = this._blendMode;
                            slot._updateBlendMode();
                        }
                    }
                }
            },
            _updateColor: function() {
                this._renderDisplay.setOpacity(255 * this._colorTransform.alphaMultiplier);
                var r = 255 * this._colorTransform.redMultiplier;
                var g = 255 * this._colorTransform.greenMultiplier;
                var b = 255 * this._colorTransform.blueMultiplier;
                this._renderDisplay.setColor(cc.color(r, g, b));
            },
            _updateFilters: function() {},
            _updateFrame: function() {
                if (this._display && this._displayIndex >= 0) {
                    var rawDisplayData = this._displayIndex < this._displayDataSet.displays.length ? this._displayDataSet.displays[this._displayIndex] : null;
                    var replacedDisplayData = this._displayIndex < this._replacedDisplayDataSet.length ? this._replacedDisplayDataSet[this._displayIndex] : null;
                    var currentDisplayData = replacedDisplayData || rawDisplayData;
                    var currentTextureData = currentDisplayData.texture;
                    if (currentTextureData) {
                        var textureAtlasTexture = currentTextureData.parent.texture;
                        if (textureAtlasTexture && (!currentTextureData.texture || currentTextureData.texture.getTexture() !== textureAtlasTexture)) {
                            var rect = cc.rect(currentTextureData.region.x, currentTextureData.region.y, currentTextureData.region.width, currentTextureData.region.height);
                            var offset = cc.p(0, 0);
                            var size = cc.size(currentTextureData.region.width, currentTextureData.region.height);
                            currentTextureData.texture = new cc.SpriteFrame();
                            currentTextureData.texture.setTexture(textureAtlasTexture, rect, false, offset, size);
                        }
                        var texture = this._armature._replacedTexture || (currentTextureData.texture ? currentTextureData.texture.getTexture() : null);
                        if (this._meshData && this._display === this._meshDisplay) {
                            var region = currentTextureData.region;
                            var textureAtlasSize = currentTextureData.texture.getTexture().getContentSize();
                            var displayVertices = [], vertexIndices = [];
                            var boundsRect = cc.rect(999999, 999999, -999999, -999999);
                            if (this._meshData !== rawDisplayData.mesh && rawDisplayData && rawDisplayData !== currentDisplayData) {
                                this._pivotX = rawDisplayData.transform.x - currentDisplayData.transform.x;
                                this._pivotY = rawDisplayData.transform.y - currentDisplayData.transform.y;
                            } else {
                                this._pivotX = 0;
                                this._pivotY = 0;
                            }
                            var i, n;
                            for (i = 0, n = this._meshData.uvs.length; i < n; i += 2) {
                                var x = this._meshData.vertices[i];
                                var y = this._meshData.vertices[i + 1];
                                var u = (region.x + this._meshData.uvs[i] * region.width) / textureAtlasSize.width;
                                var v = (region.y + this._meshData.uvs[i + 1] * region.height) / textureAtlasSize.height;
                                displayVertices.push({
                                    x: x,
                                    y: -y,
                                    u: u,
                                    v: v
                                });
                                boundsRect.x > x && (boundsRect.x = x);
                                boundsRect.width < x && (boundsRect.width = x);
                                boundsRect.y > -y && (boundsRect.y = -y);
                                boundsRect.height < -y && (boundsRect.height = -y);
                            }
                            boundsRect.width -= boundsRect.x;
                            boundsRect.height -= boundsRect.y;
                            for (i = 0, n = this._meshData.vertexIndices.length; i < n; ++i) {
                                vertexIndices.push(this._meshData.vertexIndices[i]);
                            }
                            var polygonInfo = {
                                triangles: {
                                    verts: displayVertices,
                                    indices: vertexIndices
                                },
                                rect: boundsRect
                            };
                            this._meshDisplay.setSpriteFrame(currentTextureData.texture);
                            texture != currentTextureData.texture.getTexture() && this._meshDisplay.setTexture(texture);
                            this._meshDisplay.setMeshPolygonInfo(polygonInfo);
                            this._meshDisplay.setContentSize(cc.size(boundsRect.width, boundsRect.height));
                            if (this._meshData.skinned) {
                                this._meshDisplay.setScale(1, 1);
                                this._meshDisplay.setRotationX(0);
                                this._meshDisplay.setRotationY(0);
                                this._meshDisplay.setPosition(0, 0);
                            }
                            this._meshDisplay.setAnchorPoint(cc.p(0, 0));
                        } else {
                            var scale = this._armature.armatureData.scale;
                            this._pivotX = currentDisplayData.pivot.x;
                            this._pivotY = currentDisplayData.pivot.y;
                            if (currentDisplayData.isRelativePivot) {
                                var rectData = currentTextureData.frame || currentTextureData.region;
                                var width = rectData.width * scale;
                                var height = rectData.height * scale;
                                if (!currentTextureData.frame && currentTextureData.rotated) {
                                    width = rectData.height;
                                    height = rectData.width;
                                }
                                this._pivotX *= width;
                                this._pivotY *= height;
                            }
                            if (currentTextureData.frame) {
                                this._pivotX += currentTextureData.frame.x * scale;
                                this._pivotY += currentTextureData.frame.y * scale;
                            }
                            if (rawDisplayData && rawDisplayData !== currentDisplayData) {
                                this._pivotX += rawDisplayData.transform.x - currentDisplayData.transform.x;
                                this._pivotY += rawDisplayData.transform.y - currentDisplayData.transform.y;
                            }
                            this._pivotY -= currentTextureData.region.height * scale;
                            this._rawDisplay.setSpriteFrame(currentTextureData.texture);
                            this._rawDisplay.setContentSize(currentTextureData.texture.getOriginalSize());
                            texture !== currentTextureData.texture.getTexture() && this._rawDisplay.setTexture(texture);
                            this._blendModeDirty = true;
                        }
                        this._updateVisible();
                        return;
                    }
                }
                this._pivotX = 0;
                this._pivotY = 0;
                this._rawDisplay.setTexture(null);
                this._rawDisplay.setVisible(false);
                this._rawDisplay.setPosition(this.origin.x, this.origin.y);
            },
            _updateMesh: function() {
                var meshDisplay = this._meshDisplay;
                var polygonInfo = meshDisplay.getMeshPolygonInfo();
                if (!meshDisplay || !polygonInfo) {
                    return;
                }
                var hasFFD = this._ffdVertices.length > 0;
                var displayVertices = polygonInfo.triangles.verts;
                var boundsRect = cc.rect(999999, 999999, -999999, -999999);
                var iH = 0, xG = 0, yG = 0, i, l;
                if (this._meshData.skinned) {
                    var iF = 0;
                    for (i = 0, l = this._meshData.vertices.length; i < l; i += 2) {
                        iH = Math.floor(i / 2);
                        var boneIndices = this._meshData.boneIndices[iH];
                        var boneVertices = this._meshData.boneVertices[iH];
                        var weights = this._meshData.weights[iH];
                        xG = 0;
                        yG = 0;
                        for (var iB = 0, lB = boneIndices.length; iB < lB; ++iB) {
                            var bone = this._meshBones[boneIndices[iB]];
                            var matrix = bone.globalTransformMatrix;
                            var weight = weights[iB];
                            var xL = 0, yL = 0;
                            if (hasFFD) {
                                xL = boneVertices[2 * iB] + this._ffdVertices[iF];
                                yL = boneVertices[2 * iB + 1] + this._ffdVertices[iF + 1];
                            } else {
                                xL = boneVertices[2 * iB];
                                yL = boneVertices[2 * iB + 1];
                            }
                            xG += (matrix.a * xL + matrix.c * yL + matrix.tx) * weight;
                            yG += (matrix.b * xL + matrix.d * yL + matrix.ty) * weight;
                            iF += 2;
                        }
                        displayVertices[iH].x = xG;
                        displayVertices[iH].y = -yG;
                        boundsRect.x > xG && (boundsRect.x = xG);
                        boundsRect.width < xG && (boundsRect.width = xG);
                        boundsRect.y > -yG && (boundsRect.y = -yG);
                        boundsRect.height < -yG && (boundsRect.height = -yG);
                    }
                } else {
                    if (hasFFD) {
                        var vertices = this._meshData.vertices;
                        for (i = 0, l = this._meshData.vertices.length; i < l; i += 2) {
                            iH = Math.floor(i / 2);
                            xG = vertices[i] + this._ffdVertices[i];
                            yG = vertices[i + 1] + this._ffdVertices[i + 1];
                            displayVertices[iH].x = xG;
                            displayVertices[iH].y = -yG;
                            boundsRect.x > xG && (boundsRect.x = xG);
                            boundsRect.width < xG && (boundsRect.width = xG);
                            boundsRect.y > -yG && (boundsRect.y = -yG);
                            boundsRect.height < -yG && (boundsRect.height = -yG);
                        }
                    }
                }
                boundsRect.width -= boundsRect.x;
                boundsRect.height -= boundsRect.y;
                polygonInfo.rect = boundsRect;
                var transform = meshDisplay.getNodeToParentTransform();
                meshDisplay.setContentSize(cc.size(boundsRect.width, boundsRect.height));
                meshDisplay.setMeshPolygonInfo(polygonInfo);
                this._renderDisplay._renderCmd.setNodeToParentTransform(transform);
            },
            _updateTransform: function() {
                var transform = {
                    a: this.globalTransformMatrix.a,
                    b: -this.globalTransformMatrix.b,
                    c: -this.globalTransformMatrix.c,
                    d: this.globalTransformMatrix.d,
                    tx: this.globalTransformMatrix.tx - (this.globalTransformMatrix.a * this._pivotX + this.globalTransformMatrix.c * this._pivotY),
                    ty: -(this.globalTransformMatrix.ty - (this.globalTransformMatrix.b * this._pivotX + this.globalTransformMatrix.d * this._pivotY))
                };
                this._renderDisplay._renderCmd.setNodeToParentTransform(transform);
            }
        });
    }), {} ],
    296: [ (function(require, module, exports) {
        dragonBones.CCTextureAtlasData = cc.Class({
            name: "dragonBones.CCTextureAtlasData",
            extends: dragonBones.TextureAtlasData,
            texture: null,
            statics: {
                toString: function() {
                    return "[class dragonBones.CCTextureAtlasData]";
                }
            },
            _onClear: function() {
                dragonBones.TextureAtlasData.prototype._onClear.call(this);
                this.texture = null;
            },
            generateTextureData: function() {
                return dragonBones.BaseObject.borrowObject(dragonBones.CCTextureData);
            }
        });
        dragonBones.CCTextureData = cc.Class({
            name: "dragonBones.CCTextureData",
            extends: dragonBones.TextureData,
            texture: null,
            statics: {
                toString: function() {
                    return "[class dragonBones.CCTextureData]";
                }
            },
            _onClear: function() {
                dragonBones.TextureData.prototype._onClear.call(this);
                if (this.texture) {
                    this.texture.dispose();
                    this.texture = null;
                }
            }
        });
    }), {} ],
    297: [ (function(require, module, exports) {
        var DragonBonesAsset = cc.Class({
            name: "dragonBones.DragonBonesAsset",
            extends: cc.Asset,
            properties: {
                _dragonBonesJson: "",
                dragonBonesJson: {
                    get: function() {
                        return this._dragonBonesJson;
                    },
                    set: function(value) {
                        this._dragonBonesJson = value;
                        this.reset();
                    }
                }
            },
            statics: {
                preventDeferredLoadDependents: true
            },
            createNode: false,
            reset: function() {},
            getRuntimeData: false,
            getArmatureEnum: false,
            getAnimsEnum: false
        });
        dragonBones.DragonBonesAsset = module.exports = DragonBonesAsset;
    }), {} ],
    298: [ (function(require, module, exports) {
        var DragonBonesAtlasAsset = cc.Class({
            name: "dragonBones.DragonBonesAtlasAsset",
            extends: cc.Asset,
            properties: {
                _atlasJson: "",
                atlasJson: {
                    get: function() {
                        return this._atlasJson;
                    },
                    set: function(value) {
                        this._atlasJson = value;
                    }
                },
                texture: {
                    default: "",
                    url: cc.Texture2D
                }
            },
            statics: {
                preventDeferredLoadDependents: true
            },
            createNode: false
        });
        dragonBones.DragonBonesAtlasAsset = module.exports = DragonBonesAtlasAsset;
    }), {} ],
    299: [ (function(require, module, exports) {
        dragonBones = require("./lib/dragonBones");
        dragonBones.DisplayType = {
            Image: 0,
            Armature: 1,
            Mesh: 2
        };
        dragonBones.ArmatureType = {
            Armature: 0,
            MovieClip: 1,
            Stage: 2
        };
        dragonBones.ExtensionType = {
            FFD: 0,
            AdjustColor: 10,
            BevelFilter: 11,
            BlurFilter: 12,
            DropShadowFilter: 13,
            GlowFilter: 14,
            GradientBevelFilter: 15,
            GradientGlowFilter: 16
        };
        dragonBones.EventType = {
            Frame: 0,
            Sound: 1
        };
        dragonBones.ActionType = {
            Play: 0,
            Stop: 1,
            GotoAndPlay: 2,
            GotoAndStop: 3,
            FadeIn: 4,
            FadeOut: 5
        };
        dragonBones.AnimationFadeOutMode = {
            None: 0,
            SameLayer: 1,
            SameGroup: 2,
            SameLayerAndGroup: 3,
            All: 4
        };
        require("./CCFactory");
        require("./CCSlot");
        require("./CCTextureData");
        require("./CCArmatureDisplay");
        require("./DragonBonesAsset");
        require("./DragonBonesAtlasAsset");
        require("./ArmatureDisplay");
    }), {
        "./ArmatureDisplay": 292,
        "./CCArmatureDisplay": 293,
        "./CCFactory": 294,
        "./CCSlot": 295,
        "./CCTextureData": 296,
        "./DragonBonesAsset": 297,
        "./DragonBonesAtlasAsset": 298,
        "./lib/dragonBones": 300
    } ],
    300: [ (function(require, module, exports) {
        var __extends = this && this.__extends || function(d, b) {
            for (var p in b) {
                b.hasOwnProperty(p) && (d[p] = b[p]);
            }
            function __() {
                this.constructor = d;
            }
            d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        var dragonBones;
        (function(dragonBones) {
            var DragonBones = (function() {
                function DragonBones() {}
                DragonBones.hasArmature = function(value) {
                    return DragonBones._armatures.indexOf(value) >= 0;
                };
                DragonBones.addArmature = function(value) {
                    value && DragonBones._armatures.indexOf(value) < 0 && DragonBones._armatures.push(value);
                };
                DragonBones.removeArmature = function(value) {
                    if (value) {
                        var index = DragonBones._armatures.indexOf(value);
                        index >= 0 && DragonBones._armatures.splice(index, 1);
                    }
                };
                DragonBones.PI_D = 2 * Math.PI;
                DragonBones.PI_H = Math.PI / 2;
                DragonBones.PI_Q = Math.PI / 4;
                DragonBones.ANGLE_TO_RADIAN = Math.PI / 180;
                DragonBones.RADIAN_TO_ANGLE = 180 / Math.PI;
                DragonBones.SECOND_TO_MILLISECOND = 1e3;
                DragonBones.NO_TWEEN = 100;
                DragonBones.VERSION = "4.7.2";
                DragonBones.debug = false;
                DragonBones.debugDraw = false;
                DragonBones._armatures = [];
                return DragonBones;
            })();
            dragonBones.DragonBones = DragonBones;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var BaseObject = (function() {
                function BaseObject() {
                    this.hashCode = BaseObject._hashCode++;
                }
                BaseObject._returnObject = function(object) {
                    var classType = String(object.constructor);
                    var maxCount = null == BaseObject._maxCountMap[classType] ? BaseObject._defaultMaxCount : BaseObject._maxCountMap[classType];
                    var pool = BaseObject._poolsMap[classType] = BaseObject._poolsMap[classType] || [];
                    if (pool.length < maxCount) {
                        if (!(pool.indexOf(object) < 0)) {
                            throw new Error();
                        }
                        pool.push(object);
                    }
                };
                BaseObject.setMaxCount = function(objectConstructor, maxCount) {
                    (maxCount < 0 || maxCount != maxCount) && (maxCount = 0);
                    if (objectConstructor) {
                        var classType = String(objectConstructor);
                        BaseObject._maxCountMap[classType] = maxCount;
                        var pool = BaseObject._poolsMap[classType];
                        pool && pool.length > maxCount && (pool.length = maxCount);
                    } else {
                        BaseObject._defaultMaxCount = maxCount;
                        for (var classType in BaseObject._poolsMap) {
                            if (null == BaseObject._maxCountMap[classType]) {
                                continue;
                            }
                            BaseObject._maxCountMap[classType] = maxCount;
                            var pool = BaseObject._poolsMap[classType];
                            pool.length > maxCount && (pool.length = maxCount);
                        }
                    }
                };
                BaseObject.clearPool = function(objectConstructor) {
                    void 0 === objectConstructor && (objectConstructor = null);
                    if (objectConstructor) {
                        var pool = BaseObject._poolsMap[String(objectConstructor)];
                        pool && pool.length && (pool.length = 0);
                    } else {
                        for (var iP in BaseObject._poolsMap) {
                            var pool = BaseObject._poolsMap[iP];
                            pool.length = 0;
                        }
                    }
                };
                BaseObject.borrowObject = function(objectConstructor) {
                    var pool = BaseObject._poolsMap[String(objectConstructor)];
                    if (pool && pool.length) {
                        return pool.pop();
                    }
                    var object = new objectConstructor();
                    object._onClear();
                    return object;
                };
                BaseObject.prototype.returnToPool = function() {
                    this._onClear();
                    BaseObject._returnObject(this);
                };
                BaseObject._hashCode = 0;
                BaseObject._defaultMaxCount = 5e3;
                BaseObject._maxCountMap = {};
                BaseObject._poolsMap = {};
                return BaseObject;
            })();
            dragonBones.BaseObject = BaseObject;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var ColorTransform = (function() {
                function ColorTransform(alphaMultiplier, redMultiplier, greenMultiplier, blueMultiplier, alphaOffset, redOffset, greenOffset, blueOffset) {
                    void 0 === alphaMultiplier && (alphaMultiplier = 1);
                    void 0 === redMultiplier && (redMultiplier = 1);
                    void 0 === greenMultiplier && (greenMultiplier = 1);
                    void 0 === blueMultiplier && (blueMultiplier = 1);
                    void 0 === alphaOffset && (alphaOffset = 0);
                    void 0 === redOffset && (redOffset = 0);
                    void 0 === greenOffset && (greenOffset = 0);
                    void 0 === blueOffset && (blueOffset = 0);
                    this.alphaMultiplier = alphaMultiplier;
                    this.redMultiplier = redMultiplier;
                    this.greenMultiplier = greenMultiplier;
                    this.blueMultiplier = blueMultiplier;
                    this.alphaOffset = alphaOffset;
                    this.redOffset = redOffset;
                    this.greenOffset = greenOffset;
                    this.blueOffset = blueOffset;
                }
                ColorTransform.prototype.copyFrom = function(value) {
                    this.alphaMultiplier = value.alphaMultiplier;
                    this.redMultiplier = value.redMultiplier;
                    this.greenMultiplier = value.greenMultiplier;
                    this.blueMultiplier = value.blueMultiplier;
                    this.alphaOffset = value.alphaOffset;
                    this.redOffset = value.redOffset;
                    this.redOffset = value.redOffset;
                    this.greenOffset = value.blueOffset;
                };
                ColorTransform.prototype.identity = function() {
                    this.alphaMultiplier = this.redMultiplier = this.greenMultiplier = this.blueMultiplier = 1;
                    this.alphaOffset = this.redOffset = this.greenOffset = this.blueOffset = 0;
                };
                return ColorTransform;
            })();
            dragonBones.ColorTransform = ColorTransform;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var Point = (function() {
                function Point(x, y) {
                    void 0 === x && (x = 0);
                    void 0 === y && (y = 0);
                    this.x = x;
                    this.y = y;
                }
                Point.prototype.copyFrom = function(value) {
                    this.x = value.x;
                    this.y = value.y;
                };
                Point.prototype.clear = function() {
                    this.x = this.y = 0;
                };
                return Point;
            })();
            dragonBones.Point = Point;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var Matrix = (function() {
                function Matrix(a, b, c, d, tx, ty) {
                    void 0 === a && (a = 1);
                    void 0 === b && (b = 0);
                    void 0 === c && (c = 0);
                    void 0 === d && (d = 1);
                    void 0 === tx && (tx = 0);
                    void 0 === ty && (ty = 0);
                    this.a = a;
                    this.b = b;
                    this.c = c;
                    this.d = d;
                    this.tx = tx;
                    this.ty = ty;
                }
                Matrix.prototype.toString = function() {
                    return "[object dragonBones.Matrix] a:" + this.a + " b:" + this.b + " c:" + this.c + " d:" + this.d + " tx:" + this.tx + " ty:" + this.ty;
                };
                Matrix.prototype.copyFrom = function(value) {
                    this.a = value.a;
                    this.b = value.b;
                    this.c = value.c;
                    this.d = value.d;
                    this.tx = value.tx;
                    this.ty = value.ty;
                };
                Matrix.prototype.identity = function() {
                    this.a = this.d = 1;
                    this.b = this.c = 0;
                    this.tx = this.ty = 0;
                };
                Matrix.prototype.concat = function(value) {
                    var aA = this.a;
                    var bA = this.b;
                    var cA = this.c;
                    var dA = this.d;
                    var txA = this.tx;
                    var tyA = this.ty;
                    var aB = value.a;
                    var bB = value.b;
                    var cB = value.c;
                    var dB = value.d;
                    var txB = value.tx;
                    var tyB = value.ty;
                    this.a = aA * aB + bA * cB;
                    this.b = aA * bB + bA * dB;
                    this.c = cA * aB + dA * cB;
                    this.d = cA * bB + dA * dB;
                    this.tx = aB * txA + cB * tyA + txB;
                    this.ty = dB * tyA + bB * txA + tyB;
                };
                Matrix.prototype.invert = function() {
                    var aA = this.a;
                    var bA = this.b;
                    var cA = this.c;
                    var dA = this.d;
                    var txA = this.tx;
                    var tyA = this.ty;
                    var n = aA * dA - bA * cA;
                    this.a = dA / n;
                    this.b = -bA / n;
                    this.c = -cA / n;
                    this.d = aA / n;
                    this.tx = (cA * tyA - dA * txA) / n;
                    this.ty = -(aA * tyA - bA * txA) / n;
                };
                Matrix.prototype.transformPoint = function(x, y, result, delta) {
                    void 0 === delta && (delta = false);
                    result.x = this.a * x + this.c * y;
                    result.y = this.b * x + this.d * y;
                    if (!delta) {
                        result.x += this.tx;
                        result.y += this.ty;
                    }
                };
                return Matrix;
            })();
            dragonBones.Matrix = Matrix;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var Rectangle = (function() {
                function Rectangle(x, y, width, height) {
                    void 0 === x && (x = 0);
                    void 0 === y && (y = 0);
                    void 0 === width && (width = 0);
                    void 0 === height && (height = 0);
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                }
                Rectangle.prototype.copyFrom = function(value) {
                    this.x = value.x;
                    this.y = value.y;
                    this.width = value.width;
                    this.height = value.height;
                };
                Rectangle.prototype.clear = function() {
                    this.x = this.y = 0;
                    this.width = this.height = 0;
                };
                return Rectangle;
            })();
            dragonBones.Rectangle = Rectangle;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var Transform = (function() {
                function Transform(x, y, skewX, skewY, scaleX, scaleY) {
                    void 0 === x && (x = 0);
                    void 0 === y && (y = 0);
                    void 0 === skewX && (skewX = 0);
                    void 0 === skewY && (skewY = 0);
                    void 0 === scaleX && (scaleX = 1);
                    void 0 === scaleY && (scaleY = 1);
                    this.x = x;
                    this.y = y;
                    this.skewX = skewX;
                    this.skewY = skewY;
                    this.scaleX = scaleX;
                    this.scaleY = scaleY;
                }
                Transform.normalizeRadian = function(value) {
                    value = (value + Math.PI) % (2 * Math.PI);
                    value += value > 0 ? -Math.PI : Math.PI;
                    return value;
                };
                Transform.prototype.toString = function() {
                    return "[object dragonBones.Transform] x:" + this.x + " y:" + this.y + " skewX:" + 180 * this.skewX / Math.PI + " skewY:" + 180 * this.skewY / Math.PI + " scaleX:" + this.scaleX + " scaleY:" + this.scaleY;
                };
                Transform.prototype.copyFrom = function(value) {
                    this.x = value.x;
                    this.y = value.y;
                    this.skewX = value.skewX;
                    this.skewY = value.skewY;
                    this.scaleX = value.scaleX;
                    this.scaleY = value.scaleY;
                    return this;
                };
                Transform.prototype.identity = function() {
                    this.x = this.y = this.skewX = this.skewY = 0;
                    this.scaleX = this.scaleY = 1;
                    return this;
                };
                Transform.prototype.add = function(value) {
                    this.x += value.x;
                    this.y += value.y;
                    this.skewX += value.skewX;
                    this.skewY += value.skewY;
                    this.scaleX *= value.scaleX;
                    this.scaleY *= value.scaleY;
                    return this;
                };
                Transform.prototype.minus = function(value) {
                    this.x -= value.x;
                    this.y -= value.y;
                    this.skewX = Transform.normalizeRadian(this.skewX - value.skewX);
                    this.skewY = Transform.normalizeRadian(this.skewY - value.skewY);
                    this.scaleX /= value.scaleX;
                    this.scaleY /= value.scaleY;
                    return this;
                };
                Transform.prototype.fromMatrix = function(matrix) {
                    var PI_Q = .25 * Math.PI;
                    var backupScaleX = this.scaleX, backupScaleY = this.scaleY;
                    this.x = matrix.tx;
                    this.y = matrix.ty;
                    this.skewX = Math.atan(-matrix.c / matrix.d);
                    this.skewY = Math.atan(matrix.b / matrix.a);
                    this.skewX != this.skewX && (this.skewX = 0);
                    this.skewY != this.skewY && (this.skewY = 0);
                    this.scaleY = this.skewX > -PI_Q && this.skewX < PI_Q ? matrix.d / Math.cos(this.skewX) : -matrix.c / Math.sin(this.skewX);
                    this.scaleX = this.skewY > -PI_Q && this.skewY < PI_Q ? matrix.a / Math.cos(this.skewY) : matrix.b / Math.sin(this.skewY);
                    if (backupScaleX >= 0 && this.scaleX < 0) {
                        this.scaleX = -this.scaleX;
                        this.skewY = this.skewY - Math.PI;
                    }
                    if (backupScaleY >= 0 && this.scaleY < 0) {
                        this.scaleY = -this.scaleY;
                        this.skewX = this.skewX - Math.PI;
                    }
                    return this;
                };
                Transform.prototype.toMatrix = function(matrix) {
                    matrix.a = this.scaleX * Math.cos(this.skewY);
                    matrix.b = this.scaleX * Math.sin(this.skewY);
                    matrix.c = -this.scaleY * Math.sin(this.skewX);
                    matrix.d = this.scaleY * Math.cos(this.skewX);
                    matrix.tx = this.x;
                    matrix.ty = this.y;
                    return this;
                };
                Object.defineProperty(Transform.prototype, "rotation", {
                    get: function() {
                        return this.skewY;
                    },
                    set: function(value) {
                        var dValue = value - this.skewY;
                        this.skewX += dValue;
                        this.skewY += dValue;
                    },
                    enumerable: true,
                    configurable: true
                });
                return Transform;
            })();
            dragonBones.Transform = Transform;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var TimelineState = (function(_super) {
                __extends(TimelineState, _super);
                function TimelineState() {
                    _super.call(this);
                }
                TimelineState.prototype._onClear = function() {
                    this._isCompleted = false;
                    this._currentPlayTimes = 0;
                    this._currentTime = -1;
                    this._timeline = null;
                    this._isReverse = false;
                    this._hasAsynchronyTimeline = false;
                    this._frameRate = 0;
                    this._keyFrameCount = 0;
                    this._frameCount = 0;
                    this._position = 0;
                    this._duration = 0;
                    this._animationDutation = 0;
                    this._timeScale = 1;
                    this._timeOffset = 0;
                    this._currentFrame = null;
                    this._armature = null;
                    this._animationState = null;
                };
                TimelineState.prototype._onUpdateFrame = function(isUpdate) {};
                TimelineState.prototype._onArriveAtFrame = function(isUpdate) {};
                TimelineState.prototype._setCurrentTime = function(value) {
                    var self = this;
                    var currentPlayTimes = 0;
                    if (1 == self._keyFrameCount && this != self._animationState._timeline) {
                        self._isCompleted = self._animationState._fadeState >= 0;
                        currentPlayTimes = 1;
                    } else {
                        if (self._hasAsynchronyTimeline) {
                            var playTimes = self._animationState.playTimes;
                            var totalTime = playTimes * self._duration;
                            value *= self._timeScale;
                            0 != self._timeOffset && (value += self._timeOffset * self._animationDutation);
                            if (playTimes > 0 && (value >= totalTime || value <= -totalTime)) {
                                self._isCompleted = true;
                                currentPlayTimes = playTimes;
                                value = value < 0 ? 0 : self._duration;
                            } else {
                                self._isCompleted = false;
                                if (value < 0) {
                                    currentPlayTimes = Math.floor(-value / self._duration);
                                    value = self._duration - -value % self._duration;
                                } else {
                                    currentPlayTimes = Math.floor(value / self._duration);
                                    value %= self._duration;
                                }
                                playTimes > 0 && currentPlayTimes > playTimes && (currentPlayTimes = playTimes);
                            }
                            value += self._position;
                        } else {
                            self._isCompleted = self._animationState._timeline._isCompleted;
                            currentPlayTimes = self._animationState._timeline._currentPlayTimes;
                        }
                    }
                    if (self._currentTime == value) {
                        return false;
                    }
                    self._isReverse = self._currentTime > value && self._currentPlayTimes == currentPlayTimes;
                    self._currentTime = value;
                    self._currentPlayTimes = currentPlayTimes;
                    self._animationState._onFadeInComplete && (self._currentFrame = null);
                    return true;
                };
                TimelineState.prototype.fadeIn = function(armature, animationState, timelineData, time) {
                    this._armature = armature;
                    this._animationState = animationState;
                    this._timeline = timelineData;
                    var isMainTimeline = this == this._animationState._timeline;
                    this._hasAsynchronyTimeline = isMainTimeline || this._animationState.animationData.hasAsynchronyTimeline;
                    this._frameRate = this._armature.armatureData.frameRate;
                    this._keyFrameCount = this._timeline.frames.length;
                    this._frameCount = this._animationState.animationData.frameCount;
                    this._position = this._animationState._position;
                    this._duration = this._animationState._duration;
                    this._animationDutation = this._animationState.animationData.duration;
                    this._timeScale = isMainTimeline ? 1 : 1 / this._timeline.scale;
                    this._timeOffset = isMainTimeline ? 0 : this._timeline.offset;
                };
                TimelineState.prototype.fadeOut = function() {};
                TimelineState.prototype.update = function(time) {
                    var self = this;
                    if (!self._isCompleted && self._setCurrentTime(time)) {
                        var currentFrameIndex = self._keyFrameCount > 1 ? Math.floor(self._currentTime * self._frameRate) : 0;
                        var currentFrame = self._timeline.frames[currentFrameIndex];
                        if (self._currentFrame != currentFrame) {
                            self._currentFrame = currentFrame;
                            self._onArriveAtFrame(true);
                        }
                        self._onUpdateFrame(true);
                    }
                };
                return TimelineState;
            })(dragonBones.BaseObject);
            dragonBones.TimelineState = TimelineState;
            var TweenTimelineState = (function(_super) {
                __extends(TweenTimelineState, _super);
                function TweenTimelineState() {
                    _super.call(this);
                }
                TweenTimelineState._getEasingValue = function(progress, easing) {
                    if (progress <= 0) {
                        return 0;
                    }
                    if (progress >= 1) {
                        return 1;
                    }
                    var value = 1;
                    if (easing > 2) {
                        return progress;
                    }
                    if (easing > 1) {
                        value = .5 * (1 - Math.cos(progress * Math.PI));
                        easing -= 1;
                    } else {
                        if (easing > 0) {
                            value = 1 - Math.pow(1 - progress, 2);
                        } else {
                            if (easing >= -1) {
                                easing *= -1;
                                value = Math.pow(progress, 2);
                            } else {
                                if (!(easing >= -2)) {
                                    return progress;
                                }
                                easing *= -1;
                                value = Math.acos(1 - 2 * progress) / Math.PI;
                                easing -= 1;
                            }
                        }
                    }
                    return (value - progress) * easing + progress;
                };
                TweenTimelineState._getEasingCurveValue = function(progress, samples) {
                    if (progress <= 0) {
                        return 0;
                    }
                    if (progress >= 1) {
                        return 1;
                    }
                    var segmentCount = samples.length + 1;
                    var valueIndex = Math.floor(progress * segmentCount);
                    var fromValue = 0 == valueIndex ? 0 : samples[valueIndex - 1];
                    var toValue = valueIndex == segmentCount - 1 ? 1 : samples[valueIndex];
                    return fromValue + (toValue - fromValue) * (progress - valueIndex / segmentCount);
                };
                TweenTimelineState.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this._tweenProgress = 0;
                    this._tweenEasing = dragonBones.DragonBones.NO_TWEEN;
                    this._curve = null;
                };
                TweenTimelineState.prototype._onArriveAtFrame = function(isUpdate) {
                    var self = this;
                    self._tweenEasing = self._currentFrame.tweenEasing;
                    self._curve = self._currentFrame.curve;
                    if (self._keyFrameCount <= 1 || self._currentFrame.next == self._timeline.frames[0] && (self._tweenEasing != dragonBones.DragonBones.NO_TWEEN || self._curve) && self._animationState.playTimes > 0 && self._animationState.currentPlayTimes == self._animationState.playTimes - 1) {
                        self._tweenEasing = dragonBones.DragonBones.NO_TWEEN;
                        self._curve = null;
                    }
                };
                TweenTimelineState.prototype._onUpdateFrame = function(isUpdate) {
                    var self = this;
                    if (self._tweenEasing != dragonBones.DragonBones.NO_TWEEN) {
                        self._tweenProgress = (self._currentTime - self._currentFrame.position + self._position) / self._currentFrame.duration;
                        0 != self._tweenEasing && (self._tweenProgress = TweenTimelineState._getEasingValue(self._tweenProgress, self._tweenEasing));
                    } else {
                        if (self._curve) {
                            self._tweenProgress = (self._currentTime - self._currentFrame.position + self._position) / self._currentFrame.duration;
                            self._tweenProgress = TweenTimelineState._getEasingCurveValue(self._tweenProgress, self._curve);
                        } else {
                            self._tweenProgress = 0;
                        }
                    }
                };
                TweenTimelineState.prototype._updateExtensionKeyFrame = function(current, next, result) {
                    var tweenType = 0;
                    if (current.type == next.type) {
                        for (var i = 0, l = current.tweens.length; i < l; ++i) {
                            var tweenDuration = next.tweens[i] - current.tweens[i];
                            result.tweens[i] = tweenDuration;
                            tweenDuration > 0 && (tweenType = 2);
                        }
                    }
                    if (0 == tweenType) {
                        if (result.type != current.type) {
                            tweenType = 1;
                            result.type = current.type;
                        }
                        if (result.tweens.length != current.tweens.length) {
                            tweenType = 1;
                            result.tweens.length = current.tweens.length;
                        }
                        if (result.keys.length != current.keys.length) {
                            tweenType = 1;
                            result.keys.length = current.keys.length;
                        }
                        for (var i = 0, l = current.keys.length; i < l; ++i) {
                            var key = current.keys[i];
                            if (result.keys[i] != key) {
                                tweenType = 1;
                                result.keys[i] = key;
                            }
                        }
                    }
                    return tweenType;
                };
                return TweenTimelineState;
            })(TimelineState);
            dragonBones.TweenTimelineState = TweenTimelineState;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var Animation = (function(_super) {
                __extends(Animation, _super);
                function Animation() {
                    _super.call(this);
                    this._animations = {};
                    this._animationNames = [];
                    this._animationStates = [];
                }
                Animation._sortAnimationState = function(a, b) {
                    return a.layer > b.layer ? -1 : 1;
                };
                Animation.toString = function() {
                    return "[class dragonBones.Animation]";
                };
                Animation.prototype._onClear = function() {
                    for (var i in this._animations) {
                        delete this._animations[i];
                    }
                    for (var i = 0, l = this._animationStates.length; i < l; ++i) {
                        this._animationStates[i].returnToPool();
                    }
                    this.timeScale = 1;
                    this._animationStateDirty = false;
                    this._armature = null;
                    this._isPlaying = false;
                    this._time = 0;
                    this._duration = 0;
                    this._lastAnimationState = null;
                    this._animationNames.length = 0;
                    this._animationStates.length = 0;
                };
                Animation.prototype._fadeOut = function(fadeOutTime, layer, group, fadeOutMode, pauseFadeOut) {
                    var i = 0, l = this._animationStates.length;
                    var animationState = null;
                    switch (fadeOutMode) {
                      case 1:
                        for (;i < l; ++i) {
                            animationState = this._animationStates[i];
                            animationState.layer == layer && animationState.fadeOut(fadeOutTime, pauseFadeOut);
                        }
                        break;

                      case 2:
                        for (;i < l; ++i) {
                            animationState = this._animationStates[i];
                            animationState.group == group && animationState.fadeOut(fadeOutTime, pauseFadeOut);
                        }
                        break;

                      case 4:
                        for (;i < l; ++i) {
                            animationState = this._animationStates[i];
                            0 == fadeOutTime ? animationState.returnToPool() : animationState.fadeOut(fadeOutTime, pauseFadeOut);
                        }
                        0 == fadeOutTime && (this._animationStates.length = 0);
                        break;

                      case 3:
                        for (;i < l; ++i) {
                            animationState = this._animationStates[i];
                            animationState.layer == layer && animationState.group == group && animationState.fadeOut(fadeOutTime, pauseFadeOut);
                        }
                        break;

                      case 0:                    }
                };
                Animation.prototype._updateFFDTimelineStates = function() {
                    for (var i = 0, l = this._animationStates.length; i < l; ++i) {
                        this._animationStates[i]._updateFFDTimelineStates();
                    }
                };
                Animation.prototype._advanceTime = function(passedTime) {
                    var self = this;
                    if (!self._isPlaying) {
                        return;
                    }
                    passedTime < 0 && (passedTime = -passedTime);
                    var animationStateCount = self._animationStates.length;
                    if (1 == animationStateCount) {
                        var animationState = self._animationStates[0];
                        if (animationState._fadeState > 0 && animationState._fadeProgress <= 0) {
                            animationState.returnToPool();
                            self._animationStates.length = 0;
                            self._animationStateDirty = true;
                            self._lastAnimationState = null;
                        } else {
                            animationState._advanceTime(passedTime, 1, 0);
                        }
                    } else {
                        if (animationStateCount > 1) {
                            var prevLayer = self._animationStates[0]._layer;
                            var weightLeft = 1;
                            var layerTotalWeight = 0;
                            var animationIndex = 1;
                            for (var i = 0, r = 0; i < animationStateCount; ++i) {
                                var animationState = self._animationStates[i];
                                if (animationState._fadeState > 0 && animationState._fadeProgress <= 0) {
                                    r++;
                                    animationState.returnToPool();
                                    self._animationStateDirty = true;
                                    self._lastAnimationState == animationState && (i - r >= 0 ? self._lastAnimationState = self._animationStates[i - r] : self._lastAnimationState = null);
                                } else {
                                    r > 0 && (self._animationStates[i - r] = animationState);
                                    if (prevLayer != animationState._layer) {
                                        prevLayer = animationState._layer;
                                        layerTotalWeight >= weightLeft ? weightLeft = 0 : weightLeft -= layerTotalWeight;
                                        layerTotalWeight = 0;
                                    }
                                    animationState._advanceTime(passedTime, weightLeft, animationIndex);
                                    if (animationState._weightResult > 0) {
                                        layerTotalWeight += animationState._weightResult;
                                        animationIndex++;
                                    }
                                }
                                i == animationStateCount - 1 && r > 0 && (self._animationStates.length -= r);
                            }
                        }
                    }
                };
                Animation.prototype.reset = function() {
                    for (var i = 0, l = this._animationStates.length; i < l; ++i) {
                        this._animationStates[i].returnToPool();
                    }
                    this._isPlaying = false;
                    this._lastAnimationState = null;
                    this._animationStates.length = 0;
                };
                Animation.prototype.stop = function(animationName) {
                    void 0 === animationName && (animationName = null);
                    if (animationName) {
                        var animationState = this.getState(animationName);
                        animationState && animationState.stop();
                    } else {
                        this._isPlaying = false;
                    }
                };
                Animation.prototype.play = function(animationName, playTimes) {
                    void 0 === animationName && (animationName = null);
                    void 0 === playTimes && (playTimes = -1);
                    var animationState = null;
                    if (animationName) {
                        animationState = this.fadeIn(animationName, 0, playTimes, 0, null, 4);
                    } else {
                        if (this._lastAnimationState) {
                            if (this._isPlaying && (this._lastAnimationState.isPlaying || this._lastAnimationState.isCompleted)) {
                                animationState = this.fadeIn(this._lastAnimationState.name, 0, playTimes, 0, null, 4);
                            } else {
                                this._isPlaying = true;
                                this._lastAnimationState.play();
                            }
                        } else {
                            var defaultAnimation = this._armature.armatureData.defaultAnimation;
                            defaultAnimation && (animationState = this.fadeIn(defaultAnimation.name, 0, playTimes, 0, null, 4));
                        }
                    }
                    return animationState;
                };
                Animation.prototype.fadeIn = function(animationName, fadeInTime, playTimes, layer, group, fadeOutMode, additiveBlending, displayControl, pauseFadeOut, pauseFadeIn) {
                    void 0 === fadeInTime && (fadeInTime = -1);
                    void 0 === playTimes && (playTimes = -1);
                    void 0 === layer && (layer = 0);
                    void 0 === group && (group = null);
                    void 0 === fadeOutMode && (fadeOutMode = 3);
                    void 0 === additiveBlending && (additiveBlending = false);
                    void 0 === displayControl && (displayControl = true);
                    void 0 === pauseFadeOut && (pauseFadeOut = true);
                    void 0 === pauseFadeIn && (pauseFadeIn = true);
                    var animationData = this._animations[animationName];
                    if (!animationData) {
                        this._time = 0;
                        this._duration = 0;
                        console.warn("Non-existent animation.", "DragonBones: " + this._armature.armatureData.parent.name, "Armature: " + this._armature.name, "Animation: " + animationName);
                        return null;
                    }
                    this._isPlaying = true;
                    this._time != this._time && (this._time = 0);
                    this._duration != this._duration && (this._duration = 0);
                    (fadeInTime != fadeInTime || fadeInTime < 0) && (fadeInTime = this._lastAnimationState ? animationData.fadeInTime : 0);
                    playTimes < 0 && (playTimes = animationData.playTimes);
                    this._fadeOut(fadeInTime, layer, group, fadeOutMode, pauseFadeOut);
                    var time = this._duration > 0 ? 0 : this._time;
                    var position = this._duration > 0 ? this._time : animationData.position;
                    var duration = this._duration > 0 ? this._duration : animationData.duration;
                    this._lastAnimationState = dragonBones.BaseObject.borrowObject(dragonBones.AnimationState);
                    this._lastAnimationState._layer = layer;
                    this._lastAnimationState._group = group;
                    this._lastAnimationState.additiveBlending = additiveBlending;
                    this._lastAnimationState.displayControl = displayControl;
                    this._lastAnimationState._fadeIn(this._armature, animationData.animation || animationData, animationName, playTimes, position, duration, time, 1 / animationData.scale, fadeInTime, pauseFadeIn);
                    this._animationStates.push(this._lastAnimationState);
                    this._animationStateDirty = true;
                    this._time = 0;
                    this._duration = 0;
                    this._armature._cacheFrameIndex = -1;
                    this._animationStates.length > 1 && this._animationStates.sort(Animation._sortAnimationState);
                    var slots = this._armature.getSlots();
                    for (var i = 0, l = slots.length; i < l; ++i) {
                        var slot = slots[i];
                        if (slot.inheritAnimation) {
                            var childArmature = slot.childArmature;
                            childArmature && childArmature.animation.hasAnimation(animationName) && !childArmature.animation.getState(animationName) && childArmature.animation.fadeIn(animationName);
                        }
                    }
                    fadeInTime <= 0 && this._armature.advanceTime(0);
                    return this._lastAnimationState;
                };
                Animation.prototype.gotoAndPlayByTime = function(animationName, time, playTimes, toTime) {
                    void 0 === time && (time = 0);
                    void 0 === playTimes && (playTimes = -1);
                    void 0 === toTime && (toTime = 0);
                    var animationData = this._animations[animationName];
                    if (animationData) {
                        this._time = time;
                        this._duration = toTime - time;
                        this._duration < 0 ? this._duration = 0 : this._duration > animationData.duration - this._time && (this._duration = animationData.duration - this._time);
                    }
                    return this.fadeIn(animationName, 0, playTimes, 0, null, 4);
                };
                Animation.prototype.gotoAndPlayByFrame = function(animationName, frame, playTimes, toFrame) {
                    void 0 === frame && (frame = 0);
                    void 0 === playTimes && (playTimes = -1);
                    void 0 === toFrame && (toFrame = 0);
                    var animationData = this._animations[animationName];
                    if (animationData) {
                        this._time = animationData.duration * frame / animationData.frameCount;
                        this._duration < 0 ? this._duration = 0 : this._duration > animationData.duration - this._time && (this._duration = animationData.duration - this._time);
                    }
                    return this.fadeIn(animationName, 0, playTimes, 0, null, 4);
                };
                Animation.prototype.gotoAndPlayByProgress = function(animationName, progress, playTimes, toProgress) {
                    void 0 === progress && (progress = 0);
                    void 0 === playTimes && (playTimes = -1);
                    void 0 === toProgress && (toProgress = 0);
                    var animationData = this._animations[animationName];
                    if (animationData) {
                        this._time = animationData.duration * (progress > 0 ? progress : 0);
                        this._duration < 0 ? this._duration = 0 : this._duration > animationData.duration - this._time && (this._duration = animationData.duration - this._time);
                    }
                    return this.fadeIn(animationName, 0, playTimes, 0, null, 4);
                };
                Animation.prototype.gotoAndStopByTime = function(animationName, time) {
                    void 0 === time && (time = 0);
                    var animationState = this.gotoAndPlayByTime(animationName, time, 1);
                    animationState && animationState.stop();
                    return animationState;
                };
                Animation.prototype.gotoAndStopByFrame = function(animationName, frame) {
                    void 0 === frame && (frame = 0);
                    var animationState = this.gotoAndPlayByFrame(animationName, frame, 1);
                    animationState && animationState.stop();
                    return animationState;
                };
                Animation.prototype.gotoAndStopByProgress = function(animationName, progress) {
                    void 0 === progress && (progress = 0);
                    var animationState = this.gotoAndPlayByProgress(animationName, progress, 1);
                    animationState && animationState.stop();
                    return animationState;
                };
                Animation.prototype.getState = function(animationName) {
                    for (var i = 0, l = this._animationStates.length; i < l; ++i) {
                        var animationState = this._animationStates[i];
                        if (animationState.name == animationName) {
                            return animationState;
                        }
                    }
                    return null;
                };
                Animation.prototype.hasAnimation = function(animationName) {
                    return null != this._animations[animationName];
                };
                Object.defineProperty(Animation.prototype, "isPlaying", {
                    get: function() {
                        if (this._animationStates.length > 1) {
                            return this._isPlaying && !this.isCompleted;
                        }
                        if (this._lastAnimationState) {
                            return this._isPlaying && this._lastAnimationState.isPlaying;
                        }
                        return this._isPlaying;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Animation.prototype, "isCompleted", {
                    get: function() {
                        if (this._lastAnimationState) {
                            if (!this._lastAnimationState.isCompleted) {
                                return false;
                            }
                            for (var i = 0, l = this._animationStates.length; i < l; ++i) {
                                if (!this._animationStates[i].isCompleted) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        return false;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Animation.prototype, "lastAnimationName", {
                    get: function() {
                        return this._lastAnimationState ? this._lastAnimationState.name : null;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Animation.prototype, "lastAnimationState", {
                    get: function() {
                        return this._lastAnimationState;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Animation.prototype, "animationNames", {
                    get: function() {
                        return this._animationNames;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Animation.prototype, "animations", {
                    get: function() {
                        return this._animations;
                    },
                    set: function(value) {
                        if (this._animations == value) {
                            return;
                        }
                        for (var i in this._animations) {
                            delete this._animations[i];
                        }
                        this._animationNames.length = 0;
                        if (value) {
                            for (var i in value) {
                                this._animations[i] = value[i];
                                this._animationNames.push(i);
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Animation.prototype.gotoAndPlay = function(animationName, fadeInTime, duration, playTimes, layer, group, fadeOutMode, pauseFadeOut, pauseFadeIn) {
                    void 0 === fadeInTime && (fadeInTime = -1);
                    void 0 === duration && (duration = -1);
                    void 0 === playTimes && (playTimes = -1);
                    void 0 === layer && (layer = 0);
                    void 0 === group && (group = null);
                    void 0 === fadeOutMode && (fadeOutMode = 3);
                    void 0 === pauseFadeOut && (pauseFadeOut = true);
                    void 0 === pauseFadeIn && (pauseFadeIn = true);
                    var animationState = this.fadeIn(animationName, fadeInTime, playTimes, layer, group, fadeOutMode, false, true, pauseFadeOut, pauseFadeIn);
                    animationState && duration && duration > 0 && (animationState.timeScale = animationState.totalTime / duration);
                    return animationState;
                };
                Animation.prototype.gotoAndStop = function(animationName, time) {
                    void 0 === time && (time = 0);
                    return this.gotoAndStopByTime(animationName, time);
                };
                Object.defineProperty(Animation.prototype, "animationList", {
                    get: function() {
                        return this._animationNames;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Animation.prototype, "animationDataList", {
                    get: function() {
                        var list = [];
                        for (var i = 0, l = this._animationNames.length; i < l; ++i) {
                            list.push(this._animations[this._animationNames[i]]);
                        }
                        return list;
                    },
                    enumerable: true,
                    configurable: true
                });
                return Animation;
            })(dragonBones.BaseObject);
            dragonBones.Animation = Animation;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var AnimationState = (function(_super) {
                __extends(AnimationState, _super);
                function AnimationState() {
                    _super.call(this);
                    this._boneMask = [];
                    this._boneTimelines = [];
                    this._slotTimelines = [];
                    this._ffdTimelines = [];
                    this.autoTween = false;
                }
                AnimationState.toString = function() {
                    return "[class dragonBones.AnimationState]";
                };
                AnimationState.prototype._onClear = function() {
                    for (var i = 0, l = this._boneTimelines.length; i < l; ++i) {
                        this._boneTimelines[i].returnToPool();
                    }
                    for (var i = 0, l = this._slotTimelines.length; i < l; ++i) {
                        this._slotTimelines[i].returnToPool();
                    }
                    for (var i = 0, l = this._ffdTimelines.length; i < l; ++i) {
                        this._ffdTimelines[i].returnToPool();
                    }
                    this._timeline && this._timeline.returnToPool();
                    this._zOrderTimeline && this._zOrderTimeline.returnToPool();
                    this.displayControl = true;
                    this.additiveBlending = false;
                    this.actionEnabled = false;
                    this.playTimes = 1;
                    this.timeScale = 1;
                    this.weight = 1;
                    this.autoFadeOutTime = -1;
                    this.fadeTotalTime = 0;
                    this._onFadeInComplete = false;
                    this._fadeState = 0;
                    this._layer = 0;
                    this._position = 0;
                    this._duration = 0;
                    this._weightResult = 0;
                    this._fadeProgress = 0;
                    this._group = null;
                    this._timeline = null;
                    this._isPlaying = true;
                    this._isPausePlayhead = false;
                    this._fadeTime = 0;
                    this._time = 0;
                    this._name = null;
                    this._armature = null;
                    this._animationData = null;
                    this._zOrderTimeline = null;
                    this._boneMask.length = 0;
                    this._boneTimelines.length = 0;
                    this._slotTimelines.length = 0;
                    this._ffdTimelines.length = 0;
                };
                AnimationState.prototype._updateTimelineStates = function() {
                    var time = this._time;
                    this._animationData.hasAsynchronyTimeline || (time = this._timeline._currentTime);
                    var boneTimelineStates = {};
                    var slotTimelineStates = {};
                    for (var i = 0, l = this._boneTimelines.length; i < l; ++i) {
                        var boneTimelineState = this._boneTimelines[i];
                        boneTimelineStates[boneTimelineState.bone.name] = boneTimelineState;
                    }
                    var bones = this._armature.getBones();
                    for (var i = 0, l = bones.length; i < l; ++i) {
                        var bone = bones[i];
                        var boneTimelineName = bone.name;
                        var boneTimelineData = this._animationData.getBoneTimeline(boneTimelineName);
                        if (boneTimelineData && this.containsBoneMask(boneTimelineName)) {
                            var boneTimelineState = boneTimelineStates[boneTimelineName];
                            if (boneTimelineState) {
                                delete boneTimelineStates[boneTimelineName];
                            } else {
                                boneTimelineState = dragonBones.BaseObject.borrowObject(dragonBones.BoneTimelineState);
                                boneTimelineState.bone = bone;
                                boneTimelineState.fadeIn(this._armature, this, boneTimelineData, time);
                                this._boneTimelines.push(boneTimelineState);
                            }
                        }
                    }
                    for (var i in boneTimelineStates) {
                        var boneTimelineState = boneTimelineStates[i];
                        boneTimelineState.bone.invalidUpdate();
                        this._boneTimelines.splice(this._boneTimelines.indexOf(boneTimelineState), 1);
                        boneTimelineState.returnToPool();
                    }
                    for (var i = 0, l = this._slotTimelines.length; i < l; ++i) {
                        var slotTimelineState = this._slotTimelines[i];
                        slotTimelineStates[slotTimelineState.slot.name] = slotTimelineState;
                    }
                    var slots = this._armature.getSlots();
                    for (var i = 0, l = slots.length; i < l; ++i) {
                        var slot = slots[i];
                        var slotTimelineName = slot.name;
                        var parentTimelineName = slot.parent.name;
                        var slotTimelineData = this._animationData.getSlotTimeline(slotTimelineName);
                        if (slotTimelineData && this.containsBoneMask(parentTimelineName) && this._fadeState <= 0) {
                            var slotTimelineState = slotTimelineStates[slotTimelineName];
                            if (slotTimelineState) {
                                delete slotTimelineStates[slotTimelineName];
                            } else {
                                slotTimelineState = dragonBones.BaseObject.borrowObject(dragonBones.SlotTimelineState);
                                slotTimelineState.slot = slot;
                                slotTimelineState.fadeIn(this._armature, this, slotTimelineData, time);
                                this._slotTimelines.push(slotTimelineState);
                            }
                        }
                    }
                    for (var i in slotTimelineStates) {
                        var slotTimelineState = slotTimelineStates[i];
                        this._slotTimelines.splice(this._slotTimelines.indexOf(slotTimelineState), 1);
                        slotTimelineState.returnToPool();
                    }
                    this._updateFFDTimelineStates();
                };
                AnimationState.prototype._advanceFadeTime = function(passedTime) {
                    var self = this;
                    passedTime < 0 && (passedTime = -passedTime);
                    self._fadeTime += passedTime;
                    var fadeProgress = 0;
                    fadeProgress = self._fadeTime >= self.fadeTotalTime ? self._fadeState > 0 ? 0 : 1 : self._fadeTime > 0 ? self._fadeState > 0 ? 1 - self._fadeTime / self.fadeTotalTime : self._fadeTime / self.fadeTotalTime : self._fadeState > 0 ? 1 : 0;
                    if (self._fadeProgress != fadeProgress) {
                        self._fadeProgress = fadeProgress;
                        var eventDispatcher = self._armature._display;
                        if (self._fadeTime <= passedTime) {
                            if (self._fadeState > 0) {
                                if (eventDispatcher.hasEvent(dragonBones.EventObject.FADE_OUT)) {
                                    var event_1 = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                                    event_1.animationState = this;
                                    self._armature._bufferEvent(event_1, dragonBones.EventObject.FADE_OUT);
                                }
                            } else {
                                if (eventDispatcher.hasEvent(dragonBones.EventObject.FADE_IN)) {
                                    var event_2 = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                                    event_2.animationState = this;
                                    self._armature._bufferEvent(event_2, dragonBones.EventObject.FADE_IN);
                                }
                            }
                        }
                        if (self._fadeTime >= self.fadeTotalTime) {
                            if (self._fadeState > 0) {
                                if (eventDispatcher.hasEvent(dragonBones.EventObject.FADE_OUT_COMPLETE)) {
                                    var event_3 = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                                    event_3.animationState = this;
                                    self._armature._bufferEvent(event_3, dragonBones.EventObject.FADE_OUT_COMPLETE);
                                }
                            } else {
                                self._onFadeInComplete = true;
                                self._isPausePlayhead = false;
                                self._fadeState = 0;
                                if (eventDispatcher.hasEvent(dragonBones.EventObject.FADE_IN_COMPLETE)) {
                                    var event_4 = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                                    event_4.animationState = this;
                                    self._armature._bufferEvent(event_4, dragonBones.EventObject.FADE_IN_COMPLETE);
                                }
                            }
                        }
                    }
                };
                AnimationState.prototype._isDisabled = function(slot) {
                    if (this.displayControl && (!slot.displayController || slot.displayController == this._name || slot.displayController == this._group)) {
                        return false;
                    }
                    return true;
                };
                AnimationState.prototype._fadeIn = function(armature, clip, animationName, playTimes, position, duration, time, timeScale, fadeInTime, pausePlayhead) {
                    this._armature = armature;
                    this._animationData = clip;
                    this._name = animationName;
                    this.actionEnabled = AnimationState.stateActionEnabled;
                    this.playTimes = playTimes;
                    this.timeScale = timeScale;
                    this.fadeTotalTime = fadeInTime;
                    this._fadeState = -1;
                    this._position = position;
                    this._duration = duration;
                    this._time = time;
                    this._isPausePlayhead = pausePlayhead;
                    this.fadeTotalTime <= 0 && (this._fadeProgress = .999999);
                    this._timeline = dragonBones.BaseObject.borrowObject(dragonBones.AnimationTimelineState);
                    this._timeline.fadeIn(this._armature, this, this._animationData, this._time);
                    if (this._animationData.zOrderTimeline) {
                        this._zOrderTimeline = dragonBones.BaseObject.borrowObject(dragonBones.ZOrderTimelineState);
                        this._zOrderTimeline.fadeIn(this._armature, this, this._animationData.zOrderTimeline, this._time);
                    }
                    this._updateTimelineStates();
                };
                AnimationState.prototype._updateFFDTimelineStates = function() {
                    var time = this._time;
                    this._animationData.hasAsynchronyTimeline || (time = this._timeline._currentTime);
                    var ffdTimelineStates = {};
                    for (var i = 0, l = this._ffdTimelines.length; i < l; ++i) {
                        var ffdTimelineState = this._ffdTimelines[i];
                        ffdTimelineStates[ffdTimelineState.slot.name] = ffdTimelineState;
                    }
                    var slots = this._armature.getSlots();
                    for (var i = 0, l = slots.length; i < l; ++i) {
                        var slot = slots[i];
                        var slotTimelineName = slot.name;
                        var parentTimelineName = slot.parent.name;
                        var displayData = slot.displayData;
                        if (!displayData) {
                            continue;
                        }
                        if (slot._meshData && slot._meshData == displayData.mesh) {
                            var ffdTimelineData = this._animationData.getFFDTimeline(this._armature._skinData.name, slotTimelineName, displayData.share && displayData.inheritAnimation ? displayData.share.name : displayData.name);
                            if (ffdTimelineData && this.containsBoneMask(parentTimelineName)) {
                                var ffdTimelineState = ffdTimelineStates[slotTimelineName];
                                if (ffdTimelineState && ffdTimelineState._timeline == ffdTimelineData) {
                                    delete ffdTimelineStates[slotTimelineName];
                                } else {
                                    ffdTimelineState = dragonBones.BaseObject.borrowObject(dragonBones.FFDTimelineState);
                                    ffdTimelineState.slot = slot;
                                    ffdTimelineState.fadeIn(this._armature, this, ffdTimelineData, time);
                                    this._ffdTimelines.push(ffdTimelineState);
                                }
                            } else {
                                for (var iF = 0, lF = slot._ffdVertices.length; iF < lF; ++iF) {
                                    slot._ffdVertices[iF] = 0;
                                }
                                slot._ffdDirty = true;
                            }
                        }
                    }
                    for (var i in ffdTimelineStates) {
                        var ffdTimelineState = ffdTimelineStates[i];
                        this._ffdTimelines.splice(this._ffdTimelines.indexOf(ffdTimelineState), 1);
                        ffdTimelineState.returnToPool();
                    }
                };
                AnimationState.prototype._advanceTime = function(passedTime, weightLeft, index) {
                    var self = this;
                    self._onFadeInComplete = false;
                    0 != self._fadeState && self._advanceFadeTime(passedTime);
                    passedTime *= self.timeScale;
                    0 != passedTime && self._isPlaying && !self._isPausePlayhead && (self._time += passedTime);
                    self._weightResult = self.weight * self._fadeProgress * weightLeft;
                    if (0 != self._weightResult) {
                        var cacheFrameRate = self._animationData.cacheFrameRate;
                        var isCacheEnabled = self._fadeProgress >= 1 && 0 == index && cacheFrameRate > 0;
                        var isUpdatesTimeline = true;
                        var isUpdatesBoneTimeline = true;
                        var time = 2 * cacheFrameRate;
                        time = isCacheEnabled ? Math.floor(self._time * time) / time : self._time;
                        self._timeline.update(time);
                        self._animationData.hasAsynchronyTimeline || (time = self._timeline._currentTime);
                        self._zOrderTimeline && self._zOrderTimeline.update(time);
                        if (isCacheEnabled) {
                            var cacheFrameIndex = Math.floor(self._timeline._currentTime * cacheFrameRate);
                            if (self._armature._cacheFrameIndex == cacheFrameIndex) {
                                isUpdatesTimeline = false;
                                isUpdatesBoneTimeline = false;
                            } else {
                                self._armature._cacheFrameIndex = cacheFrameIndex;
                                if (self._armature._animation._animationStateDirty) {
                                    self._armature._animation._animationStateDirty = false;
                                    for (var i = 0, l = self._boneTimelines.length; i < l; ++i) {
                                        var boneTimeline = self._boneTimelines[i];
                                        boneTimeline.bone._cacheFrames = boneTimeline._timeline.cachedFrames;
                                    }
                                    for (var i = 0, l = self._slotTimelines.length; i < l; ++i) {
                                        var slotTimeline = self._slotTimelines[i];
                                        slotTimeline.slot._cacheFrames = slotTimeline._timeline.cachedFrames;
                                    }
                                }
                                self._animationData.cachedFrames[cacheFrameIndex] ? isUpdatesBoneTimeline = false : self._animationData.cachedFrames[cacheFrameIndex] = true;
                            }
                        } else {
                            self._armature._cacheFrameIndex = -1;
                        }
                        if (isUpdatesTimeline) {
                            if (isUpdatesBoneTimeline) {
                                for (var i = 0, l = self._boneTimelines.length; i < l; ++i) {
                                    self._boneTimelines[i].update(time);
                                }
                            }
                            for (var i = 0, l = self._slotTimelines.length; i < l; ++i) {
                                self._slotTimelines[i].update(time);
                            }
                            for (var i = 0, l = self._ffdTimelines.length; i < l; ++i) {
                                self._ffdTimelines[i].update(time);
                            }
                        }
                    }
                    self.autoFadeOutTime >= 0 && self._fadeProgress >= 1 && self._timeline._isCompleted && self.fadeOut(self.autoFadeOutTime);
                };
                AnimationState.prototype.play = function() {
                    this._isPlaying = true;
                };
                AnimationState.prototype.stop = function() {
                    this._isPlaying = false;
                };
                AnimationState.prototype.fadeOut = function(fadeOutTime, pausePlayhead) {
                    void 0 === pausePlayhead && (pausePlayhead = true);
                    (fadeOutTime < 0 || fadeOutTime != fadeOutTime) && (fadeOutTime = 0);
                    this._isPausePlayhead = pausePlayhead;
                    if (this._fadeState > 0) {
                        if (fadeOutTime > fadeOutTime - this._fadeTime) {
                            return;
                        }
                    } else {
                        this._fadeState = 1;
                        (fadeOutTime <= 0 || this._fadeProgress <= 0) && (this._fadeProgress = 1e-6);
                        for (var i = 0, l = this._boneTimelines.length; i < l; ++i) {
                            this._boneTimelines[i].fadeOut();
                        }
                        for (var i = 0, l = this._slotTimelines.length; i < l; ++i) {
                            this._slotTimelines[i].fadeOut();
                        }
                    }
                    this.displayControl = false;
                    this.fadeTotalTime = this._fadeProgress > 1e-6 ? fadeOutTime / this._fadeProgress : 0;
                    this._fadeTime = this.fadeTotalTime * (1 - this._fadeProgress);
                };
                AnimationState.prototype.containsBoneMask = function(name) {
                    return !this._boneMask.length || this._boneMask.indexOf(name) >= 0;
                };
                AnimationState.prototype.addBoneMask = function(name, recursive) {
                    void 0 === recursive && (recursive = true);
                    var currentBone = this._armature.getBone(name);
                    if (!currentBone) {
                        return;
                    }
                    this._boneMask.indexOf(name) < 0 && this._animationData.getBoneTimeline(name) && this._boneMask.push(name);
                    if (recursive) {
                        var bones = this._armature.getBones();
                        for (var i = 0, l = bones.length; i < l; ++i) {
                            var bone = bones[i];
                            var boneName = bone.name;
                            this._boneMask.indexOf(boneName) < 0 && this._animationData.getBoneTimeline(boneName) && currentBone.contains(bone) && this._boneMask.push(boneName);
                        }
                    }
                    this._updateTimelineStates();
                };
                AnimationState.prototype.removeBoneMask = function(name, recursive) {
                    void 0 === recursive && (recursive = true);
                    var index = this._boneMask.indexOf(name);
                    index >= 0 && this._boneMask.splice(index, 1);
                    if (recursive) {
                        var currentBone = this._armature.getBone(name);
                        if (currentBone) {
                            var bones = this._armature.getBones();
                            for (var i = 0, l = bones.length; i < l; ++i) {
                                var bone = bones[i];
                                var boneName = bone.name;
                                var index_1 = this._boneMask.indexOf(boneName);
                                index_1 >= 0 && currentBone.contains(bone) && this._boneMask.splice(index_1, 1);
                            }
                        }
                    }
                    this._updateTimelineStates();
                };
                AnimationState.prototype.removeAllBoneMask = function() {
                    this._boneMask.length = 0;
                    this._updateTimelineStates();
                };
                Object.defineProperty(AnimationState.prototype, "layer", {
                    get: function() {
                        return this._layer;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AnimationState.prototype, "group", {
                    get: function() {
                        return this._group;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AnimationState.prototype, "name", {
                    get: function() {
                        return this._name;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AnimationState.prototype, "animationData", {
                    get: function() {
                        return this._animationData;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AnimationState.prototype, "isCompleted", {
                    get: function() {
                        return this._timeline._isCompleted;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AnimationState.prototype, "isPlaying", {
                    get: function() {
                        return this._isPlaying && !this._timeline._isCompleted;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AnimationState.prototype, "currentPlayTimes", {
                    get: function() {
                        return this._timeline._currentPlayTimes;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AnimationState.prototype, "totalTime", {
                    get: function() {
                        return this._duration;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AnimationState.prototype, "currentTime", {
                    get: function() {
                        return this._timeline._currentTime;
                    },
                    set: function(value) {
                        (value < 0 || value != value) && (value = 0);
                        var currentPlayTimes = this._timeline._currentPlayTimes - (this._timeline._isCompleted ? 1 : 0);
                        value = value % this._duration + currentPlayTimes * this._duration;
                        if (this._time == value) {
                            return;
                        }
                        this._time = value;
                        this._timeline.setCurrentTime(this._time);
                        this._zOrderTimeline && (this._zOrderTimeline._isCompleted = false);
                        for (var i = 0, l = this._boneTimelines.length; i < l; ++i) {
                            this._boneTimelines[i]._isCompleted = false;
                        }
                        for (var i = 0, l = this._slotTimelines.length; i < l; ++i) {
                            this._slotTimelines[i]._isCompleted = false;
                        }
                        for (var i = 0, l = this._ffdTimelines.length; i < l; ++i) {
                            this._ffdTimelines[i]._isCompleted = false;
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(AnimationState.prototype, "clip", {
                    get: function() {
                        return this._animationData;
                    },
                    enumerable: true,
                    configurable: true
                });
                AnimationState.stateActionEnabled = true;
                return AnimationState;
            })(dragonBones.BaseObject);
            dragonBones.AnimationState = AnimationState;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var AnimationTimelineState = (function(_super) {
                __extends(AnimationTimelineState, _super);
                function AnimationTimelineState() {
                    _super.call(this);
                }
                AnimationTimelineState.toString = function() {
                    return "[class dragonBones.AnimationTimelineState]";
                };
                AnimationTimelineState.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this._isStarted = false;
                };
                AnimationTimelineState.prototype._onCrossFrame = function(frame) {
                    var self = this;
                    if (self._animationState._fadeState < 0) {
                        return;
                    }
                    if (self._animationState.actionEnabled) {
                        var actions = frame.actions;
                        for (var i = 0, l = actions.length; i < l; ++i) {
                            self._armature._bufferAction(actions[i]);
                        }
                    }
                    var eventDispatcher = self._armature._display;
                    var events = frame.events;
                    for (var i = 0, l = events.length; i < l; ++i) {
                        var eventData = events[i];
                        var eventType = "";
                        switch (eventData.type) {
                          case 10:
                            eventType = dragonBones.EventObject.FRAME_EVENT;
                            break;

                          case 11:
                            eventType = dragonBones.EventObject.SOUND_EVENT;
                        }
                        if ((11 == eventData.type ? self._armature._eventManager : eventDispatcher).hasEvent(eventType)) {
                            var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                            eventObject.name = eventData.name;
                            eventObject.animationState = self._animationState;
                            eventObject.frame = frame;
                            eventObject.data = eventData;
                            eventData.bone && (eventObject.bone = self._armature.getBone(eventData.bone.name));
                            eventData.slot && (eventObject.slot = self._armature.getSlot(eventData.slot.name));
                            self._armature._bufferEvent(eventObject, eventType);
                        }
                    }
                };
                AnimationTimelineState.prototype.fadeIn = function(armature, animationState, timelineData, time) {
                    _super.prototype.fadeIn.call(this, armature, animationState, timelineData, time);
                    this._currentTime = time;
                };
                AnimationTimelineState.prototype.update = function(time) {
                    var self = this;
                    var prevTime = self._currentTime;
                    var prevPlayTimes = self._currentPlayTimes;
                    if (!self._isCompleted && self._setCurrentTime(time)) {
                        var eventDispatcher = self._armature._display;
                        if (!self._isStarted) {
                            self._isStarted = true;
                            if (eventDispatcher.hasEvent(dragonBones.EventObject.START)) {
                                var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                                eventObject.animationState = self._animationState;
                                self._armature._bufferEvent(eventObject, dragonBones.EventObject.START);
                            }
                        }
                        if (self._keyFrameCount > 0) {
                            var currentFrameIndex = self._keyFrameCount > 1 ? Math.floor(self._currentTime * self._frameRate) : 0;
                            var currentFrame = self._timeline.frames[currentFrameIndex];
                            if (self._currentFrame != currentFrame) {
                                if (self._keyFrameCount > 1) {
                                    var crossedFrame = self._currentFrame;
                                    self._currentFrame = currentFrame;
                                    if (!crossedFrame) {
                                        var prevFrameIndex = Math.floor(prevTime * self._frameRate);
                                        crossedFrame = self._timeline.frames[prevFrameIndex];
                                        self._isReverse || (prevTime <= crossedFrame.position || prevPlayTimes != self._currentPlayTimes) && (crossedFrame = crossedFrame.prev);
                                    }
                                    if (self._isReverse) {
                                        while (crossedFrame != currentFrame) {
                                            self._onCrossFrame(crossedFrame);
                                            crossedFrame = crossedFrame.prev;
                                        }
                                    } else {
                                        while (crossedFrame != currentFrame) {
                                            crossedFrame = crossedFrame.next;
                                            self._onCrossFrame(crossedFrame);
                                        }
                                    }
                                } else {
                                    self._currentFrame = currentFrame;
                                    self._onCrossFrame(self._currentFrame);
                                }
                            }
                        }
                        if (prevPlayTimes != self._currentPlayTimes) {
                            if (eventDispatcher.hasEvent(dragonBones.EventObject.LOOP_COMPLETE)) {
                                var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                                eventObject.animationState = self._animationState;
                                self._armature._bufferEvent(eventObject, dragonBones.EventObject.LOOP_COMPLETE);
                            }
                            if (self._isCompleted && eventDispatcher.hasEvent(dragonBones.EventObject.COMPLETE)) {
                                var eventObject = dragonBones.BaseObject.borrowObject(dragonBones.EventObject);
                                eventObject.animationState = self._animationState;
                                self._armature._bufferEvent(eventObject, dragonBones.EventObject.COMPLETE);
                            }
                            self._currentFrame = null;
                        }
                    }
                };
                AnimationTimelineState.prototype.setCurrentTime = function(value) {
                    this._setCurrentTime(value);
                    this._currentFrame = null;
                };
                return AnimationTimelineState;
            })(dragonBones.TimelineState);
            dragonBones.AnimationTimelineState = AnimationTimelineState;
            var ZOrderTimelineState = (function(_super) {
                __extends(ZOrderTimelineState, _super);
                function ZOrderTimelineState() {
                    _super.call(this);
                }
                ZOrderTimelineState.toString = function() {
                    return "[class dragonBones.ZOrderTimelineState]";
                };
                ZOrderTimelineState.prototype._onArriveAtFrame = function(isUpdate) {
                    var self = this;
                    _super.prototype._onArriveAtFrame.call(this, isUpdate);
                    self._armature._sortZOrder(self._currentFrame.zOrder);
                };
                return ZOrderTimelineState;
            })(dragonBones.TimelineState);
            dragonBones.ZOrderTimelineState = ZOrderTimelineState;
            var BoneTimelineState = (function(_super) {
                __extends(BoneTimelineState, _super);
                function BoneTimelineState() {
                    _super.call(this);
                    this._transform = new dragonBones.Transform();
                    this._currentTransform = new dragonBones.Transform();
                    this._durationTransform = new dragonBones.Transform();
                }
                BoneTimelineState.toString = function() {
                    return "[class dragonBones.BoneTimelineState]";
                };
                BoneTimelineState.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this.bone = null;
                    this._tweenTransform = 0;
                    this._tweenRotate = 0;
                    this._tweenScale = 0;
                    this._boneTransform = null;
                    this._originalTransform = null;
                    this._transform.identity();
                    this._currentTransform.identity();
                    this._durationTransform.identity();
                };
                BoneTimelineState.prototype._onArriveAtFrame = function(isUpdate) {
                    var self = this;
                    _super.prototype._onArriveAtFrame.call(this, isUpdate);
                    self._currentTransform.copyFrom(self._currentFrame.transform);
                    self._tweenTransform = 1;
                    self._tweenRotate = 1;
                    self._tweenScale = 1;
                    if (self._keyFrameCount > 1 && (self._tweenEasing != dragonBones.DragonBones.NO_TWEEN || self._curve)) {
                        var nextFrame = self._currentFrame.next;
                        var nextTransform = nextFrame.transform;
                        self._durationTransform.x = nextTransform.x - self._currentTransform.x;
                        self._durationTransform.y = nextTransform.y - self._currentTransform.y;
                        0 == self._durationTransform.x && 0 == self._durationTransform.y || (self._tweenTransform = 2);
                        var tweenRotate = self._currentFrame.tweenRotate;
                        if (tweenRotate == tweenRotate) {
                            if (tweenRotate) {
                                if (tweenRotate > 0 ? nextTransform.skewY >= self._currentTransform.skewY : nextTransform.skewY <= self._currentTransform.skewY) {
                                    var rotate = tweenRotate > 0 ? tweenRotate - 1 : tweenRotate + 1;
                                    self._durationTransform.skewX = nextTransform.skewX - self._currentTransform.skewX + dragonBones.DragonBones.PI_D * rotate;
                                    self._durationTransform.skewY = nextTransform.skewY - self._currentTransform.skewY + dragonBones.DragonBones.PI_D * rotate;
                                } else {
                                    self._durationTransform.skewX = nextTransform.skewX - self._currentTransform.skewX + dragonBones.DragonBones.PI_D * tweenRotate;
                                    self._durationTransform.skewY = nextTransform.skewY - self._currentTransform.skewY + dragonBones.DragonBones.PI_D * tweenRotate;
                                }
                            } else {
                                self._durationTransform.skewX = dragonBones.Transform.normalizeRadian(nextTransform.skewX - self._currentTransform.skewX);
                                self._durationTransform.skewY = dragonBones.Transform.normalizeRadian(nextTransform.skewY - self._currentTransform.skewY);
                            }
                            0 == self._durationTransform.skewX && 0 == self._durationTransform.skewY || (self._tweenRotate = 2);
                        } else {
                            self._durationTransform.skewX = 0;
                            self._durationTransform.skewY = 0;
                        }
                        if (self._currentFrame.tweenScale) {
                            self._durationTransform.scaleX = nextTransform.scaleX - self._currentTransform.scaleX;
                            self._durationTransform.scaleY = nextTransform.scaleY - self._currentTransform.scaleY;
                            0 == self._durationTransform.scaleX && 0 == self._durationTransform.scaleY || (self._tweenScale = 2);
                        } else {
                            self._durationTransform.scaleX = 0;
                            self._durationTransform.scaleY = 0;
                        }
                    } else {
                        self._durationTransform.x = 0;
                        self._durationTransform.y = 0;
                        self._durationTransform.skewX = 0;
                        self._durationTransform.skewY = 0;
                        self._durationTransform.scaleX = 0;
                        self._durationTransform.scaleY = 0;
                    }
                };
                BoneTimelineState.prototype._onUpdateFrame = function(isUpdate) {
                    var self = this;
                    if (self._tweenTransform || self._tweenRotate || self._tweenScale) {
                        _super.prototype._onUpdateFrame.call(this, isUpdate);
                        var tweenProgress = 0;
                        if (self._tweenTransform) {
                            if (1 == self._tweenTransform) {
                                self._tweenTransform = 0;
                                tweenProgress = 0;
                            } else {
                                tweenProgress = self._tweenProgress;
                            }
                            if (self._animationState.additiveBlending) {
                                self._transform.x = self._currentTransform.x + self._durationTransform.x * tweenProgress;
                                self._transform.y = self._currentTransform.y + self._durationTransform.y * tweenProgress;
                            } else {
                                self._transform.x = self._originalTransform.x + self._currentTransform.x + self._durationTransform.x * tweenProgress;
                                self._transform.y = self._originalTransform.y + self._currentTransform.y + self._durationTransform.y * tweenProgress;
                            }
                        }
                        if (self._tweenRotate) {
                            if (1 == self._tweenRotate) {
                                self._tweenRotate = 0;
                                tweenProgress = 0;
                            } else {
                                tweenProgress = self._tweenProgress;
                            }
                            if (self._animationState.additiveBlending) {
                                self._transform.skewX = self._currentTransform.skewX + self._durationTransform.skewX * tweenProgress;
                                self._transform.skewY = self._currentTransform.skewY + self._durationTransform.skewY * tweenProgress;
                            } else {
                                self._transform.skewX = self._originalTransform.skewX + self._currentTransform.skewX + self._durationTransform.skewX * tweenProgress;
                                self._transform.skewY = self._originalTransform.skewY + self._currentTransform.skewY + self._durationTransform.skewY * tweenProgress;
                            }
                        }
                        if (self._tweenScale) {
                            if (1 == self._tweenScale) {
                                self._tweenScale = 0;
                                tweenProgress = 0;
                            } else {
                                tweenProgress = self._tweenProgress;
                            }
                            if (self._animationState.additiveBlending) {
                                self._transform.scaleX = self._currentTransform.scaleX + self._durationTransform.scaleX * tweenProgress;
                                self._transform.scaleY = self._currentTransform.scaleY + self._durationTransform.scaleY * tweenProgress;
                            } else {
                                self._transform.scaleX = self._originalTransform.scaleX * (self._currentTransform.scaleX + self._durationTransform.scaleX * tweenProgress);
                                self._transform.scaleY = self._originalTransform.scaleY * (self._currentTransform.scaleY + self._durationTransform.scaleY * tweenProgress);
                            }
                        }
                        self.bone.invalidUpdate();
                    }
                };
                BoneTimelineState.prototype.fadeIn = function(armature, animationState, timelineData, time) {
                    _super.prototype.fadeIn.call(this, armature, animationState, timelineData, time);
                    this._originalTransform = this._timeline.originalTransform;
                    this._boneTransform = this.bone._animationPose;
                };
                BoneTimelineState.prototype.fadeOut = function() {
                    this._transform.skewX = dragonBones.Transform.normalizeRadian(this._transform.skewX);
                    this._transform.skewY = dragonBones.Transform.normalizeRadian(this._transform.skewY);
                };
                BoneTimelineState.prototype.update = function(time) {
                    var self = this;
                    _super.prototype.update.call(this, time);
                    var weight = self._animationState._weightResult;
                    if (weight > 0) {
                        if (0 == self.bone._blendIndex) {
                            self._boneTransform.x = self._transform.x * weight;
                            self._boneTransform.y = self._transform.y * weight;
                            self._boneTransform.skewX = self._transform.skewX * weight;
                            self._boneTransform.skewY = self._transform.skewY * weight;
                            self._boneTransform.scaleX = (self._transform.scaleX - 1) * weight + 1;
                            self._boneTransform.scaleY = (self._transform.scaleY - 1) * weight + 1;
                        } else {
                            self._boneTransform.x += self._transform.x * weight;
                            self._boneTransform.y += self._transform.y * weight;
                            self._boneTransform.skewX += self._transform.skewX * weight;
                            self._boneTransform.skewY += self._transform.skewY * weight;
                            self._boneTransform.scaleX += (self._transform.scaleX - 1) * weight;
                            self._boneTransform.scaleY += (self._transform.scaleY - 1) * weight;
                        }
                        self.bone._blendIndex++;
                        0 != self._animationState._fadeState && self.bone.invalidUpdate();
                    }
                };
                return BoneTimelineState;
            })(dragonBones.TweenTimelineState);
            dragonBones.BoneTimelineState = BoneTimelineState;
            var SlotTimelineState = (function(_super) {
                __extends(SlotTimelineState, _super);
                function SlotTimelineState() {
                    _super.call(this);
                    this._color = new dragonBones.ColorTransform();
                    this._durationColor = new dragonBones.ColorTransform();
                }
                SlotTimelineState.toString = function() {
                    return "[class dragonBones.SlotTimelineState]";
                };
                SlotTimelineState.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this.slot = null;
                    this._colorDirty = false;
                    this._tweenColor = 0;
                    this._slotColor = null;
                    this._color.identity();
                    this._durationColor.identity();
                };
                SlotTimelineState.prototype._onArriveAtFrame = function(isUpdate) {
                    var self = this;
                    _super.prototype._onArriveAtFrame.call(this, isUpdate);
                    if (self._animationState._isDisabled(self.slot)) {
                        self._tweenEasing = dragonBones.DragonBones.NO_TWEEN;
                        self._curve = null;
                        self._tweenColor = 0;
                        return;
                    }
                    if (self._animationState._fadeState >= 0) {
                        self.slot._setDisplayIndex(self._currentFrame.displayIndex);
                        self.slot._updateMeshData(true);
                    }
                    self._tweenColor = 0;
                    var currentColor = self._currentFrame.color;
                    if (self._keyFrameCount > 1 && (self._tweenEasing != dragonBones.DragonBones.NO_TWEEN || self._curve)) {
                        var nextFrame = self._currentFrame.next;
                        var nextColor = nextFrame.color;
                        if (currentColor != nextColor && nextFrame.displayIndex >= 0) {
                            self._durationColor.alphaMultiplier = nextColor.alphaMultiplier - currentColor.alphaMultiplier;
                            self._durationColor.redMultiplier = nextColor.redMultiplier - currentColor.redMultiplier;
                            self._durationColor.greenMultiplier = nextColor.greenMultiplier - currentColor.greenMultiplier;
                            self._durationColor.blueMultiplier = nextColor.blueMultiplier - currentColor.blueMultiplier;
                            self._durationColor.alphaOffset = nextColor.alphaOffset - currentColor.alphaOffset;
                            self._durationColor.redOffset = nextColor.redOffset - currentColor.redOffset;
                            self._durationColor.greenOffset = nextColor.greenOffset - currentColor.greenOffset;
                            self._durationColor.blueOffset = nextColor.blueOffset - currentColor.blueOffset;
                            0 == self._durationColor.alphaMultiplier && 0 == self._durationColor.redMultiplier && 0 == self._durationColor.greenMultiplier && 0 == self._durationColor.blueMultiplier && 0 == self._durationColor.alphaOffset && 0 == self._durationColor.redOffset && 0 == self._durationColor.greenOffset && 0 == self._durationColor.blueOffset || (self._tweenColor = 2);
                        }
                    }
                    0 == self._tweenColor && (self._slotColor.alphaMultiplier == currentColor.alphaMultiplier && self._slotColor.redMultiplier == currentColor.redMultiplier && self._slotColor.greenMultiplier == currentColor.greenMultiplier && self._slotColor.blueMultiplier == currentColor.blueMultiplier && self._slotColor.alphaOffset == currentColor.alphaOffset && self._slotColor.redOffset == currentColor.redOffset && self._slotColor.greenOffset == currentColor.greenOffset && self._slotColor.blueOffset == currentColor.blueOffset || (self._tweenColor = 1));
                };
                SlotTimelineState.prototype._onUpdateFrame = function(isUpdate) {
                    var self = this;
                    _super.prototype._onUpdateFrame.call(this, isUpdate);
                    var tweenProgress = 0;
                    if (self._tweenColor) {
                        if (1 == self._tweenColor) {
                            self._tweenColor = 0;
                            tweenProgress = 0;
                        } else {
                            tweenProgress = self._tweenProgress;
                        }
                        var currentColor = self._currentFrame.color;
                        self._color.alphaMultiplier = currentColor.alphaMultiplier + self._durationColor.alphaMultiplier * tweenProgress;
                        self._color.redMultiplier = currentColor.redMultiplier + self._durationColor.redMultiplier * tweenProgress;
                        self._color.greenMultiplier = currentColor.greenMultiplier + self._durationColor.greenMultiplier * tweenProgress;
                        self._color.blueMultiplier = currentColor.blueMultiplier + self._durationColor.blueMultiplier * tweenProgress;
                        self._color.alphaOffset = currentColor.alphaOffset + self._durationColor.alphaOffset * tweenProgress;
                        self._color.redOffset = currentColor.redOffset + self._durationColor.redOffset * tweenProgress;
                        self._color.greenOffset = currentColor.greenOffset + self._durationColor.greenOffset * tweenProgress;
                        self._color.blueOffset = currentColor.blueOffset + self._durationColor.blueOffset * tweenProgress;
                        self._colorDirty = true;
                    }
                };
                SlotTimelineState.prototype.fadeIn = function(armature, animationState, timelineData, time) {
                    _super.prototype.fadeIn.call(this, armature, animationState, timelineData, time);
                    this._slotColor = this.slot._colorTransform;
                };
                SlotTimelineState.prototype.fadeOut = function() {
                    this._tweenColor = 0;
                };
                SlotTimelineState.prototype.update = function(time) {
                    var self = this;
                    _super.prototype.update.call(this, time);
                    if (0 != self._tweenColor || self._colorDirty) {
                        var weight = self._animationState._weightResult;
                        if (weight > 0) {
                            if (0 != self._animationState._fadeState) {
                                var fadeProgress = Math.pow(self._animationState._fadeProgress, 4);
                                self._slotColor.alphaMultiplier += (self._color.alphaMultiplier - self._slotColor.alphaMultiplier) * fadeProgress;
                                self._slotColor.redMultiplier += (self._color.redMultiplier - self._slotColor.redMultiplier) * fadeProgress;
                                self._slotColor.greenMultiplier += (self._color.greenMultiplier - self._slotColor.greenMultiplier) * fadeProgress;
                                self._slotColor.blueMultiplier += (self._color.blueMultiplier - self._slotColor.blueMultiplier) * fadeProgress;
                                self._slotColor.alphaOffset += (self._color.alphaOffset - self._slotColor.alphaOffset) * fadeProgress;
                                self._slotColor.redOffset += (self._color.redOffset - self._slotColor.redOffset) * fadeProgress;
                                self._slotColor.greenOffset += (self._color.greenOffset - self._slotColor.greenOffset) * fadeProgress;
                                self._slotColor.blueOffset += (self._color.blueOffset - self._slotColor.blueOffset) * fadeProgress;
                                self.slot._colorDirty = true;
                            } else {
                                if (self._colorDirty) {
                                    self._colorDirty = false;
                                    self._slotColor.alphaMultiplier = self._color.alphaMultiplier;
                                    self._slotColor.redMultiplier = self._color.redMultiplier;
                                    self._slotColor.greenMultiplier = self._color.greenMultiplier;
                                    self._slotColor.blueMultiplier = self._color.blueMultiplier;
                                    self._slotColor.alphaOffset = self._color.alphaOffset;
                                    self._slotColor.redOffset = self._color.redOffset;
                                    self._slotColor.greenOffset = self._color.greenOffset;
                                    self._slotColor.blueOffset = self._color.blueOffset;
                                    self.slot._colorDirty = true;
                                }
                            }
                        }
                    }
                };
                return SlotTimelineState;
            })(dragonBones.TweenTimelineState);
            dragonBones.SlotTimelineState = SlotTimelineState;
            var FFDTimelineState = (function(_super) {
                __extends(FFDTimelineState, _super);
                function FFDTimelineState() {
                    _super.call(this);
                    this._ffdVertices = [];
                }
                FFDTimelineState.toString = function() {
                    return "[class dragonBones.FFDTimelineState]";
                };
                FFDTimelineState.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this.slot = null;
                    this._tweenFFD = 0;
                    this._slotFFDVertices = null;
                    if (this._durationFFDFrame) {
                        this._durationFFDFrame.returnToPool();
                        this._durationFFDFrame = null;
                    }
                    this._ffdVertices.length = 0;
                };
                FFDTimelineState.prototype._onArriveAtFrame = function(isUpdate) {
                    var self = this;
                    _super.prototype._onArriveAtFrame.call(this, isUpdate);
                    self._tweenFFD = 0;
                    (self._tweenEasing != dragonBones.DragonBones.NO_TWEEN || self._curve) && (self._tweenFFD = self._updateExtensionKeyFrame(self._currentFrame, self._currentFrame.next, self._durationFFDFrame));
                    if (0 == self._tweenFFD) {
                        var currentFFDVertices = self._currentFrame.tweens;
                        for (var i = 0, l = currentFFDVertices.length; i < l; ++i) {
                            if (self._slotFFDVertices[i] != currentFFDVertices[i]) {
                                self._tweenFFD = 1;
                                break;
                            }
                        }
                    }
                };
                FFDTimelineState.prototype._onUpdateFrame = function(isUpdate) {
                    var self = this;
                    _super.prototype._onUpdateFrame.call(this, isUpdate);
                    var tweenProgress = 0;
                    if (0 != self._tweenFFD) {
                        if (1 == self._tweenFFD) {
                            self._tweenFFD = 0;
                            tweenProgress = 0;
                        } else {
                            tweenProgress = self._tweenProgress;
                        }
                        var currentFFDVertices = self._currentFrame.tweens;
                        var nextFFDVertices = self._durationFFDFrame.tweens;
                        for (var i = 0, l = currentFFDVertices.length; i < l; ++i) {
                            self._ffdVertices[i] = currentFFDVertices[i] + nextFFDVertices[i] * tweenProgress;
                        }
                        self.slot._ffdDirty = true;
                    }
                };
                FFDTimelineState.prototype.fadeIn = function(armature, animationState, timelineData, time) {
                    _super.prototype.fadeIn.call(this, armature, animationState, timelineData, time);
                    this._slotFFDVertices = this.slot._ffdVertices;
                    this._durationFFDFrame = dragonBones.BaseObject.borrowObject(dragonBones.ExtensionFrameData);
                    this._durationFFDFrame.tweens.length = this._slotFFDVertices.length;
                    this._ffdVertices.length = this._slotFFDVertices.length;
                    for (var i = 0, l = this._durationFFDFrame.tweens.length; i < l; ++i) {
                        this._durationFFDFrame.tweens[i] = 0;
                    }
                    for (var i = 0, l = this._ffdVertices.length; i < l; ++i) {
                        this._ffdVertices[i] = 0;
                    }
                };
                FFDTimelineState.prototype.update = function(time) {
                    var self = this;
                    _super.prototype.update.call(this, time);
                    var weight = self._animationState._weightResult;
                    if (weight > 0) {
                        if (0 == self.slot._blendIndex) {
                            for (var i = 0, l = self._ffdVertices.length; i < l; ++i) {
                                self._slotFFDVertices[i] = self._ffdVertices[i] * weight;
                            }
                        } else {
                            for (var i = 0, l = self._ffdVertices.length; i < l; ++i) {
                                self._slotFFDVertices[i] += self._ffdVertices[i] * weight;
                            }
                        }
                        self.slot._blendIndex++;
                        0 != self._animationState._fadeState && (self.slot._ffdDirty = true);
                    }
                };
                return FFDTimelineState;
            })(dragonBones.TweenTimelineState);
            dragonBones.FFDTimelineState = FFDTimelineState;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var WorldClock = (function() {
                function WorldClock() {
                    this.time = new Date().getTime() / dragonBones.DragonBones.SECOND_TO_MILLISECOND;
                    this.timeScale = 1;
                    this._animatebles = [];
                }
                Object.defineProperty(WorldClock, "clock", {
                    get: function() {
                        WorldClock._clock || (WorldClock._clock = new WorldClock());
                        return WorldClock._clock;
                    },
                    enumerable: true,
                    configurable: true
                });
                WorldClock.prototype.advanceTime = function(passedTime) {
                    passedTime != passedTime && (passedTime = 0);
                    passedTime < 0 && (passedTime = new Date().getTime() / dragonBones.DragonBones.SECOND_TO_MILLISECOND - this.time);
                    passedTime *= this.timeScale;
                    passedTime < 0 ? this.time -= passedTime : this.time += passedTime;
                    if (passedTime) {
                        var i = 0, r = 0, l = this._animatebles.length;
                        for (;i < l; ++i) {
                            var animateble = this._animatebles[i];
                            if (animateble) {
                                if (r > 0) {
                                    this._animatebles[i - r] = animateble;
                                    this._animatebles[i] = null;
                                }
                                animateble.advanceTime(passedTime);
                            } else {
                                r++;
                            }
                        }
                        if (r > 0) {
                            l = this._animatebles.length;
                            for (;i < l; ++i) {
                                var animateble = this._animatebles[i];
                                animateble ? this._animatebles[i - r] = animateble : r++;
                            }
                            this._animatebles.length -= r;
                        }
                    }
                };
                WorldClock.prototype.contains = function(value) {
                    return this._animatebles.indexOf(value) >= 0;
                };
                WorldClock.prototype.add = function(value) {
                    if (value && this._animatebles.indexOf(value) < 0) {
                        this._animatebles.push(value);
                        dragonBones.DragonBones.debug && value instanceof dragonBones.Armature && dragonBones.DragonBones.addArmature(value);
                    }
                };
                WorldClock.prototype.remove = function(value) {
                    var index = this._animatebles.indexOf(value);
                    if (index >= 0) {
                        this._animatebles[index] = null;
                        dragonBones.DragonBones.debug && value instanceof dragonBones.Armature && dragonBones.DragonBones.removeArmature(value);
                    }
                };
                WorldClock.prototype.clear = function() {
                    for (var i = 0, l = this._animatebles.length; i < l; ++i) {
                        this._animatebles[i] = null;
                    }
                };
                WorldClock._clock = null;
                return WorldClock;
            })();
            dragonBones.WorldClock = WorldClock;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var TransformObject = (function(_super) {
                __extends(TransformObject, _super);
                function TransformObject() {
                    _super.call(this);
                    this.global = new dragonBones.Transform();
                    this.origin = new dragonBones.Transform();
                    this.offset = new dragonBones.Transform();
                    this._globalTransformMatrix = new dragonBones.Matrix();
                }
                TransformObject.prototype._onClear = function() {
                    this.userData = null;
                    this.name = null;
                    this.globalTransformMatrix = this._globalTransformMatrix;
                    this.global.identity();
                    this.origin.identity();
                    this.offset.identity();
                    this._armature = null;
                    this._parent = null;
                    this._globalTransformMatrix.identity();
                };
                TransformObject.prototype._setArmature = function(value) {
                    this._armature = value;
                };
                TransformObject.prototype._setParent = function(value) {
                    this._parent = value;
                };
                Object.defineProperty(TransformObject.prototype, "armature", {
                    get: function() {
                        return this._armature;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TransformObject.prototype, "parent", {
                    get: function() {
                        return this._parent;
                    },
                    enumerable: true,
                    configurable: true
                });
                return TransformObject;
            })(dragonBones.BaseObject);
            dragonBones.TransformObject = TransformObject;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var Armature = (function(_super) {
                __extends(Armature, _super);
                function Armature() {
                    _super.call(this);
                    this._bones = [];
                    this._slots = [];
                    this._actions = [];
                    this._events = [];
                    this.enableCache = false;
                }
                Armature.toString = function() {
                    return "[class dragonBones.Armature]";
                };
                Armature._onSortSlots = function(a, b) {
                    return a._zOrder > b._zOrder ? 1 : -1;
                };
                Armature.prototype._onClear = function() {
                    for (var i = 0, l = this._bones.length; i < l; ++i) {
                        this._bones[i].returnToPool();
                    }
                    for (var i = 0, l = this._slots.length; i < l; ++i) {
                        this._slots[i].returnToPool();
                    }
                    for (var i = 0, l = this._events.length; i < l; ++i) {
                        this._events[i].returnToPool();
                    }
                    this._animation && this._animation.returnToPool();
                    this._display && this._display._onClear();
                    this.userData = null;
                    this._cacheFrameIndex = -1;
                    this._armatureData = null;
                    this._skinData = null;
                    this._animation = null;
                    this._display = null;
                    this._parent = null;
                    this._eventManager = null;
                    this._delayDispose = false;
                    this._lockDispose = false;
                    this._debugDraw = false;
                    this._bonesDirty = false;
                    this._slotsDirty = false;
                    this._replacedTexture = null;
                    this._bones.length = 0;
                    this._slots.length = 0;
                    this._actions.length = 0;
                    this._events.length = 0;
                };
                Armature.prototype._sortBones = function() {
                    var total = this._bones.length;
                    if (total <= 0) {
                        return;
                    }
                    var sortHelper = this._bones.concat();
                    var index = 0;
                    var count = 0;
                    this._bones.length = 0;
                    while (count < total) {
                        var bone = sortHelper[index++];
                        index >= total && (index = 0);
                        if (this._bones.indexOf(bone) >= 0) {
                            continue;
                        }
                        if (bone.parent && this._bones.indexOf(bone.parent) < 0) {
                            continue;
                        }
                        if (bone.ik && this._bones.indexOf(bone.ik) < 0) {
                            continue;
                        }
                        bone.ik && bone.ikChain > 0 && bone.ikChainIndex == bone.ikChain ? this._bones.splice(this._bones.indexOf(bone.parent) + 1, 0, bone) : this._bones.push(bone);
                        count++;
                    }
                };
                Armature.prototype._sortSlots = function() {
                    this._slots.sort(Armature._onSortSlots);
                };
                Armature.prototype._doAction = function(value) {
                    switch (value.type) {
                      case 0:
                        this._animation.play(value.data[0], value.data[1]);
                        break;

                      case 1:
                        this._animation.stop(value.data[0]);
                        break;

                      case 2:
                        this._animation.gotoAndPlayByTime(value.data[0], value.data[1], value.data[2]);
                        break;

                      case 3:
                        this._animation.gotoAndStopByTime(value.data[0], value.data[1]);
                        break;

                      case 4:
                        this._animation.fadeIn(value.data[0], value.data[1], value.data[2]);
                        break;

                      case 5:                    }
                };
                Armature.prototype._addBoneToBoneList = function(value) {
                    if (this._bones.indexOf(value) < 0) {
                        this._bonesDirty = true;
                        this._bones.push(value);
                    }
                };
                Armature.prototype._removeBoneFromBoneList = function(value) {
                    var index = this._bones.indexOf(value);
                    index >= 0 && this._bones.splice(index, 1);
                };
                Armature.prototype._addSlotToSlotList = function(value) {
                    if (this._slots.indexOf(value) < 0) {
                        this._slotsDirty = true;
                        this._slots.push(value);
                    }
                };
                Armature.prototype._removeSlotFromSlotList = function(value) {
                    var index = this._slots.indexOf(value);
                    index >= 0 && this._slots.splice(index, 1);
                };
                Armature.prototype._sortZOrder = function(slotIndices) {
                    var sortedSlots = this._armatureData.sortedSlots;
                    var isOriginal = slotIndices.length < 1;
                    for (var i = 0, l = sortedSlots.length; i < l; ++i) {
                        var slotIndex = isOriginal ? i : slotIndices[i];
                        var slotData = sortedSlots[slotIndex];
                        var slot = this.getSlot(slotData.name);
                        slot && slot._setZorder(i);
                    }
                    this._slotsDirty = true;
                };
                Armature.prototype._bufferAction = function(value) {
                    this._actions.push(value);
                };
                Armature.prototype._bufferEvent = function(value, type) {
                    value.type = type;
                    value.armature = this;
                    this._events.push(value);
                };
                Armature.prototype.dispose = function() {
                    this._delayDispose = true;
                    !this._lockDispose && this._animation && this.returnToPool();
                };
                Armature.prototype.advanceTime = function(passedTime) {
                    var self = this;
                    if (!self._animation) {
                        throw new Error("The armature has been disposed.");
                    }
                    var scaledPassedTime = passedTime * self._animation.timeScale;
                    self._animation._advanceTime(scaledPassedTime);
                    if (self._bonesDirty) {
                        self._bonesDirty = false;
                        self._sortBones();
                    }
                    if (self._slotsDirty) {
                        self._slotsDirty = false;
                        self._sortSlots();
                    }
                    for (var i = 0, l = self._bones.length; i < l; ++i) {
                        self._bones[i]._update(self._cacheFrameIndex);
                    }
                    for (var i = 0, l = self._slots.length; i < l; ++i) {
                        var slot = self._slots[i];
                        slot._update(self._cacheFrameIndex);
                        var childArmature = slot._childArmature;
                        childArmature && (slot.inheritAnimation ? childArmature.advanceTime(scaledPassedTime) : childArmature.advanceTime(passedTime));
                    }
                    if (dragonBones.DragonBones.debugDraw || self._debugDraw) {
                        self._debugDraw = dragonBones.DragonBones.debugDraw;
                        self._display._debugDraw(self._debugDraw);
                    }
                    if (!self._lockDispose) {
                        self._lockDispose = true;
                        if (self._events.length > 0) {
                            for (var i = 0, l = self._events.length; i < l; ++i) {
                                var event_5 = self._events[i];
                                event_5.type == dragonBones.EventObject.SOUND_EVENT ? this._eventManager._dispatchEvent(event_5) : self._display._dispatchEvent(event_5);
                                event_5.returnToPool();
                            }
                            self._events.length = 0;
                        }
                        if (self._actions.length > 0) {
                            for (var i = 0, l = self._actions.length; i < l; ++i) {
                                var action = self._actions[i];
                                if (action.slot) {
                                    var slot = self.getSlot(action.slot.name);
                                    if (slot) {
                                        var childArmature = slot._childArmature;
                                        childArmature && childArmature._doAction(action);
                                    }
                                } else {
                                    if (action.bone) {
                                        for (var i_1 = 0, l_1 = self._slots.length; i_1 < l_1; ++i_1) {
                                            var childArmature = self._slots[i_1]._childArmature;
                                            childArmature && childArmature._doAction(action);
                                        }
                                    } else {
                                        this._doAction(action);
                                    }
                                }
                            }
                            self._actions.length = 0;
                        }
                        self._lockDispose = false;
                    }
                    self._delayDispose && self.returnToPool();
                };
                Armature.prototype.containsPoint = function(x, y, color) {
                    void 0 === color && (color = 0);
                    for (var i = 0, l = this._slots.length; i < l; ++i) {
                        var slot = this._slots[i];
                        if (slot.containsPoint(x, y, color)) {
                            return slot;
                        }
                    }
                    return null;
                };
                Armature.prototype.intersectsSegment = function(xA, yA, xB, yB, color, intersectionPointA, intersectionPointB, normalRadians) {
                    void 0 === color && (color = 0);
                    void 0 === intersectionPointA && (intersectionPointA = null);
                    void 0 === intersectionPointB && (intersectionPointB = null);
                    void 0 === normalRadians && (normalRadians = null);
                    var isV = xA == xB;
                    var dMin = 0;
                    var dMax = 0;
                    var intXA = 0;
                    var intYA = 0;
                    var intXB = 0;
                    var intYB = 0;
                    var intAN = 0;
                    var intBN = 0;
                    var intSlotA = null;
                    var intSlotB = null;
                    for (var i = 0, l = this._slots.length; i < l; ++i) {
                        var slot = this._slots[i];
                        var intersectionCount = slot.intersectsSegment(xA, yA, xB, yB, color, intersectionPointA, intersectionPointB, normalRadians);
                        if (intersectionCount > 0) {
                            if (!intersectionPointA && !intersectionPointB) {
                                intSlotA = slot;
                                break;
                            }
                            if (intersectionPointA) {
                                var d = isV ? intersectionPointA.y - yA : intersectionPointA.x - xA;
                                d < 0 && (d = -d);
                                if (!intSlotA || d < dMin) {
                                    dMin = d;
                                    intXA = intersectionPointA.x;
                                    intYA = intersectionPointA.y;
                                    intSlotA = slot;
                                    normalRadians && (intAN = normalRadians.x);
                                }
                            }
                            if (intersectionPointB) {
                                var d = intersectionPointB.x - xA;
                                d < 0 && (d = -d);
                                if (!intSlotB || d > dMax) {
                                    dMax = d;
                                    intXB = intersectionPointB.x;
                                    intYB = intersectionPointB.y;
                                    intSlotB = slot;
                                    normalRadians && (intBN = normalRadians.y);
                                }
                            }
                        }
                    }
                    if (intSlotA && intersectionPointA) {
                        intersectionPointA.x = intXA;
                        intersectionPointA.y = intYA;
                        normalRadians && (normalRadians.x = intAN);
                    }
                    if (intSlotB && intersectionPointB) {
                        intersectionPointB.x = intXB;
                        intersectionPointB.y = intYB;
                        normalRadians && (normalRadians.y = intBN);
                    }
                    return intSlotA;
                };
                Armature.prototype.invalidUpdate = function(boneName, updateSlotDisplay) {
                    void 0 === boneName && (boneName = null);
                    void 0 === updateSlotDisplay && (updateSlotDisplay = false);
                    if (boneName) {
                        var bone = this.getBone(boneName);
                        if (bone) {
                            bone.invalidUpdate();
                            if (updateSlotDisplay) {
                                for (var i = 0, l = this._slots.length; i < l; ++i) {
                                    var slot = this._slots[i];
                                    slot.parent == bone && slot.invalidUpdate();
                                }
                            }
                        }
                    } else {
                        for (var i = 0, l = this._bones.length; i < l; ++i) {
                            this._bones[i].invalidUpdate();
                        }
                        if (updateSlotDisplay) {
                            for (var i = 0, l = this._slots.length; i < l; ++i) {
                                this._slots[i].invalidUpdate();
                            }
                        }
                    }
                };
                Armature.prototype.getBone = function(name) {
                    for (var i = 0, l = this._bones.length; i < l; ++i) {
                        var bone = this._bones[i];
                        if (bone.name == name) {
                            return bone;
                        }
                    }
                    return null;
                };
                Armature.prototype.getBoneByDisplay = function(display) {
                    var slot = this.getSlotByDisplay(display);
                    return slot ? slot.parent : null;
                };
                Armature.prototype.getSlot = function(name) {
                    for (var i = 0, l = this._slots.length; i < l; ++i) {
                        var slot = this._slots[i];
                        if (slot.name == name) {
                            return slot;
                        }
                    }
                    return null;
                };
                Armature.prototype.getSlotByDisplay = function(display) {
                    if (display) {
                        for (var i = 0, l = this._slots.length; i < l; ++i) {
                            var slot = this._slots[i];
                            if (slot.display == display) {
                                return slot;
                            }
                        }
                    }
                    return null;
                };
                Armature.prototype.replaceTexture = function(texture) {
                    this.replacedTexture = texture;
                };
                Armature.prototype.getBones = function() {
                    return this._bones;
                };
                Armature.prototype.getSlots = function() {
                    return this._slots;
                };
                Object.defineProperty(Armature.prototype, "name", {
                    get: function() {
                        return this._armatureData ? this._armatureData.name : null;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Armature.prototype, "armatureData", {
                    get: function() {
                        return this._armatureData;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Armature.prototype, "animation", {
                    get: function() {
                        return this._animation;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Armature.prototype, "display", {
                    get: function() {
                        return this._display;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Armature.prototype, "parent", {
                    get: function() {
                        return this._parent;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Armature.prototype, "cacheFrameRate", {
                    get: function() {
                        return this._armatureData.cacheFrameRate;
                    },
                    set: function(value) {
                        if (this._armatureData.cacheFrameRate != value) {
                            this._armatureData.cacheFrames(value);
                            for (var i = 0, l = this._slots.length; i < l; ++i) {
                                var slot = this._slots[i];
                                var childArmature = slot.childArmature;
                                childArmature && 0 == childArmature.cacheFrameRate && (childArmature.cacheFrameRate = value);
                            }
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Armature.prototype, "replacedTexture", {
                    get: function() {
                        return this._replacedTexture;
                    },
                    set: function(value) {
                        this._display._onReplaceTexture(value);
                        this._replacedTexture = value;
                        for (var i = 0, l = this._slots.length; i < l; ++i) {
                            this._slots[i].invalidUpdate();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Armature.prototype.enableAnimationCache = function(frameRate) {
                    this.cacheFrameRate = frameRate;
                };
                Armature.prototype.hasEventListener = function(type) {
                    return this._display.hasEvent(type);
                };
                Armature.prototype.addEventListener = function(type, listener, target) {
                    this._display.addEvent(type, listener, target);
                };
                Armature.prototype.removeEventListener = function(type, listener, target) {
                    this._display.removeEvent(type, listener, target);
                };
                Armature.prototype.addBone = function(value, parentName) {
                    void 0 === parentName && (parentName = null);
                    if (!value) {
                        throw new Error();
                    }
                    value._setArmature(this);
                    value._setParent(parentName ? this.getBone(parentName) : null);
                };
                Armature.prototype.addSlot = function(value, parentName) {
                    var bone = this.getBone(parentName);
                    if (!bone) {
                        throw new Error();
                    }
                    value._setArmature(this);
                    value._setParent(bone);
                };
                Armature.prototype.removeBone = function(value) {
                    if (!value || value.armature != this) {
                        throw new Error();
                    }
                    value._setParent(null);
                    value._setArmature(null);
                };
                Armature.prototype.removeSlot = function(value) {
                    if (!value || value.armature != this) {
                        throw new Error();
                    }
                    value._setParent(null);
                    value._setArmature(null);
                };
                Armature.prototype.getDisplay = function() {
                    return this._display;
                };
                return Armature;
            })(dragonBones.BaseObject);
            dragonBones.Armature = Armature;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var Bone = (function(_super) {
                __extends(Bone, _super);
                function Bone() {
                    _super.call(this);
                    this._animationPose = new dragonBones.Transform();
                    this._bones = [];
                    this._slots = [];
                }
                Bone.toString = function() {
                    return "[class dragonBones.Bone]";
                };
                Bone.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this.inheritTranslation = false;
                    this.inheritRotation = false;
                    this.inheritScale = false;
                    this.ikBendPositive = false;
                    this.ikWeight = 0;
                    this.length = 0;
                    this._transformDirty = 2;
                    this._blendIndex = 0;
                    this._cacheFrames = null;
                    this._animationPose.identity();
                    this._visible = true;
                    this._ikChain = 0;
                    this._ikChainIndex = 0;
                    this._ik = null;
                    this._bones.length = 0;
                    this._slots.length = 0;
                };
                Bone.prototype._updateGlobalTransformMatrix = function() {
                    if (this._parent) {
                        var parentRotation = this._parent.global.skewY;
                        var parentMatrix = this._parent.globalTransformMatrix;
                        if (this.inheritScale) {
                            if (!this.inheritRotation) {
                                this.global.skewX -= parentRotation;
                                this.global.skewY -= parentRotation;
                            }
                            this.global.toMatrix(this.globalTransformMatrix);
                            this.globalTransformMatrix.concat(parentMatrix);
                            if (!this.inheritTranslation) {
                                this.globalTransformMatrix.tx = this.global.x;
                                this.globalTransformMatrix.ty = this.global.y;
                            }
                            this.global.fromMatrix(this.globalTransformMatrix);
                        } else {
                            if (this.inheritTranslation) {
                                var x = this.global.x;
                                var y = this.global.y;
                                this.global.x = parentMatrix.a * x + parentMatrix.c * y + parentMatrix.tx;
                                this.global.y = parentMatrix.d * y + parentMatrix.b * x + parentMatrix.ty;
                            }
                            if (this.inheritRotation) {
                                this.global.skewX += parentRotation;
                                this.global.skewY += parentRotation;
                            }
                            this.global.toMatrix(this.globalTransformMatrix);
                        }
                    } else {
                        this.global.toMatrix(this.globalTransformMatrix);
                    }
                };
                Bone.prototype._computeIKA = function() {
                    var ikGlobal = this._ik.global;
                    var x = this.globalTransformMatrix.a * this.length;
                    var y = this.globalTransformMatrix.b * this.length;
                    var ikRadian = (Math.atan2(ikGlobal.y - this.global.y, ikGlobal.x - this.global.x) + this.offset.skewY - 2 * this.global.skewY + Math.atan2(y, x)) * this.ikWeight;
                    this.global.skewX += ikRadian;
                    this.global.skewY += ikRadian;
                    this.global.toMatrix(this.globalTransformMatrix);
                };
                Bone.prototype._computeIKB = function() {
                    var parentGlobal = this._parent.global;
                    var ikGlobal = this._ik.global;
                    var x = this.globalTransformMatrix.a * this.length;
                    var y = this.globalTransformMatrix.b * this.length;
                    var lLL = x * x + y * y;
                    var lL = Math.sqrt(lLL);
                    var dX = this.global.x - parentGlobal.x;
                    var dY = this.global.y - parentGlobal.y;
                    var lPP = dX * dX + dY * dY;
                    var lP = Math.sqrt(lPP);
                    dX = ikGlobal.x - parentGlobal.x;
                    dY = ikGlobal.y - parentGlobal.y;
                    var lTT = dX * dX + dY * dY;
                    var lT = Math.sqrt(lTT);
                    var ikRadianA = 0;
                    if (lL + lP <= lT || lT + lL <= lP || lT + lP <= lL) {
                        ikRadianA = Math.atan2(ikGlobal.y - parentGlobal.y, ikGlobal.x - parentGlobal.x) + this._parent.offset.skewY;
                        lL + lP <= lT || lP < lL && (ikRadianA += Math.PI);
                    } else {
                        var h = (lPP - lLL + lTT) / (2 * lTT);
                        var r = Math.sqrt(lPP - h * h * lTT) / lT;
                        var hX = parentGlobal.x + dX * h;
                        var hY = parentGlobal.y + dY * h;
                        var rX = -dY * r;
                        var rY = dX * r;
                        if (this.ikBendPositive) {
                            this.global.x = hX - rX;
                            this.global.y = hY - rY;
                        } else {
                            this.global.x = hX + rX;
                            this.global.y = hY + rY;
                        }
                        ikRadianA = Math.atan2(this.global.y - parentGlobal.y, this.global.x - parentGlobal.x) + this._parent.offset.skewY;
                    }
                    ikRadianA = (ikRadianA - parentGlobal.skewY) * this.ikWeight;
                    parentGlobal.skewX += ikRadianA;
                    parentGlobal.skewY += ikRadianA;
                    parentGlobal.toMatrix(this._parent.globalTransformMatrix);
                    this._parent._transformDirty = 1;
                    this.global.x = parentGlobal.x + Math.cos(parentGlobal.skewY) * lP;
                    this.global.y = parentGlobal.y + Math.sin(parentGlobal.skewY) * lP;
                    var ikRadianB = (Math.atan2(ikGlobal.y - this.global.y, ikGlobal.x - this.global.x) + this.offset.skewY - 2 * this.global.skewY + Math.atan2(y, x)) * this.ikWeight;
                    this.global.skewX += ikRadianB;
                    this.global.skewY += ikRadianB;
                    this.global.toMatrix(this.globalTransformMatrix);
                };
                Bone.prototype._setArmature = function(value) {
                    if (this._armature == value) {
                        return;
                    }
                    this._ik = null;
                    var oldSlots = null;
                    var oldBones = null;
                    if (this._armature) {
                        oldSlots = this.getSlots();
                        oldBones = this.getBones();
                        this._armature._removeBoneFromBoneList(this);
                    }
                    this._armature = value;
                    this._armature && this._armature._addBoneToBoneList(this);
                    if (oldSlots) {
                        for (var i = 0, l = oldSlots.length; i < l; ++i) {
                            var slot = oldSlots[i];
                            slot.parent == this && slot._setArmature(this._armature);
                        }
                    }
                    if (oldBones) {
                        for (var i = 0, l = oldBones.length; i < l; ++i) {
                            var bone = oldBones[i];
                            bone.parent == this && bone._setArmature(this._armature);
                        }
                    }
                };
                Bone.prototype._setIK = function(value, chain, chainIndex) {
                    if (value) {
                        if (chain == chainIndex) {
                            var chainEnd = this._parent;
                            if (chain && chainEnd) {
                                chain = 1;
                            } else {
                                chain = 0;
                                chainIndex = 0;
                                chainEnd = this;
                            }
                            if (chainEnd == value || chainEnd.contains(value)) {
                                value = null;
                                chain = 0;
                                chainIndex = 0;
                            } else {
                                var ancestor = value;
                                while (ancestor.ik && ancestor.ikChain) {
                                    if (chainEnd.contains(ancestor.ik)) {
                                        value = null;
                                        chain = 0;
                                        chainIndex = 0;
                                        break;
                                    }
                                    ancestor = ancestor.parent;
                                }
                            }
                        }
                    } else {
                        chain = 0;
                        chainIndex = 0;
                    }
                    this._ik = value;
                    this._ikChain = chain;
                    this._ikChainIndex = chainIndex;
                    this._armature && (this._armature._bonesDirty = true);
                };
                Bone.prototype._update = function(cacheFrameIndex) {
                    var self = this;
                    self._blendIndex = 0;
                    if (cacheFrameIndex >= 0) {
                        var cacheFrame = self._cacheFrames[cacheFrameIndex];
                        if (self.globalTransformMatrix == cacheFrame) {
                            self._transformDirty = 0;
                        } else {
                            if (cacheFrame) {
                                self._transformDirty = 2;
                                self.globalTransformMatrix = cacheFrame;
                            } else {
                                if (2 == self._transformDirty || self._parent && 0 != self._parent._transformDirty || self._ik && self.ikWeight > 0 && 0 != self._ik._transformDirty) {
                                    self._transformDirty = 2;
                                    self.globalTransformMatrix = self._globalTransformMatrix;
                                } else {
                                    if (self.globalTransformMatrix != self._globalTransformMatrix) {
                                        self._transformDirty = 0;
                                        self._cacheFrames[cacheFrameIndex] = self.globalTransformMatrix;
                                    } else {
                                        self._transformDirty = 2;
                                        self.globalTransformMatrix = self._globalTransformMatrix;
                                    }
                                }
                            }
                        }
                    } else {
                        if (2 == self._transformDirty || self._parent && 0 != self._parent._transformDirty || self._ik && self.ikWeight > 0 && 0 != self._ik._transformDirty) {
                            self._transformDirty = 2;
                            self.globalTransformMatrix = self._globalTransformMatrix;
                        }
                    }
                    if (0 != self._transformDirty) {
                        if (2 == self._transformDirty) {
                            self._transformDirty = 1;
                            if (self.globalTransformMatrix == self._globalTransformMatrix) {
                                self.global.x = self.origin.x + self.offset.x + self._animationPose.x;
                                self.global.y = self.origin.y + self.offset.y + self._animationPose.y;
                                self.global.skewX = self.origin.skewX + self.offset.skewX + self._animationPose.skewX;
                                self.global.skewY = self.origin.skewY + self.offset.skewY + self._animationPose.skewY;
                                self.global.scaleX = self.origin.scaleX * self.offset.scaleX * self._animationPose.scaleX;
                                self.global.scaleY = self.origin.scaleY * self.offset.scaleY * self._animationPose.scaleY;
                                self._updateGlobalTransformMatrix();
                                self._ik && self._ikChainIndex == self._ikChain && self.ikWeight > 0 && (self.inheritTranslation && self._ikChain > 0 && self._parent ? self._computeIKB() : self._computeIKA());
                                cacheFrameIndex >= 0 && !self._cacheFrames[cacheFrameIndex] && (self.globalTransformMatrix = dragonBones.BoneTimelineData.cacheFrame(self._cacheFrames, cacheFrameIndex, self._globalTransformMatrix));
                            }
                        } else {
                            self._transformDirty = 0;
                        }
                    }
                };
                Bone.prototype.invalidUpdate = function() {
                    this._transformDirty = 2;
                };
                Bone.prototype.contains = function(child) {
                    if (child) {
                        if (child == this) {
                            return false;
                        }
                        var ancestor = child;
                        while (ancestor != this && ancestor) {
                            ancestor = ancestor.parent;
                        }
                        return ancestor == this;
                    }
                    return false;
                };
                Bone.prototype.getBones = function() {
                    this._bones.length = 0;
                    var bones = this._armature.getBones();
                    for (var i = 0, l = bones.length; i < l; ++i) {
                        var bone = bones[i];
                        bone.parent == this && this._bones.push(bone);
                    }
                    return this._bones;
                };
                Bone.prototype.getSlots = function() {
                    this._slots.length = 0;
                    var slots = this._armature.getSlots();
                    for (var i = 0, l = slots.length; i < l; ++i) {
                        var slot = slots[i];
                        slot.parent == this && this._slots.push(slot);
                    }
                    return this._slots;
                };
                Object.defineProperty(Bone.prototype, "ikChain", {
                    get: function() {
                        return this._ikChain;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Bone.prototype, "ikChainIndex", {
                    get: function() {
                        return this._ikChainIndex;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Bone.prototype, "ik", {
                    get: function() {
                        return this._ik;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Bone.prototype, "visible", {
                    get: function() {
                        return this._visible;
                    },
                    set: function(value) {
                        if (this._visible == value) {
                            return;
                        }
                        this._visible = value;
                        var slots = this._armature.getSlots();
                        for (var i = 0, l = slots.length; i < l; ++i) {
                            var slot = slots[i];
                            slot._parent == this && slot._updateVisible();
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Bone.prototype, "slot", {
                    get: function() {
                        var slots = this._armature.getSlots();
                        for (var i = 0, l = slots.length; i < l; ++i) {
                            var slot = slots[i];
                            if (slot.parent == this) {
                                return slot;
                            }
                        }
                        return null;
                    },
                    enumerable: true,
                    configurable: true
                });
                return Bone;
            })(dragonBones.TransformObject);
            dragonBones.Bone = Bone;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var Slot = (function(_super) {
                __extends(Slot, _super);
                function Slot() {
                    _super.call(this);
                    this._colorTransform = new dragonBones.ColorTransform();
                    this._ffdVertices = [];
                    this._replacedDisplayDataSet = [];
                    this._localMatrix = new dragonBones.Matrix();
                    this._displayList = [];
                    this._meshBones = [];
                }
                Slot.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    var disposeDisplayList = [];
                    for (var i = 0, l = this._displayList.length; i < l; ++i) {
                        var eachDisplay = this._displayList[i];
                        eachDisplay != this._rawDisplay && eachDisplay != this._meshDisplay && disposeDisplayList.indexOf(eachDisplay) < 0 && disposeDisplayList.push(eachDisplay);
                    }
                    for (var i = 0, l = disposeDisplayList.length; i < l; ++i) {
                        var eachDisplay = disposeDisplayList[i];
                        eachDisplay instanceof dragonBones.Armature ? eachDisplay.dispose() : this._disposeDisplay(eachDisplay);
                    }
                    this._meshDisplay && this._meshDisplay != this._rawDisplay && this._disposeDisplay(this._meshDisplay);
                    this._rawDisplay && this._disposeDisplay(this._rawDisplay);
                    this.inheritAnimation = true;
                    this.displayController = null;
                    this._blendIndex = 0;
                    this._displayDataSet = null;
                    this._meshData = null;
                    this._childArmature = null;
                    this._rawDisplay = null;
                    this._meshDisplay = null;
                    this._cacheFrames = null;
                    this._colorTransform.identity();
                    this._ffdVertices.length = 0;
                    this._replacedDisplayDataSet.length = 0;
                    this._zOrderDirty = false;
                    this._displayDirty = false;
                    this._colorDirty = false;
                    this._blendModeDirty = false;
                    this._originDirty = false;
                    this._transformDirty = false;
                    this._ffdDirty = false;
                    this._zOrder = 0;
                    this._displayIndex = -2;
                    this._pivotX = 0;
                    this._pivotY = 0;
                    this._blendMode = 0;
                    this._display = null;
                    this._localMatrix.identity();
                    this._displayList.length = 0;
                    this._meshBones.length = 0;
                };
                Slot.prototype._isMeshBonesUpdate = function() {
                    for (var i = 0, l = this._meshBones.length; i < l; ++i) {
                        if (0 != this._meshBones[i]._transformDirty) {
                            return true;
                        }
                    }
                    return false;
                };
                Slot.prototype._updatePivot = function(rawDisplayData, currentDisplayData, currentTextureData) {
                    var isReplaceDisplay = rawDisplayData && rawDisplayData != currentDisplayData && (!this._meshData || this._meshData != rawDisplayData.mesh);
                    if (this._meshData && this._display == this._meshDisplay) {
                        this._pivotX = 0;
                        this._pivotY = 0;
                    } else {
                        var scale = this._armature.armatureData.scale;
                        this._pivotX = currentDisplayData.pivot.x;
                        this._pivotY = currentDisplayData.pivot.y;
                        if (currentDisplayData.isRelativePivot) {
                            var rect = currentTextureData.frame || currentTextureData.region;
                            var width = rect.width * scale;
                            var height = rect.height * scale;
                            if (currentTextureData.rotated) {
                                width = rect.height;
                                height = rect.width;
                            }
                            this._pivotX *= width;
                            this._pivotY *= height;
                        }
                        if (currentTextureData.frame) {
                            this._pivotX += currentTextureData.frame.x * scale;
                            this._pivotY += currentTextureData.frame.y * scale;
                        }
                    }
                    if (isReplaceDisplay) {
                        rawDisplayData.transform.toMatrix(Slot._helpMatrix);
                        Slot._helpMatrix.invert();
                        Slot._helpMatrix.transformPoint(0, 0, Slot._helpPoint);
                        this._pivotX -= Slot._helpPoint.x;
                        this._pivotY -= Slot._helpPoint.y;
                        currentDisplayData.transform.toMatrix(Slot._helpMatrix);
                        Slot._helpMatrix.invert();
                        Slot._helpMatrix.transformPoint(0, 0, Slot._helpPoint);
                        this._pivotX += Slot._helpPoint.x;
                        this._pivotY += Slot._helpPoint.y;
                    }
                };
                Slot.prototype._updateDisplay = function() {
                    var prevDisplay = this._display || this._rawDisplay;
                    var prevChildArmature = this._childArmature;
                    if (this._displayIndex >= 0 && this._displayIndex < this._displayList.length) {
                        this._display = this._displayList[this._displayIndex];
                        if (this._display instanceof dragonBones.Armature) {
                            this._childArmature = this._display;
                            this._display = this._childArmature._display;
                        } else {
                            this._childArmature = null;
                        }
                    } else {
                        this._display = null;
                        this._childArmature = null;
                    }
                    var currentDisplay = this._display || this._rawDisplay;
                    if (currentDisplay != prevDisplay) {
                        this._onUpdateDisplay();
                        prevDisplay ? this._replaceDisplay(prevDisplay) : this._addDisplay();
                        this._blendModeDirty = true;
                        this._colorDirty = true;
                    }
                    if (this._displayDataSet && this._displayIndex >= 0 && this._displayIndex < this._displayDataSet.displays.length) {
                        this.origin.copyFrom(this._displayDataSet.displays[this._displayIndex].transform);
                        this._originDirty = true;
                    }
                    this._updateMeshData(false);
                    currentDisplay != this._rawDisplay && currentDisplay != this._meshDisplay || this._updateFrame();
                    if (this._childArmature != prevChildArmature) {
                        if (prevChildArmature) {
                            prevChildArmature._parent = null;
                            this.inheritAnimation && prevChildArmature.animation.reset();
                        }
                        if (this._childArmature) {
                            this._childArmature._parent = this;
                            if (this.inheritAnimation) {
                                if (0 == this._childArmature.cacheFrameRate) {
                                    var cacheFrameRate = this._armature.cacheFrameRate;
                                    0 != cacheFrameRate && (this._childArmature.cacheFrameRate = cacheFrameRate);
                                }
                                var slotData = this._armature.armatureData.getSlot(this.name);
                                var actions = slotData.actions.length > 0 ? slotData.actions : this._childArmature.armatureData.actions;
                                if (actions.length > 0) {
                                    for (var i = 0, l = actions.length; i < l; ++i) {
                                        this._childArmature._bufferAction(actions[i]);
                                    }
                                } else {
                                    this._childArmature.animation.play();
                                }
                            }
                        }
                    }
                };
                Slot.prototype._updateLocalTransformMatrix = function() {
                    this.global.copyFrom(this.origin).add(this.offset).toMatrix(this._localMatrix);
                };
                Slot.prototype._updateGlobalTransformMatrix = function() {
                    this.globalTransformMatrix.copyFrom(this._localMatrix);
                    this.globalTransformMatrix.concat(this._parent.globalTransformMatrix);
                    this.global.fromMatrix(this.globalTransformMatrix);
                };
                Slot.prototype._setArmature = function(value) {
                    if (this._armature == value) {
                        return;
                    }
                    this._armature && this._armature._removeSlotFromSlotList(this);
                    this._armature = value;
                    this._onUpdateDisplay();
                    if (this._armature) {
                        this._armature._addSlotToSlotList(this);
                        this._addDisplay();
                    } else {
                        this._removeDisplay();
                    }
                };
                Slot.prototype._updateMeshData = function(isTimelineUpdate) {
                    var prevMeshData = this._meshData;
                    var rawMeshData = null;
                    if (this._display && this._display == this._meshDisplay && this._displayIndex >= 0) {
                        rawMeshData = this._displayDataSet && this._displayIndex < this._displayDataSet.displays.length ? this._displayDataSet.displays[this._displayIndex].mesh : null;
                        var replaceDisplayData = this._displayIndex < this._replacedDisplayDataSet.length ? this._replacedDisplayDataSet[this._displayIndex] : null;
                        var replaceMeshData = replaceDisplayData ? replaceDisplayData.mesh : null;
                        this._meshData = replaceMeshData || rawMeshData;
                    } else {
                        this._meshData = null;
                    }
                    if (this._meshData != prevMeshData) {
                        if (this._meshData && this._meshData == rawMeshData) {
                            if (this._meshData.skinned) {
                                this._meshBones.length = this._meshData.bones.length;
                                for (var i = 0, l = this._meshBones.length; i < l; ++i) {
                                    this._meshBones[i] = this._armature.getBone(this._meshData.bones[i].name);
                                }
                                var ffdVerticesCount = 0;
                                for (var i = 0, l = this._meshData.boneIndices.length; i < l; ++i) {
                                    ffdVerticesCount += this._meshData.boneIndices[i].length;
                                }
                                this._ffdVertices.length = 2 * ffdVerticesCount;
                            } else {
                                this._meshBones.length = 0;
                                this._ffdVertices.length = this._meshData.vertices.length;
                            }
                            for (var i = 0, l = this._ffdVertices.length; i < l; ++i) {
                                this._ffdVertices[i] = 0;
                            }
                            this._ffdDirty = true;
                        } else {
                            this._meshBones.length = 0;
                            this._ffdVertices.length = 0;
                        }
                        isTimelineUpdate && this._armature.animation._updateFFDTimelineStates();
                    }
                };
                Slot.prototype._update = function(cacheFrameIndex) {
                    var self = this;
                    self._blendIndex = 0;
                    if (self._zOrderDirty) {
                        self._zOrderDirty = false;
                        self._updateZOrder();
                    }
                    if (self._displayDirty) {
                        self._displayDirty = false;
                        self._updateDisplay();
                    }
                    if (!self._display) {
                        return;
                    }
                    if (self._blendModeDirty) {
                        self._blendModeDirty = false;
                        self._updateBlendMode();
                    }
                    if (self._colorDirty) {
                        self._colorDirty = false;
                        self._updateColor();
                    }
                    if (self._meshData) {
                        if (self._ffdDirty || self._meshData.skinned && self._isMeshBonesUpdate()) {
                            self._ffdDirty = false;
                            self._updateMesh();
                        }
                        if (self._meshData.skinned) {
                            return;
                        }
                    }
                    if (self._originDirty) {
                        self._originDirty = false;
                        self._transformDirty = true;
                        self._updateLocalTransformMatrix();
                    }
                    if (cacheFrameIndex >= 0 && self._cacheFrames) {
                        var cacheFrame = self._cacheFrames[cacheFrameIndex];
                        if (self.globalTransformMatrix == cacheFrame) {
                            self._transformDirty = false;
                        } else {
                            if (cacheFrame) {
                                self._transformDirty = true;
                                self.globalTransformMatrix = cacheFrame;
                            } else {
                                if (self._transformDirty || 0 != self._parent._transformDirty) {
                                    self._transformDirty = true;
                                    self.globalTransformMatrix = self._globalTransformMatrix;
                                } else {
                                    if (self.globalTransformMatrix != self._globalTransformMatrix) {
                                        self._transformDirty = false;
                                        self._cacheFrames[cacheFrameIndex] = self.globalTransformMatrix;
                                    } else {
                                        self._transformDirty = true;
                                        self.globalTransformMatrix = self._globalTransformMatrix;
                                    }
                                }
                            }
                        }
                    } else {
                        if (self._transformDirty || 0 != self._parent._transformDirty) {
                            self._transformDirty = true;
                            self.globalTransformMatrix = self._globalTransformMatrix;
                        }
                    }
                    if (self._transformDirty) {
                        self._transformDirty = false;
                        if (self.globalTransformMatrix == self._globalTransformMatrix) {
                            self._updateGlobalTransformMatrix();
                            cacheFrameIndex >= 0 && self._cacheFrames && !self._cacheFrames[cacheFrameIndex] && (self.globalTransformMatrix = dragonBones.SlotTimelineData.cacheFrame(self._cacheFrames, cacheFrameIndex, self._globalTransformMatrix));
                        }
                        self._updateTransform();
                    }
                };
                Slot.prototype._setDisplayList = function(value) {
                    if (value && value.length > 0) {
                        this._displayList.length != value.length && (this._displayList.length = value.length);
                        for (var i = 0, l = value.length; i < l; ++i) {
                            var eachDisplay = value[i];
                            eachDisplay && eachDisplay != this._rawDisplay && eachDisplay != this._meshDisplay && !(eachDisplay instanceof dragonBones.Armature) && this._displayList.indexOf(eachDisplay) < 0 && this._initDisplay(eachDisplay);
                            this._displayList[i] = eachDisplay;
                        }
                    } else {
                        this._displayList.length > 0 && (this._displayList.length = 0);
                    }
                    this._displayIndex >= 0 && this._displayIndex < this._displayList.length ? this._displayDirty = this._display != this._displayList[this._displayIndex] : this._displayDirty = null != this._display;
                    return this._displayDirty;
                };
                Slot.prototype._setZorder = function(value) {
                    this._zOrder == value;
                    this._zOrder = value;
                    this._zOrderDirty = true;
                    return this._zOrderDirty;
                };
                Slot.prototype._setDisplayIndex = function(value) {
                    if (this._displayIndex == value) {
                        return false;
                    }
                    this._displayIndex = value;
                    this._displayDirty = true;
                    return this._displayDirty;
                };
                Slot.prototype._setBlendMode = function(value) {
                    if (this._blendMode == value) {
                        return false;
                    }
                    this._blendMode = value;
                    this._blendModeDirty = true;
                    return true;
                };
                Slot.prototype._setColor = function(value) {
                    this._colorTransform.copyFrom(value);
                    this._colorDirty = true;
                    return true;
                };
                Slot.prototype.containsPoint = function(x, y, color) {
                    void 0 === color && (color = 0);
                    var displayData = this.displayData;
                    if (!displayData || !displayData.boundingBox || color && displayData.color != color) {
                        return false;
                    }
                    if (0 == this._blendIndex) {
                        this._blendIndex = 1;
                        this._updateLocalTransformMatrix();
                        this._updateGlobalTransformMatrix();
                    }
                    Slot._helpMatrix.copyFrom(this.globalTransformMatrix);
                    Slot._helpMatrix.invert();
                    Slot._helpMatrix.transformPoint(x, y, Slot._helpPoint);
                    return displayData.boundingBox.containsPoint(Slot._helpPoint.x, Slot._helpPoint.y);
                };
                Slot.prototype.intersectsSegment = function(xA, yA, xB, yB, color, intersectionPointA, intersectionPointB, normalRadians) {
                    void 0 === color && (color = 0);
                    void 0 === intersectionPointA && (intersectionPointA = null);
                    void 0 === intersectionPointB && (intersectionPointB = null);
                    void 0 === normalRadians && (normalRadians = null);
                    var displayData = this.displayData;
                    if (!displayData || !displayData.boundingBox || color && displayData.color != color) {
                        return 0;
                    }
                    if (0 == this._blendIndex) {
                        this._blendIndex = 1;
                        this._updateLocalTransformMatrix();
                        this._updateGlobalTransformMatrix();
                    }
                    Slot._helpMatrix.copyFrom(this.globalTransformMatrix);
                    Slot._helpMatrix.invert();
                    Slot._helpMatrix.transformPoint(xA, yA, Slot._helpPoint);
                    xA = Slot._helpPoint.x;
                    yA = Slot._helpPoint.y;
                    Slot._helpMatrix.transformPoint(xB, yB, Slot._helpPoint);
                    xB = Slot._helpPoint.x;
                    yB = Slot._helpPoint.y;
                    var intersectionCount = displayData.boundingBox.intersectsSegment(xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians);
                    if (intersectionCount > 0) {
                        if (1 == intersectionCount || 2 == intersectionCount) {
                            if (intersectionPointA) {
                                this.globalTransformMatrix.transformPoint(intersectionPointA.x, intersectionPointA.y, intersectionPointA);
                                if (intersectionPointB) {
                                    intersectionPointB.x = intersectionPointA.x;
                                    intersectionPointB.y = intersectionPointA.y;
                                }
                            } else {
                                intersectionPointB && this.globalTransformMatrix.transformPoint(intersectionPointB.x, intersectionPointB.y, intersectionPointB);
                            }
                        } else {
                            intersectionPointA && this.globalTransformMatrix.transformPoint(intersectionPointA.x, intersectionPointA.y, intersectionPointA);
                            intersectionPointB && this.globalTransformMatrix.transformPoint(intersectionPointB.x, intersectionPointB.y, intersectionPointB);
                        }
                        if (normalRadians) {
                            this.globalTransformMatrix.transformPoint(Math.cos(normalRadians.x), Math.sin(normalRadians.x), Slot._helpPoint, true);
                            normalRadians.x = Math.atan2(Slot._helpPoint.y, Slot._helpPoint.x);
                            this.globalTransformMatrix.transformPoint(Math.cos(normalRadians.y), Math.sin(normalRadians.y), Slot._helpPoint, true);
                            normalRadians.y = Math.atan2(Slot._helpPoint.y, Slot._helpPoint.x);
                        }
                    }
                    return intersectionCount;
                };
                Slot.prototype.invalidUpdate = function() {
                    this._displayDirty = true;
                };
                Object.defineProperty(Slot.prototype, "displayData", {
                    get: function() {
                        if (this._displayIndex < 0 || this._displayIndex >= this._displayDataSet.displays.length) {
                            return null;
                        }
                        return this._displayDataSet.displays[this._displayIndex];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Slot.prototype, "rawDisplay", {
                    get: function() {
                        return this._rawDisplay;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Slot.prototype, "meshDisplay", {
                    get: function() {
                        return this._meshDisplay;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Slot.prototype, "displayIndex", {
                    get: function() {
                        return this._displayIndex;
                    },
                    set: function(value) {
                        this._setDisplayIndex(value) && this._update(-1);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Slot.prototype, "displayList", {
                    get: function() {
                        return this._displayList.concat();
                    },
                    set: function(value) {
                        var backupDisplayList = this._displayList.concat();
                        var disposeDisplayList = [];
                        this._setDisplayList(value) && this._update(-1);
                        for (var i = 0, l = backupDisplayList.length; i < l; ++i) {
                            var eachDisplay = backupDisplayList[i];
                            eachDisplay && eachDisplay != this._rawDisplay && eachDisplay != this._meshDisplay && this._displayList.indexOf(eachDisplay) < 0 && disposeDisplayList.indexOf(eachDisplay) < 0 && disposeDisplayList.push(eachDisplay);
                        }
                        for (var i = 0, l = disposeDisplayList.length; i < l; ++i) {
                            var eachDisplay = disposeDisplayList[i];
                            eachDisplay instanceof dragonBones.Armature ? eachDisplay.dispose() : this._disposeDisplay(eachDisplay);
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Slot.prototype, "display", {
                    get: function() {
                        return this._display;
                    },
                    set: function(value) {
                        if (this._display == value) {
                            return;
                        }
                        var displayListLength = this._displayList.length;
                        this._displayIndex < 0 && 0 == displayListLength && (this._displayIndex = 0);
                        if (this._displayIndex < 0) {
                            return;
                        }
                        var replaceDisplayList = this.displayList;
                        displayListLength <= this._displayIndex && (replaceDisplayList.length = this._displayIndex + 1);
                        replaceDisplayList[this._displayIndex] = value;
                        this.displayList = replaceDisplayList;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Slot.prototype, "childArmature", {
                    get: function() {
                        return this._childArmature;
                    },
                    set: function(value) {
                        if (this._childArmature == value) {
                            return;
                        }
                        value && value.display.advanceTimeBySelf(false);
                        this.display = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Slot.prototype.getDisplay = function() {
                    return this._display;
                };
                Slot.prototype.setDisplay = function(value) {
                    this.display = value;
                };
                Slot._helpPoint = new dragonBones.Point();
                Slot._helpMatrix = new dragonBones.Matrix();
                return Slot;
            })(dragonBones.TransformObject);
            dragonBones.Slot = Slot;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var EventObject = (function(_super) {
                __extends(EventObject, _super);
                function EventObject() {
                    _super.call(this);
                }
                EventObject.toString = function() {
                    return "[class dragonBones.EventObject]";
                };
                EventObject.prototype._onClear = function() {
                    this.type = null;
                    this.name = null;
                    this.armature = null;
                    this.bone = null;
                    this.slot = null;
                    this.animationState = null;
                    this.frame = null;
                    this.data = null;
                    this.userData = null;
                };
                EventObject.prototype.getInt = function(index) {
                    return this.data ? this.data.ints[index] : 0;
                };
                EventObject.prototype.getFloat = function(index) {
                    return this.data ? this.data.floats[index] : 0;
                };
                EventObject.prototype.getString = function(index) {
                    return this.data ? this.data.strings[index] : null;
                };
                EventObject.START = "start";
                EventObject.LOOP_COMPLETE = "loopComplete";
                EventObject.COMPLETE = "complete";
                EventObject.FADE_IN = "fadeIn";
                EventObject.FADE_IN_COMPLETE = "fadeInComplete";
                EventObject.FADE_OUT = "fadeOut";
                EventObject.FADE_OUT_COMPLETE = "fadeOutComplete";
                EventObject.FRAME_EVENT = "frameEvent";
                EventObject.SOUND_EVENT = "soundEvent";
                return EventObject;
            })(dragonBones.BaseObject);
            dragonBones.EventObject = EventObject;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var TimelineData = (function(_super) {
                __extends(TimelineData, _super);
                function TimelineData() {
                    _super.call(this);
                    this.frames = [];
                }
                TimelineData.toString = function() {
                    return "[class dragonBones.TimelineData]";
                };
                TimelineData.prototype._onClear = function() {
                    var prevFrame = null;
                    for (var i = 0, l = this.frames.length; i < l; ++i) {
                        var frame = this.frames[i];
                        prevFrame && frame != prevFrame && prevFrame.returnToPool();
                        prevFrame = frame;
                    }
                    this.scale = 1;
                    this.offset = 0;
                    this.frames.length = 0;
                };
                return TimelineData;
            })(dragonBones.BaseObject);
            dragonBones.TimelineData = TimelineData;
            var ZOrderTimelineData = (function(_super) {
                __extends(ZOrderTimelineData, _super);
                function ZOrderTimelineData() {
                    _super.apply(this, arguments);
                }
                ZOrderTimelineData.toString = function() {
                    return "[class dragonBones.ZOrderTimelineData]";
                };
                return ZOrderTimelineData;
            })(TimelineData);
            dragonBones.ZOrderTimelineData = ZOrderTimelineData;
            var BoneTimelineData = (function(_super) {
                __extends(BoneTimelineData, _super);
                function BoneTimelineData() {
                    _super.call(this);
                    this.originalTransform = new dragonBones.Transform();
                    this.cachedFrames = [];
                }
                BoneTimelineData.cacheFrame = function(cacheFrames, cacheFrameIndex, globalTransformMatrix) {
                    var cacheMatrix = cacheFrames[cacheFrameIndex] = new dragonBones.Matrix();
                    cacheMatrix.copyFrom(globalTransformMatrix);
                    return cacheMatrix;
                };
                BoneTimelineData.toString = function() {
                    return "[class dragonBones.BoneTimelineData]";
                };
                BoneTimelineData.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this.bone = null;
                    this.originalTransform.identity();
                    this.cachedFrames.length = 0;
                };
                BoneTimelineData.prototype.cacheFrames = function(cacheFrameCount) {
                    this.cachedFrames.length = 0;
                    this.cachedFrames.length = cacheFrameCount;
                };
                return BoneTimelineData;
            })(TimelineData);
            dragonBones.BoneTimelineData = BoneTimelineData;
            var SlotTimelineData = (function(_super) {
                __extends(SlotTimelineData, _super);
                function SlotTimelineData() {
                    _super.call(this);
                    this.cachedFrames = [];
                }
                SlotTimelineData.cacheFrame = function(cacheFrames, cacheFrameIndex, globalTransformMatrix) {
                    var cacheMatrix = cacheFrames[cacheFrameIndex] = new dragonBones.Matrix();
                    cacheMatrix.copyFrom(globalTransformMatrix);
                    return cacheMatrix;
                };
                SlotTimelineData.toString = function() {
                    return "[class dragonBones.SlotTimelineData]";
                };
                SlotTimelineData.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this.slot = null;
                    this.cachedFrames.length = 0;
                };
                SlotTimelineData.prototype.cacheFrames = function(cacheFrameCount) {
                    this.cachedFrames.length = 0;
                    this.cachedFrames.length = cacheFrameCount;
                };
                return SlotTimelineData;
            })(TimelineData);
            dragonBones.SlotTimelineData = SlotTimelineData;
            var FFDTimelineData = (function(_super) {
                __extends(FFDTimelineData, _super);
                function FFDTimelineData() {
                    _super.call(this);
                }
                FFDTimelineData.toString = function() {
                    return "[class dragonBones.FFDTimelineData]";
                };
                FFDTimelineData.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this.skin = null;
                    this.slot = null;
                    this.display = null;
                };
                return FFDTimelineData;
            })(TimelineData);
            dragonBones.FFDTimelineData = FFDTimelineData;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var AnimationData = (function(_super) {
                __extends(AnimationData, _super);
                function AnimationData() {
                    _super.call(this);
                    this.boneTimelines = {};
                    this.slotTimelines = {};
                    this.ffdTimelines = {};
                    this.cachedFrames = [];
                }
                AnimationData.toString = function() {
                    return "[class dragonBones.AnimationData]";
                };
                AnimationData.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this.zOrderTimeline && this.zOrderTimeline.returnToPool();
                    for (var i in this.boneTimelines) {
                        this.boneTimelines[i].returnToPool();
                        delete this.boneTimelines[i];
                    }
                    for (var i in this.slotTimelines) {
                        this.slotTimelines[i].returnToPool();
                        delete this.slotTimelines[i];
                    }
                    for (var i in this.ffdTimelines) {
                        for (var j in this.ffdTimelines[i]) {
                            for (var k in this.ffdTimelines[i][j]) {
                                this.ffdTimelines[i][j][k].returnToPool();
                            }
                        }
                        delete this.ffdTimelines[i];
                    }
                    this.hasAsynchronyTimeline = false;
                    this.frameCount = 0;
                    this.playTimes = 0;
                    this.position = 0;
                    this.duration = 0;
                    this.fadeInTime = 0;
                    this.cacheFrameRate = 0;
                    this.name = null;
                    this.animation = null;
                    this.zOrderTimeline = null;
                    this.cachedFrames.length = 0;
                };
                AnimationData.prototype.cacheFrames = function(cacheFrameRate) {
                    if (this.animation) {
                        return;
                    }
                    this.cacheFrameRate = Math.max(Math.ceil(cacheFrameRate * this.scale), 1);
                    var cacheFrameCount = Math.ceil(this.cacheFrameRate * this.duration) + 1;
                    this.cachedFrames.length = 0;
                    this.cachedFrames.length = cacheFrameCount;
                    for (var i in this.boneTimelines) {
                        this.boneTimelines[i].cacheFrames(cacheFrameCount);
                    }
                    for (var i in this.slotTimelines) {
                        this.slotTimelines[i].cacheFrames(cacheFrameCount);
                    }
                };
                AnimationData.prototype.addBoneTimeline = function(value) {
                    if (!value || !value.bone || this.boneTimelines[value.bone.name]) {
                        throw new Error();
                    }
                    this.boneTimelines[value.bone.name] = value;
                };
                AnimationData.prototype.addSlotTimeline = function(value) {
                    if (!value || !value.slot || this.slotTimelines[value.slot.name]) {
                        throw new Error();
                    }
                    this.slotTimelines[value.slot.name] = value;
                };
                AnimationData.prototype.addFFDTimeline = function(value) {
                    if (!(value && value.skin && value.slot && value.display)) {
                        throw new Error();
                    }
                    var skin = this.ffdTimelines[value.skin.name] = this.ffdTimelines[value.skin.name] || {};
                    var slot = skin[value.slot.slot.name] = skin[value.slot.slot.name] || {};
                    if (slot[value.display.name]) {
                        throw new Error();
                    }
                    slot[value.display.name] = value;
                };
                AnimationData.prototype.getBoneTimeline = function(name) {
                    return this.boneTimelines[name];
                };
                AnimationData.prototype.getSlotTimeline = function(name) {
                    return this.slotTimelines[name];
                };
                AnimationData.prototype.getFFDTimeline = function(skinName, slotName, displayName) {
                    var skin = this.ffdTimelines[skinName];
                    if (skin) {
                        var slot = skin[slotName];
                        if (slot) {
                            return slot[displayName];
                        }
                    }
                    return null;
                };
                return AnimationData;
            })(dragonBones.TimelineData);
            dragonBones.AnimationData = AnimationData;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var ArmatureData = (function(_super) {
                __extends(ArmatureData, _super);
                function ArmatureData() {
                    _super.call(this);
                    this.aabb = new dragonBones.Rectangle();
                    this.bones = {};
                    this.slots = {};
                    this.skins = {};
                    this.animations = {};
                    this.actions = [];
                    this._sortedBones = [];
                    this._sortedSlots = [];
                    this._bonesChildren = {};
                }
                ArmatureData._onSortSlots = function(a, b) {
                    return a.zOrder > b.zOrder ? 1 : -1;
                };
                ArmatureData.toString = function() {
                    return "[class dragonBones.ArmatureData]";
                };
                ArmatureData.prototype._onClear = function() {
                    for (var i in this.bones) {
                        this.bones[i].returnToPool();
                        delete this.bones[i];
                    }
                    for (var i in this.slots) {
                        this.slots[i].returnToPool();
                        delete this.slots[i];
                    }
                    for (var i in this.skins) {
                        this.skins[i].returnToPool();
                        delete this.skins[i];
                    }
                    for (var i in this.animations) {
                        this.animations[i].returnToPool();
                        delete this.animations[i];
                    }
                    for (var i = 0, l = this.actions.length; i < l; ++i) {
                        this.actions[i].returnToPool();
                    }
                    this.frameRate = 0;
                    this.type = -1;
                    this.name = null;
                    this.parent = null;
                    this.userData = null;
                    this.aabb.clear();
                    this.actions.length = 0;
                    this.cacheFrameRate = 0;
                    this.scale = 1;
                    for (var i in this._bonesChildren) {
                        delete this._bonesChildren[i];
                    }
                    this._boneDirty = false;
                    this._slotDirty = false;
                    this._defaultSkin = null;
                    this._defaultAnimation = null;
                    this._sortedBones.length = 0;
                    this._sortedSlots.length = 0;
                };
                ArmatureData.prototype._sortBones = function() {
                    var total = this._sortedBones.length;
                    if (total < 1) {
                        return;
                    }
                    var sortHelper = this._sortedBones.concat();
                    var index = 0;
                    var count = 0;
                    this._sortedBones.length = 0;
                    while (count < total) {
                        var bone = sortHelper[index++];
                        index >= total && (index = 0);
                        if (this._sortedBones.indexOf(bone) >= 0) {
                            continue;
                        }
                        if (bone.parent && this._sortedBones.indexOf(bone.parent) < 0) {
                            continue;
                        }
                        if (bone.ik && this._sortedBones.indexOf(bone.ik) < 0) {
                            continue;
                        }
                        bone.ik && bone.chain > 0 && bone.chainIndex == bone.chain ? this._sortedBones.splice(this._sortedBones.indexOf(bone.parent) + 1, 0, bone) : this._sortedBones.push(bone);
                        count++;
                    }
                };
                ArmatureData.prototype._sortSlots = function() {
                    this._sortedSlots.sort(ArmatureData._onSortSlots);
                };
                ArmatureData.prototype.cacheFrames = function(value) {
                    if (this.cacheFrameRate == value) {
                        return;
                    }
                    this.cacheFrameRate = value;
                    for (var i in this.animations) {
                        this.animations[i].cacheFrames(this.cacheFrameRate);
                    }
                };
                ArmatureData.prototype.addBone = function(value, parentName) {
                    if (!value || !value.name || this.bones[value.name]) {
                        throw new Error();
                    }
                    if (parentName) {
                        var parent_1 = this.getBone(parentName);
                        parent_1 ? value.parent = parent_1 : (this._bonesChildren[parentName] = this._bonesChildren[parentName] || []).push(value);
                    }
                    var children = this._bonesChildren[value.name];
                    if (children) {
                        for (var i = 0, l = children.length; i < l; ++i) {
                            children[i].parent = value;
                        }
                        delete this._bonesChildren[value.name];
                    }
                    this.bones[value.name] = value;
                    this._sortedBones.push(value);
                    this._boneDirty = true;
                };
                ArmatureData.prototype.addSlot = function(value) {
                    if (!value || !value.name || this.slots[value.name]) {
                        throw new Error();
                    }
                    this.slots[value.name] = value;
                    this._sortedSlots.push(value);
                    this._slotDirty = true;
                };
                ArmatureData.prototype.addSkin = function(value) {
                    if (!value || !value.name || this.skins[value.name]) {
                        throw new Error();
                    }
                    this.skins[value.name] = value;
                    this._defaultSkin || (this._defaultSkin = value);
                };
                ArmatureData.prototype.addAnimation = function(value) {
                    if (!value || !value.name || this.animations[value.name]) {
                        throw new Error();
                    }
                    this.animations[value.name] = value;
                    this._defaultAnimation || (this._defaultAnimation = value);
                };
                ArmatureData.prototype.getBone = function(name) {
                    return this.bones[name];
                };
                ArmatureData.prototype.getSlot = function(name) {
                    return this.slots[name];
                };
                ArmatureData.prototype.getSkin = function(name) {
                    return name ? this.skins[name] : this._defaultSkin;
                };
                ArmatureData.prototype.getAnimation = function(name) {
                    return name ? this.animations[name] : this._defaultAnimation;
                };
                Object.defineProperty(ArmatureData.prototype, "sortedBones", {
                    get: function() {
                        if (this._boneDirty) {
                            this._boneDirty = false;
                            this._sortBones();
                        }
                        return this._sortedBones;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArmatureData.prototype, "sortedSlots", {
                    get: function() {
                        if (this._slotDirty) {
                            this._slotDirty = false;
                            this._sortSlots();
                        }
                        return this._sortedSlots;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArmatureData.prototype, "defaultSkin", {
                    get: function() {
                        return this._defaultSkin;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ArmatureData.prototype, "defaultAnimation", {
                    get: function() {
                        return this._defaultAnimation;
                    },
                    enumerable: true,
                    configurable: true
                });
                return ArmatureData;
            })(dragonBones.BaseObject);
            dragonBones.ArmatureData = ArmatureData;
            var BoneData = (function(_super) {
                __extends(BoneData, _super);
                function BoneData() {
                    _super.call(this);
                    this.transform = new dragonBones.Transform();
                }
                BoneData.toString = function() {
                    return "[class dragonBones.BoneData]";
                };
                BoneData.prototype._onClear = function() {
                    this.inheritTranslation = false;
                    this.inheritRotation = false;
                    this.inheritScale = false;
                    this.bendPositive = false;
                    this.chain = 0;
                    this.chainIndex = 0;
                    this.weight = 0;
                    this.length = 0;
                    this.name = null;
                    this.parent = null;
                    this.ik = null;
                    this.transform.identity();
                };
                return BoneData;
            })(dragonBones.BaseObject);
            dragonBones.BoneData = BoneData;
            var SlotData = (function(_super) {
                __extends(SlotData, _super);
                function SlotData() {
                    _super.call(this);
                    this.actions = [];
                }
                SlotData.generateColor = function() {
                    return new dragonBones.ColorTransform();
                };
                SlotData.toString = function() {
                    return "[class dragonBones.SlotData]";
                };
                SlotData.prototype._onClear = function() {
                    for (var i = 0, l = this.actions.length; i < l; ++i) {
                        this.actions[i].returnToPool();
                    }
                    this.displayIndex = 0;
                    this.zOrder = 0;
                    this.blendMode = 0;
                    this.name = null;
                    this.parent = null;
                    this.color = null;
                    this.actions.length = 0;
                };
                SlotData.DEFAULT_COLOR = new dragonBones.ColorTransform();
                return SlotData;
            })(dragonBones.BaseObject);
            dragonBones.SlotData = SlotData;
            var SkinData = (function(_super) {
                __extends(SkinData, _super);
                function SkinData() {
                    _super.call(this);
                    this.slots = {};
                }
                SkinData.toString = function() {
                    return "[class dragonBones.SkinData]";
                };
                SkinData.prototype._onClear = function() {
                    for (var i in this.slots) {
                        this.slots[i].returnToPool();
                        delete this.slots[i];
                    }
                    this.name = null;
                };
                SkinData.prototype.addSlot = function(value) {
                    if (!value || !value.slot || this.slots[value.slot.name]) {
                        throw new Error();
                    }
                    this.slots[value.slot.name] = value;
                };
                SkinData.prototype.getSlot = function(name) {
                    return this.slots[name];
                };
                return SkinData;
            })(dragonBones.BaseObject);
            dragonBones.SkinData = SkinData;
            var SlotDisplayDataSet = (function(_super) {
                __extends(SlotDisplayDataSet, _super);
                function SlotDisplayDataSet() {
                    _super.call(this);
                    this.displays = [];
                }
                SlotDisplayDataSet.toString = function() {
                    return "[class dragonBones.SlotDisplayDataSet]";
                };
                SlotDisplayDataSet.prototype._onClear = function() {
                    for (var i = 0, l = this.displays.length; i < l; ++i) {
                        this.displays[i].returnToPool();
                    }
                    this.slot = null;
                    this.displays.length = 0;
                };
                return SlotDisplayDataSet;
            })(dragonBones.BaseObject);
            dragonBones.SlotDisplayDataSet = SlotDisplayDataSet;
            var DisplayData = (function(_super) {
                __extends(DisplayData, _super);
                function DisplayData() {
                    _super.call(this);
                    this.pivot = new dragonBones.Point();
                    this.transform = new dragonBones.Transform();
                }
                DisplayData.toString = function() {
                    return "[class dragonBones.DisplayData]";
                };
                DisplayData.prototype._onClear = function() {
                    this.mesh && !this.share && this.mesh.returnToPool();
                    this.boundingBox && this.boundingBox.returnToPool();
                    this.isRelativePivot = false;
                    this.type = -1;
                    this.inheritAnimation = true;
                    this.color = 0;
                    this.name = null;
                    this.path = null;
                    this.texture = null;
                    this.armature = null;
                    this.mesh = null;
                    this.share = null;
                    this.boundingBox = null;
                    this.pivot.clear();
                    this.transform.identity();
                };
                return DisplayData;
            })(dragonBones.BaseObject);
            dragonBones.DisplayData = DisplayData;
            var MeshData = (function(_super) {
                __extends(MeshData, _super);
                function MeshData() {
                    _super.call(this);
                    this.slotPose = new dragonBones.Matrix();
                    this.uvs = [];
                    this.vertices = [];
                    this.vertexIndices = [];
                    this.boneIndices = [];
                    this.weights = [];
                    this.boneVertices = [];
                    this.bones = [];
                    this.inverseBindPose = [];
                }
                MeshData.toString = function() {
                    return "[class dragonBones.MeshData]";
                };
                MeshData.prototype._onClear = function() {
                    this.skinned = false;
                    this.slotPose.identity();
                    this.uvs.length = 0;
                    this.vertices.length = 0;
                    this.vertexIndices.length = 0;
                    this.boneIndices.length = 0;
                    this.weights.length = 0;
                    this.boneVertices.length = 0;
                    this.bones.length = 0;
                    this.inverseBindPose.length = 0;
                };
                return MeshData;
            })(dragonBones.BaseObject);
            dragonBones.MeshData = MeshData;
            var BoundingBoxData = (function(_super) {
                __extends(BoundingBoxData, _super);
                function BoundingBoxData() {
                    _super.call(this);
                    this.x = 0;
                    this.y = 0;
                    this.width = 0;
                    this.height = 0;
                    this.vertices = [];
                }
                BoundingBoxData.toString = function() {
                    return "[class dragonBones.BoundingBoxData]";
                };
                BoundingBoxData._computeOutCode = function(x, y, xMin, yMin, xMax, yMax) {
                    var code = 0;
                    x < xMin ? code |= 1 : x > xMax && (code |= 2);
                    y < yMin ? code |= 4 : y > yMax && (code |= 8);
                    return code;
                };
                BoundingBoxData.segmentIntersectsRectangle = function(xA, yA, xB, yB, xMin, yMin, xMax, yMax, intersectionPointA, intersectionPointB, normalRadians) {
                    void 0 === intersectionPointA && (intersectionPointA = null);
                    void 0 === intersectionPointB && (intersectionPointB = null);
                    void 0 === normalRadians && (normalRadians = null);
                    var inSideA = xA > xMin && xA < xMax && yA > yMin && yA < yMax;
                    var inSideB = xB > xMin && xB < xMax && yB > yMin && yB < yMax;
                    if (inSideA && inSideB) {
                        return -1;
                    }
                    var intersectionCount = 0;
                    var outcode0 = BoundingBoxData._computeOutCode(xA, yA, xMin, yMin, xMax, yMax);
                    var outcode1 = BoundingBoxData._computeOutCode(xB, yB, xMin, yMin, xMax, yMax);
                    while (true) {
                        if (!(outcode0 | outcode1)) {
                            intersectionCount = 2;
                            break;
                        }
                        if (outcode0 & outcode1) {
                            break;
                        }
                        var x = 0;
                        var y = 0;
                        var normalRadian = 0;
                        var outcodeOut = outcode0 ? outcode0 : outcode1;
                        if (4 & outcodeOut) {
                            x = xA + (xB - xA) * (yMin - yA) / (yB - yA);
                            y = yMin;
                            normalRadians && (normalRadian = .5 * -Math.PI);
                        } else {
                            if (8 & outcodeOut) {
                                x = xA + (xB - xA) * (yMax - yA) / (yB - yA);
                                y = yMax;
                                normalRadians && (normalRadian = .5 * Math.PI);
                            } else {
                                if (2 & outcodeOut) {
                                    y = yA + (yB - yA) * (xMax - xA) / (xB - xA);
                                    x = xMax;
                                    normalRadians && (normalRadian = 0);
                                } else {
                                    if (1 & outcodeOut) {
                                        y = yA + (yB - yA) * (xMin - xA) / (xB - xA);
                                        x = xMin;
                                        normalRadians && (normalRadian = Math.PI);
                                    }
                                }
                            }
                        }
                        if (outcodeOut == outcode0) {
                            xA = x;
                            yA = y;
                            outcode0 = BoundingBoxData._computeOutCode(xA, yA, xMin, yMin, xMax, yMax);
                            normalRadians && (normalRadians.x = normalRadian);
                        } else {
                            xB = x;
                            yB = y;
                            outcode1 = BoundingBoxData._computeOutCode(xB, yB, xMin, yMin, xMax, yMax);
                            normalRadians && (normalRadians.y = normalRadian);
                        }
                    }
                    if (intersectionCount) {
                        if (inSideA) {
                            intersectionCount = 2;
                            if (intersectionPointA) {
                                intersectionPointA.x = xB;
                                intersectionPointA.y = yB;
                            }
                            if (intersectionPointB) {
                                intersectionPointB.x = xB;
                                intersectionPointB.y = xB;
                            }
                            normalRadians && (normalRadians.x = normalRadians.y + Math.PI);
                        } else {
                            if (inSideB) {
                                intersectionCount = 1;
                                if (intersectionPointA) {
                                    intersectionPointA.x = xA;
                                    intersectionPointA.y = yA;
                                }
                                if (intersectionPointB) {
                                    intersectionPointB.x = xA;
                                    intersectionPointB.y = yA;
                                }
                                normalRadians && (normalRadians.y = normalRadians.x + Math.PI);
                            } else {
                                intersectionCount = 3;
                                if (intersectionPointA) {
                                    intersectionPointA.x = xA;
                                    intersectionPointA.y = yA;
                                }
                                if (intersectionPointB) {
                                    intersectionPointB.x = xB;
                                    intersectionPointB.y = yB;
                                }
                            }
                        }
                    }
                    return intersectionCount;
                };
                BoundingBoxData.segmentIntersectsEllipse = function(xA, yA, xB, yB, xC, yC, widthH, heightH, intersectionPointA, intersectionPointB, normalRadians) {
                    void 0 === intersectionPointA && (intersectionPointA = null);
                    void 0 === intersectionPointB && (intersectionPointB = null);
                    void 0 === normalRadians && (normalRadians = null);
                    var d = widthH / heightH;
                    var dd = d * d;
                    yA *= d;
                    yB *= d;
                    var dX = xB - xA;
                    var dY = yB - yA;
                    var lAB = Math.sqrt(dX * dX + dY * dY);
                    var xD = dX / lAB;
                    var yD = dY / lAB;
                    var a = (xC - xA) * xD + (yC - yA) * yD;
                    var aa = a * a;
                    var ee = xA * xA + yA * yA;
                    var rr = widthH * widthH;
                    var dR = rr - ee + aa;
                    var intersectionCount = 0;
                    if (dR >= 0) {
                        var dT = Math.sqrt(dR);
                        var sA = a - dT;
                        var sB = a + dT;
                        var inSideA = sA < 0 ? -1 : sA <= lAB ? 0 : 1;
                        var inSideB = sB < 0 ? -1 : sB <= lAB ? 0 : 1;
                        var sideAB = inSideA * inSideB;
                        if (sideAB < 0) {
                            return -1;
                        }
                        if (0 == sideAB) {
                            if (inSideA == -1) {
                                intersectionCount = 2;
                                xB = xA + sB * xD;
                                yB = (yA + sB * yD) / d;
                                if (intersectionPointA) {
                                    intersectionPointA.x = xB;
                                    intersectionPointA.y = yB;
                                }
                                if (intersectionPointB) {
                                    intersectionPointB.x = xB;
                                    intersectionPointB.y = yB;
                                }
                                if (normalRadians) {
                                    normalRadians.x = Math.atan2(yB / rr * dd, xB / rr);
                                    normalRadians.y = normalRadians.x + Math.PI;
                                }
                            } else {
                                if (1 == inSideB) {
                                    intersectionCount = 1;
                                    xA += sA * xD;
                                    yA = (yA + sA * yD) / d;
                                    if (intersectionPointA) {
                                        intersectionPointA.x = xA;
                                        intersectionPointA.y = yA;
                                    }
                                    if (intersectionPointB) {
                                        intersectionPointB.x = xA;
                                        intersectionPointB.y = yA;
                                    }
                                    if (normalRadians) {
                                        normalRadians.x = Math.atan2(yA / rr * dd, xA / rr);
                                        normalRadians.y = normalRadians.x + Math.PI;
                                    }
                                } else {
                                    intersectionCount = 3;
                                    if (intersectionPointA) {
                                        intersectionPointA.x = xA + sA * xD;
                                        intersectionPointA.y = (yA + sA * yD) / d;
                                        normalRadians && (normalRadians.x = Math.atan2(intersectionPointA.y / rr * dd, intersectionPointA.x / rr));
                                    }
                                    if (intersectionPointB) {
                                        intersectionPointB.x = xA + sB * xD;
                                        intersectionPointB.y = (yA + sB * yD) / d;
                                        normalRadians && (normalRadians.y = Math.atan2(intersectionPointB.y / rr * dd, intersectionPointB.x / rr));
                                    }
                                }
                            }
                        }
                    }
                    return intersectionCount;
                };
                BoundingBoxData.segmentIntersectsPolygon = function(xA, yA, xB, yB, vertices, intersectionPointA, intersectionPointB, normalRadians) {
                    void 0 === intersectionPointA && (intersectionPointA = null);
                    void 0 === intersectionPointB && (intersectionPointB = null);
                    void 0 === normalRadians && (normalRadians = null);
                    xA == xB && (xA = xB + .01);
                    yA == yB && (yA = yB + .01);
                    var l = vertices.length;
                    var dXAB = xA - xB;
                    var dYAB = yA - yB;
                    var llAB = xA * yB - yA * xB;
                    var intersectionCount = 0;
                    var xC = vertices[l - 2];
                    var yC = vertices[l - 1];
                    var dMin = 0;
                    var dMax = 0;
                    var xMin = 0;
                    var yMin = 0;
                    var xMax = 0;
                    var yMax = 0;
                    for (var i = 0; i < l; i += 2) {
                        var xD = vertices[i];
                        var yD = vertices[i + 1];
                        xC == xD && (xC = xD + .01);
                        yC == yD && (yC = yD + .01);
                        var dXCD = xC - xD;
                        var dYCD = yC - yD;
                        var llCD = xC * yD - yC * xD;
                        var ll = dXAB * dYCD - dYAB * dXCD;
                        var x = (llAB * dXCD - dXAB * llCD) / ll;
                        if ((x >= xC && x <= xD || x >= xD && x <= xC) && (0 == dXAB || x >= xA && x <= xB || x >= xB && x <= xA)) {
                            var y = (llAB * dYCD - dYAB * llCD) / ll;
                            if ((y >= yC && y <= yD || y >= yD && y <= yC) && (0 == dYAB || y >= yA && y <= yB || y >= yB && y <= yA)) {
                                if (!intersectionPointB) {
                                    xMin = x;
                                    yMin = y;
                                    xMax = x;
                                    yMax = y;
                                    intersectionCount++;
                                    if (normalRadians) {
                                        normalRadians.x = Math.atan2(yD - yC, xD - xC) - .5 * Math.PI;
                                        normalRadians.y = normalRadians.x;
                                    }
                                    break;
                                }
                                var d = x - xA;
                                d < 0 && (d = -d);
                                if (0 == intersectionCount) {
                                    dMin = d;
                                    dMax = d;
                                    xMin = x;
                                    yMin = y;
                                    xMax = x;
                                    yMax = y;
                                    if (normalRadians) {
                                        normalRadians.x = Math.atan2(yD - yC, xD - xC) - .5 * Math.PI;
                                        normalRadians.y = normalRadians.x;
                                    }
                                } else {
                                    if (d < dMin) {
                                        dMin = d;
                                        xMin = x;
                                        yMin = y;
                                        normalRadians && (normalRadians.x = Math.atan2(yD - yC, xD - xC) - .5 * Math.PI);
                                    }
                                    if (d > dMax) {
                                        dMax = d;
                                        xMax = x;
                                        yMax = y;
                                        normalRadians && (normalRadians.y = Math.atan2(yD - yC, xD - xC) - .5 * Math.PI);
                                    }
                                }
                                intersectionCount++;
                            }
                        }
                        xC = xD;
                        yC = yD;
                    }
                    if (1 == intersectionCount) {
                        if (intersectionPointA) {
                            intersectionPointA.x = xMin;
                            intersectionPointA.y = yMin;
                        }
                        if (intersectionPointB) {
                            intersectionPointB.x = xMin;
                            intersectionPointB.y = yMin;
                        }
                        normalRadians && (normalRadians.y = normalRadians.x + Math.PI);
                    } else {
                        if (intersectionCount > 1) {
                            intersectionCount++;
                            if (intersectionPointA) {
                                intersectionPointA.x = xMin;
                                intersectionPointA.y = yMin;
                            }
                            if (intersectionPointB) {
                                intersectionPointB.x = xMax;
                                intersectionPointB.y = yMax;
                            }
                        }
                    }
                    return intersectionCount;
                };
                BoundingBoxData.prototype._onClear = function() {
                    this.type = -1;
                    this.x = 0;
                    this.y = 0;
                    this.width = 0;
                    this.height = 0;
                    this.vertices.length = 0;
                };
                BoundingBoxData.prototype.containsPoint = function(x, y) {
                    var isInSide = false;
                    if (2 == this.type) {
                        if (x >= this.x && x <= this.width && y >= this.y && y <= this.height) {
                            for (var i = 0, l = this.vertices.length, prevIndex = l - 2; i < l; i += 2) {
                                var yA = this.vertices[prevIndex + 1];
                                var yB = this.vertices[i + 1];
                                if (yB < y && yA >= y || yA < y && yB >= y) {
                                    var xA = this.vertices[prevIndex];
                                    var xB = this.vertices[i];
                                    (y - yB) * (xA - xB) / (yA - yB) + xB < x && (isInSide = !isInSide);
                                }
                                prevIndex = i;
                            }
                        }
                    } else {
                        var widthH = .5 * this.width;
                        if (x >= -widthH && x <= widthH) {
                            var heightH = .5 * this.height;
                            if (y >= -heightH && y <= heightH) {
                                if (1 == this.type) {
                                    y *= widthH / heightH;
                                    isInSide = Math.sqrt(x * x + y * y) <= widthH;
                                } else {
                                    isInSide = true;
                                }
                            }
                        }
                    }
                    return isInSide;
                };
                BoundingBoxData.prototype.intersectsSegment = function(xA, yA, xB, yB, intersectionPointA, intersectionPointB, normalRadians) {
                    void 0 === intersectionPointA && (intersectionPointA = null);
                    void 0 === intersectionPointB && (intersectionPointB = null);
                    void 0 === normalRadians && (normalRadians = null);
                    var intersectionCount = 0;
                    switch (this.type) {
                      case 0:
                        var widthH = .5 * this.width;
                        var heightH = .5 * this.height;
                        intersectionCount = BoundingBoxData.segmentIntersectsRectangle(xA, yA, xB, yB, -widthH, -heightH, widthH, heightH, intersectionPointA, intersectionPointB, normalRadians);
                        break;

                      case 1:
                        intersectionCount = BoundingBoxData.segmentIntersectsEllipse(xA, yA, xB, yB, 0, 0, .5 * this.width, .5 * this.height, intersectionPointA, intersectionPointB, normalRadians);
                        break;

                      case 2:
                        0 != BoundingBoxData.segmentIntersectsRectangle(xA, yA, xB, yB, this.x, this.y, this.width, this.height, null, null) && (intersectionCount = BoundingBoxData.segmentIntersectsPolygon(xA, yA, xB, yB, this.vertices, intersectionPointA, intersectionPointB, normalRadians));
                    }
                    return intersectionCount;
                };
                return BoundingBoxData;
            })(dragonBones.BaseObject);
            dragonBones.BoundingBoxData = BoundingBoxData;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var DragonBonesData = (function(_super) {
                __extends(DragonBonesData, _super);
                function DragonBonesData() {
                    _super.call(this);
                    this.armatures = {};
                    this._armatureNames = [];
                }
                DragonBonesData.toString = function() {
                    return "[class dragonBones.DragonBonesData]";
                };
                DragonBonesData.prototype._onClear = function() {
                    for (var i in this.armatures) {
                        this.armatures[i].returnToPool();
                        delete this.armatures[i];
                    }
                    this.autoSearch = false;
                    this.frameRate = 0;
                    this.name = null;
                    this._armatureNames.length = 0;
                };
                DragonBonesData.prototype.getArmature = function(name) {
                    return this.armatures[name];
                };
                DragonBonesData.prototype.addArmature = function(value) {
                    if (!value || !value.name || this.armatures[value.name]) {
                        throw new Error();
                    }
                    this.armatures[value.name] = value;
                    this._armatureNames.push(value.name);
                    value.parent = this;
                };
                Object.defineProperty(DragonBonesData.prototype, "armatureNames", {
                    get: function() {
                        return this._armatureNames;
                    },
                    enumerable: true,
                    configurable: true
                });
                DragonBonesData.prototype.dispose = function() {
                    this.returnToPool();
                };
                return DragonBonesData;
            })(dragonBones.BaseObject);
            dragonBones.DragonBonesData = DragonBonesData;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var ActionData = (function(_super) {
                __extends(ActionData, _super);
                function ActionData() {
                    _super.call(this);
                    this.data = [];
                }
                ActionData.toString = function() {
                    return "[class dragonBones.ActionData]";
                };
                ActionData.prototype._onClear = function() {
                    this.type = -1;
                    this.bone = null;
                    this.slot = null;
                    this.data.length = 0;
                };
                return ActionData;
            })(dragonBones.BaseObject);
            dragonBones.ActionData = ActionData;
            var EventData = (function(_super) {
                __extends(EventData, _super);
                function EventData() {
                    _super.call(this);
                    this.ints = [];
                    this.floats = [];
                    this.strings = [];
                }
                EventData.toString = function() {
                    return "[class dragonBones.EventData]";
                };
                EventData.prototype._onClear = function() {
                    this.type = -1;
                    this.name = null;
                    this.ints.length = 0;
                    this.floats.length = 0;
                    this.strings.length = 0;
                    this.bone = null;
                    this.slot = null;
                };
                return EventData;
            })(dragonBones.BaseObject);
            dragonBones.EventData = EventData;
            var FrameData = (function(_super) {
                __extends(FrameData, _super);
                function FrameData() {
                    _super.call(this);
                }
                FrameData.prototype._onClear = function() {
                    this.position = 0;
                    this.duration = 0;
                    this.prev = null;
                    this.next = null;
                };
                return FrameData;
            })(dragonBones.BaseObject);
            dragonBones.FrameData = FrameData;
            var TweenFrameData = (function(_super) {
                __extends(TweenFrameData, _super);
                function TweenFrameData() {
                    _super.call(this);
                }
                TweenFrameData._getCurvePoint = function(x1, y1, x2, y2, x3, y3, x4, y4, t, result) {
                    var l_t = 1 - t;
                    var powA = l_t * l_t;
                    var powB = t * t;
                    var kA = l_t * powA;
                    var kB = 3 * t * powA;
                    var kC = 3 * l_t * powB;
                    var kD = t * powB;
                    result.x = kA * x1 + kB * x2 + kC * x3 + kD * x4;
                    result.y = kA * y1 + kB * y2 + kC * y3 + kD * y4;
                };
                TweenFrameData.samplingEasingCurve = function(curve, samples) {
                    var curveCount = curve.length;
                    var result = new dragonBones.Point();
                    var stepIndex = -2;
                    for (var i = 0, l = samples.length; i < l; ++i) {
                        var t = (i + 1) / (l + 1);
                        while ((stepIndex + 6 < curveCount ? curve[stepIndex + 6] : 1) < t) {
                            stepIndex += 6;
                        }
                        var isInCurve = stepIndex >= 0 && stepIndex + 6 < curveCount;
                        var x1 = isInCurve ? curve[stepIndex] : 0;
                        var y1 = isInCurve ? curve[stepIndex + 1] : 0;
                        var x2 = curve[stepIndex + 2];
                        var y2 = curve[stepIndex + 3];
                        var x3 = curve[stepIndex + 4];
                        var y3 = curve[stepIndex + 5];
                        var x4 = isInCurve ? curve[stepIndex + 6] : 1;
                        var y4 = isInCurve ? curve[stepIndex + 7] : 1;
                        var lower = 0;
                        var higher = 1;
                        while (higher - lower > .01) {
                            var percentage = (higher + lower) / 2;
                            TweenFrameData._getCurvePoint(x1, y1, x2, y2, x3, y3, x4, y4, percentage, result);
                            t - result.x > 0 ? lower = percentage : higher = percentage;
                        }
                        samples[i] = result.y;
                    }
                };
                TweenFrameData.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this.tweenEasing = 0;
                    this.curve = null;
                };
                return TweenFrameData;
            })(FrameData);
            dragonBones.TweenFrameData = TweenFrameData;
            var AnimationFrameData = (function(_super) {
                __extends(AnimationFrameData, _super);
                function AnimationFrameData() {
                    _super.call(this);
                    this.actions = [];
                    this.events = [];
                }
                AnimationFrameData.toString = function() {
                    return "[class dragonBones.AnimationFrameData]";
                };
                AnimationFrameData.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    for (var i = 0, l = this.actions.length; i < l; ++i) {
                        this.actions[i].returnToPool();
                    }
                    for (var i = 0, l = this.events.length; i < l; ++i) {
                        this.events[i].returnToPool();
                    }
                    this.actions.length = 0;
                    this.events.length = 0;
                };
                return AnimationFrameData;
            })(FrameData);
            dragonBones.AnimationFrameData = AnimationFrameData;
            var ZOrderFrameData = (function(_super) {
                __extends(ZOrderFrameData, _super);
                function ZOrderFrameData() {
                    _super.call(this);
                    this.zOrder = [];
                }
                ZOrderFrameData.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this.zOrder.length = 0;
                };
                return ZOrderFrameData;
            })(FrameData);
            dragonBones.ZOrderFrameData = ZOrderFrameData;
            var BoneFrameData = (function(_super) {
                __extends(BoneFrameData, _super);
                function BoneFrameData() {
                    _super.call(this);
                    this.transform = new dragonBones.Transform();
                }
                BoneFrameData.toString = function() {
                    return "[class dragonBones.BoneFrameData]";
                };
                BoneFrameData.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this.tweenScale = false;
                    this.tweenRotate = 0;
                    this.transform.identity();
                };
                return BoneFrameData;
            })(TweenFrameData);
            dragonBones.BoneFrameData = BoneFrameData;
            var SlotFrameData = (function(_super) {
                __extends(SlotFrameData, _super);
                function SlotFrameData() {
                    _super.call(this);
                }
                SlotFrameData.generateColor = function() {
                    return new dragonBones.ColorTransform();
                };
                SlotFrameData.toString = function() {
                    return "[class dragonBones.SlotFrameData]";
                };
                SlotFrameData.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this.displayIndex = 0;
                    this.color = null;
                };
                SlotFrameData.DEFAULT_COLOR = new dragonBones.ColorTransform();
                return SlotFrameData;
            })(TweenFrameData);
            dragonBones.SlotFrameData = SlotFrameData;
            var ExtensionFrameData = (function(_super) {
                __extends(ExtensionFrameData, _super);
                function ExtensionFrameData() {
                    _super.call(this);
                    this.tweens = [];
                    this.keys = [];
                }
                ExtensionFrameData.toString = function() {
                    return "[class dragonBones.ExtensionFrameData]";
                };
                ExtensionFrameData.prototype._onClear = function() {
                    _super.prototype._onClear.call(this);
                    this.type = -1;
                    this.tweens.length = 0;
                    this.keys.length = 0;
                };
                return ExtensionFrameData;
            })(TweenFrameData);
            dragonBones.ExtensionFrameData = ExtensionFrameData;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var DataParser = (function() {
                function DataParser() {
                    this._data = null;
                    this._armature = null;
                    this._skin = null;
                    this._slotDisplayDataSet = null;
                    this._animation = null;
                    this._timeline = null;
                    this._isOldData = false;
                    this._isGlobalTransform = false;
                    this._isAutoTween = false;
                    this._animationTweenEasing = 0;
                    this._timelinePivot = new dragonBones.Point();
                    this._helpPoint = new dragonBones.Point();
                    this._helpTransformA = new dragonBones.Transform();
                    this._helpTransformB = new dragonBones.Transform();
                    this._helpMatrix = new dragonBones.Matrix();
                    this._rawBones = [];
                }
                DataParser._getArmatureType = function(value) {
                    switch (value.toLowerCase()) {
                      case "stage":
                        return 2;

                      case "armature":
                        return 0;

                      case "movieclip":
                        return 1;

                      default:
                        return -1;
                    }
                };
                DataParser._getDisplayType = function(value) {
                    switch (value.toLowerCase()) {
                      case "image":
                        return 0;

                      case "mesh":
                        return 2;

                      case "armature":
                        return 1;

                      case "boundingbox":
                        return 3;

                      default:
                        return -1;
                    }
                };
                DataParser._getBoundingBoxType = function(value) {
                    switch (value.toLowerCase()) {
                      case "rectangle":
                        return 0;

                      case "ellipse":
                        return 1;

                      case "polygon":
                        return 2;

                      default:
                        return -1;
                    }
                };
                DataParser._getBlendMode = function(value) {
                    switch (value.toLowerCase()) {
                      case "normal":
                        return 0;

                      case "add":
                        return 1;

                      case "alpha":
                        return 2;

                      case "darken":
                        return 3;

                      case "difference":
                        return 4;

                      case "erase":
                        return 5;

                      case "hardlight":
                        return 6;

                      case "invert":
                        return 7;

                      case "layer":
                        return 8;

                      case "lighten":
                        return 9;

                      case "multiply":
                        return 10;

                      case "overlay":
                        return 11;

                      case "screen":
                        return 12;

                      case "subtract":
                        return 13;

                      default:
                        return -1;
                    }
                };
                DataParser._getActionType = function(value) {
                    switch (value.toLowerCase()) {
                      case "play":
                        return 0;

                      case "stop":
                        return 1;

                      case "gotoandplay":
                        return 2;

                      case "gotoandstop":
                        return 3;

                      case "fadein":
                        return 4;

                      case "fadeout":
                        return 5;

                      default:
                        return -1;
                    }
                };
                DataParser.prototype._getTimelineFrameMatrix = function(animation, timeline, position, transform) {
                    var frameIndex = Math.floor(position * animation.frameCount / animation.duration);
                    if (1 == timeline.frames.length || frameIndex >= timeline.frames.length) {
                        transform.copyFrom(timeline.frames[0].transform);
                    } else {
                        var frame = timeline.frames[frameIndex];
                        var tweenProgress = 0;
                        if (frame.tweenEasing != dragonBones.DragonBones.NO_TWEEN) {
                            tweenProgress = (position - frame.position) / frame.duration;
                            0 != frame.tweenEasing && (tweenProgress = dragonBones.TweenTimelineState._getEasingValue(tweenProgress, frame.tweenEasing));
                        } else {
                            if (frame.curve) {
                                tweenProgress = (position - frame.position) / frame.duration;
                                tweenProgress = dragonBones.TweenTimelineState._getEasingCurveValue(tweenProgress, frame.curve);
                            }
                        }
                        var nextFrame = frame.next;
                        transform.x = nextFrame.transform.x - frame.transform.x;
                        transform.y = nextFrame.transform.y - frame.transform.y;
                        transform.skewX = dragonBones.Transform.normalizeRadian(nextFrame.transform.skewX - frame.transform.skewX);
                        transform.skewY = dragonBones.Transform.normalizeRadian(nextFrame.transform.skewY - frame.transform.skewY);
                        transform.scaleX = nextFrame.transform.scaleX - frame.transform.scaleX;
                        transform.scaleY = nextFrame.transform.scaleY - frame.transform.scaleY;
                        transform.x = frame.transform.x + transform.x * tweenProgress;
                        transform.y = frame.transform.y + transform.y * tweenProgress;
                        transform.skewX = frame.transform.skewX + transform.skewX * tweenProgress;
                        transform.skewY = frame.transform.skewY + transform.skewY * tweenProgress;
                        transform.scaleX = frame.transform.scaleX + transform.scaleX * tweenProgress;
                        transform.scaleY = frame.transform.scaleY + transform.scaleY * tweenProgress;
                    }
                    transform.add(timeline.originalTransform);
                };
                DataParser.prototype._globalToLocal = function(armature) {
                    var keyFrames = new Array();
                    var bones = armature.sortedBones.concat().reverse();
                    for (var i = 0, l = bones.length; i < l; ++i) {
                        var bone = bones[i];
                        if (bone.parent) {
                            bone.parent.transform.toMatrix(this._helpMatrix);
                            this._helpMatrix.invert();
                            this._helpMatrix.transformPoint(bone.transform.x, bone.transform.y, this._helpPoint);
                            bone.transform.x = this._helpPoint.x;
                            bone.transform.y = this._helpPoint.y;
                            bone.transform.rotation -= bone.parent.transform.rotation;
                        }
                        for (var i_2 in armature.animations) {
                            var animation = armature.animations[i_2];
                            var timeline = animation.getBoneTimeline(bone.name);
                            if (!timeline) {
                                continue;
                            }
                            var parentTimeline = bone.parent ? animation.getBoneTimeline(bone.parent.name) : null;
                            this._helpTransformB.copyFrom(timeline.originalTransform);
                            keyFrames.length = 0;
                            for (var i_3 = 0, l_2 = timeline.frames.length; i_3 < l_2; ++i_3) {
                                var frame = timeline.frames[i_3];
                                if (keyFrames.indexOf(frame) >= 0) {
                                    continue;
                                }
                                keyFrames.push(frame);
                                if (parentTimeline) {
                                    this._getTimelineFrameMatrix(animation, parentTimeline, frame.position, this._helpTransformA);
                                    frame.transform.add(this._helpTransformB);
                                    this._helpTransformA.toMatrix(this._helpMatrix);
                                    this._helpMatrix.invert();
                                    this._helpMatrix.transformPoint(frame.transform.x, frame.transform.y, this._helpPoint);
                                    frame.transform.x = this._helpPoint.x;
                                    frame.transform.y = this._helpPoint.y;
                                    frame.transform.rotation -= this._helpTransformA.rotation;
                                } else {
                                    frame.transform.add(this._helpTransformB);
                                }
                                frame.transform.minus(bone.transform);
                                if (0 == i_3) {
                                    timeline.originalTransform.copyFrom(frame.transform);
                                    frame.transform.identity();
                                } else {
                                    frame.transform.minus(timeline.originalTransform);
                                }
                            }
                        }
                    }
                };
                DataParser.prototype._mergeFrameToAnimationTimeline = function(framePostion, actions, events) {
                    var frameStart = Math.floor(framePostion * this._armature.frameRate);
                    var frames = this._animation.frames;
                    if (0 == frames.length) {
                        var startFrame = dragonBones.BaseObject.borrowObject(dragonBones.AnimationFrameData);
                        startFrame.position = 0;
                        if (this._animation.frameCount > 1) {
                            frames.length = this._animation.frameCount + 1;
                            var endFrame = dragonBones.BaseObject.borrowObject(dragonBones.AnimationFrameData);
                            endFrame.position = this._animation.frameCount / this._armature.frameRate;
                            frames[0] = startFrame;
                            frames[this._animation.frameCount] = endFrame;
                        }
                    }
                    var insertedFrame = null;
                    var replacedFrame = frames[frameStart];
                    if (!replacedFrame || 0 != frameStart && frames[frameStart - 1] != replacedFrame.prev) {
                        insertedFrame = dragonBones.BaseObject.borrowObject(dragonBones.AnimationFrameData);
                        insertedFrame.position = frameStart / this._armature.frameRate;
                        frames[frameStart] = insertedFrame;
                        for (var i = frameStart + 1, l = frames.length; i < l; ++i) {
                            replacedFrame && frames[i] == replacedFrame && (frames[i] = null);
                        }
                    } else {
                        insertedFrame = replacedFrame;
                    }
                    if (actions) {
                        for (var i = 0, l = actions.length; i < l; ++i) {
                            insertedFrame.actions.push(actions[i]);
                        }
                    }
                    if (events) {
                        for (var i = 0, l = events.length; i < l; ++i) {
                            insertedFrame.events.push(events[i]);
                        }
                    }
                    var prevFrame = null;
                    var nextFrame = null;
                    for (var i = 0, l = frames.length; i < l; ++i) {
                        var currentFrame = frames[i];
                        if (currentFrame && nextFrame != currentFrame) {
                            nextFrame = currentFrame;
                            if (prevFrame) {
                                nextFrame.prev = prevFrame;
                                prevFrame.next = nextFrame;
                                prevFrame.duration = nextFrame.position - prevFrame.position;
                            }
                            prevFrame = nextFrame;
                        } else {
                            frames[i] = prevFrame;
                        }
                    }
                    nextFrame.duration = this._animation.duration - nextFrame.position;
                    nextFrame = frames[0];
                    prevFrame.next = nextFrame;
                    nextFrame.prev = prevFrame;
                };
                DataParser.parseDragonBonesData = function(rawData) {
                    return dragonBones.ObjectDataParser.getInstance().parseDragonBonesData(rawData);
                };
                DataParser.parseTextureAtlasData = function(rawData, scale) {
                    void 0 === scale && (scale = 1);
                    var textureAtlasData = {};
                    var subTextureList = rawData[DataParser.SUB_TEXTURE];
                    for (var i = 0, len = subTextureList.length; i < len; i++) {
                        var subTextureObject = subTextureList[i];
                        var subTextureName = subTextureObject[DataParser.NAME];
                        var subTextureRegion = new dragonBones.Rectangle();
                        var subTextureFrame = null;
                        subTextureRegion.x = subTextureObject[DataParser.X] / scale;
                        subTextureRegion.y = subTextureObject[DataParser.Y] / scale;
                        subTextureRegion.width = subTextureObject[DataParser.WIDTH] / scale;
                        subTextureRegion.height = subTextureObject[DataParser.HEIGHT] / scale;
                        if (DataParser.FRAME_WIDTH in subTextureObject) {
                            subTextureFrame = new dragonBones.Rectangle();
                            subTextureFrame.x = subTextureObject[DataParser.FRAME_X] / scale;
                            subTextureFrame.y = subTextureObject[DataParser.FRAME_Y] / scale;
                            subTextureFrame.width = subTextureObject[DataParser.FRAME_WIDTH] / scale;
                            subTextureFrame.height = subTextureObject[DataParser.FRAME_HEIGHT] / scale;
                        }
                        textureAtlasData[subTextureName] = {
                            region: subTextureRegion,
                            frame: subTextureFrame,
                            rotated: false
                        };
                    }
                    return textureAtlasData;
                };
                DataParser.DATA_VERSION_2_3 = "2.3";
                DataParser.DATA_VERSION_3_0 = "3.0";
                DataParser.DATA_VERSION_4_0 = "4.0";
                DataParser.DATA_VERSION = "4.5";
                DataParser.TEXTURE_ATLAS = "TextureAtlas";
                DataParser.SUB_TEXTURE = "SubTexture";
                DataParser.FORMAT = "format";
                DataParser.IMAGE_PATH = "imagePath";
                DataParser.WIDTH = "width";
                DataParser.HEIGHT = "height";
                DataParser.ROTATED = "rotated";
                DataParser.FRAME_X = "frameX";
                DataParser.FRAME_Y = "frameY";
                DataParser.FRAME_WIDTH = "frameWidth";
                DataParser.FRAME_HEIGHT = "frameHeight";
                DataParser.DRADON_BONES = "dragonBones";
                DataParser.ARMATURE = "armature";
                DataParser.BONE = "bone";
                DataParser.IK = "ik";
                DataParser.SLOT = "slot";
                DataParser.SKIN = "skin";
                DataParser.DISPLAY = "display";
                DataParser.ANIMATION = "animation";
                DataParser.Z_ORDER = "zOrder";
                DataParser.FFD = "ffd";
                DataParser.FRAME = "frame";
                DataParser.EVENTS = "events";
                DataParser.ACTIONS = "actions";
                DataParser.INTS = "ints";
                DataParser.FLOATS = "floats";
                DataParser.STRINGS = "strings";
                DataParser.PIVOT = "pivot";
                DataParser.TRANSFORM = "transform";
                DataParser.AABB = "aabb";
                DataParser.COLOR = "color";
                DataParser.FILTER = "filter";
                DataParser.VERSION = "version";
                DataParser.IS_GLOBAL = "isGlobal";
                DataParser.FRAME_RATE = "frameRate";
                DataParser.TYPE = "type";
                DataParser.SUB_TYPE = "subType";
                DataParser.NAME = "name";
                DataParser.PARENT = "parent";
                DataParser.SHARE = "share";
                DataParser.LENGTH = "length";
                DataParser.DATA = "data";
                DataParser.DISPLAY_INDEX = "displayIndex";
                DataParser.BLEND_MODE = "blendMode";
                DataParser.INHERIT_TRANSLATION = "inheritTranslation";
                DataParser.INHERIT_ROTATION = "inheritRotation";
                DataParser.INHERIT_SCALE = "inheritScale";
                DataParser.INHERIT_ANIMATION = "inheritAnimation";
                DataParser.TARGET = "target";
                DataParser.BEND_POSITIVE = "bendPositive";
                DataParser.CHAIN = "chain";
                DataParser.WEIGHT = "weight";
                DataParser.FADE_IN_TIME = "fadeInTime";
                DataParser.PLAY_TIMES = "playTimes";
                DataParser.SCALE = "scale";
                DataParser.OFFSET = "offset";
                DataParser.POSITION = "position";
                DataParser.DURATION = "duration";
                DataParser.TWEEN_EASING = "tweenEasing";
                DataParser.TWEEN_ROTATE = "tweenRotate";
                DataParser.TWEEN_SCALE = "tweenScale";
                DataParser.CURVE = "curve";
                DataParser.GUIDE_CURVE = "guideCurve";
                DataParser.EVENT = "event";
                DataParser.SOUND = "sound";
                DataParser.ACTION = "action";
                DataParser.DEFAULT_ACTIONS = "defaultActions";
                DataParser.X = "x";
                DataParser.Y = "y";
                DataParser.SKEW_X = "skX";
                DataParser.SKEW_Y = "skY";
                DataParser.SCALE_X = "scX";
                DataParser.SCALE_Y = "scY";
                DataParser.ALPHA_OFFSET = "aO";
                DataParser.RED_OFFSET = "rO";
                DataParser.GREEN_OFFSET = "gO";
                DataParser.BLUE_OFFSET = "bO";
                DataParser.ALPHA_MULTIPLIER = "aM";
                DataParser.RED_MULTIPLIER = "rM";
                DataParser.GREEN_MULTIPLIER = "gM";
                DataParser.BLUE_MULTIPLIER = "bM";
                DataParser.UVS = "uvs";
                DataParser.VERTICES = "vertices";
                DataParser.TRIANGLES = "triangles";
                DataParser.WEIGHTS = "weights";
                DataParser.SLOT_POSE = "slotPose";
                DataParser.BONE_POSE = "bonePose";
                DataParser.TWEEN = "tween";
                DataParser.KEY = "key";
                DataParser.COLOR_TRANSFORM = "colorTransform";
                DataParser.TIMELINE = "timeline";
                DataParser.PIVOT_X = "pX";
                DataParser.PIVOT_Y = "pY";
                DataParser.Z = "z";
                DataParser.LOOP = "loop";
                DataParser.AUTO_TWEEN = "autoTween";
                DataParser.HIDE = "hide";
                return DataParser;
            })();
            dragonBones.DataParser = DataParser;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var ObjectDataParser = (function(_super) {
                __extends(ObjectDataParser, _super);
                function ObjectDataParser() {
                    _super.call(this);
                }
                ObjectDataParser._getBoolean = function(rawData, key, defaultValue) {
                    if (key in rawData) {
                        var value = rawData[key];
                        var valueType = typeof value;
                        if ("boolean" == valueType) {
                            return value;
                        }
                        if ("string" != valueType) {
                            return !!value;
                        }
                        switch (value) {
                          case "0":
                          case "NaN":
                          case "":
                          case "false":
                          case "null":
                          case "undefined":
                            return false;

                          default:
                            return true;
                        }
                    }
                    return defaultValue;
                };
                ObjectDataParser._getNumber = function(rawData, key, defaultValue) {
                    if (key in rawData) {
                        var value = rawData[key];
                        if (null == value || "NaN" == value) {
                            return defaultValue;
                        }
                        return +value || 0;
                    }
                    return defaultValue;
                };
                ObjectDataParser._getString = function(rawData, key, defaultValue) {
                    if (key in rawData) {
                        return String(rawData[key]);
                    }
                    return defaultValue;
                };
                ObjectDataParser._getParameter = function(rawData, index, defaultValue) {
                    if (rawData.length > index) {
                        return rawData[index];
                    }
                    return defaultValue;
                };
                ObjectDataParser.prototype._parseArmature = function(rawData, scale) {
                    var armature = dragonBones.BaseObject.borrowObject(dragonBones.ArmatureData);
                    armature.name = ObjectDataParser._getString(rawData, ObjectDataParser.NAME, null);
                    armature.frameRate = ObjectDataParser._getNumber(rawData, ObjectDataParser.FRAME_RATE, this._data.frameRate) || this._data.frameRate;
                    armature.scale = scale;
                    ObjectDataParser.TYPE in rawData && "string" == typeof rawData[ObjectDataParser.TYPE] ? armature.type = ObjectDataParser._getArmatureType(rawData[ObjectDataParser.TYPE]) : armature.type = ObjectDataParser._getNumber(rawData, ObjectDataParser.TYPE, 0);
                    this._armature = armature;
                    this._rawBones.length = 0;
                    if (ObjectDataParser.AABB in rawData) {
                        var aabbObject = rawData[ObjectDataParser.AABB];
                        armature.aabb.x = ObjectDataParser._getNumber(aabbObject, ObjectDataParser.X, 0);
                        armature.aabb.y = ObjectDataParser._getNumber(aabbObject, ObjectDataParser.Y, 0);
                        armature.aabb.width = ObjectDataParser._getNumber(aabbObject, ObjectDataParser.WIDTH, 0);
                        armature.aabb.height = ObjectDataParser._getNumber(aabbObject, ObjectDataParser.HEIGHT, 0);
                    }
                    if (ObjectDataParser.BONE in rawData) {
                        var bones = rawData[ObjectDataParser.BONE];
                        for (var i = 0, l = bones.length; i < l; ++i) {
                            var boneObject = bones[i];
                            var bone = this._parseBone(boneObject);
                            armature.addBone(bone, ObjectDataParser._getString(boneObject, ObjectDataParser.PARENT, null));
                            this._rawBones.push(bone);
                        }
                    }
                    if (ObjectDataParser.IK in rawData) {
                        var iks = rawData[ObjectDataParser.IK];
                        for (var i = 0, l = iks.length; i < l; ++i) {
                            this._parseIK(iks[i]);
                        }
                    }
                    if (ObjectDataParser.SLOT in rawData) {
                        var slots = rawData[ObjectDataParser.SLOT];
                        var zOrder = 0;
                        for (var i = 0, l = slots.length; i < l; ++i) {
                            armature.addSlot(this._parseSlot(slots[i], zOrder++));
                        }
                    }
                    if (ObjectDataParser.SKIN in rawData) {
                        var skins = rawData[ObjectDataParser.SKIN];
                        for (var i = 0, l = skins.length; i < l; ++i) {
                            armature.addSkin(this._parseSkin(skins[i]));
                        }
                    }
                    if (ObjectDataParser.ANIMATION in rawData) {
                        var animations = rawData[ObjectDataParser.ANIMATION];
                        for (var i = 0, l = animations.length; i < l; ++i) {
                            armature.addAnimation(this._parseAnimation(animations[i]));
                        }
                    }
                    (ObjectDataParser.ACTIONS in rawData || ObjectDataParser.DEFAULT_ACTIONS in rawData) && this._parseActionData(rawData, armature.actions, null, null);
                    this._isOldData && this._isGlobalTransform && this._globalToLocal(armature);
                    this._armature = null;
                    this._rawBones.length = 0;
                    return armature;
                };
                ObjectDataParser.prototype._parseBone = function(rawData) {
                    var bone = dragonBones.BaseObject.borrowObject(dragonBones.BoneData);
                    bone.name = ObjectDataParser._getString(rawData, ObjectDataParser.NAME, null);
                    bone.inheritTranslation = ObjectDataParser._getBoolean(rawData, ObjectDataParser.INHERIT_TRANSLATION, true);
                    bone.inheritRotation = ObjectDataParser._getBoolean(rawData, ObjectDataParser.INHERIT_ROTATION, true);
                    bone.inheritScale = ObjectDataParser._getBoolean(rawData, ObjectDataParser.INHERIT_SCALE, true);
                    bone.length = ObjectDataParser._getNumber(rawData, ObjectDataParser.LENGTH, 0) * this._armature.scale;
                    ObjectDataParser.TRANSFORM in rawData && this._parseTransform(rawData[ObjectDataParser.TRANSFORM], bone.transform);
                    this._isOldData && (bone.inheritScale = false);
                    return bone;
                };
                ObjectDataParser.prototype._parseIK = function(rawData) {
                    var bone = this._armature.getBone(ObjectDataParser._getString(rawData, ObjectDataParser.BONE in rawData ? ObjectDataParser.BONE : ObjectDataParser.NAME, null));
                    if (bone) {
                        bone.ik = this._armature.getBone(ObjectDataParser._getString(rawData, ObjectDataParser.TARGET, null));
                        bone.bendPositive = ObjectDataParser._getBoolean(rawData, ObjectDataParser.BEND_POSITIVE, true);
                        bone.chain = ObjectDataParser._getNumber(rawData, ObjectDataParser.CHAIN, 0);
                        bone.weight = ObjectDataParser._getNumber(rawData, ObjectDataParser.WEIGHT, 1);
                        if (bone.chain > 0 && bone.parent && !bone.parent.ik) {
                            bone.parent.ik = bone.ik;
                            bone.parent.chainIndex = 0;
                            bone.parent.chain = 0;
                            bone.chainIndex = 1;
                        } else {
                            bone.chain = 0;
                            bone.chainIndex = 0;
                        }
                    }
                };
                ObjectDataParser.prototype._parseSlot = function(rawData, zOrder) {
                    var slot = dragonBones.BaseObject.borrowObject(dragonBones.SlotData);
                    slot.name = ObjectDataParser._getString(rawData, ObjectDataParser.NAME, null);
                    slot.parent = this._armature.getBone(ObjectDataParser._getString(rawData, ObjectDataParser.PARENT, null));
                    slot.displayIndex = ObjectDataParser._getNumber(rawData, ObjectDataParser.DISPLAY_INDEX, 0);
                    slot.zOrder = ObjectDataParser._getNumber(rawData, ObjectDataParser.Z, zOrder);
                    if (ObjectDataParser.COLOR in rawData || ObjectDataParser.COLOR_TRANSFORM in rawData) {
                        slot.color = dragonBones.SlotData.generateColor();
                        this._parseColorTransform(rawData[ObjectDataParser.COLOR] || rawData[ObjectDataParser.COLOR_TRANSFORM], slot.color);
                    } else {
                        slot.color = dragonBones.SlotData.DEFAULT_COLOR;
                    }
                    ObjectDataParser.BLEND_MODE in rawData && "string" == typeof rawData[ObjectDataParser.BLEND_MODE] ? slot.blendMode = ObjectDataParser._getBlendMode(rawData[ObjectDataParser.BLEND_MODE]) : slot.blendMode = ObjectDataParser._getNumber(rawData, ObjectDataParser.BLEND_MODE, 0);
                    (ObjectDataParser.ACTIONS in rawData || ObjectDataParser.DEFAULT_ACTIONS in rawData) && this._parseActionData(rawData, slot.actions, null, null);
                    if (this._isOldData) {
                        if (ObjectDataParser.COLOR_TRANSFORM in rawData) {
                            slot.color = dragonBones.SlotData.generateColor();
                            this._parseColorTransform(rawData[ObjectDataParser.COLOR_TRANSFORM], slot.color);
                        } else {
                            slot.color = dragonBones.SlotData.DEFAULT_COLOR;
                        }
                    }
                    return slot;
                };
                ObjectDataParser.prototype._parseSkin = function(rawData) {
                    var skin = dragonBones.BaseObject.borrowObject(dragonBones.SkinData);
                    skin.name = ObjectDataParser._getString(rawData, ObjectDataParser.NAME, "__default") || "__default";
                    if (ObjectDataParser.SLOT in rawData) {
                        this._skin = skin;
                        var slots = rawData[ObjectDataParser.SLOT];
                        var zOrder = 0;
                        for (var i = 0, l = slots.length; i < l; ++i) {
                            this._isOldData && this._armature.addSlot(this._parseSlot(slots[i], zOrder++));
                            skin.addSlot(this._parseSlotDisplaySet(slots[i]));
                        }
                        this._skin = null;
                    }
                    return skin;
                };
                ObjectDataParser.prototype._parseSlotDisplaySet = function(rawData) {
                    var slotDisplayDataSet = dragonBones.BaseObject.borrowObject(dragonBones.SlotDisplayDataSet);
                    slotDisplayDataSet.slot = this._armature.getSlot(ObjectDataParser._getString(rawData, ObjectDataParser.NAME, null));
                    if (ObjectDataParser.DISPLAY in rawData) {
                        var displayObjectSet = rawData[ObjectDataParser.DISPLAY];
                        var displayDataSet = slotDisplayDataSet.displays;
                        this._slotDisplayDataSet = slotDisplayDataSet;
                        for (var i = 0, l = displayObjectSet.length; i < l; ++i) {
                            displayDataSet.push(this._parseDisplay(displayObjectSet[i]));
                        }
                        this._slotDisplayDataSet = null;
                    }
                    return slotDisplayDataSet;
                };
                ObjectDataParser.prototype._parseDisplay = function(rawData) {
                    var display = dragonBones.BaseObject.borrowObject(dragonBones.DisplayData);
                    display.name = ObjectDataParser._getString(rawData, ObjectDataParser.NAME, null);
                    display.path = ObjectDataParser._getString(rawData, ObjectDataParser.SHARE, display.name);
                    display.inheritAnimation = ObjectDataParser._getBoolean(rawData, ObjectDataParser.INHERIT_ANIMATION, true);
                    ObjectDataParser.TYPE in rawData && "string" == typeof rawData[ObjectDataParser.TYPE] ? display.type = ObjectDataParser._getDisplayType(rawData[ObjectDataParser.TYPE]) : display.type = ObjectDataParser._getNumber(rawData, ObjectDataParser.TYPE, 0);
                    display.isRelativePivot = true;
                    if (ObjectDataParser.PIVOT in rawData) {
                        var pivotObject = rawData[ObjectDataParser.PIVOT];
                        display.pivot.x = ObjectDataParser._getNumber(pivotObject, ObjectDataParser.X, 0);
                        display.pivot.y = ObjectDataParser._getNumber(pivotObject, ObjectDataParser.Y, 0);
                    } else {
                        if (this._isOldData) {
                            var transformObject = rawData[ObjectDataParser.TRANSFORM];
                            display.isRelativePivot = false;
                            display.pivot.x = ObjectDataParser._getNumber(transformObject, ObjectDataParser.PIVOT_X, 0) * this._armature.scale;
                            display.pivot.y = ObjectDataParser._getNumber(transformObject, ObjectDataParser.PIVOT_Y, 0) * this._armature.scale;
                        } else {
                            display.pivot.x = .5;
                            display.pivot.y = .5;
                        }
                    }
                    ObjectDataParser.TRANSFORM in rawData && this._parseTransform(rawData[ObjectDataParser.TRANSFORM], display.transform);
                    switch (display.type) {
                      case 0:
                        break;

                      case 1:
                        break;

                      case 2:
                        var shareMeshName = ObjectDataParser._getString(rawData, ObjectDataParser.SHARE, null);
                        if (shareMeshName) {
                            for (var i = 0, l = this._slotDisplayDataSet.displays.length; i < l; ++i) {
                                var eachDisplay = this._slotDisplayDataSet.displays[i];
                                if (eachDisplay.name == shareMeshName) {
                                    display.share = eachDisplay;
                                    display.mesh = eachDisplay.mesh;
                                    break;
                                }
                            }
                        } else {
                            display.mesh = this._parseMesh(rawData);
                        }
                        break;

                      case 3:
                        display.boundingBox = this._BoundingBox(rawData);
                    }
                    return display;
                };
                ObjectDataParser.prototype._BoundingBox = function(rawData) {
                    var boundingBox = dragonBones.BaseObject.borrowObject(dragonBones.BoundingBoxData);
                    ObjectDataParser.SUB_TYPE in rawData && "string" == typeof rawData[ObjectDataParser.SUB_TYPE] ? boundingBox.type = ObjectDataParser._getBoundingBoxType(rawData[ObjectDataParser.SUB_TYPE]) : boundingBox.type = ObjectDataParser._getNumber(rawData, ObjectDataParser.SUB_TYPE, 0);
                    switch (boundingBox.type) {
                      case 0:
                      case 1:
                        boundingBox.width = ObjectDataParser._getNumber(rawData, ObjectDataParser.WIDTH, 0);
                        boundingBox.height = ObjectDataParser._getNumber(rawData, ObjectDataParser.HEIGHT, 0);
                        break;

                      case 2:
                        if (ObjectDataParser.VERTICES in rawData) {
                            var rawVertices = rawData[ObjectDataParser.VERTICES];
                            boundingBox.vertices.length = rawVertices.length;
                            for (var i = 0, l = rawVertices.length; i < l; i += 2) {
                                var iN = i + 1;
                                var x = rawVertices[i];
                                var y = rawVertices[iN];
                                boundingBox.vertices[i] = x;
                                boundingBox.vertices[iN] = y;
                                if (0 == i) {
                                    boundingBox.x = x;
                                    boundingBox.y = y;
                                    boundingBox.width = x;
                                    boundingBox.height = y;
                                } else {
                                    x < boundingBox.x ? boundingBox.x = x : x > boundingBox.width && (boundingBox.width = x);
                                    y < boundingBox.y ? boundingBox.y = y : y > boundingBox.height && (boundingBox.height = y);
                                }
                            }
                        }
                    }
                    return boundingBox;
                };
                ObjectDataParser.prototype._parseMesh = function(rawData) {
                    var mesh = dragonBones.BaseObject.borrowObject(dragonBones.MeshData);
                    var rawVertices = rawData[ObjectDataParser.VERTICES];
                    var rawUVs = rawData[ObjectDataParser.UVS];
                    var rawTriangles = rawData[ObjectDataParser.TRIANGLES];
                    var numVertices = Math.floor(rawVertices.length / 2);
                    var numTriangles = Math.floor(rawTriangles.length / 3);
                    var inverseBindPose = new Array(this._armature.sortedBones.length);
                    mesh.skinned = ObjectDataParser.WEIGHTS in rawData && rawData[ObjectDataParser.WEIGHTS].length > 0;
                    mesh.uvs.length = 2 * numVertices;
                    mesh.vertices.length = 2 * numVertices;
                    mesh.vertexIndices.length = 3 * numTriangles;
                    if (mesh.skinned) {
                        mesh.boneIndices.length = numVertices;
                        mesh.weights.length = numVertices;
                        mesh.boneVertices.length = numVertices;
                        if (ObjectDataParser.SLOT_POSE in rawData) {
                            var rawSlotPose = rawData[ObjectDataParser.SLOT_POSE];
                            mesh.slotPose.a = rawSlotPose[0];
                            mesh.slotPose.b = rawSlotPose[1];
                            mesh.slotPose.c = rawSlotPose[2];
                            mesh.slotPose.d = rawSlotPose[3];
                            mesh.slotPose.tx = rawSlotPose[4] * this._armature.scale;
                            mesh.slotPose.ty = rawSlotPose[5] * this._armature.scale;
                        }
                        if (ObjectDataParser.BONE_POSE in rawData) {
                            var rawBonePose = rawData[ObjectDataParser.BONE_POSE];
                            for (var i = 0, l = rawBonePose.length; i < l; i += 7) {
                                var rawBoneIndex = rawBonePose[i];
                                var boneMatrix = inverseBindPose[rawBoneIndex] = new dragonBones.Matrix();
                                boneMatrix.a = rawBonePose[i + 1];
                                boneMatrix.b = rawBonePose[i + 2];
                                boneMatrix.c = rawBonePose[i + 3];
                                boneMatrix.d = rawBonePose[i + 4];
                                boneMatrix.tx = rawBonePose[i + 5] * this._armature.scale;
                                boneMatrix.ty = rawBonePose[i + 6] * this._armature.scale;
                                boneMatrix.invert();
                            }
                        }
                    }
                    for (var i = 0, iW = 0, l = rawVertices.length; i < l; i += 2) {
                        var iN = i + 1;
                        var vertexIndex = i / 2;
                        var x = mesh.vertices[i] = rawVertices[i] * this._armature.scale;
                        var y = mesh.vertices[iN] = rawVertices[iN] * this._armature.scale;
                        mesh.uvs[i] = rawUVs[i];
                        mesh.uvs[iN] = rawUVs[iN];
                        if (mesh.skinned) {
                            var rawWeights = rawData[ObjectDataParser.WEIGHTS];
                            var numBones = rawWeights[iW];
                            var indices = mesh.boneIndices[vertexIndex] = new Array(numBones);
                            var weights = mesh.weights[vertexIndex] = new Array(numBones);
                            var boneVertices = mesh.boneVertices[vertexIndex] = new Array(2 * numBones);
                            mesh.slotPose.transformPoint(x, y, this._helpPoint);
                            x = mesh.vertices[i] = this._helpPoint.x;
                            y = mesh.vertices[iN] = this._helpPoint.y;
                            for (var iB = 0; iB < numBones; ++iB) {
                                var iI = iW + 1 + 2 * iB;
                                var rawBoneIndex = rawWeights[iI];
                                var boneData = this._rawBones[rawBoneIndex];
                                var boneIndex = mesh.bones.indexOf(boneData);
                                if (boneIndex < 0) {
                                    boneIndex = mesh.bones.length;
                                    mesh.bones[boneIndex] = boneData;
                                    mesh.inverseBindPose[boneIndex] = inverseBindPose[rawBoneIndex];
                                }
                                mesh.inverseBindPose[boneIndex].transformPoint(x, y, this._helpPoint);
                                indices[iB] = boneIndex;
                                weights[iB] = rawWeights[iI + 1];
                                boneVertices[2 * iB] = this._helpPoint.x;
                                boneVertices[2 * iB + 1] = this._helpPoint.y;
                            }
                            iW += 2 * numBones + 1;
                        }
                    }
                    for (var i = 0, l = rawTriangles.length; i < l; ++i) {
                        mesh.vertexIndices[i] = rawTriangles[i];
                    }
                    return mesh;
                };
                ObjectDataParser.prototype._parseAnimation = function(rawData) {
                    var animation = dragonBones.BaseObject.borrowObject(dragonBones.AnimationData);
                    animation.name = ObjectDataParser._getString(rawData, ObjectDataParser.NAME, "__default") || "__default";
                    animation.frameCount = Math.max(ObjectDataParser._getNumber(rawData, ObjectDataParser.DURATION, 1), 1);
                    animation.position = ObjectDataParser._getNumber(rawData, ObjectDataParser.POSITION, 0) / this._armature.frameRate;
                    animation.duration = animation.frameCount / this._armature.frameRate;
                    animation.playTimes = ObjectDataParser._getNumber(rawData, ObjectDataParser.PLAY_TIMES, 1);
                    animation.fadeInTime = ObjectDataParser._getNumber(rawData, ObjectDataParser.FADE_IN_TIME, 0);
                    this._animation = animation;
                    var animationName = ObjectDataParser._getString(rawData, ObjectDataParser.ANIMATION, null);
                    if (animationName) {
                        animation.animation = this._armature.getAnimation(animationName);
                        !animation.animation;
                        return animation;
                    }
                    this._parseTimeline(rawData, animation, this._parseAnimationFrame);
                    if (ObjectDataParser.Z_ORDER in rawData) {
                        animation.zOrderTimeline = dragonBones.BaseObject.borrowObject(dragonBones.ZOrderTimelineData);
                        this._parseTimeline(rawData[ObjectDataParser.Z_ORDER], animation.zOrderTimeline, this._parseZOrderFrame);
                    }
                    if (ObjectDataParser.BONE in rawData) {
                        var boneTimelines = rawData[ObjectDataParser.BONE];
                        for (var i = 0, l = boneTimelines.length; i < l; ++i) {
                            animation.addBoneTimeline(this._parseBoneTimeline(boneTimelines[i]));
                        }
                    }
                    if (ObjectDataParser.SLOT in rawData) {
                        var slotTimelines = rawData[ObjectDataParser.SLOT];
                        for (var i = 0, l = slotTimelines.length; i < l; ++i) {
                            animation.addSlotTimeline(this._parseSlotTimeline(slotTimelines[i]));
                        }
                    }
                    if (ObjectDataParser.FFD in rawData) {
                        var ffdTimelines = rawData[ObjectDataParser.FFD];
                        for (var i = 0, l = ffdTimelines.length; i < l; ++i) {
                            animation.addFFDTimeline(this._parseFFDTimeline(ffdTimelines[i]));
                        }
                    }
                    if (this._isOldData) {
                        this._isAutoTween = ObjectDataParser._getBoolean(rawData, ObjectDataParser.AUTO_TWEEN, true);
                        this._animationTweenEasing = ObjectDataParser._getNumber(rawData, ObjectDataParser.TWEEN_EASING, 0) || 0;
                        animation.playTimes = ObjectDataParser._getNumber(rawData, ObjectDataParser.LOOP, 1);
                        if (ObjectDataParser.TIMELINE in rawData) {
                            var timelineObjects = rawData[ObjectDataParser.TIMELINE];
                            for (var i = 0, l = timelineObjects.length; i < l; ++i) {
                                var timelineObject = timelineObjects[i];
                                animation.addBoneTimeline(this._parseBoneTimeline(timelineObject));
                                animation.addSlotTimeline(this._parseSlotTimeline(timelineObject));
                            }
                        }
                    } else {
                        this._isAutoTween = false;
                        this._animationTweenEasing = 0;
                    }
                    for (var i in this._armature.bones) {
                        var bone = this._armature.bones[i];
                        if (!animation.getBoneTimeline(bone.name)) {
                            var boneTimeline = dragonBones.BaseObject.borrowObject(dragonBones.BoneTimelineData);
                            var boneFrame = dragonBones.BaseObject.borrowObject(dragonBones.BoneFrameData);
                            boneTimeline.bone = bone;
                            boneTimeline.frames[0] = boneFrame;
                            animation.addBoneTimeline(boneTimeline);
                        }
                    }
                    for (var i in this._armature.slots) {
                        var slot = this._armature.slots[i];
                        if (!animation.getSlotTimeline(slot.name)) {
                            var slotTimeline = dragonBones.BaseObject.borrowObject(dragonBones.SlotTimelineData);
                            var slotFrame = dragonBones.BaseObject.borrowObject(dragonBones.SlotFrameData);
                            slotTimeline.slot = slot;
                            slotFrame.displayIndex = slot.displayIndex;
                            if (slot.color == dragonBones.SlotData.DEFAULT_COLOR) {
                                slotFrame.color = dragonBones.SlotFrameData.DEFAULT_COLOR;
                            } else {
                                slotFrame.color = dragonBones.SlotFrameData.generateColor();
                                slotFrame.color.copyFrom(slot.color);
                            }
                            slotTimeline.frames[0] = slotFrame;
                            animation.addSlotTimeline(slotTimeline);
                            this._isOldData && (slotFrame.displayIndex = -1);
                        }
                    }
                    this._animation = null;
                    return animation;
                };
                ObjectDataParser.prototype._parseBoneTimeline = function(rawData) {
                    var timeline = dragonBones.BaseObject.borrowObject(dragonBones.BoneTimelineData);
                    timeline.bone = this._armature.getBone(ObjectDataParser._getString(rawData, ObjectDataParser.NAME, null));
                    this._parseTimeline(rawData, timeline, this._parseBoneFrame);
                    var originalTransform = timeline.originalTransform;
                    var prevFrame = null;
                    for (var i = 0, l = timeline.frames.length; i < l; ++i) {
                        var frame = timeline.frames[i];
                        if (prevFrame) {
                            prevFrame != frame && frame.transform.minus(originalTransform);
                        } else {
                            originalTransform.copyFrom(frame.transform);
                            frame.transform.identity();
                            0 == originalTransform.scaleX && (originalTransform.scaleX = .001);
                            0 == originalTransform.scaleY && (originalTransform.scaleY = .001);
                        }
                        prevFrame = frame;
                    }
                    1 == timeline.scale && 0 == timeline.offset || (this._animation.hasAsynchronyTimeline = true);
                    if (this._isOldData && (ObjectDataParser.PIVOT_X in rawData || ObjectDataParser.PIVOT_Y in rawData)) {
                        this._timelinePivot.x = ObjectDataParser._getNumber(rawData, ObjectDataParser.PIVOT_X, 0);
                        this._timelinePivot.y = ObjectDataParser._getNumber(rawData, ObjectDataParser.PIVOT_Y, 0);
                    } else {
                        this._timelinePivot.clear();
                    }
                    return timeline;
                };
                ObjectDataParser.prototype._parseSlotTimeline = function(rawData) {
                    var timeline = dragonBones.BaseObject.borrowObject(dragonBones.SlotTimelineData);
                    timeline.slot = this._armature.getSlot(ObjectDataParser._getString(rawData, ObjectDataParser.NAME, null));
                    this._parseTimeline(rawData, timeline, this._parseSlotFrame);
                    1 == timeline.scale && 0 == timeline.offset || (this._animation.hasAsynchronyTimeline = true);
                    return timeline;
                };
                ObjectDataParser.prototype._parseFFDTimeline = function(rawData) {
                    var timeline = dragonBones.BaseObject.borrowObject(dragonBones.FFDTimelineData);
                    timeline.skin = this._armature.getSkin(ObjectDataParser._getString(rawData, ObjectDataParser.SKIN, null));
                    timeline.slot = timeline.skin.getSlot(ObjectDataParser._getString(rawData, ObjectDataParser.SLOT, null));
                    var meshName = ObjectDataParser._getString(rawData, ObjectDataParser.NAME, null);
                    for (var i = 0, l = timeline.slot.displays.length; i < l; ++i) {
                        var display = timeline.slot.displays[i];
                        if (display.mesh && display.name == meshName) {
                            timeline.display = display;
                            break;
                        }
                    }
                    this._parseTimeline(rawData, timeline, this._parseFFDFrame);
                    return timeline;
                };
                ObjectDataParser.prototype._parseAnimationFrame = function(rawData, frameStart, frameCount) {
                    var frame = dragonBones.BaseObject.borrowObject(dragonBones.AnimationFrameData);
                    this._parseFrame(rawData, frame, frameStart, frameCount);
                    (ObjectDataParser.ACTION in rawData || ObjectDataParser.ACTIONS in rawData) && this._parseActionData(rawData, frame.actions, null, null);
                    (ObjectDataParser.EVENT in rawData || ObjectDataParser.SOUND in rawData) && this._parseEventData(rawData, frame.events, null, null);
                    return frame;
                };
                ObjectDataParser.prototype._parseZOrderFrame = function(rawData, frameStart, frameCount) {
                    var frame = dragonBones.BaseObject.borrowObject(dragonBones.ZOrderFrameData);
                    this._parseFrame(rawData, frame, frameStart, frameCount);
                    var rawZOrder = rawData[ObjectDataParser.Z_ORDER];
                    if (rawZOrder && rawZOrder.length > 0) {
                        var slotCount = this._armature.sortedSlots.length;
                        var unchanged = new Array(slotCount - rawZOrder.length / 2);
                        frame.zOrder.length = slotCount;
                        for (var i_4 = 0; i_4 < slotCount; ++i_4) {
                            frame.zOrder[i_4] = -1;
                        }
                        var originalIndex = 0;
                        var unchangedIndex = 0;
                        for (var i_5 = 0, l = rawZOrder.length; i_5 < l; i_5 += 2) {
                            var slotIndex = rawZOrder[i_5];
                            var offset = rawZOrder[i_5 + 1];
                            while (originalIndex != slotIndex) {
                                unchanged[unchangedIndex++] = originalIndex++;
                            }
                            frame.zOrder[originalIndex + offset] = originalIndex++;
                        }
                        while (originalIndex < slotCount) {
                            unchanged[unchangedIndex++] = originalIndex++;
                        }
                        var i = slotCount;
                        while (i--) {
                            frame.zOrder[i] == -1 && (frame.zOrder[i] = unchanged[--unchangedIndex]);
                        }
                    }
                    return frame;
                };
                ObjectDataParser.prototype._parseBoneFrame = function(rawData, frameStart, frameCount) {
                    var frame = dragonBones.BaseObject.borrowObject(dragonBones.BoneFrameData);
                    frame.tweenRotate = ObjectDataParser._getNumber(rawData, ObjectDataParser.TWEEN_ROTATE, 0);
                    frame.tweenScale = ObjectDataParser._getBoolean(rawData, ObjectDataParser.TWEEN_SCALE, true);
                    this._parseTweenFrame(rawData, frame, frameStart, frameCount);
                    if (ObjectDataParser.TRANSFORM in rawData) {
                        var transformObject = rawData[ObjectDataParser.TRANSFORM];
                        this._parseTransform(transformObject, frame.transform);
                        if (this._isOldData) {
                            this._helpPoint.x = this._timelinePivot.x + ObjectDataParser._getNumber(transformObject, ObjectDataParser.PIVOT_X, 0);
                            this._helpPoint.y = this._timelinePivot.y + ObjectDataParser._getNumber(transformObject, ObjectDataParser.PIVOT_Y, 0);
                            frame.transform.toMatrix(this._helpMatrix);
                            this._helpMatrix.transformPoint(this._helpPoint.x, this._helpPoint.y, this._helpPoint, true);
                            frame.transform.x += this._helpPoint.x;
                            frame.transform.y += this._helpPoint.y;
                        }
                    }
                    var bone = this._timeline.bone;
                    var actions = new Array();
                    var events = new Array();
                    if (ObjectDataParser.ACTION in rawData || ObjectDataParser.ACTIONS in rawData) {
                        var slot = this._armature.getSlot(bone.name);
                        this._parseActionData(rawData, actions, bone, slot);
                    }
                    (ObjectDataParser.EVENT in rawData || ObjectDataParser.SOUND in rawData) && this._parseEventData(rawData, events, bone, null);
                    (actions.length > 0 || events.length > 0) && this._mergeFrameToAnimationTimeline(frame.position, actions, events);
                    return frame;
                };
                ObjectDataParser.prototype._parseSlotFrame = function(rawData, frameStart, frameCount) {
                    var frame = dragonBones.BaseObject.borrowObject(dragonBones.SlotFrameData);
                    frame.displayIndex = ObjectDataParser._getNumber(rawData, ObjectDataParser.DISPLAY_INDEX, 0);
                    this._parseTweenFrame(rawData, frame, frameStart, frameCount);
                    if (ObjectDataParser.COLOR in rawData || ObjectDataParser.COLOR_TRANSFORM in rawData) {
                        frame.color = dragonBones.SlotFrameData.generateColor();
                        this._parseColorTransform(rawData[ObjectDataParser.COLOR] || rawData[ObjectDataParser.COLOR_TRANSFORM], frame.color);
                    } else {
                        frame.color = dragonBones.SlotFrameData.DEFAULT_COLOR;
                    }
                    if (this._isOldData) {
                        ObjectDataParser._getBoolean(rawData, ObjectDataParser.HIDE, false) && (frame.displayIndex = -1);
                    } else {
                        if (ObjectDataParser.ACTION in rawData || ObjectDataParser.ACTIONS in rawData) {
                            var slot = this._timeline.slot;
                            var actions = new Array();
                            this._parseActionData(rawData, actions, slot.parent, slot);
                            this._mergeFrameToAnimationTimeline(frame.position, actions, null);
                        }
                    }
                    return frame;
                };
                ObjectDataParser.prototype._parseFFDFrame = function(rawData, frameStart, frameCount) {
                    var ffdTimeline = this._timeline;
                    var mesh = ffdTimeline.display.mesh;
                    var frame = dragonBones.BaseObject.borrowObject(dragonBones.ExtensionFrameData);
                    frame.type = ObjectDataParser._getNumber(rawData, ObjectDataParser.TYPE, 0);
                    this._parseTweenFrame(rawData, frame, frameStart, frameCount);
                    var rawVertices = rawData[ObjectDataParser.VERTICES];
                    var offset = ObjectDataParser._getNumber(rawData, ObjectDataParser.OFFSET, 0);
                    var x = 0;
                    var y = 0;
                    for (var i = 0, l = mesh.vertices.length; i < l; i += 2) {
                        if (!rawVertices || i < offset || i - offset >= rawVertices.length) {
                            x = 0;
                            y = 0;
                        } else {
                            x = rawVertices[i - offset] * this._armature.scale;
                            y = rawVertices[i + 1 - offset] * this._armature.scale;
                        }
                        if (mesh.skinned) {
                            mesh.slotPose.transformPoint(x, y, this._helpPoint, true);
                            x = this._helpPoint.x;
                            y = this._helpPoint.y;
                            var boneIndices = mesh.boneIndices[i / 2];
                            for (var iB = 0, lB = boneIndices.length; iB < lB; ++iB) {
                                var boneIndex = boneIndices[iB];
                                mesh.inverseBindPose[boneIndex].transformPoint(x, y, this._helpPoint, true);
                                frame.tweens.push(this._helpPoint.x, this._helpPoint.y);
                            }
                        } else {
                            frame.tweens.push(x, y);
                        }
                    }
                    return frame;
                };
                ObjectDataParser.prototype._parseTweenFrame = function(rawData, frame, frameStart, frameCount) {
                    this._parseFrame(rawData, frame, frameStart, frameCount);
                    if (frame.duration > 0) {
                        ObjectDataParser.TWEEN_EASING in rawData ? frame.tweenEasing = ObjectDataParser._getNumber(rawData, ObjectDataParser.TWEEN_EASING, dragonBones.DragonBones.NO_TWEEN) : this._isOldData ? frame.tweenEasing = this._isAutoTween ? this._animationTweenEasing : dragonBones.DragonBones.NO_TWEEN : frame.tweenEasing = dragonBones.DragonBones.NO_TWEEN;
                        this._isOldData && 1 == this._animation.scale && 1 == this._timeline.scale && frame.duration * this._armature.frameRate < 2 && (frame.tweenEasing = dragonBones.DragonBones.NO_TWEEN);
                        if (frameCount > 0 && ObjectDataParser.CURVE in rawData) {
                            frame.curve = new Array(2 * frameCount - 1);
                            dragonBones.TweenFrameData.samplingEasingCurve(rawData[ObjectDataParser.CURVE], frame.curve);
                        }
                    } else {
                        frame.tweenEasing = dragonBones.DragonBones.NO_TWEEN;
                        frame.curve = null;
                    }
                };
                ObjectDataParser.prototype._parseFrame = function(rawData, frame, frameStart, frameCount) {
                    frame.position = frameStart / this._armature.frameRate;
                    frame.duration = frameCount / this._armature.frameRate;
                };
                ObjectDataParser.prototype._parseTimeline = function(rawData, timeline, frameParser) {
                    timeline.scale = ObjectDataParser._getNumber(rawData, ObjectDataParser.SCALE, 1);
                    timeline.offset = ObjectDataParser._getNumber(rawData, ObjectDataParser.OFFSET, 0);
                    if (ObjectDataParser.FRAME in rawData) {
                        this._timeline = timeline;
                        var rawFrames = rawData[ObjectDataParser.FRAME];
                        if (1 == rawFrames.length) {
                            timeline.frames.length = 1;
                            timeline.frames[0] = frameParser.call(this, rawFrames[0], 0, ObjectDataParser._getNumber(rawFrames[0], ObjectDataParser.DURATION, 1));
                        } else {
                            if (rawFrames.length > 1) {
                                timeline.frames.length = this._animation.frameCount + 1;
                                var frameStart = 0;
                                var frameCount = 0;
                                var frame = null;
                                var prevFrame = null;
                                for (var i = 0, iW = 0, l = timeline.frames.length; i < l; ++i) {
                                    if (frameStart + frameCount <= i && iW < rawFrames.length) {
                                        var frameObject = rawFrames[iW++];
                                        frameStart = i;
                                        frameCount = ObjectDataParser._getNumber(frameObject, ObjectDataParser.DURATION, 1);
                                        frame = frameParser.call(this, frameObject, frameStart, frameCount);
                                        if (prevFrame) {
                                            prevFrame.next = frame;
                                            frame.prev = prevFrame;
                                            this._isOldData && prevFrame instanceof dragonBones.TweenFrameData && ObjectDataParser._getNumber(frameObject, ObjectDataParser.DISPLAY_INDEX, 0) == -1 && (prevFrame.tweenEasing = dragonBones.DragonBones.NO_TWEEN);
                                        }
                                        prevFrame = frame;
                                    }
                                    timeline.frames[i] = frame;
                                }
                                frame.duration = this._animation.duration - frame.position;
                                frame = timeline.frames[0];
                                prevFrame.next = frame;
                                frame.prev = prevFrame;
                                this._isOldData && prevFrame instanceof dragonBones.TweenFrameData && ObjectDataParser._getNumber(rawFrames[0], ObjectDataParser.DISPLAY_INDEX, 0) == -1 && (prevFrame.tweenEasing = dragonBones.DragonBones.NO_TWEEN);
                            }
                        }
                        this._timeline = null;
                    }
                };
                ObjectDataParser.prototype._parseActionData = function(rawData, actions, bone, slot) {
                    var actionsObject = rawData[ObjectDataParser.ACTION] || rawData[ObjectDataParser.ACTIONS] || rawData[ObjectDataParser.DEFAULT_ACTIONS];
                    if ("string" == typeof actionsObject) {
                        var actionData = dragonBones.BaseObject.borrowObject(dragonBones.ActionData);
                        actionData.type = 4;
                        actionData.bone = bone;
                        actionData.slot = slot;
                        actionData.data[0] = actionsObject;
                        actionData.data[1] = -1;
                        actionData.data[2] = -1;
                        actions.push(actionData);
                    } else {
                        if (actionsObject instanceof Array) {
                            for (var i = 0, l = actionsObject.length; i < l; ++i) {
                                var actionObject = actionsObject[i];
                                var isArray = actionObject instanceof Array;
                                var actionData = dragonBones.BaseObject.borrowObject(dragonBones.ActionData);
                                var animationName = isArray ? ObjectDataParser._getParameter(actionObject, 1, null) : ObjectDataParser._getString(actionObject, "gotoAndPlay", null);
                                if (isArray) {
                                    var actionType = actionObject[0];
                                    "string" == typeof actionType ? actionData.type = ObjectDataParser._getActionType(actionType) : actionData.type = ObjectDataParser._getParameter(actionObject, 0, 4);
                                } else {
                                    actionData.type = 2;
                                }
                                switch (actionData.type) {
                                  case 0:
                                    actionData.data[0] = animationName;
                                    actionData.data[1] = isArray ? ObjectDataParser._getParameter(actionObject, 2, -1) : -1;
                                    break;

                                  case 1:
                                    actionData.data[0] = animationName;
                                    break;

                                  case 2:
                                    actionData.data[0] = animationName;
                                    actionData.data[1] = isArray ? ObjectDataParser._getParameter(actionObject, 2, 0) : 0;
                                    actionData.data[2] = isArray ? ObjectDataParser._getParameter(actionObject, 3, -1) : -1;
                                    break;

                                  case 3:
                                    actionData.data[0] = animationName;
                                    actionData.data[1] = isArray ? ObjectDataParser._getParameter(actionObject, 2, 0) : 0;
                                    break;

                                  case 4:
                                    actionData.data[0] = animationName;
                                    actionData.data[1] = isArray ? ObjectDataParser._getParameter(actionObject, 2, -1) : -1;
                                    actionData.data[2] = isArray ? ObjectDataParser._getParameter(actionObject, 3, -1) : -1;
                                    break;

                                  case 5:
                                    actionData.data[0] = animationName;
                                    actionData.data[1] = isArray ? ObjectDataParser._getParameter(actionObject, 2, 0) : 0;
                                }
                                actionData.bone = bone;
                                actionData.slot = slot;
                                actions.push(actionData);
                            }
                        }
                    }
                };
                ObjectDataParser.prototype._parseEventData = function(rawData, events, bone, slot) {
                    if (ObjectDataParser.SOUND in rawData) {
                        var soundEventData = dragonBones.BaseObject.borrowObject(dragonBones.EventData);
                        soundEventData.type = 11;
                        soundEventData.name = ObjectDataParser._getString(rawData, ObjectDataParser.SOUND, null);
                        soundEventData.bone = bone;
                        soundEventData.slot = slot;
                        events.push(soundEventData);
                    }
                    if (ObjectDataParser.EVENT in rawData) {
                        var eventData = dragonBones.BaseObject.borrowObject(dragonBones.EventData);
                        eventData.type = 10;
                        eventData.name = ObjectDataParser._getString(rawData, ObjectDataParser.EVENT, null);
                        eventData.bone = bone;
                        eventData.slot = slot;
                        events.push(eventData);
                    }
                    if (ObjectDataParser.EVENTS in rawData) {
                        var rawEvents = rawData[ObjectDataParser.EVENTS];
                        for (var i = 0, l = rawEvents.length; i < l; ++i) {
                            var rawEvent = rawEvents[i];
                            var boneName = ObjectDataParser._getString(rawEvent, ObjectDataParser.BONE, null);
                            var eventData = dragonBones.BaseObject.borrowObject(dragonBones.EventData);
                            eventData.type = 10;
                            eventData.name = ObjectDataParser._getString(rawEvent, ObjectDataParser.NAME, null);
                            eventData.bone = this._armature.getBone(boneName);
                            if (ObjectDataParser.INTS in rawEvent) {
                                var rawInts = rawEvent[ObjectDataParser.INTS];
                                for (var i_6 = 0, l_3 = rawInts.length; i_6 < l_3; ++i_6) {
                                    eventData.ints.push(ObjectDataParser._getParameter(rawInts, i_6, 0));
                                }
                            }
                            if (ObjectDataParser.FLOATS in rawEvent) {
                                var rawFloats = rawEvent[ObjectDataParser.FLOATS];
                                for (var i_7 = 0, l_4 = rawFloats.length; i_7 < l_4; ++i_7) {
                                    eventData.floats.push(ObjectDataParser._getParameter(rawFloats, i_7, 0));
                                }
                            }
                            if (ObjectDataParser.STRINGS in rawEvent) {
                                var rawStrings = rawEvent[ObjectDataParser.STRINGS];
                                for (var i_8 = 0, l_5 = rawStrings.length; i_8 < l_5; ++i_8) {
                                    eventData.strings.push(ObjectDataParser._getParameter(rawStrings, i_8, null));
                                }
                            }
                            events.push(eventData);
                        }
                    }
                };
                ObjectDataParser.prototype._parseTransform = function(rawData, transform) {
                    transform.x = ObjectDataParser._getNumber(rawData, ObjectDataParser.X, 0) * this._armature.scale;
                    transform.y = ObjectDataParser._getNumber(rawData, ObjectDataParser.Y, 0) * this._armature.scale;
                    transform.skewX = ObjectDataParser._getNumber(rawData, ObjectDataParser.SKEW_X, 0) * dragonBones.DragonBones.ANGLE_TO_RADIAN;
                    transform.skewY = ObjectDataParser._getNumber(rawData, ObjectDataParser.SKEW_Y, 0) * dragonBones.DragonBones.ANGLE_TO_RADIAN;
                    transform.scaleX = ObjectDataParser._getNumber(rawData, ObjectDataParser.SCALE_X, 1);
                    transform.scaleY = ObjectDataParser._getNumber(rawData, ObjectDataParser.SCALE_Y, 1);
                };
                ObjectDataParser.prototype._parseColorTransform = function(rawData, color) {
                    color.alphaMultiplier = .01 * ObjectDataParser._getNumber(rawData, ObjectDataParser.ALPHA_MULTIPLIER, 100);
                    color.redMultiplier = .01 * ObjectDataParser._getNumber(rawData, ObjectDataParser.RED_MULTIPLIER, 100);
                    color.greenMultiplier = .01 * ObjectDataParser._getNumber(rawData, ObjectDataParser.GREEN_MULTIPLIER, 100);
                    color.blueMultiplier = .01 * ObjectDataParser._getNumber(rawData, ObjectDataParser.BLUE_MULTIPLIER, 100);
                    color.alphaOffset = ObjectDataParser._getNumber(rawData, ObjectDataParser.ALPHA_OFFSET, 0);
                    color.redOffset = ObjectDataParser._getNumber(rawData, ObjectDataParser.RED_OFFSET, 0);
                    color.greenOffset = ObjectDataParser._getNumber(rawData, ObjectDataParser.GREEN_OFFSET, 0);
                    color.blueOffset = ObjectDataParser._getNumber(rawData, ObjectDataParser.BLUE_OFFSET, 0);
                };
                ObjectDataParser.prototype.parseDragonBonesData = function(rawData, scale) {
                    void 0 === scale && (scale = 1);
                    if (rawData) {
                        var version = ObjectDataParser._getString(rawData, ObjectDataParser.VERSION, null);
                        this._isOldData = version == ObjectDataParser.DATA_VERSION_2_3 || version == ObjectDataParser.DATA_VERSION_3_0;
                        this._isOldData ? this._isGlobalTransform = ObjectDataParser._getBoolean(rawData, ObjectDataParser.IS_GLOBAL, true) : this._isGlobalTransform = false;
                        if (version == ObjectDataParser.DATA_VERSION || version == ObjectDataParser.DATA_VERSION_4_0 || this._isOldData) {
                            var data = dragonBones.BaseObject.borrowObject(dragonBones.DragonBonesData);
                            data.name = ObjectDataParser._getString(rawData, ObjectDataParser.NAME, null);
                            data.frameRate = ObjectDataParser._getNumber(rawData, ObjectDataParser.FRAME_RATE, 24) || 24;
                            if (ObjectDataParser.ARMATURE in rawData) {
                                this._data = data;
                                var armatures = rawData[ObjectDataParser.ARMATURE];
                                for (var i = 0, l = armatures.length; i < l; ++i) {
                                    data.addArmature(this._parseArmature(armatures[i], scale));
                                }
                                this._data = null;
                            }
                            return data;
                        }
                        throw new Error("Nonsupport data version.");
                    }
                    throw new Error("No data.");
                };
                ObjectDataParser.prototype.parseTextureAtlasData = function(rawData, textureAtlasData, scale) {
                    void 0 === scale && (scale = 0);
                    if (!rawData) {
                        throw new Error("No data.");
                    }
                    textureAtlasData.name = ObjectDataParser._getString(rawData, ObjectDataParser.NAME, null);
                    textureAtlasData.imagePath = ObjectDataParser._getString(rawData, ObjectDataParser.IMAGE_PATH, null);
                    scale > 0 ? textureAtlasData.scale = scale : scale = textureAtlasData.scale = ObjectDataParser._getNumber(rawData, ObjectDataParser.SCALE, textureAtlasData.scale);
                    scale = 1 / scale;
                    if (ObjectDataParser.SUB_TEXTURE in rawData) {
                        var textures = rawData[ObjectDataParser.SUB_TEXTURE];
                        for (var i = 0, l = textures.length; i < l; ++i) {
                            var textureObject = textures[i];
                            var textureData = textureAtlasData.generateTextureData();
                            textureData.name = ObjectDataParser._getString(textureObject, ObjectDataParser.NAME, null);
                            textureData.rotated = ObjectDataParser._getBoolean(textureObject, ObjectDataParser.ROTATED, false);
                            textureData.region.x = ObjectDataParser._getNumber(textureObject, ObjectDataParser.X, 0) * scale;
                            textureData.region.y = ObjectDataParser._getNumber(textureObject, ObjectDataParser.Y, 0) * scale;
                            textureData.region.width = ObjectDataParser._getNumber(textureObject, ObjectDataParser.WIDTH, 0) * scale;
                            textureData.region.height = ObjectDataParser._getNumber(textureObject, ObjectDataParser.HEIGHT, 0) * scale;
                            var frameWidth = ObjectDataParser._getNumber(textureObject, ObjectDataParser.FRAME_WIDTH, -1);
                            var frameHeight = ObjectDataParser._getNumber(textureObject, ObjectDataParser.FRAME_HEIGHT, -1);
                            if (frameWidth > 0 && frameHeight > 0) {
                                textureData.frame = dragonBones.TextureData.generateRectangle();
                                textureData.frame.x = ObjectDataParser._getNumber(textureObject, ObjectDataParser.FRAME_X, 0) * scale;
                                textureData.frame.y = ObjectDataParser._getNumber(textureObject, ObjectDataParser.FRAME_Y, 0) * scale;
                                textureData.frame.width = frameWidth * scale;
                                textureData.frame.height = frameHeight * scale;
                            }
                            textureAtlasData.addTexture(textureData);
                        }
                    }
                };
                ObjectDataParser.getInstance = function() {
                    ObjectDataParser._instance || (ObjectDataParser._instance = new ObjectDataParser());
                    return ObjectDataParser._instance;
                };
                ObjectDataParser._instance = null;
                return ObjectDataParser;
            })(dragonBones.DataParser);
            dragonBones.ObjectDataParser = ObjectDataParser;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var TextureAtlasData = (function(_super) {
                __extends(TextureAtlasData, _super);
                function TextureAtlasData() {
                    _super.call(this);
                    this.textures = {};
                }
                TextureAtlasData.prototype._onClear = function() {
                    for (var i in this.textures) {
                        this.textures[i].returnToPool();
                        delete this.textures[i];
                    }
                    this.autoSearch = false;
                    this.scale = 1;
                    this.name = null;
                    this.imagePath = null;
                };
                TextureAtlasData.prototype.addTexture = function(value) {
                    if (!value || !value.name || this.textures[value.name]) {
                        throw new Error();
                    }
                    this.textures[value.name] = value;
                    value.parent = this;
                };
                TextureAtlasData.prototype.getTexture = function(name) {
                    return this.textures[name];
                };
                return TextureAtlasData;
            })(dragonBones.BaseObject);
            dragonBones.TextureAtlasData = TextureAtlasData;
            var TextureData = (function(_super) {
                __extends(TextureData, _super);
                function TextureData() {
                    _super.call(this);
                    this.region = new dragonBones.Rectangle();
                }
                TextureData.generateRectangle = function() {
                    return new dragonBones.Rectangle();
                };
                TextureData.prototype._onClear = function() {
                    this.rotated = false;
                    this.name = null;
                    this.frame = null;
                    this.parent = null;
                    this.region.clear();
                };
                return TextureData;
            })(dragonBones.BaseObject);
            dragonBones.TextureData = TextureData;
        })(dragonBones || (dragonBones = {}));
        var dragonBones;
        (function(dragonBones) {
            var BaseFactory = (function() {
                function BaseFactory(dataParser) {
                    void 0 === dataParser && (dataParser = null);
                    this.autoSearch = false;
                    this._dataParser = null;
                    this._dragonBonesDataMap = {};
                    this._textureAtlasDataMap = {};
                    this._dataParser = dataParser;
                    if (!this._dataParser) {
                        BaseFactory._defaultParser || (BaseFactory._defaultParser = new dragonBones.ObjectDataParser());
                        this._dataParser = BaseFactory._defaultParser;
                    }
                }
                BaseFactory.prototype._getTextureData = function(textureAtlasName, textureName) {
                    var textureAtlasDataList = this._textureAtlasDataMap[textureAtlasName];
                    if (textureAtlasDataList) {
                        for (var i = 0, l = textureAtlasDataList.length; i < l; ++i) {
                            var textureData = textureAtlasDataList[i].getTexture(textureName);
                            if (textureData) {
                                return textureData;
                            }
                        }
                    }
                    if (this.autoSearch) {
                        for (var i in this._textureAtlasDataMap) {
                            textureAtlasDataList = this._textureAtlasDataMap[i];
                            for (var j = 0, lJ = textureAtlasDataList.length; j < lJ; ++j) {
                                var textureAtlasData = textureAtlasDataList[j];
                                if (textureAtlasData.autoSearch) {
                                    var textureData = textureAtlasData.getTexture(textureName);
                                    if (textureData) {
                                        return textureData;
                                    }
                                }
                            }
                        }
                    }
                    return null;
                };
                BaseFactory.prototype._fillBuildArmaturePackage = function(dataPackage, dragonBonesName, armatureName, skinName, textureAtlasName) {
                    var dragonBonesData = null;
                    var armatureData = null;
                    if (dragonBonesName) {
                        dragonBonesData = this._dragonBonesDataMap[dragonBonesName];
                        dragonBonesData && (armatureData = dragonBonesData.getArmature(armatureName));
                    }
                    if (!armatureData && (!dragonBonesName || this.autoSearch)) {
                        for (var eachDragonBonesName in this._dragonBonesDataMap) {
                            dragonBonesData = this._dragonBonesDataMap[eachDragonBonesName];
                            if (!dragonBonesName || dragonBonesData.autoSearch) {
                                armatureData = dragonBonesData.getArmature(armatureName);
                                if (armatureData) {
                                    dragonBonesName = eachDragonBonesName;
                                    break;
                                }
                            }
                        }
                    }
                    if (armatureData) {
                        dataPackage.dataName = dragonBonesName;
                        dataPackage.textureAtlasName = textureAtlasName;
                        dataPackage.data = dragonBonesData;
                        dataPackage.armature = armatureData;
                        dataPackage.skin = armatureData.getSkin(skinName);
                        dataPackage.skin || (dataPackage.skin = armatureData.defaultSkin);
                        return true;
                    }
                    return false;
                };
                BaseFactory.prototype._buildBones = function(dataPackage, armature) {
                    var bones = dataPackage.armature.sortedBones;
                    for (var i = 0, l = bones.length; i < l; ++i) {
                        var boneData = bones[i];
                        var bone = dragonBones.BaseObject.borrowObject(dragonBones.Bone);
                        bone.name = boneData.name;
                        bone.inheritTranslation = boneData.inheritTranslation;
                        bone.inheritRotation = boneData.inheritRotation;
                        bone.inheritScale = boneData.inheritScale;
                        bone.length = boneData.length;
                        bone.origin.copyFrom(boneData.transform);
                        boneData.parent ? armature.addBone(bone, boneData.parent.name) : armature.addBone(bone);
                        if (boneData.ik) {
                            bone.ikBendPositive = boneData.bendPositive;
                            bone.ikWeight = boneData.weight;
                            bone._setIK(armature.getBone(boneData.ik.name), boneData.chain, boneData.chainIndex);
                        }
                    }
                };
                BaseFactory.prototype._buildSlots = function(dataPackage, armature) {
                    var currentSkin = dataPackage.skin;
                    var defaultSkin = dataPackage.armature.defaultSkin;
                    var slotDisplayDataSetMap = {};
                    for (var i in defaultSkin.slots) {
                        var slotDisplayDataSet = defaultSkin.slots[i];
                        slotDisplayDataSetMap[slotDisplayDataSet.slot.name] = slotDisplayDataSet;
                    }
                    if (currentSkin != defaultSkin) {
                        for (var i in currentSkin.slots) {
                            var slotDisplayDataSet = currentSkin.slots[i];
                            slotDisplayDataSetMap[slotDisplayDataSet.slot.name] = slotDisplayDataSet;
                        }
                    }
                    var slots = dataPackage.armature.sortedSlots;
                    for (var i = 0, l = slots.length; i < l; ++i) {
                        var slotData = slots[i];
                        var slotDisplayDataSet = slotDisplayDataSetMap[slotData.name];
                        if (!slotDisplayDataSet) {
                            continue;
                        }
                        var slot = this._generateSlot(dataPackage, slotDisplayDataSet, armature);
                        if (slot) {
                            slot._displayDataSet = slotDisplayDataSet;
                            slot._setDisplayIndex(slotData.displayIndex);
                            slot._setBlendMode(slotData.blendMode);
                            slot._setColor(slotData.color);
                            armature.addSlot(slot, slotData.parent.name);
                        }
                    }
                };
                BaseFactory.prototype._replaceSlotDisplay = function(dataPackage, displayData, slot, displayIndex) {
                    displayIndex < 0 && (displayIndex = slot.displayIndex);
                    if (displayIndex >= 0) {
                        var displayList = slot.displayList;
                        displayList.length <= displayIndex && (displayList.length = displayIndex + 1);
                        slot._replacedDisplayDataSet.length <= displayIndex && (slot._replacedDisplayDataSet.length = displayIndex + 1);
                        slot._replacedDisplayDataSet[displayIndex] = displayData;
                        if (1 == displayData.type) {
                            var childArmature = this.buildArmature(displayData.path, dataPackage.dataName, null, dataPackage.textureAtlasName);
                            displayList[displayIndex] = childArmature;
                        } else {
                            displayData.texture && !dataPackage.textureAtlasName || (displayData.texture = this._getTextureData(dataPackage.textureAtlasName || dataPackage.dataName, displayData.path));
                            displayData.mesh || displayIndex < slot._displayDataSet.displays.length && slot._displayDataSet.displays[displayIndex].mesh ? displayList[displayIndex] = slot.meshDisplay : displayList[displayIndex] = slot.rawDisplay;
                        }
                        slot.displayList = displayList;
                        slot.invalidUpdate();
                    }
                };
                BaseFactory.prototype.parseDragonBonesData = function(rawData, name, scale) {
                    void 0 === name && (name = null);
                    void 0 === scale && (scale = 1);
                    var dragonBonesData = this._dataParser.parseDragonBonesData(rawData, scale);
                    this.addDragonBonesData(dragonBonesData, name);
                    return dragonBonesData;
                };
                BaseFactory.prototype.parseTextureAtlasData = function(rawData, textureAtlas, name, scale) {
                    void 0 === name && (name = null);
                    void 0 === scale && (scale = 0);
                    var textureAtlasData = this._generateTextureAtlasData(null, null);
                    this._dataParser.parseTextureAtlasData(rawData, textureAtlasData, scale);
                    this._generateTextureAtlasData(textureAtlasData, textureAtlas);
                    this.addTextureAtlasData(textureAtlasData, name);
                    return textureAtlasData;
                };
                BaseFactory.prototype.getDragonBonesData = function(name) {
                    return this._dragonBonesDataMap[name];
                };
                BaseFactory.prototype.addDragonBonesData = function(data, name) {
                    void 0 === name && (name = null);
                    if (!data) {
                        throw new Error();
                    }
                    name = name || data.name;
                    name ? this._dragonBonesDataMap[name] ? console.warn("Same name data.", name) : this._dragonBonesDataMap[name] = data : console.warn("Unnamed data.");
                };
                BaseFactory.prototype.removeDragonBonesData = function(name, disposeData) {
                    void 0 === disposeData && (disposeData = true);
                    var dragonBonesData = this._dragonBonesDataMap[name];
                    if (dragonBonesData) {
                        if (disposeData) {
                            if (dragonBones.DragonBones.debug) {
                                for (var i = 0, l = dragonBones.DragonBones._armatures.length; i < l; ++i) {
                                    var armature = dragonBones.DragonBones._armatures[i];
                                    if (armature.armatureData.parent == dragonBonesData) {
                                        throw new Error("ArmatureData: " + armature.armatureData.name + " DragonBonesData: " + name);
                                    }
                                }
                            }
                            dragonBonesData.returnToPool();
                        }
                        delete this._dragonBonesDataMap[name];
                    }
                };
                BaseFactory.prototype.getTextureAtlasData = function(name) {
                    return this._textureAtlasDataMap[name];
                };
                BaseFactory.prototype.addTextureAtlasData = function(data, name) {
                    void 0 === name && (name = null);
                    if (!data) {
                        throw new Error();
                    }
                    name = name || data.name;
                    if (name) {
                        var textureAtlasList = this._textureAtlasDataMap[name] = this._textureAtlasDataMap[name] || [];
                        textureAtlasList.indexOf(data) < 0 && textureAtlasList.push(data);
                    } else {
                        console.warn("Unnamed data.");
                    }
                };
                BaseFactory.prototype.removeTextureAtlasData = function(name, disposeData) {
                    void 0 === disposeData && (disposeData = true);
                    var textureAtlasDataList = this._textureAtlasDataMap[name];
                    if (textureAtlasDataList) {
                        if (disposeData) {
                            for (var i = 0, l = textureAtlasDataList.length; i < l; ++i) {
                                textureAtlasDataList[i].returnToPool();
                            }
                        }
                        delete this._textureAtlasDataMap[name];
                    }
                };
                BaseFactory.prototype.clear = function(disposeData) {
                    void 0 === disposeData && (disposeData = true);
                    for (var i in this._dragonBonesDataMap) {
                        disposeData && this._dragonBonesDataMap[i].returnToPool();
                        delete this._dragonBonesDataMap[i];
                    }
                    for (var i in this._textureAtlasDataMap) {
                        if (disposeData) {
                            var textureAtlasDataList = this._textureAtlasDataMap[i];
                            for (var i_9 = 0, l = textureAtlasDataList.length; i_9 < l; ++i_9) {
                                textureAtlasDataList[i_9].returnToPool();
                            }
                        }
                        delete this._textureAtlasDataMap[i];
                    }
                };
                BaseFactory.prototype.buildArmature = function(armatureName, dragonBonesName, skinName, textureAtlasName) {
                    void 0 === dragonBonesName && (dragonBonesName = null);
                    void 0 === skinName && (skinName = null);
                    void 0 === textureAtlasName && (textureAtlasName = null);
                    var dataPackage = {};
                    if (this._fillBuildArmaturePackage(dataPackage, dragonBonesName, armatureName, skinName, textureAtlasName)) {
                        var armature = this._generateArmature(dataPackage);
                        this._buildBones(dataPackage, armature);
                        this._buildSlots(dataPackage, armature);
                        armature.advanceTime(0);
                        return armature;
                    }
                    console.warn("No armature data.", armatureName, dragonBonesName || "");
                    return null;
                };
                BaseFactory.prototype.copyAnimationsToArmature = function(toArmature, fromArmatreName, fromSkinName, fromDragonBonesDataName, ifRemoveOriginalAnimationList) {
                    void 0 === fromSkinName && (fromSkinName = null);
                    void 0 === fromDragonBonesDataName && (fromDragonBonesDataName = null);
                    void 0 === ifRemoveOriginalAnimationList && (ifRemoveOriginalAnimationList = true);
                    var dataPackage = {};
                    if (this._fillBuildArmaturePackage(dataPackage, fromDragonBonesDataName, fromArmatreName, fromSkinName, null)) {
                        var fromArmatureData = dataPackage.armature;
                        if (ifRemoveOriginalAnimationList) {
                            toArmature.animation.animations = fromArmatureData.animations;
                        } else {
                            var animations = {};
                            for (var animationName in toArmature.animation.animations) {
                                animations[animationName] = toArmature.animation.animations[animationName];
                            }
                            for (var animationName in fromArmatureData.animations) {
                                animations[animationName] = fromArmatureData.animations[animationName];
                            }
                            toArmature.animation.animations = animations;
                        }
                        if (dataPackage.skin) {
                            var slots = toArmature.getSlots();
                            for (var i = 0, l = slots.length; i < l; ++i) {
                                var toSlot = slots[i];
                                var toSlotDisplayList = toSlot.displayList;
                                for (var i_10 = 0, l_6 = toSlotDisplayList.length; i_10 < l_6; ++i_10) {
                                    var toDisplayObject = toSlotDisplayList[i_10];
                                    if (toDisplayObject instanceof dragonBones.Armature) {
                                        var displays = dataPackage.skin.getSlot(toSlot.name).displays;
                                        if (i_10 < displays.length) {
                                            var fromDisplayData = displays[i_10];
                                            1 == fromDisplayData.type && this.copyAnimationsToArmature(toDisplayObject, fromDisplayData.path, fromSkinName, fromDragonBonesDataName, ifRemoveOriginalAnimationList);
                                        }
                                    }
                                }
                            }
                            return true;
                        }
                    }
                    return false;
                };
                BaseFactory.prototype.replaceSlotDisplay = function(dragonBonesName, armatureName, slotName, displayName, slot, displayIndex) {
                    void 0 === displayIndex && (displayIndex = -1);
                    var dataPackage = {};
                    if (this._fillBuildArmaturePackage(dataPackage, dragonBonesName, armatureName, null, null)) {
                        var slotDisplayDataSet = dataPackage.skin.getSlot(slotName);
                        if (slotDisplayDataSet) {
                            for (var i = 0, l = slotDisplayDataSet.displays.length; i < l; ++i) {
                                var displayData = slotDisplayDataSet.displays[i];
                                if (displayData.path == displayName) {
                                    this._replaceSlotDisplay(dataPackage, displayData, slot, displayIndex);
                                    break;
                                }
                            }
                        }
                    }
                };
                BaseFactory.prototype.replaceSlotDisplayList = function(dragonBonesName, armatureName, slotName, slot) {
                    var dataPackage = {};
                    if (this._fillBuildArmaturePackage(dataPackage, dragonBonesName, armatureName, null, null)) {
                        var slotDisplayDataSet = dataPackage.skin.getSlot(slotName);
                        if (slotDisplayDataSet) {
                            var displayIndex = 0;
                            for (var i = 0, l = slotDisplayDataSet.displays.length; i < l; ++i) {
                                var displayData = slotDisplayDataSet.displays[i];
                                this._replaceSlotDisplay(dataPackage, displayData, slot, displayIndex++);
                            }
                        }
                    }
                };
                BaseFactory.prototype.getAllDragonBonesData = function() {
                    return this._dragonBonesDataMap;
                };
                BaseFactory.prototype.getAllTextureAtlasData = function() {
                    return this._textureAtlasDataMap;
                };
                BaseFactory._defaultParser = null;
                return BaseFactory;
            })();
            dragonBones.BaseFactory = BaseFactory;
        })(dragonBones || (dragonBones = {}));
        module.exports = dragonBones;
    }), {} ],
    301: [ (function(require, module, exports) {
        var spine = sp.spine;
        sp._SGSkeleton = _ccsg.Node.extend({
            _skeleton: null,
            _rootBone: null,
            _timeScale: 1,
            _debugSlots: false,
            _debugBones: false,
            _premultipliedAlpha: false,
            _ownsSkeletonData: null,
            _atlas: null,
            _blendFunc: null,
            ctor: function(skeletonDataFile, atlasFile, scale) {
                _ccsg.Node.prototype.ctor.call(this);
                0 === arguments.length ? this.init() : this.initWithArgs(skeletonDataFile, atlasFile, scale);
            },
            _createRenderCmd: function() {
                return cc._renderType === cc.game.RENDER_TYPE_CANVAS ? new sp._SGSkeleton.CanvasRenderCmd(this) : new sp._SGSkeleton.WebGLRenderCmd(this);
            },
            init: function() {
                _ccsg.Node.prototype.init.call(this);
                this._premultipliedAlpha = cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.OPTIMIZE_BLEND_FUNC_FOR_PREMULTIPLIED_ALPHA;
                this._blendFunc = {
                    src: cc.BLEND_SRC,
                    dst: cc.BLEND_DST
                };
                this.scheduleUpdate();
            },
            setDebugSlotsEnabled: function(enabled) {
                this._debugSlots = enabled;
            },
            getDebugSlotsEnabled: function() {
                return this._debugSlots;
            },
            setDebugBonesEnabled: function(enabled) {
                this._debugBones = enabled;
            },
            getDebugBonesEnabled: function() {
                return this._debugBones;
            },
            setTimeScale: function(scale) {
                this._timeScale = scale;
            },
            getTimeScale: function() {
                return this._timeScale;
            },
            initWithArgs: function(skeletonDataFile, atlasFile, scale) {
                var argSkeletonFile = skeletonDataFile, argAtlasFile = atlasFile, skeletonData, atlas, ownsSkeletonData;
                if (cc.js.isString(argSkeletonFile)) {
                    if (cc.js.isString(argAtlasFile)) {
                        var data = cc.loader.getRes(argAtlasFile);
                        sp._atlasLoader.setAtlasFile(argAtlasFile);
                        atlas = new spine.TextureAtlas(data, sp._atlasLoader.load.bind(sp._atlasLoader));
                    } else {
                        atlas = atlasFile;
                    }
                    scale = scale || 1 / cc.director.getContentScaleFactor();
                    var attachmentLoader = new spine.AtlasAttachmentLoader(atlas);
                    var skeletonJsonReader = new spine.SkeletonJson(attachmentLoader);
                    skeletonJsonReader.scale = scale;
                    var skeletonJson = cc.loader.getRes(argSkeletonFile);
                    skeletonData = skeletonJsonReader.readSkeletonData(skeletonJson);
                    atlas.dispose(skeletonJsonReader);
                    ownsSkeletonData = true;
                } else {
                    skeletonData = skeletonDataFile;
                    ownsSkeletonData = atlasFile;
                }
                this.setSkeletonData(skeletonData, ownsSkeletonData);
                this.init();
            },
            getBoundingBox: function() {
                var minX = cc.macro.FLT_MAX, minY = cc.macro.FLT_MAX, maxX = cc.macro.FLT_MIN, maxY = cc.macro.FLT_MIN;
                var scaleX = this.getScaleX(), scaleY = this.getScaleY(), vertices = [], slots = this._skeleton.slots, VERTEX = spine.RegionAttachment;
                for (var i = 0, slotCount = slots.length; i < slotCount; ++i) {
                    var slot = slots[i];
                    var attachment = slot.attachment;
                    if (!attachment || !(attachment instanceof spine.RegionAttachment)) {
                        continue;
                    }
                    vertices = attachment.updateWorldVertices(slot, false);
                    minX = Math.min(minX, vertices[VERTEX.X1] * scaleX, vertices[VERTEX.X4] * scaleX, vertices[VERTEX.X2] * scaleX, vertices[VERTEX.X3] * scaleX);
                    minY = Math.min(minY, vertices[VERTEX.Y1] * scaleY, vertices[VERTEX.Y4] * scaleY, vertices[VERTEX.Y2] * scaleY, vertices[VERTEX.Y3] * scaleY);
                    maxX = Math.max(maxX, vertices[VERTEX.X1] * scaleX, vertices[VERTEX.X4] * scaleX, vertices[VERTEX.X2] * scaleX, vertices[VERTEX.X3] * scaleX);
                    maxY = Math.max(maxY, vertices[VERTEX.Y1] * scaleY, vertices[VERTEX.Y4] * scaleY, vertices[VERTEX.Y2] * scaleY, vertices[VERTEX.Y3] * scaleY);
                }
                var position = this.getPosition();
                return cc.rect(position.x + minX, position.y + minY, maxX - minX, maxY - minY);
            },
            updateWorldTransform: function() {
                this._skeleton.updateWorldTransform();
            },
            setToSetupPose: function() {
                this._skeleton.setToSetupPose();
            },
            setBonesToSetupPose: function() {
                this._skeleton.setBonesToSetupPose();
            },
            setSlotsToSetupPose: function() {
                this._skeleton.setSlotsToSetupPose();
            },
            findBone: function(boneName) {
                return this._skeleton.findBone(boneName);
            },
            findSlot: function(slotName) {
                return this._skeleton.findSlot(slotName);
            },
            setSkin: function(skinName) {
                return this._skeleton.setSkinByName(skinName);
            },
            getAttachment: function(slotName, attachmentName) {
                return this._skeleton.getAttachmentByName(slotName, attachmentName);
            },
            setAttachment: function(slotName, attachmentName) {
                this._skeleton.setAttachment(slotName, attachmentName);
            },
            setPremultipliedAlpha: function(premultiplied) {
                this._premultipliedAlpha = premultiplied;
            },
            isPremultipliedAlpha: function() {
                return this._premultipliedAlpha;
            },
            setSkeletonData: function(skeletonData, ownsSkeletonData) {
                null != skeletonData.width && null != skeletonData.height && this.setContentSize(skeletonData.width / cc.director.getContentScaleFactor(), skeletonData.height / cc.director.getContentScaleFactor());
                this._skeleton = new spine.Skeleton(skeletonData);
                this._skeleton.updateWorldTransform();
                this._rootBone = this._skeleton.getRootBone();
                this._ownsSkeletonData = ownsSkeletonData;
                this._renderCmd._createChildFormSkeletonData();
            },
            getTextureAtlas: function(regionAttachment) {
                return regionAttachment.region;
            },
            getBlendFunc: function() {
                return this._blendFunc;
            },
            setBlendFunc: function(src, dst) {
                var locBlendFunc = this._blendFunc;
                if (void 0 === dst) {
                    locBlendFunc.src = src.src;
                    locBlendFunc.dst = src.dst;
                } else {
                    locBlendFunc.src = src;
                    locBlendFunc.dst = dst;
                }
            },
            update: function(dt) {
                this._skeleton.update(dt);
            }
        });
        Object.defineProperty(sp._SGSkeleton.prototype, "opacityModifyRGB", {
            get: sp._SGSkeleton.prototype.isOpacityModifyRGB
        });
    }), {} ],
    302: [ (function(require, module, exports) {
        var spine = sp.spine;
        var animEventType = sp.AnimationEventType;
        sp._atlasPage_createTexture_webGL = function(self, path) {
            var texture = cc.textureCache.addImage(path);
            self.rendererObject = new cc.TextureAtlas(texture, 128);
            self.width = texture.getPixelWidth();
            self.height = texture.getPixelHeight();
        };
        sp._atlasPage_createTexture_canvas = function(self, path) {
            self._texture = cc.textureCache.addImage(path);
        };
        sp._atlasPage_disposeTexture = function(self) {
            self.rendererObject.release();
        };
        sp._atlasLoader = {
            spAtlasFile: null,
            setAtlasFile: function(spAtlasFile) {
                this.spAtlasFile = spAtlasFile;
            },
            load: function(line) {
                var texturePath = cc.path.join(cc.path.dirname(this.spAtlasFile), line);
                var texture = cc.textureCache.addImage(texturePath);
                var tex = new sp.SkeletonTexture({
                    width: texture.getPixelWidth(),
                    height: texture.getPixelHeight()
                });
                tex.setRealTexture(texture);
                return tex;
            },
            unload: function(obj) {}
        };
        sp.TrackEntryListeners = function(startListener, endListener, completeListener, eventListener, interruptListener, disposeListener) {
            this.startListener = startListener || null;
            this.endListener = endListener || null;
            this.completeListener = completeListener || null;
            this.eventListener = eventListener || null;
            this.interruptListener = interruptListener || null;
            this.disposeListener = disposeListener || null;
            this.callback = null;
            this.callbackTarget = null;
            this.skeletonNode = null;
        };
        var proto = sp.TrackEntryListeners.prototype;
        proto.start = function(trackEntry) {
            this.startListener && this.startListener(trackEntry);
            this.callback && this.callback.call(this.callbackTarget, this.skeletonNode, trackEntry, animEventType.START, null, 0);
        };
        proto.interrupt = function(trackEntry) {
            this.interruptListener && this.interruptListener(trackEntry);
            this.callback && this.callback.call(this.callbackTarget, this.skeletonNode, trackEntry, animEventType.INTERRUPT, null, 0);
        };
        proto.end = function(trackEntry) {
            this.endListener && this.endListener(trackEntry);
            this.callback && this.callback.call(this.callbackTarget, this.skeletonNode, trackEntry, animEventType.END, null, 0);
        };
        proto.dispose = function(trackEntry) {
            this.disposeListener && this.disposeListener(trackEntry);
            this.callback && this.callback.call(this.callbackTarget, this.skeletonNode, trackEntry, animEventType.DISPOSE, null, 0);
        };
        proto.complete = function(trackEntry) {
            var loopCount = Math.floor(trackEntry.trackTime / trackEntry.animationEnd);
            this.completeListener && this.completeListener(trackEntry, loopCount);
            this.callback && this.callback.call(this.callbackTarget, this.skeletonNode, trackEntry, animEventType.COMPLETE, null, loopCount);
        };
        proto.event = function(trackEntry, event) {
            this.eventListener && this.eventListener(trackEntry, event);
            this.callback && this.callback.call(this.callbackTarget, this.skeletonNode, trackEntry, animEventType.EVENT, event, 0);
        };
        sp.TrackEntryListeners.getListeners = function(entry) {
            entry.listener || (entry.listener = new sp.TrackEntryListeners());
            return entry.listener;
        };
        sp._SGSkeletonAnimation = sp._SGSkeleton.extend({
            _state: null,
            _ownsAnimationStateData: false,
            _listener: null,
            init: function() {
                sp._SGSkeleton.prototype.init.call(this);
                this._ownsAnimationStateData = true;
                this.setAnimationStateData(new spine.AnimationStateData(this._skeleton.data));
            },
            setAnimationStateData: function(stateData) {
                var state = new spine.AnimationState(stateData);
                this._listener = new sp.TrackEntryListeners();
                state.rendererObject = this;
                state.addListener(this._listener);
                this._state = state;
            },
            setMix: function(fromAnimation, toAnimation, duration) {
                this._state.data.setMixWith(fromAnimation, toAnimation, duration);
            },
            setAnimationListener: function(target, callback) {
                this._listener.callbackTarget = target;
                this._listener.callback = callback;
                this._listener.skeletonNode = this;
            },
            setAnimation: function(trackIndex, name, loop) {
                var animation = this._skeleton.data.findAnimation(name);
                if (!animation) {
                    cc.logID(7509, name);
                    return null;
                }
                return this._state.setAnimationWith(trackIndex, animation, loop);
            },
            addAnimation: function(trackIndex, name, loop, delay) {
                delay = null == delay ? 0 : delay;
                var animation = this._skeleton.data.findAnimation(name);
                if (!animation) {
                    cc.logID(7510, name);
                    return null;
                }
                return this._state.addAnimationWith(trackIndex, animation, loop, delay);
            },
            findAnimation: function(name) {
                return this._skeleton.data.findAnimation(name);
            },
            getCurrent: function(trackIndex) {
                return this._state.getCurrent(trackIndex);
            },
            clearTracks: function() {
                this._state.clearTracks();
            },
            clearTrack: function(trackIndex) {
                this._state.clearTrack(trackIndex);
            },
            update: function(dt) {
                this._super(dt);
                dt *= this._timeScale;
                this._renderCmd.setDirtyFlag(_ccsg.Node._dirtyFlags.contentDirty);
                this._state.update(dt);
                this._state.apply(this._skeleton);
                this._skeleton.updateWorldTransform();
                this._renderCmd._updateChild();
            },
            setStartListener: function(listener) {
                this._listener.startListener = listener;
            },
            setInterruptListener: function(listener) {
                this._listener.interruptListener = listener;
            },
            setEndListener: function(listener) {
                this._listener.endListener = listener;
            },
            setDisposeListener: function(listener) {
                this._listener.disposeListener = listener;
            },
            setCompleteListener: function(listener) {
                this._listener.completeListener = listener;
            },
            setEventListener: function(listener) {
                this._listener.eventListener = listener;
            },
            setTrackStartListener: function(entry, listener) {
                sp.TrackEntryListeners.getListeners(entry).startListener = listener;
            },
            setTrackInterruptListener: function(entry, listener) {
                sp.TrackEntryListeners.getListeners(entry).interruptListener = listener;
            },
            setTrackEndListener: function(entry, listener) {
                sp.TrackEntryListeners.getListeners(entry).endListener = listener;
            },
            setTrackDisposeListener: function(entry, listener) {
                sp.TrackEntryListeners.getListeners(entry).disposeListener = listener;
            },
            setTrackCompleteListener: function(entry, listener) {
                sp.TrackEntryListeners.getListeners(entry).completeListener = listener;
            },
            setTrackEventListener: function(entry, listener) {
                sp.TrackEntryListeners.getListeners(entry).eventListener = listener;
            },
            getState: function() {
                return this._state;
            }
        });
    }), {} ],
    303: [ (function(require, module, exports) {
        var spine = sp.spine;
        sp._SGSkeleton.CanvasRenderCmd = function(renderableObject) {
            this._rootCtor(renderableObject);
            this._needDraw = true;
        };
        var proto = sp._SGSkeleton.CanvasRenderCmd.prototype = Object.create(_ccsg.Node.CanvasRenderCmd.prototype);
        proto.constructor = sp._SGSkeleton.CanvasRenderCmd;
        proto.rendering = function(wrapper, scaleX, scaleY) {
            var node = this._node, i, n, slot, slotNode;
            wrapper = wrapper || cc._renderContext;
            var locSkeleton = node._skeleton, drawOrder = locSkeleton.drawOrder;
            for (i = 0, n = drawOrder.length; i < n; i++) {
                slot = drawOrder[i];
                slotNode = slot._slotNode;
                if (slotNode._visible && slotNode._renderCmd && slot.currentSprite) {
                    slotNode._renderCmd.transform(this, true);
                    slot.currentSprite._renderCmd.rendering(wrapper, scaleX, scaleY);
                    slotNode._renderCmd._dirtyFlag = slot.currentSprite._renderCmd._dirtyFlag = 0;
                }
            }
            if (!node._debugSlots && !node._debugBones) {
                return;
            }
            wrapper.setTransform(this._worldTransform, scaleX, scaleY);
            wrapper.setGlobalAlpha(1);
            var attachment, drawingUtil = cc._drawingUtil;
            if (node._debugSlots) {
                drawingUtil.setDrawColor(0, 0, 255, 255);
                drawingUtil.setLineWidth(1);
                var points = [];
                for (i = 0, n = locSkeleton.slots.length; i < n; i++) {
                    slot = locSkeleton.drawOrder[i];
                    if (!slot.attachment || !(slot.attachment instanceof spine.RegionAttachment)) {
                        continue;
                    }
                    attachment = slot.attachment;
                    this._updateRegionAttachmentSlot(attachment, slot, points);
                    drawingUtil.drawPoly(points, 4, true);
                }
            }
            if (node._debugBones) {
                var bone;
                drawingUtil.setLineWidth(2);
                drawingUtil.setDrawColor(255, 0, 0, 255);
                for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                    bone = locSkeleton.bones[i];
                    var x = bone.data.length * bone.a + bone.worldX;
                    var y = bone.data.length * bone.c + bone.worldY;
                    drawingUtil.drawLine({
                        x: bone.worldX,
                        y: bone.worldY
                    }, {
                        x: x,
                        y: y
                    });
                }
                drawingUtil.setPointSize(4);
                drawingUtil.setDrawColor(0, 0, 255, 255);
                for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                    bone = locSkeleton.bones[i];
                    drawingUtil.drawPoint({
                        x: bone.worldX,
                        y: bone.worldY
                    });
                    0 === i && drawingUtil.setDrawColor(0, 255, 0, 255);
                }
            }
        };
        proto.updateStatus = function() {
            this.originUpdateStatus();
            this._updateCurrentRegions();
            this._regionFlag = _ccsg.Node.CanvasRenderCmd.RegionStatus.DirtyDouble;
            this._dirtyFlag &= ~_ccsg.Node._dirtyFlags.contentDirty;
        };
        proto.getLocalBB = function() {
            return this._node.getBoundingBox();
        };
        proto._updateRegionAttachmentSlot = function(attachment, slot, points) {
            if (!points) {
                return;
            }
            var vertices = attachment.updateWorldVertices(slot, false);
            var VERTEX = spine.RegionAttachment;
            points.length = 0;
            points.push(cc.p(vertices[VERTEX.X1], vertices[VERTEX.Y1]));
            points.push(cc.p(vertices[VERTEX.X4], vertices[VERTEX.Y4]));
            points.push(cc.p(vertices[VERTEX.X3], vertices[VERTEX.Y3]));
            points.push(cc.p(vertices[VERTEX.X2], vertices[VERTEX.Y2]));
        };
        proto._createChildFormSkeletonData = function() {
            var node = this._node;
            var locSkeleton = node._skeleton, spriteName, sprite;
            for (var i = 0, n = locSkeleton.slots.length; i < n; i++) {
                var slot = locSkeleton.slots[i], attachment = slot.attachment;
                var slotNode = new _ccsg.Node();
                slot._slotNode = slotNode;
                if (attachment instanceof spine.RegionAttachment) {
                    spriteName = attachment.region.name;
                    sprite = this._createSprite(slot, attachment);
                    slot.currentSprite = sprite;
                    slot.currentSpriteName = spriteName;
                    slotNode.addChild(sprite);
                } else {
                    attachment instanceof spine.MeshAttachment;
                }
            }
        };
        proto._createSprite = function(slot, attachment) {
            var rendererObject = attachment.region;
            var texture = rendererObject.texture.getRealTexture();
            var rect = new cc.Rect(rendererObject.x, rendererObject.y, rendererObject.width, rendererObject.height);
            var sprite = new _ccsg.Sprite();
            sprite.initWithTexture(texture, rect, rendererObject.rotate, false);
            sprite._rect.width = attachment.width;
            sprite._rect.height = attachment.height;
            sprite.setContentSize(attachment.width, attachment.height);
            sprite.setRotation(-attachment.rotation);
            sprite.setScale(rendererObject.width / rendererObject.originalWidth * attachment.scaleX, rendererObject.height / rendererObject.originalHeight * attachment.scaleY);
            slot.sprites = slot.sprites || {};
            slot.sprites[rendererObject.name] = sprite;
            return sprite;
        };
        proto._updateChild = function() {
            var locSkeleton = this._node._skeleton, slots = locSkeleton.slots;
            var color = this._displayedColor, opacity = this._displayedOpacity;
            var i, n, selSprite, ax, ay;
            var slot, attachment, slotNode;
            for (i = 0, n = slots.length; i < n; i++) {
                slot = slots[i];
                attachment = slot.attachment;
                slotNode = slot._slotNode;
                if (!attachment) {
                    slotNode.setVisible(false);
                    continue;
                }
                if (attachment instanceof spine.RegionAttachment) {
                    if (attachment.region && (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name)) {
                        var spriteName = attachment.region.name;
                        void 0 !== slot.currentSprite && slot.currentSprite.setVisible(false);
                        slot.sprites = slot.sprites || {};
                        if (void 0 !== slot.sprites[spriteName]) {
                            slot.sprites[spriteName].setVisible(true);
                        } else {
                            var sprite = this._createSprite(slot, attachment);
                            slotNode.addChild(sprite);
                        }
                        slot.currentSprite = slot.sprites[spriteName];
                        slot.currentSpriteName = spriteName;
                    }
                    var bone = slot.bone;
                    if (0 === attachment.region.offsetX && 0 === attachment.region.offsetY) {
                        ax = attachment.x;
                        ay = attachment.y;
                    } else {
                        ax = .5 * (attachment.offset[0] + attachment.offset[4]);
                        ay = .5 * (attachment.offset[1] + attachment.offset[5]);
                    }
                    slotNode.setPosition(bone.worldX + ax * bone.a + ay * bone.b, bone.worldY + ax * bone.c + ay * bone.d);
                    slotNode.setScale(bone.getWorldScaleX(), bone.getWorldScaleY());
                    selSprite = slot.currentSprite;
                    selSprite._flippedX = bone.skeleton.flipX;
                    selSprite._flippedY = bone.skeleton.flipY;
                    if (selSprite._flippedY || selSprite._flippedX) {
                        slotNode.setRotation(bone.getWorldRotationX());
                        selSprite.setRotation(attachment.rotation);
                    } else {
                        slotNode.setRotation(-bone.getWorldRotationX());
                        selSprite.setRotation(-attachment.rotation);
                    }
                    selSprite._renderCmd._displayedOpacity = 0 | opacity * slot.color.a;
                    var r = 0 | color.r * slot.color.r, g = 0 | color.g * slot.color.g, b = 0 | color.b * slot.color.b;
                    selSprite.setColor(cc.color(r, g, b));
                    selSprite._renderCmd._updateColor();
                } else {
                    if (!(attachment instanceof spine.MeshAttachment)) {
                        slotNode.setVisible(false);
                        continue;
                    }
                }
                slotNode.setVisible(true);
            }
        };
    }), {} ],
    304: [ (function(require, module, exports) {
        sp.SkeletonTexture = cc.Class({
            name: "sp.SkeletonTexture",
            extends: sp.spine.Texture,
            _texture: null,
            setRealTexture: function(tex) {
                this._texture = tex;
            },
            getRealTexture: function() {
                return this._texture;
            },
            setFilters: function(minFilter, magFilter) {
                if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                    var gl = cc._renderContext;
                    this.bind();
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
                }
            },
            setWraps: function(uWrap, vWrap) {
                if (cc._renderType === cc.game.RENDER_TYPE_WEBGL) {
                    var gl = cc._renderContext;
                    this.bind();
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, uWrap);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, vWrap);
                }
            },
            dispose: function() {},
            bind: function() {
                cc._renderType === cc.game.RENDER_TYPE_WEBGL && cc.gl.bindTexture2D(this._texture);
            }
        });
    }), {} ],
    305: [ (function(require, module, exports) {
        var spine = sp.spine;
        sp._SGSkeleton.WebGLRenderCmd = function(renderableObject) {
            this._rootCtor(renderableObject);
            this._needDraw = true;
            this._matrix = new cc.math.Matrix4();
            this._matrix.identity();
            this.vertexType = cc.renderer.VertexType.CUSTOM;
            this.setShaderProgram(cc.shaderCache.programForKey(cc.macro.SHADER_POSITION_TEXTURECOLOR));
        };
        var proto = sp._SGSkeleton.WebGLRenderCmd.prototype = Object.create(_ccsg.Node.WebGLRenderCmd.prototype);
        proto.constructor = sp._SGSkeleton.WebGLRenderCmd;
        proto.uploadData = function(f32buffer, ui32buffer, vertexDataOffset) {
            cc.renderer._batchRendering();
            vertexDataOffset = 0;
            var node = this._node;
            var color = this._displayedColor, locSkeleton = node._skeleton;
            var textureAtlas, attachment, slot, i, n;
            var premultiAlpha = node._premultipliedAlpha;
            var blendMode = -1;
            var dataInited = false;
            var cachedVertices = 0;
            var wt = this._worldTransform, mat = this._matrix.mat;
            mat[0] = wt.a;
            mat[4] = wt.c;
            mat[12] = wt.tx;
            mat[1] = wt.b;
            mat[5] = wt.d;
            mat[13] = wt.ty;
            this._shaderProgram.use();
            this._shaderProgram._setUniformForMVPMatrixWithMat4(this._matrix);
            locSkeleton.r = color.r / 255;
            locSkeleton.g = color.g / 255;
            locSkeleton.b = color.b / 255;
            locSkeleton.a = this._displayedOpacity / 255;
            if (premultiAlpha) {
                locSkeleton.r *= locSkeleton.a;
                locSkeleton.g *= locSkeleton.a;
                locSkeleton.b *= locSkeleton.a;
            }
            var debugSlotsInfo = null;
            this._node._debugSlots && (debugSlotsInfo = []);
            for (i = 0, n = locSkeleton.drawOrder.length; i < n; i++) {
                slot = locSkeleton.drawOrder[i];
                if (!slot.attachment) {
                    continue;
                }
                attachment = slot.attachment;
                var vertCount = 0;
                if (attachment instanceof spine.RegionAttachment) {
                    vertCount = 6;
                } else {
                    if (!(attachment instanceof spine.MeshAttachment)) {
                        continue;
                    }
                    vertCount = attachment.regionUVs.length / 2;
                }
                if (0 === vertCount) {
                    continue;
                }
                var regionTextureAtlas = node.getTextureAtlas(attachment);
                if (!dataInited) {
                    textureAtlas = regionTextureAtlas;
                    blendMode = slot.data.blendMode;
                    cc.renderer._updateBatchedInfo(textureAtlas.texture.getRealTexture(), this._getBlendFunc(blendMode, premultiAlpha), this.getShaderProgram());
                    dataInited = true;
                }
                if (6 * (cachedVertices + vertCount) > f32buffer.length || textureAtlas !== regionTextureAtlas || blendMode !== slot.data.blendMode) {
                    cc.renderer._batchRendering();
                    vertexDataOffset = 0;
                    cachedVertices = 0;
                    textureAtlas = regionTextureAtlas;
                    blendMode = slot.data.blendMode;
                    cc.renderer._updateBatchedInfo(textureAtlas.texture.getRealTexture(), this._getBlendFunc(blendMode, premultiAlpha), this.getShaderProgram());
                }
                var slotDebugPoints = null;
                if (attachment instanceof spine.RegionAttachment) {
                    slotDebugPoints = this._uploadRegionAttachmentData(attachment, slot, premultiAlpha, f32buffer, ui32buffer, vertexDataOffset);
                } else {
                    if (!(attachment instanceof spine.MeshAttachment)) {
                        continue;
                    }
                    this._uploadMeshAttachmentData(attachment, slot, premultiAlpha, f32buffer, ui32buffer, vertexDataOffset);
                }
                this._node._debugSlots && (debugSlotsInfo[i] = slotDebugPoints);
                attachment instanceof spine.RegionAttachment ? cc.renderer._increaseBatchingSize(vertCount, cc.renderer.VertexType.TRIANGLE) : cc.renderer._increaseBatchingSize(vertCount, cc.renderer.VertexType.CUSTOM, attachment.triangles);
                cachedVertices += vertCount;
                vertexDataOffset += 6 * vertCount;
            }
            cachedVertices > 0 && cc.renderer._batchRendering();
            if (node._debugBones || node._debugSlots) {
                cc.math.glMatrixMode(cc.math.KM_GL_MODELVIEW);
                cc.current_stack.stack.push(cc.current_stack.top);
                cc.current_stack.top = this._matrix;
                var drawingUtil = cc._drawingUtil;
                if (node._debugSlots && debugSlotsInfo && debugSlotsInfo.length > 0) {
                    drawingUtil.setDrawColor(0, 0, 255, 255);
                    drawingUtil.setLineWidth(1);
                    for (i = 0, n = locSkeleton.slots.length; i < n; i++) {
                        var points = debugSlotsInfo[i];
                        points && drawingUtil.drawPoly(points, 4, true);
                    }
                }
                if (node._debugBones) {
                    var bone;
                    drawingUtil.setLineWidth(2);
                    drawingUtil.setDrawColor(255, 0, 0, 255);
                    for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                        bone = locSkeleton.bones[i];
                        var x = bone.data.length * bone.a + bone.worldX;
                        var y = bone.data.length * bone.c + bone.worldY;
                        drawingUtil.drawLine(cc.p(bone.worldX, bone.worldY), cc.p(x, y));
                    }
                    drawingUtil.setPointSize(4);
                    drawingUtil.setDrawColor(0, 0, 255, 255);
                    for (i = 0, n = locSkeleton.bones.length; i < n; i++) {
                        bone = locSkeleton.bones[i];
                        drawingUtil.drawPoint(cc.p(bone.worldX, bone.worldY));
                        0 == i && drawingUtil.setDrawColor(0, 255, 0, 255);
                    }
                }
                cc.math.glPopMatrix();
            }
            return 0;
        };
        proto._getBlendFunc = function(blendMode, premultiAlpha) {
            var ret = {};
            switch (blendMode) {
              case spine.BlendMode.Normal:
                ret.src = premultiAlpha ? cc.macro.ONE : cc.macro.SRC_ALPHA;
                ret.dst = cc.macro.ONE_MINUS_SRC_ALPHA;
                break;

              case spine.BlendMode.Additive:
                ret.src = premultiAlpha ? cc.macro.ONE : cc.macro.SRC_ALPHA;
                ret.dst = cc.macro.ONE;
                break;

              case spine.BlendMode.Multiply:
                ret.src = cc.macro.DST_COLOR;
                ret.dst = cc.macro.ONE_MINUS_SRC_ALPHA;
                break;

              case spine.BlendMode.Screen:
                ret.src = cc.macro.ONE;
                ret.dst = cc.macro.ONE_MINUS_SRC_COLOR;
                break;

              default:
                ret = this._node._blendFunc;
            }
            return ret;
        };
        proto._createChildFormSkeletonData = function() {};
        proto._updateChild = function() {};
        proto._uploadRegionAttachmentData = function(attachment, slot, premultipliedAlpha, f32buffer, ui32buffer, vertexDataOffset) {
            var nodeColor = this._displayedColor;
            var nodeR = nodeColor.r, nodeG = nodeColor.g, nodeB = nodeColor.b, nodeA = this._displayedOpacity;
            var vertices = attachment.updateWorldVertices(slot, premultipliedAlpha);
            var offset = vertexDataOffset;
            for (var i = 0; i < 6; i++) {
                var srcIdx = i < 4 ? i % 3 : i - 2;
                var r = vertices[8 * srcIdx + 2] * nodeR, g = vertices[8 * srcIdx + 3] * nodeG, b = vertices[8 * srcIdx + 4] * nodeB, a = vertices[8 * srcIdx + 5] * nodeA;
                var color = a << 24 | b << 16 | g << 8 | r;
                f32buffer[offset] = vertices[8 * srcIdx];
                f32buffer[offset + 1] = vertices[8 * srcIdx + 1];
                f32buffer[offset + 2] = this._node.vertexZ;
                ui32buffer[offset + 3] = color;
                f32buffer[offset + 4] = vertices[8 * srcIdx + 6];
                f32buffer[offset + 5] = vertices[8 * srcIdx + 7];
                offset += 6;
            }
            if (this._node._debugSlots) {
                var VERTEX = spine.RegionAttachment;
                return [ cc.p(vertices[VERTEX.X1], vertices[VERTEX.Y1]), cc.p(vertices[VERTEX.X2], vertices[VERTEX.Y2]), cc.p(vertices[VERTEX.X3], vertices[VERTEX.Y3]), cc.p(vertices[VERTEX.X4], vertices[VERTEX.Y4]) ];
            }
        };
        proto._uploadMeshAttachmentData = function(attachment, slot, premultipliedAlpha, f32buffer, ui32buffer, vertexDataOffset) {
            var vertices = attachment.updateWorldVertices(slot, premultipliedAlpha);
            var offset = vertexDataOffset;
            var nodeColor = this._displayedColor;
            var nodeR = nodeColor.r, nodeG = nodeColor.g, nodeB = nodeColor.b, nodeA = this._displayedOpacity;
            for (var i = 0, n = vertices.length; i < n; i += 8) {
                var r = vertices[i + 2] * nodeR, g = vertices[i + 3] * nodeG, b = vertices[i + 4] * nodeB, a = vertices[i + 5] * nodeA;
                var color = a << 24 | b << 16 | g << 8 | r;
                f32buffer[offset] = vertices[i];
                f32buffer[offset + 1] = vertices[i + 1];
                f32buffer[offset + 2] = this._node.vertexZ;
                ui32buffer[offset + 3] = color;
                f32buffer[offset + 4] = vertices[i + 6];
                f32buffer[offset + 5] = vertices[i + 7];
                offset += 6;
            }
        };
    }), {} ],
    306: [ (function(require, module, exports) {
        var DefaultSkinsEnum = cc.Enum({
            default: -1
        });
        var DefaultAnimsEnum = cc.Enum({
            "<None>": 0
        });
        function setEnumAttr(obj, propName, enumDef) {
            cc.Class.attr(obj, propName, {
                type: "Enum",
                enumList: cc.Enum.getList(enumDef)
            });
        }
        sp.Skeleton = cc.Class({
            name: "sp.Skeleton",
            extends: cc._RendererUnderSG,
            editor: false,
            properties: {
                _startListener: {
                    default: null,
                    serializable: false
                },
                _endListener: {
                    default: null,
                    serializable: false
                },
                _completeListener: {
                    default: null,
                    serializable: false
                },
                _eventListener: {
                    default: null,
                    serializable: false
                },
                _disposeListener: {
                    default: null,
                    serializable: false
                },
                _interruptListener: {
                    default: null,
                    serializable: false
                },
                _paused: false,
                paused: {
                    get: function() {
                        return this._paused;
                    },
                    set: function(value) {
                        this._paused = value;
                        if (!this._sgNode) {
                            return;
                        }
                        value ? this._sgNode.pause() : this._sgNode.resume();
                    },
                    visible: false
                },
                skeletonData: {
                    default: null,
                    type: sp.SkeletonData,
                    notify: function() {
                        this.defaultSkin = "";
                        this.defaultAnimation = "";
                        this._refresh();
                    },
                    tooltip: "i18n:COMPONENT.skeleton.skeleton_data"
                },
                defaultSkin: {
                    default: "",
                    visible: false
                },
                defaultAnimation: {
                    default: "",
                    visible: false
                },
                animation: {
                    get: function() {
                        var entry = this.getCurrent(0);
                        return entry && entry.animation.name || "";
                    },
                    set: function(value) {
                        this.defaultAnimation = value;
                        if (value) {
                            this.setAnimation(0, value, this.loop);
                        } else {
                            this.clearTrack(0);
                            this.setToSetupPose();
                        }
                    },
                    visible: false
                },
                _defaultSkinIndex: {
                    get: function() {
                        if (this.skeletonData && this.defaultSkin) {
                            var skinsEnum = this.skeletonData.getSkinsEnum();
                            if (skinsEnum) {
                                var skinIndex = skinsEnum[this.defaultSkin];
                                if (void 0 !== skinIndex) {
                                    return skinIndex;
                                }
                            }
                        }
                        return 0;
                    },
                    set: function(value) {
                        var skinsEnum;
                        this.skeletonData && (skinsEnum = this.skeletonData.getSkinsEnum());
                        if (!skinsEnum) {
                            return cc.errorID("", this.name);
                        }
                        var skinName = skinsEnum[value];
                        void 0 !== skinName ? this.defaultSkin = skinName : cc.errorID(7501, this.name);
                    },
                    type: DefaultSkinsEnum,
                    visible: true,
                    displayName: "Default Skin",
                    tooltip: "i18n:COMPONENT.skeleton.default_skin"
                },
                _animationIndex: {
                    get: function() {
                        var animationName = this.animation;
                        if (this.skeletonData && animationName) {
                            var animsEnum = this.skeletonData.getAnimsEnum();
                            if (animsEnum) {
                                var animIndex = animsEnum[animationName];
                                if (void 0 !== animIndex) {
                                    return animIndex;
                                }
                            }
                        }
                        return 0;
                    },
                    set: function(value) {
                        if (0 === value) {
                            this.animation = "";
                            return;
                        }
                        var animsEnum;
                        this.skeletonData && (animsEnum = this.skeletonData.getAnimsEnum());
                        if (!animsEnum) {
                            return cc.errorID(7502, this.name);
                        }
                        var animName = animsEnum[value];
                        void 0 !== animName ? this.animation = animName : cc.errorID(7503, this.name);
                    },
                    type: DefaultAnimsEnum,
                    visible: true,
                    displayName: "Animation",
                    tooltip: "i18n:COMPONENT.skeleton.animation"
                },
                loop: {
                    default: true,
                    tooltip: "i18n:COMPONENT.skeleton.loop"
                },
                _premultipliedAlpha: true,
                premultipliedAlpha: {
                    get: function() {
                        return this._premultipliedAlpha;
                    },
                    set: function(value) {
                        this._premultipliedAlpha = value;
                        this._sgNode && this._sgNode.setPremultipliedAlpha(value);
                    },
                    tooltip: "i18n:COMPONENT.skeleton.premultipliedAlpha"
                },
                timeScale: {
                    default: 1,
                    notify: function() {
                        this._sgNode && this._sgNode.setTimeScale(this.timeScale);
                    },
                    tooltip: "i18n:COMPONENT.skeleton.time_scale"
                },
                debugSlots: {
                    default: false,
                    notify: function() {
                        this._sgNode && this._sgNode.setDebugSlotsEnabled(this.debugSlots);
                    },
                    editorOnly: true,
                    tooltip: "i18n:COMPONENT.skeleton.debug_slots"
                },
                debugBones: {
                    default: false,
                    notify: function() {
                        this._sgNode && this._sgNode.setDebugBonesEnabled(this.debugBones);
                    },
                    editorOnly: true,
                    tooltip: "i18n:COMPONENT.skeleton.debug_bones"
                }
            },
            __preload: function() {
                var Flags = cc.Object.Flags;
                this._objFlags &= Flags.PersistentMask;
                this._objFlags |= Flags.IsAnchorLocked | Flags.IsSizeLocked;
                this.node.setContentSize(0, 0);
                this._refresh();
            },
            _createSgNode: function() {
                if (this.skeletonData) {
                    var uuid;
                    var jsonFile;
                    var atlasFile;
                    var data = this.skeletonData.getRuntimeData();
                    if (data) {
                        try {
                            return new sp._SGSkeletonAnimation(data, null, this.skeletonData.scale);
                        } catch (e) {
                            cc._throw(e);
                        }
                    }
                }
                return null;
            },
            _initSgNode: function() {
                var sgNode = this._sgNode;
                sgNode.setTimeScale(this.timeScale);
                var self = this;
                sgNode.onEnter = function() {
                    _ccsg.Node.prototype.onEnter.call(this);
                    self._paused && this.pause();
                };
                this._startListener && this.setStartListener(this._startListener);
                this._endListener && this.setEndListener(this._endListener);
                this._completeListener && this.setCompleteListener(this._completeListener);
                this._eventListener && this.setEventListener(this._eventListener);
                this._interruptListener && this.setInterruptListener(this._interruptListener);
                this._disposeListener && this.setDisposeListener(this._disposeListener);
                if (this.defaultSkin) {
                    try {
                        sgNode.setSkin(this.defaultSkin);
                    } catch (e) {
                        cc._throw(e);
                    }
                }
                sgNode.setPremultipliedAlpha(this._premultipliedAlpha);
                this.animation = this.defaultAnimation;
            },
            _getLocalBounds: false,
            updateWorldTransform: function() {
                this._sgNode && this._sgNode.updateWorldTransform();
            },
            setToSetupPose: function() {
                this._sgNode && this._sgNode.setToSetupPose();
            },
            setBonesToSetupPose: function() {
                this._sgNode && this._sgNode.setBonesToSetupPose();
            },
            setSlotsToSetupPose: function() {
                this._sgNode && this._sgNode.setSlotsToSetupPose();
            },
            findBone: function(boneName) {
                if (this._sgNode) {
                    return this._sgNode.findBone(boneName);
                }
                return null;
            },
            findSlot: function(slotName) {
                if (this._sgNode) {
                    return this._sgNode.findSlot(slotName);
                }
                return null;
            },
            setSkin: function(skinName) {
                if (this._sgNode) {
                    return this._sgNode.setSkin(skinName);
                }
                return null;
            },
            getAttachment: function(slotName, attachmentName) {
                if (this._sgNode) {
                    return this._sgNode.getAttachment(slotName, attachmentName);
                }
                return null;
            },
            setAttachment: function(slotName, attachmentName) {
                this._sgNode && this._sgNode.setAttachment(slotName, attachmentName);
            },
            setSkeletonData: function(skeletonData, ownsSkeletonData) {
                this._sgNode && this._sgNode.setSkeletonData(skeletonData, ownsSkeletonData);
            },
            setAnimationStateData: function(stateData) {
                if (this._sgNode) {
                    return this._sgNode.setAnimationStateData(stateData);
                }
            },
            setMix: function(fromAnimation, toAnimation, duration) {
                this._sgNode && this._sgNode.setMix(fromAnimation, toAnimation, duration);
            },
            setAnimationListener: function(target, callback) {
                this._sgNode && this._sgNode.setAnimationListener(target, callback);
            },
            setAnimation: function(trackIndex, name, loop) {
                if (this._sgNode) {
                    var res = this._sgNode.setAnimation(trackIndex, name, loop);
                    return res;
                }
                return null;
            },
            _sample: function() {
                this._sgNode && this._sgNode.update(0);
            },
            addAnimation: function(trackIndex, name, loop, delay) {
                if (this._sgNode) {
                    return this._sgNode.addAnimation(trackIndex, name, loop, delay);
                }
                return null;
            },
            findAnimation: function(name) {
                if (this._sgNode) {
                    return this._sgNode.findAnimation(name);
                }
                return null;
            },
            getCurrent: function(trackIndex) {
                if (this._sgNode) {
                    return this._sgNode.getCurrent(trackIndex);
                }
                return null;
            },
            clearTracks: function() {
                this._sgNode && this._sgNode.clearTracks();
            },
            clearTrack: function(trackIndex) {
                this._sgNode && this._sgNode.clearTrack(trackIndex);
            },
            _updateAnimEnum: false,
            _updateSkinEnum: false,
            setStartListener: function(listener) {
                this._startListener = listener;
                this._sgNode && this._sgNode.setStartListener(listener);
            },
            setInterruptListener: function(listener) {
                this._interruptListener = listener;
                this._sgNode && this._sgNode.setInterruptListener(listener);
            },
            setEndListener: function(listener) {
                this._endListener = listener;
                this._sgNode && this._sgNode.setEndListener(listener);
            },
            setDisposeListener: function(listener) {
                this._disposeListener = listener;
                this._sgNode && this._sgNode.setDisposeListener(listener);
            },
            setCompleteListener: function(listener) {
                this._completeListener = listener;
                this._sgNode && this._sgNode.setCompleteListener(listener);
            },
            setEventListener: function(listener) {
                this._eventListener = listener;
                this._sgNode && this._sgNode.setEventListener(listener);
            },
            setTrackStartListener: function(entry, listener) {
                this._sgNode && this._sgNode.setTrackStartListener(entry, listener);
            },
            setTrackInterruptListener: function(entry, listener) {
                this._sgNode && this._sgNode.setTrackInterruptListener(entry, listener);
            },
            setTrackEndListener: function(entry, listener) {
                this._sgNode && this._sgNode.setTrackEndListener(entry, listener);
            },
            setTrackDisposeListener: function(entry, listener) {
                this._sgNode && this._sgNode.setTrackDisposeListener(entry, listener);
            },
            setTrackCompleteListener: function(entry, listener) {
                this._sgNode && this._sgNode.setTrackCompleteListener(entry, listener);
            },
            setTrackEventListener: function(entry, listener) {
                this._sgNode && this._sgNode.setTrackEventListener(entry, listener);
            },
            getState: function() {
                if (this._sgNode) {
                    return this._sgNode.getState();
                }
            },
            _refresh: function() {
                var self = this;
                if (self._sgNode) {
                    self.node._sizeProvider === self._sgNode && (self.node._sizeProvider = null);
                    self._removeSgNode();
                    self._sgNode = null;
                }
                var sgNode = self._sgNode = self._createSgNode();
                if (sgNode) {
                    self.enabledInHierarchy || sgNode.setVisible(false);
                    sgNode.setContentSize(0, 0);
                    self._initSgNode();
                    self._appendSgNode(sgNode);
                    self._registSizeProvider();
                }
            }
        });
    }), {} ],
    307: [ (function(require, module, exports) {
        var TextureLoader = cc.Class({
            ctor: function() {
                this.asset = arguments[0];
            },
            getTexture: function(line) {
                var urls = this.asset.textures;
                for (var i = 0; i < urls.length; i++) {
                    var url = urls[i];
                    if (url.endsWith(line)) {
                        var texture = cc.textureCache.addImage(url);
                        var tex = new sp.SkeletonTexture({
                            width: texture.getPixelWidth(),
                            height: texture.getPixelHeight()
                        });
                        tex.setRealTexture(texture);
                        return tex;
                    }
                }
                return null;
            },
            load: function(line) {
                var texture = this.getTexture(line);
                if (texture) {
                    return texture;
                }
                cc.errorID(7506, line);
                return null;
            },
            unload: function(obj) {}
        });
        var SkeletonData = cc.Class({
            name: "sp.SkeletonData",
            extends: cc.Asset,
            ctor: function() {
                this.reset();
            },
            properties: {
                _skeletonJson: null,
                skeletonJson: {
                    get: function() {
                        return this._skeletonJson;
                    },
                    set: function(value) {
                        this._skeletonJson = value;
                        this.reset();
                    }
                },
                _atlasText: "",
                atlasText: {
                    get: function() {
                        return this._atlasText;
                    },
                    set: function(value) {
                        this._atlasText = value;
                        this.reset();
                    }
                },
                atlasUrl: {
                    default: "",
                    url: cc.RawAsset
                },
                textures: {
                    default: [],
                    url: [ cc.Texture2D ]
                },
                scale: 1
            },
            statics: {
                preventDeferredLoadDependents: true
            },
            createNode: false,
            reset: function() {
                this._skeletonCache = null;
                this._atlasCache = null;
            },
            getRuntimeData: function(quiet) {
                if (this._skeletonCache) {
                    return this._skeletonCache;
                }
                if (!(this.textures && this.textures.length > 0)) {
                    quiet || cc.errorID(7507, this.name);
                    return null;
                }
                var atlas = this._getAtlas(quiet);
                if (!atlas) {
                    return null;
                }
                var attachmentLoader = new sp.spine.AtlasAttachmentLoader(atlas);
                var jsonReader = new sp.spine.SkeletonJson(attachmentLoader);
                jsonReader.scale = this.scale;
                var json = this.skeletonJson;
                this._skeletonCache = jsonReader.readSkeletonData(json);
                atlas.dispose(jsonReader);
                return this._skeletonCache;
            },
            getSkinsEnum: false,
            getAnimsEnum: false,
            _getAtlas: function(quiet) {
                if (this._atlasCache) {
                    return this._atlasCache;
                }
                if (!this.atlasText) {
                    quiet || cc.errorID(7508, this.name);
                    return null;
                }
                var loader = new TextureLoader(this);
                return this._atlasCache = new sp.spine.TextureAtlas(this.atlasText, loader.load.bind(loader));
            }
        });
        sp.SkeletonData = module.exports = SkeletonData;
    }), {} ],
    308: [ (function(require, module, exports) {
        sp = {};
        sp.VERTEX_INDEX = {
            X1: 0,
            Y1: 1,
            X2: 2,
            Y2: 3,
            X3: 4,
            Y3: 5,
            X4: 6,
            Y4: 7
        };
        sp.ATTACHMENT_TYPE = {
            REGION: 0,
            BOUNDING_BOX: 1,
            MESH: 2,
            SKINNED_MESH: 3
        };
        sp.AnimationEventType = cc.Enum({
            START: 0,
            INTERRUPT: 1,
            END: 2,
            DISPOSE: 3,
            COMPLETE: 4,
            EVENT: 5
        });
        sp.spine = require("./lib/spine");
        require("./SGSkeletonTexture");
        require("./SGSkeleton");
        require("./SGSkeletonCanvasRenderCmd");
        require("./SGSkeletonWebGLRenderCmd");
        require("./SGSkeletonAnimation");
        require("./SkeletonData");
        require("./Skeleton");
    }), {
        "./SGSkeleton": 301,
        "./SGSkeletonAnimation": 302,
        "./SGSkeletonCanvasRenderCmd": 303,
        "./SGSkeletonTexture": 304,
        "./SGSkeletonWebGLRenderCmd": 305,
        "./Skeleton": 306,
        "./SkeletonData": 307,
        "./lib/spine": 309
    } ],
    309: [ (function(require, module, exports) {
        var __extends = this && this.__extends || function(d, b) {
            for (var p in b) {
                b.hasOwnProperty(p) && (d[p] = b[p]);
            }
            function __() {
                this.constructor = d;
            }
            d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        var spine;
        (function(spine) {
            var Animation = (function() {
                function Animation(name, timelines, duration) {
                    if (null == name) {
                        throw new Error("name cannot be null.");
                    }
                    if (null == timelines) {
                        throw new Error("timelines cannot be null.");
                    }
                    this.name = name;
                    this.timelines = timelines;
                    this.duration = duration;
                }
                Animation.prototype.apply = function(skeleton, lastTime, time, loop, events, alpha, setupPose, mixingOut) {
                    if (null == skeleton) {
                        throw new Error("skeleton cannot be null.");
                    }
                    if (loop && 0 != this.duration) {
                        time %= this.duration;
                        lastTime > 0 && (lastTime %= this.duration);
                    }
                    var timelines = this.timelines;
                    for (var i = 0, n = timelines.length; i < n; i++) {
                        timelines[i].apply(skeleton, lastTime, time, events, alpha, setupPose, mixingOut);
                    }
                };
                Animation.binarySearch = function(values, target, step) {
                    void 0 === step && (step = 1);
                    var low = 0;
                    var high = values.length / step - 2;
                    if (0 == high) {
                        return step;
                    }
                    var current = high >>> 1;
                    while (true) {
                        values[(current + 1) * step] <= target ? low = current + 1 : high = current;
                        if (low == high) {
                            return (low + 1) * step;
                        }
                        current = low + high >>> 1;
                    }
                };
                Animation.linearSearch = function(values, target, step) {
                    for (var i = 0, last = values.length - step; i <= last; i += step) {
                        if (values[i] > target) {
                            return i;
                        }
                    }
                    return -1;
                };
                return Animation;
            })();
            spine.Animation = Animation;
            (function(TimelineType) {
                TimelineType[TimelineType["rotate"] = 0] = "rotate";
                TimelineType[TimelineType["translate"] = 1] = "translate";
                TimelineType[TimelineType["scale"] = 2] = "scale";
                TimelineType[TimelineType["shear"] = 3] = "shear";
                TimelineType[TimelineType["attachment"] = 4] = "attachment";
                TimelineType[TimelineType["color"] = 5] = "color";
                TimelineType[TimelineType["deform"] = 6] = "deform";
                TimelineType[TimelineType["event"] = 7] = "event";
                TimelineType[TimelineType["drawOrder"] = 8] = "drawOrder";
                TimelineType[TimelineType["ikConstraint"] = 9] = "ikConstraint";
                TimelineType[TimelineType["transformConstraint"] = 10] = "transformConstraint";
                TimelineType[TimelineType["pathConstraintPosition"] = 11] = "pathConstraintPosition";
                TimelineType[TimelineType["pathConstraintSpacing"] = 12] = "pathConstraintSpacing";
                TimelineType[TimelineType["pathConstraintMix"] = 13] = "pathConstraintMix";
            })(spine.TimelineType || (spine.TimelineType = {}));
            var TimelineType = spine.TimelineType;
            var CurveTimeline = (function() {
                function CurveTimeline(frameCount) {
                    if (frameCount <= 0) {
                        throw new Error("frameCount must be > 0: " + frameCount);
                    }
                    this.curves = spine.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);
                }
                CurveTimeline.prototype.getFrameCount = function() {
                    return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;
                };
                CurveTimeline.prototype.setLinear = function(frameIndex) {
                    this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;
                };
                CurveTimeline.prototype.setStepped = function(frameIndex) {
                    this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;
                };
                CurveTimeline.prototype.getCurveType = function(frameIndex) {
                    var index = frameIndex * CurveTimeline.BEZIER_SIZE;
                    if (index == this.curves.length) {
                        return CurveTimeline.LINEAR;
                    }
                    var type = this.curves[index];
                    if (type == CurveTimeline.LINEAR) {
                        return CurveTimeline.LINEAR;
                    }
                    if (type == CurveTimeline.STEPPED) {
                        return CurveTimeline.STEPPED;
                    }
                    return CurveTimeline.BEZIER;
                };
                CurveTimeline.prototype.setCurve = function(frameIndex, cx1, cy1, cx2, cy2) {
                    var tmpx = .03 * (2 * -cx1 + cx2), tmpy = .03 * (2 * -cy1 + cy2);
                    var dddfx = .006 * (3 * (cx1 - cx2) + 1), dddfy = .006 * (3 * (cy1 - cy2) + 1);
                    var ddfx = 2 * tmpx + dddfx, ddfy = 2 * tmpy + dddfy;
                    var dfx = .3 * cx1 + tmpx + .16666667 * dddfx, dfy = .3 * cy1 + tmpy + .16666667 * dddfy;
                    var i = frameIndex * CurveTimeline.BEZIER_SIZE;
                    var curves = this.curves;
                    curves[i++] = CurveTimeline.BEZIER;
                    var x = dfx, y = dfy;
                    for (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
                        curves[i] = x;
                        curves[i + 1] = y;
                        dfx += ddfx;
                        dfy += ddfy;
                        ddfx += dddfx;
                        ddfy += dddfy;
                        x += dfx;
                        y += dfy;
                    }
                };
                CurveTimeline.prototype.getCurvePercent = function(frameIndex, percent) {
                    percent = spine.MathUtils.clamp(percent, 0, 1);
                    var curves = this.curves;
                    var i = frameIndex * CurveTimeline.BEZIER_SIZE;
                    var type = curves[i];
                    if (type == CurveTimeline.LINEAR) {
                        return percent;
                    }
                    if (type == CurveTimeline.STEPPED) {
                        return 0;
                    }
                    i++;
                    var x = 0;
                    for (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {
                        x = curves[i];
                        if (x >= percent) {
                            var prevX = void 0, prevY = void 0;
                            if (i == start) {
                                prevX = 0;
                                prevY = 0;
                            } else {
                                prevX = curves[i - 2];
                                prevY = curves[i - 1];
                            }
                            return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);
                        }
                    }
                    var y = curves[i - 1];
                    return y + (1 - y) * (percent - x) / (1 - x);
                };
                CurveTimeline.LINEAR = 0;
                CurveTimeline.STEPPED = 1;
                CurveTimeline.BEZIER = 2;
                CurveTimeline.BEZIER_SIZE = 19;
                return CurveTimeline;
            })();
            spine.CurveTimeline = CurveTimeline;
            var RotateTimeline = (function(_super) {
                __extends(RotateTimeline, _super);
                function RotateTimeline(frameCount) {
                    _super.call(this, frameCount);
                    this.frames = spine.Utils.newFloatArray(frameCount << 1);
                }
                RotateTimeline.prototype.getPropertyId = function() {
                    return (TimelineType.rotate << 24) + this.boneIndex;
                };
                RotateTimeline.prototype.setFrame = function(frameIndex, time, degrees) {
                    frameIndex <<= 1;
                    this.frames[frameIndex] = time;
                    this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;
                };
                RotateTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, setupPose, mixingOut) {
                    var frames = this.frames;
                    var bone = skeleton.bones[this.boneIndex];
                    if (time < frames[0]) {
                        setupPose && (bone.rotation = bone.data.rotation);
                        return;
                    }
                    if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {
                        if (setupPose) {
                            bone.rotation = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] * alpha;
                        } else {
                            var r_1 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;
                            r_1 -= 360 * (16384 - (16384.499999999996 - r_1 / 360 | 0));
                            bone.rotation += r_1 * alpha;
                        }
                        return;
                    }
                    var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);
                    var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));
                    var r = frames[frame + RotateTimeline.ROTATION] - prevRotation;
                    r -= 360 * (16384 - (16384.499999999996 - r / 360 | 0));
                    r = prevRotation + r * percent;
                    if (setupPose) {
                        r -= 360 * (16384 - (16384.499999999996 - r / 360 | 0));
                        bone.rotation = bone.data.rotation + r * alpha;
                    } else {
                        r = bone.data.rotation + r - bone.rotation;
                        r -= 360 * (16384 - (16384.499999999996 - r / 360 | 0));
                        bone.rotation += r * alpha;
                    }
                };
                RotateTimeline.ENTRIES = 2;
                RotateTimeline.PREV_TIME = -2;
                RotateTimeline.PREV_ROTATION = -1;
                RotateTimeline.ROTATION = 1;
                return RotateTimeline;
            })(CurveTimeline);
            spine.RotateTimeline = RotateTimeline;
            var TranslateTimeline = (function(_super) {
                __extends(TranslateTimeline, _super);
                function TranslateTimeline(frameCount) {
                    _super.call(this, frameCount);
                    this.frames = spine.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);
                }
                TranslateTimeline.prototype.getPropertyId = function() {
                    return (TimelineType.translate << 24) + this.boneIndex;
                };
                TranslateTimeline.prototype.setFrame = function(frameIndex, time, x, y) {
                    frameIndex *= TranslateTimeline.ENTRIES;
                    this.frames[frameIndex] = time;
                    this.frames[frameIndex + TranslateTimeline.X] = x;
                    this.frames[frameIndex + TranslateTimeline.Y] = y;
                };
                TranslateTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, setupPose, mixingOut) {
                    var frames = this.frames;
                    var bone = skeleton.bones[this.boneIndex];
                    if (time < frames[0]) {
                        if (setupPose) {
                            bone.x = bone.data.x;
                            bone.y = bone.data.y;
                        }
                        return;
                    }
                    var x = 0, y = 0;
                    if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {
                        x = frames[frames.length + TranslateTimeline.PREV_X];
                        y = frames[frames.length + TranslateTimeline.PREV_Y];
                    } else {
                        var frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);
                        x = frames[frame + TranslateTimeline.PREV_X];
                        y = frames[frame + TranslateTimeline.PREV_Y];
                        var frameTime = frames[frame];
                        var percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));
                        x += (frames[frame + TranslateTimeline.X] - x) * percent;
                        y += (frames[frame + TranslateTimeline.Y] - y) * percent;
                    }
                    if (setupPose) {
                        bone.x = bone.data.x + x * alpha;
                        bone.y = bone.data.y + y * alpha;
                    } else {
                        bone.x += (bone.data.x + x - bone.x) * alpha;
                        bone.y += (bone.data.y + y - bone.y) * alpha;
                    }
                };
                TranslateTimeline.ENTRIES = 3;
                TranslateTimeline.PREV_TIME = -3;
                TranslateTimeline.PREV_X = -2;
                TranslateTimeline.PREV_Y = -1;
                TranslateTimeline.X = 1;
                TranslateTimeline.Y = 2;
                return TranslateTimeline;
            })(CurveTimeline);
            spine.TranslateTimeline = TranslateTimeline;
            var ScaleTimeline = (function(_super) {
                __extends(ScaleTimeline, _super);
                function ScaleTimeline(frameCount) {
                    _super.call(this, frameCount);
                }
                ScaleTimeline.prototype.getPropertyId = function() {
                    return (TimelineType.scale << 24) + this.boneIndex;
                };
                ScaleTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, setupPose, mixingOut) {
                    var frames = this.frames;
                    var bone = skeleton.bones[this.boneIndex];
                    if (time < frames[0]) {
                        if (setupPose) {
                            bone.scaleX = bone.data.scaleX;
                            bone.scaleY = bone.data.scaleY;
                        }
                        return;
                    }
                    var x = 0, y = 0;
                    if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {
                        x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;
                        y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;
                    } else {
                        var frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);
                        x = frames[frame + ScaleTimeline.PREV_X];
                        y = frames[frame + ScaleTimeline.PREV_Y];
                        var frameTime = frames[frame];
                        var percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));
                        x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;
                        y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;
                    }
                    if (1 == alpha) {
                        bone.scaleX = x;
                        bone.scaleY = y;
                    } else {
                        var bx = 0, by = 0;
                        if (setupPose) {
                            bx = bone.data.scaleX;
                            by = bone.data.scaleY;
                        } else {
                            bx = bone.scaleX;
                            by = bone.scaleY;
                        }
                        if (mixingOut) {
                            x = Math.abs(x) * spine.MathUtils.signum(bx);
                            y = Math.abs(y) * spine.MathUtils.signum(by);
                        } else {
                            bx = Math.abs(bx) * spine.MathUtils.signum(x);
                            by = Math.abs(by) * spine.MathUtils.signum(y);
                        }
                        bone.scaleX = bx + (x - bx) * alpha;
                        bone.scaleY = by + (y - by) * alpha;
                    }
                };
                return ScaleTimeline;
            })(TranslateTimeline);
            spine.ScaleTimeline = ScaleTimeline;
            var ShearTimeline = (function(_super) {
                __extends(ShearTimeline, _super);
                function ShearTimeline(frameCount) {
                    _super.call(this, frameCount);
                }
                ShearTimeline.prototype.getPropertyId = function() {
                    return (TimelineType.shear << 24) + this.boneIndex;
                };
                ShearTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, setupPose, mixingOut) {
                    var frames = this.frames;
                    var bone = skeleton.bones[this.boneIndex];
                    if (time < frames[0]) {
                        if (setupPose) {
                            bone.shearX = bone.data.shearX;
                            bone.shearY = bone.data.shearY;
                        }
                        return;
                    }
                    var x = 0, y = 0;
                    if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {
                        x = frames[frames.length + ShearTimeline.PREV_X];
                        y = frames[frames.length + ShearTimeline.PREV_Y];
                    } else {
                        var frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);
                        x = frames[frame + ShearTimeline.PREV_X];
                        y = frames[frame + ShearTimeline.PREV_Y];
                        var frameTime = frames[frame];
                        var percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));
                        x += (frames[frame + ShearTimeline.X] - x) * percent;
                        y += (frames[frame + ShearTimeline.Y] - y) * percent;
                    }
                    if (setupPose) {
                        bone.shearX = bone.data.shearX + x * alpha;
                        bone.shearY = bone.data.shearY + y * alpha;
                    } else {
                        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;
                        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;
                    }
                };
                return ShearTimeline;
            })(TranslateTimeline);
            spine.ShearTimeline = ShearTimeline;
            var ColorTimeline = (function(_super) {
                __extends(ColorTimeline, _super);
                function ColorTimeline(frameCount) {
                    _super.call(this, frameCount);
                    this.frames = spine.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);
                }
                ColorTimeline.prototype.getPropertyId = function() {
                    return (TimelineType.color << 24) + this.slotIndex;
                };
                ColorTimeline.prototype.setFrame = function(frameIndex, time, r, g, b, a) {
                    frameIndex *= ColorTimeline.ENTRIES;
                    this.frames[frameIndex] = time;
                    this.frames[frameIndex + ColorTimeline.R] = r;
                    this.frames[frameIndex + ColorTimeline.G] = g;
                    this.frames[frameIndex + ColorTimeline.B] = b;
                    this.frames[frameIndex + ColorTimeline.A] = a;
                };
                ColorTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, setupPose, mixingOut) {
                    var slot = skeleton.slots[this.slotIndex];
                    var frames = this.frames;
                    if (time < frames[0]) {
                        setupPose && slot.color.setFromColor(slot.data.color);
                        return;
                    }
                    var r = 0, g = 0, b = 0, a = 0;
                    if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {
                        var i = frames.length;
                        r = frames[i + ColorTimeline.PREV_R];
                        g = frames[i + ColorTimeline.PREV_G];
                        b = frames[i + ColorTimeline.PREV_B];
                        a = frames[i + ColorTimeline.PREV_A];
                    } else {
                        var frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);
                        r = frames[frame + ColorTimeline.PREV_R];
                        g = frames[frame + ColorTimeline.PREV_G];
                        b = frames[frame + ColorTimeline.PREV_B];
                        a = frames[frame + ColorTimeline.PREV_A];
                        var frameTime = frames[frame];
                        var percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));
                        r += (frames[frame + ColorTimeline.R] - r) * percent;
                        g += (frames[frame + ColorTimeline.G] - g) * percent;
                        b += (frames[frame + ColorTimeline.B] - b) * percent;
                        a += (frames[frame + ColorTimeline.A] - a) * percent;
                    }
                    if (1 == alpha) {
                        slot.color.set(r, g, b, a);
                    } else {
                        var color = slot.color;
                        setupPose && color.setFromColor(slot.data.color);
                        color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);
                    }
                };
                ColorTimeline.ENTRIES = 5;
                ColorTimeline.PREV_TIME = -5;
                ColorTimeline.PREV_R = -4;
                ColorTimeline.PREV_G = -3;
                ColorTimeline.PREV_B = -2;
                ColorTimeline.PREV_A = -1;
                ColorTimeline.R = 1;
                ColorTimeline.G = 2;
                ColorTimeline.B = 3;
                ColorTimeline.A = 4;
                return ColorTimeline;
            })(CurveTimeline);
            spine.ColorTimeline = ColorTimeline;
            var AttachmentTimeline = (function() {
                function AttachmentTimeline(frameCount) {
                    this.frames = spine.Utils.newFloatArray(frameCount);
                    this.attachmentNames = new Array(frameCount);
                }
                AttachmentTimeline.prototype.getPropertyId = function() {
                    return (TimelineType.attachment << 24) + this.slotIndex;
                };
                AttachmentTimeline.prototype.getFrameCount = function() {
                    return this.frames.length;
                };
                AttachmentTimeline.prototype.setFrame = function(frameIndex, time, attachmentName) {
                    this.frames[frameIndex] = time;
                    this.attachmentNames[frameIndex] = attachmentName;
                };
                AttachmentTimeline.prototype.apply = function(skeleton, lastTime, time, events, alpha, setupPose, mixingOut) {
                    var slot = skeleton.slots[this.slotIndex];
                    if (mixingOut && setupPose) {
                        var attachmentName_1 = slot.data.attachmentName;
                        slot.setAttachment(null == attachmentName_1 ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));
                        return;
                    }
                    var frames = this.frames;
                    if (time < frames[0]) {
                        if (setupPose) {
                            var attachmentName_2 = slot.data.attachmentName;
                            slot.setAttachment(null == attachmentName_2 ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));
                        }
                        return;
                    }
                    var frameIndex = 0;
                    frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : Animation.binarySearch(frames, time, 1) - 1;
                    var attachmentName = this.attachmentNames[frameIndex];
                    skeleton.slots[this.slotIndex].setAttachment(null == attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));
                };
                return AttachmentTimeline;
            })();
            spine.AttachmentTimeline = AttachmentTimeline;
            var DeformTimeline = (function(_super) {
                __extends(DeformTimeline, _super);
                function DeformTimeline(frameCount) {
                    _super.call(this, frameCount);
                    this.frames = spine.Utils.newFloatArray(frameCount);
                    this.frameVertices = new Array(frameCount);
                }
                DeformTimeline.prototype.getPropertyId = function() {
                    return (TimelineType.deform << 24) + this.slotIndex;
                };
                DeformTimeline.prototype.setFrame = function(frameIndex, time, vertices) {
                    this.frames[frameIndex] = time;
                    this.frameVertices[frameIndex] = vertices;
                };
                DeformTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
                    var slot = skeleton.slots[this.slotIndex];
                    var slotAttachment = slot.getAttachment();
                    if (!(slotAttachment instanceof spine.VertexAttachment) || !slotAttachment.applyDeform(this.attachment)) {
                        return;
                    }
                    var frames = this.frames;
                    var verticesArray = slot.attachmentVertices;
                    if (time < frames[0]) {
                        setupPose && spine.Utils.setArraySize(verticesArray, 0);
                        return;
                    }
                    var frameVertices = this.frameVertices;
                    var vertexCount = frameVertices[0].length;
                    verticesArray.length != vertexCount && (alpha = 1);
                    var vertices = spine.Utils.setArraySize(verticesArray, vertexCount);
                    if (time >= frames[frames.length - 1]) {
                        var lastVertices = frameVertices[frames.length - 1];
                        if (1 == alpha) {
                            spine.Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);
                        } else {
                            if (setupPose) {
                                var vertexAttachment = slotAttachment;
                                if (null == vertexAttachment.bones) {
                                    var setupVertices = vertexAttachment.vertices;
                                    for (var i = 0; i < vertexCount; i++) {
                                        var setup = setupVertices[i];
                                        vertices[i] = setup + (lastVertices[i] - setup) * alpha;
                                    }
                                } else {
                                    for (var i = 0; i < vertexCount; i++) {
                                        vertices[i] = lastVertices[i] * alpha;
                                    }
                                }
                            } else {
                                for (var i = 0; i < vertexCount; i++) {
                                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;
                                }
                            }
                        }
                        return;
                    }
                    var frame = Animation.binarySearch(frames, time);
                    var prevVertices = frameVertices[frame - 1];
                    var nextVertices = frameVertices[frame];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));
                    if (1 == alpha) {
                        for (var i = 0; i < vertexCount; i++) {
                            var prev = prevVertices[i];
                            vertices[i] = prev + (nextVertices[i] - prev) * percent;
                        }
                    } else {
                        if (setupPose) {
                            var vertexAttachment = slotAttachment;
                            if (null == vertexAttachment.bones) {
                                var setupVertices = vertexAttachment.vertices;
                                for (var i = 0; i < vertexCount; i++) {
                                    var prev = prevVertices[i], setup = setupVertices[i];
                                    vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;
                                }
                            } else {
                                for (var i = 0; i < vertexCount; i++) {
                                    var prev = prevVertices[i];
                                    vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;
                                }
                            }
                        } else {
                            for (var i = 0; i < vertexCount; i++) {
                                var prev = prevVertices[i];
                                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;
                            }
                        }
                    }
                };
                return DeformTimeline;
            })(CurveTimeline);
            spine.DeformTimeline = DeformTimeline;
            var EventTimeline = (function() {
                function EventTimeline(frameCount) {
                    this.frames = spine.Utils.newFloatArray(frameCount);
                    this.events = new Array(frameCount);
                }
                EventTimeline.prototype.getPropertyId = function() {
                    return TimelineType.event << 24;
                };
                EventTimeline.prototype.getFrameCount = function() {
                    return this.frames.length;
                };
                EventTimeline.prototype.setFrame = function(frameIndex, event) {
                    this.frames[frameIndex] = event.time;
                    this.events[frameIndex] = event;
                };
                EventTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
                    if (null == firedEvents) {
                        return;
                    }
                    var frames = this.frames;
                    var frameCount = this.frames.length;
                    if (lastTime > time) {
                        this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, setupPose, mixingOut);
                        lastTime = -1;
                    } else {
                        if (lastTime >= frames[frameCount - 1]) {
                            return;
                        }
                    }
                    if (time < frames[0]) {
                        return;
                    }
                    var frame = 0;
                    if (lastTime < frames[0]) {
                        frame = 0;
                    } else {
                        frame = Animation.binarySearch(frames, lastTime);
                        var frameTime = frames[frame];
                        while (frame > 0) {
                            if (frames[frame - 1] != frameTime) {
                                break;
                            }
                            frame--;
                        }
                    }
                    for (;frame < frameCount && time >= frames[frame]; frame++) {
                        firedEvents.push(this.events[frame]);
                    }
                };
                return EventTimeline;
            })();
            spine.EventTimeline = EventTimeline;
            var DrawOrderTimeline = (function() {
                function DrawOrderTimeline(frameCount) {
                    this.frames = spine.Utils.newFloatArray(frameCount);
                    this.drawOrders = new Array(frameCount);
                }
                DrawOrderTimeline.prototype.getPropertyId = function() {
                    return TimelineType.drawOrder << 24;
                };
                DrawOrderTimeline.prototype.getFrameCount = function() {
                    return this.frames.length;
                };
                DrawOrderTimeline.prototype.setFrame = function(frameIndex, time, drawOrder) {
                    this.frames[frameIndex] = time;
                    this.drawOrders[frameIndex] = drawOrder;
                };
                DrawOrderTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
                    var drawOrder = skeleton.drawOrder;
                    var slots = skeleton.slots;
                    if (mixingOut && setupPose) {
                        spine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
                        return;
                    }
                    var frames = this.frames;
                    if (time < frames[0]) {
                        setupPose && spine.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);
                        return;
                    }
                    var frame = 0;
                    frame = time >= frames[frames.length - 1] ? frames.length - 1 : Animation.binarySearch(frames, time) - 1;
                    var drawOrderToSetupIndex = this.drawOrders[frame];
                    if (null == drawOrderToSetupIndex) {
                        spine.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);
                    } else {
                        for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++) {
                            drawOrder[i] = slots[drawOrderToSetupIndex[i]];
                        }
                    }
                };
                return DrawOrderTimeline;
            })();
            spine.DrawOrderTimeline = DrawOrderTimeline;
            var IkConstraintTimeline = (function(_super) {
                __extends(IkConstraintTimeline, _super);
                function IkConstraintTimeline(frameCount) {
                    _super.call(this, frameCount);
                    this.frames = spine.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);
                }
                IkConstraintTimeline.prototype.getPropertyId = function() {
                    return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;
                };
                IkConstraintTimeline.prototype.setFrame = function(frameIndex, time, mix, bendDirection) {
                    frameIndex *= IkConstraintTimeline.ENTRIES;
                    this.frames[frameIndex] = time;
                    this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;
                    this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;
                };
                IkConstraintTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
                    var frames = this.frames;
                    var constraint = skeleton.ikConstraints[this.ikConstraintIndex];
                    if (time < frames[0]) {
                        if (setupPose) {
                            constraint.mix = constraint.data.mix;
                            constraint.bendDirection = constraint.data.bendDirection;
                        }
                        return;
                    }
                    if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {
                        if (setupPose) {
                            constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;
                            constraint.bendDirection = mixingOut ? constraint.data.bendDirection : frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];
                        } else {
                            constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;
                            mixingOut || (constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION]);
                        }
                        return;
                    }
                    var frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);
                    var mix = frames[frame + IkConstraintTimeline.PREV_MIX];
                    var frameTime = frames[frame];
                    var percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));
                    if (setupPose) {
                        constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;
                        constraint.bendDirection = mixingOut ? constraint.data.bendDirection : frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];
                    } else {
                        constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;
                        mixingOut || (constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION]);
                    }
                };
                IkConstraintTimeline.ENTRIES = 3;
                IkConstraintTimeline.PREV_TIME = -3;
                IkConstraintTimeline.PREV_MIX = -2;
                IkConstraintTimeline.PREV_BEND_DIRECTION = -1;
                IkConstraintTimeline.MIX = 1;
                IkConstraintTimeline.BEND_DIRECTION = 2;
                return IkConstraintTimeline;
            })(CurveTimeline);
            spine.IkConstraintTimeline = IkConstraintTimeline;
            var TransformConstraintTimeline = (function(_super) {
                __extends(TransformConstraintTimeline, _super);
                function TransformConstraintTimeline(frameCount) {
                    _super.call(this, frameCount);
                    this.frames = spine.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);
                }
                TransformConstraintTimeline.prototype.getPropertyId = function() {
                    return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;
                };
                TransformConstraintTimeline.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {
                    frameIndex *= TransformConstraintTimeline.ENTRIES;
                    this.frames[frameIndex] = time;
                    this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;
                    this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;
                    this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;
                    this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;
                };
                TransformConstraintTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
                    var frames = this.frames;
                    var constraint = skeleton.transformConstraints[this.transformConstraintIndex];
                    if (time < frames[0]) {
                        if (setupPose) {
                            var data = constraint.data;
                            constraint.rotateMix = data.rotateMix;
                            constraint.translateMix = data.rotateMix;
                            constraint.scaleMix = data.scaleMix;
                            constraint.shearMix = data.shearMix;
                        }
                        return;
                    }
                    var rotate = 0, translate = 0, scale = 0, shear = 0;
                    if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {
                        var i = frames.length;
                        rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];
                        translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];
                        scale = frames[i + TransformConstraintTimeline.PREV_SCALE];
                        shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];
                    } else {
                        var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);
                        rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];
                        translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];
                        scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];
                        shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];
                        var frameTime = frames[frame];
                        var percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));
                        rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;
                        translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;
                        scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;
                        shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;
                    }
                    if (setupPose) {
                        var data = constraint.data;
                        constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;
                        constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;
                        constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;
                        constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;
                    } else {
                        constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
                        constraint.translateMix += (translate - constraint.translateMix) * alpha;
                        constraint.scaleMix += (scale - constraint.scaleMix) * alpha;
                        constraint.shearMix += (shear - constraint.shearMix) * alpha;
                    }
                };
                TransformConstraintTimeline.ENTRIES = 5;
                TransformConstraintTimeline.PREV_TIME = -5;
                TransformConstraintTimeline.PREV_ROTATE = -4;
                TransformConstraintTimeline.PREV_TRANSLATE = -3;
                TransformConstraintTimeline.PREV_SCALE = -2;
                TransformConstraintTimeline.PREV_SHEAR = -1;
                TransformConstraintTimeline.ROTATE = 1;
                TransformConstraintTimeline.TRANSLATE = 2;
                TransformConstraintTimeline.SCALE = 3;
                TransformConstraintTimeline.SHEAR = 4;
                return TransformConstraintTimeline;
            })(CurveTimeline);
            spine.TransformConstraintTimeline = TransformConstraintTimeline;
            var PathConstraintPositionTimeline = (function(_super) {
                __extends(PathConstraintPositionTimeline, _super);
                function PathConstraintPositionTimeline(frameCount) {
                    _super.call(this, frameCount);
                    this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);
                }
                PathConstraintPositionTimeline.prototype.getPropertyId = function() {
                    return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;
                };
                PathConstraintPositionTimeline.prototype.setFrame = function(frameIndex, time, value) {
                    frameIndex *= PathConstraintPositionTimeline.ENTRIES;
                    this.frames[frameIndex] = time;
                    this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;
                };
                PathConstraintPositionTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
                    var frames = this.frames;
                    var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
                    if (time < frames[0]) {
                        setupPose && (constraint.position = constraint.data.position);
                        return;
                    }
                    var position = 0;
                    if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) {
                        position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];
                    } else {
                        var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);
                        position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];
                        var frameTime = frames[frame];
                        var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));
                        position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;
                    }
                    setupPose ? constraint.position = constraint.data.position + (position - constraint.data.position) * alpha : constraint.position += (position - constraint.position) * alpha;
                };
                PathConstraintPositionTimeline.ENTRIES = 2;
                PathConstraintPositionTimeline.PREV_TIME = -2;
                PathConstraintPositionTimeline.PREV_VALUE = -1;
                PathConstraintPositionTimeline.VALUE = 1;
                return PathConstraintPositionTimeline;
            })(CurveTimeline);
            spine.PathConstraintPositionTimeline = PathConstraintPositionTimeline;
            var PathConstraintSpacingTimeline = (function(_super) {
                __extends(PathConstraintSpacingTimeline, _super);
                function PathConstraintSpacingTimeline(frameCount) {
                    _super.call(this, frameCount);
                }
                PathConstraintSpacingTimeline.prototype.getPropertyId = function() {
                    return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;
                };
                PathConstraintSpacingTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
                    var frames = this.frames;
                    var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
                    if (time < frames[0]) {
                        setupPose && (constraint.spacing = constraint.data.spacing);
                        return;
                    }
                    var spacing = 0;
                    if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) {
                        spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];
                    } else {
                        var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);
                        spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];
                        var frameTime = frames[frame];
                        var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));
                        spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;
                    }
                    setupPose ? constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha : constraint.spacing += (spacing - constraint.spacing) * alpha;
                };
                return PathConstraintSpacingTimeline;
            })(PathConstraintPositionTimeline);
            spine.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;
            var PathConstraintMixTimeline = (function(_super) {
                __extends(PathConstraintMixTimeline, _super);
                function PathConstraintMixTimeline(frameCount) {
                    _super.call(this, frameCount);
                    this.frames = spine.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);
                }
                PathConstraintMixTimeline.prototype.getPropertyId = function() {
                    return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;
                };
                PathConstraintMixTimeline.prototype.setFrame = function(frameIndex, time, rotateMix, translateMix) {
                    frameIndex *= PathConstraintMixTimeline.ENTRIES;
                    this.frames[frameIndex] = time;
                    this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;
                    this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;
                };
                PathConstraintMixTimeline.prototype.apply = function(skeleton, lastTime, time, firedEvents, alpha, setupPose, mixingOut) {
                    var frames = this.frames;
                    var constraint = skeleton.pathConstraints[this.pathConstraintIndex];
                    if (time < frames[0]) {
                        if (setupPose) {
                            constraint.rotateMix = constraint.data.rotateMix;
                            constraint.translateMix = constraint.data.translateMix;
                        }
                        return;
                    }
                    var rotate = 0, translate = 0;
                    if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {
                        rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];
                        translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];
                    } else {
                        var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);
                        rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];
                        translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];
                        var frameTime = frames[frame];
                        var percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));
                        rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;
                        translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;
                    }
                    if (setupPose) {
                        constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;
                        constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;
                    } else {
                        constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;
                        constraint.translateMix += (translate - constraint.translateMix) * alpha;
                    }
                };
                PathConstraintMixTimeline.ENTRIES = 3;
                PathConstraintMixTimeline.PREV_TIME = -3;
                PathConstraintMixTimeline.PREV_ROTATE = -2;
                PathConstraintMixTimeline.PREV_TRANSLATE = -1;
                PathConstraintMixTimeline.ROTATE = 1;
                PathConstraintMixTimeline.TRANSLATE = 2;
                return PathConstraintMixTimeline;
            })(CurveTimeline);
            spine.PathConstraintMixTimeline = PathConstraintMixTimeline;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var AnimationState = (function() {
                function AnimationState(data) {
                    this.tracks = new Array();
                    this.events = new Array();
                    this.listeners = new Array();
                    this.queue = new EventQueue(this);
                    this.propertyIDs = new spine.IntSet();
                    this.animationsChanged = false;
                    this.timeScale = 1;
                    this.trackEntryPool = new spine.Pool(function() {
                        return new TrackEntry();
                    });
                    this.data = data;
                }
                AnimationState.prototype.update = function(delta) {
                    delta *= this.timeScale;
                    var tracks = this.tracks;
                    for (var i = 0, n = tracks.length; i < n; i++) {
                        var current = tracks[i];
                        if (null == current) {
                            continue;
                        }
                        current.animationLast = current.nextAnimationLast;
                        current.trackLast = current.nextTrackLast;
                        var currentDelta = delta * current.timeScale;
                        if (current.delay > 0) {
                            current.delay -= currentDelta;
                            if (current.delay > 0) {
                                continue;
                            }
                            currentDelta = -current.delay;
                            current.delay = 0;
                        }
                        var next = current.next;
                        if (null != next) {
                            var nextTime = current.trackLast - next.delay;
                            if (nextTime >= 0) {
                                next.delay = 0;
                                next.trackTime = nextTime + delta * next.timeScale;
                                current.trackTime += currentDelta;
                                this.setCurrent(i, next, true);
                                while (null != next.mixingFrom) {
                                    next.mixTime += currentDelta;
                                    next = next.mixingFrom;
                                }
                                continue;
                            }
                        } else {
                            if (current.trackLast >= current.trackEnd && null == current.mixingFrom) {
                                tracks[i] = null;
                                this.queue.end(current);
                                this.disposeNext(current);
                                continue;
                            }
                        }
                        this.updateMixingFrom(current, delta);
                        current.trackTime += currentDelta;
                    }
                    this.queue.drain();
                };
                AnimationState.prototype.updateMixingFrom = function(entry, delta) {
                    var from = entry.mixingFrom;
                    if (null == from) {
                        return;
                    }
                    this.updateMixingFrom(from, delta);
                    if (entry.mixTime >= entry.mixDuration && null != from.mixingFrom && entry.mixTime > 0) {
                        entry.mixingFrom = null;
                        this.queue.end(from);
                        return;
                    }
                    from.animationLast = from.nextAnimationLast;
                    from.trackLast = from.nextTrackLast;
                    from.trackTime += delta * from.timeScale;
                    entry.mixTime += delta * from.timeScale;
                };
                AnimationState.prototype.apply = function(skeleton) {
                    if (null == skeleton) {
                        throw new Error("skeleton cannot be null.");
                    }
                    this.animationsChanged && this._animationsChanged();
                    var events = this.events;
                    var tracks = this.tracks;
                    for (var i = 0, n = tracks.length; i < n; i++) {
                        var current = tracks[i];
                        if (null == current || current.delay > 0) {
                            continue;
                        }
                        var mix = current.alpha;
                        null != current.mixingFrom ? mix *= this.applyMixingFrom(current, skeleton) : current.trackTime >= current.trackEnd && (mix = 0);
                        var animationLast = current.animationLast, animationTime = current.getAnimationTime();
                        var timelineCount = current.animation.timelines.length;
                        var timelines = current.animation.timelines;
                        if (1 == mix) {
                            for (var ii = 0; ii < timelineCount; ii++) {
                                timelines[ii].apply(skeleton, animationLast, animationTime, events, 1, true, false);
                            }
                        } else {
                            var firstFrame = 0 == current.timelinesRotation.length;
                            firstFrame && spine.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);
                            var timelinesRotation = current.timelinesRotation;
                            var timelinesFirst = current.timelinesFirst;
                            for (var ii = 0; ii < timelineCount; ii++) {
                                var timeline = timelines[ii];
                                timeline instanceof spine.RotateTimeline ? this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelinesFirst[ii], timelinesRotation, ii << 1, firstFrame) : timeline.apply(skeleton, animationLast, animationTime, events, mix, timelinesFirst[ii], false);
                            }
                        }
                        this.queueEvents(current, animationTime);
                        events.length = 0;
                        current.nextAnimationLast = animationTime;
                        current.nextTrackLast = current.trackTime;
                    }
                    this.queue.drain();
                };
                AnimationState.prototype.applyMixingFrom = function(entry, skeleton) {
                    var from = entry.mixingFrom;
                    null != from.mixingFrom && this.applyMixingFrom(from, skeleton);
                    var mix = 0;
                    if (0 == entry.mixDuration) {
                        mix = 1;
                    } else {
                        mix = entry.mixTime / entry.mixDuration;
                        mix > 1 && (mix = 1);
                    }
                    var events = mix < from.eventThreshold ? this.events : null;
                    var attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;
                    var animationLast = from.animationLast, animationTime = from.getAnimationTime();
                    var timelineCount = from.animation.timelines.length;
                    var timelines = from.animation.timelines;
                    var timelinesFirst = from.timelinesFirst;
                    var alpha = from.alpha * entry.mixAlpha * (1 - mix);
                    var firstFrame = 0 == from.timelinesRotation.length;
                    firstFrame && spine.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);
                    var timelinesRotation = from.timelinesRotation;
                    for (var i = 0; i < timelineCount; i++) {
                        var timeline = timelines[i];
                        var setupPose = timelinesFirst[i];
                        if (timeline instanceof spine.RotateTimeline) {
                            this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, setupPose, timelinesRotation, i << 1, firstFrame);
                        } else {
                            if (!setupPose) {
                                if (!attachments && timeline instanceof spine.AttachmentTimeline) {
                                    continue;
                                }
                                if (!drawOrder && timeline instanceof spine.DrawOrderTimeline) {
                                    continue;
                                }
                            }
                            timeline.apply(skeleton, animationLast, animationTime, events, alpha, setupPose, true);
                        }
                    }
                    entry.mixDuration > 0 && this.queueEvents(from, animationTime);
                    this.events.length = 0;
                    from.nextAnimationLast = animationTime;
                    from.nextTrackLast = from.trackTime;
                    return mix;
                };
                AnimationState.prototype.applyRotateTimeline = function(timeline, skeleton, time, alpha, setupPose, timelinesRotation, i, firstFrame) {
                    firstFrame && (timelinesRotation[i] = 0);
                    if (1 == alpha) {
                        timeline.apply(skeleton, 0, time, null, 1, setupPose, false);
                        return;
                    }
                    var rotateTimeline = timeline;
                    var frames = rotateTimeline.frames;
                    var bone = skeleton.bones[rotateTimeline.boneIndex];
                    if (time < frames[0]) {
                        setupPose && (bone.rotation = bone.data.rotation);
                        return;
                    }
                    var r2 = 0;
                    if (time >= frames[frames.length - spine.RotateTimeline.ENTRIES]) {
                        r2 = bone.data.rotation + frames[frames.length + spine.RotateTimeline.PREV_ROTATION];
                    } else {
                        var frame = spine.Animation.binarySearch(frames, time, spine.RotateTimeline.ENTRIES);
                        var prevRotation = frames[frame + spine.RotateTimeline.PREV_ROTATION];
                        var frameTime = frames[frame];
                        var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + spine.RotateTimeline.PREV_TIME] - frameTime));
                        r2 = frames[frame + spine.RotateTimeline.ROTATION] - prevRotation;
                        r2 -= 360 * (16384 - (16384.499999999996 - r2 / 360 | 0));
                        r2 = prevRotation + r2 * percent + bone.data.rotation;
                        r2 -= 360 * (16384 - (16384.499999999996 - r2 / 360 | 0));
                    }
                    var r1 = setupPose ? bone.data.rotation : bone.rotation;
                    var total = 0, diff = r2 - r1;
                    if (0 == diff) {
                        total = timelinesRotation[i];
                    } else {
                        diff -= 360 * (16384 - (16384.499999999996 - diff / 360 | 0));
                        var lastTotal = 0, lastDiff = 0;
                        if (firstFrame) {
                            lastTotal = 0;
                            lastDiff = diff;
                        } else {
                            lastTotal = timelinesRotation[i];
                            lastDiff = timelinesRotation[i + 1];
                        }
                        var current = diff > 0, dir = lastTotal >= 0;
                        if (spine.MathUtils.signum(lastDiff) != spine.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {
                            Math.abs(lastTotal) > 180 && (lastTotal += 360 * spine.MathUtils.signum(lastTotal));
                            dir = current;
                        }
                        total = diff + lastTotal - lastTotal % 360;
                        dir != current && (total += 360 * spine.MathUtils.signum(lastTotal));
                        timelinesRotation[i] = total;
                    }
                    timelinesRotation[i + 1] = diff;
                    r1 += total * alpha;
                    bone.rotation = r1 - 360 * (16384 - (16384.499999999996 - r1 / 360 | 0));
                };
                AnimationState.prototype.queueEvents = function(entry, animationTime) {
                    var animationStart = entry.animationStart, animationEnd = entry.animationEnd;
                    var duration = animationEnd - animationStart;
                    var trackLastWrapped = entry.trackLast % duration;
                    var events = this.events;
                    var i = 0, n = events.length;
                    for (;i < n; i++) {
                        var event_1 = events[i];
                        if (event_1.time < trackLastWrapped) {
                            break;
                        }
                        if (event_1.time > animationEnd) {
                            continue;
                        }
                        this.queue.event(entry, event_1);
                    }
                    (entry.loop ? trackLastWrapped > entry.trackTime % duration : animationTime >= animationEnd && entry.animationLast < animationEnd) && this.queue.complete(entry);
                    for (;i < n; i++) {
                        var event_2 = events[i];
                        if (event_2.time < animationStart) {
                            continue;
                        }
                        this.queue.event(entry, events[i]);
                    }
                };
                AnimationState.prototype.clearTracks = function() {
                    this.queue.drainDisabled = true;
                    for (var i = 0, n = this.tracks.length; i < n; i++) {
                        this.clearTrack(i);
                    }
                    this.tracks.length = 0;
                    this.queue.drainDisabled = false;
                    this.queue.drain();
                };
                AnimationState.prototype.clearTrack = function(trackIndex) {
                    if (trackIndex >= this.tracks.length) {
                        return;
                    }
                    var current = this.tracks[trackIndex];
                    if (null == current) {
                        return;
                    }
                    this.queue.end(current);
                    this.disposeNext(current);
                    var entry = current;
                    while (true) {
                        var from = entry.mixingFrom;
                        if (null == from) {
                            break;
                        }
                        this.queue.end(from);
                        entry.mixingFrom = null;
                        entry = from;
                    }
                    this.tracks[current.trackIndex] = null;
                    this.queue.drain();
                };
                AnimationState.prototype.setCurrent = function(index, current, interrupt) {
                    var from = this.expandToIndex(index);
                    this.tracks[index] = current;
                    if (null != from) {
                        interrupt && this.queue.interrupt(from);
                        current.mixingFrom = from;
                        current.mixTime = 0;
                        from.timelinesRotation.length = 0;
                        null != from.mixingFrom && from.mixDuration > 0 && (current.mixAlpha *= Math.min(from.mixTime / from.mixDuration, 1));
                    }
                    this.queue.start(current);
                };
                AnimationState.prototype.setAnimation = function(trackIndex, animationName, loop) {
                    var animation = this.data.skeletonData.findAnimation(animationName);
                    if (null == animation) {
                        throw new Error("Animation not found: " + animationName);
                    }
                    return this.setAnimationWith(trackIndex, animation, loop);
                };
                AnimationState.prototype.setAnimationWith = function(trackIndex, animation, loop) {
                    if (null == animation) {
                        throw new Error("animation cannot be null.");
                    }
                    var interrupt = true;
                    var current = this.expandToIndex(trackIndex);
                    if (null != current) {
                        if (current.nextTrackLast == -1) {
                            this.tracks[trackIndex] = current.mixingFrom;
                            this.queue.interrupt(current);
                            this.queue.end(current);
                            this.disposeNext(current);
                            current = current.mixingFrom;
                            interrupt = false;
                        } else {
                            this.disposeNext(current);
                        }
                    }
                    var entry = this.trackEntry(trackIndex, animation, loop, current);
                    this.setCurrent(trackIndex, entry, interrupt);
                    this.queue.drain();
                    return entry;
                };
                AnimationState.prototype.addAnimation = function(trackIndex, animationName, loop, delay) {
                    var animation = this.data.skeletonData.findAnimation(animationName);
                    if (null == animation) {
                        throw new Error("Animation not found: " + animationName);
                    }
                    return this.addAnimationWith(trackIndex, animation, loop, delay);
                };
                AnimationState.prototype.addAnimationWith = function(trackIndex, animation, loop, delay) {
                    if (null == animation) {
                        throw new Error("animation cannot be null.");
                    }
                    var last = this.expandToIndex(trackIndex);
                    if (null != last) {
                        while (null != last.next) {
                            last = last.next;
                        }
                    }
                    var entry = this.trackEntry(trackIndex, animation, loop, last);
                    if (null == last) {
                        this.setCurrent(trackIndex, entry, true);
                        this.queue.drain();
                    } else {
                        last.next = entry;
                        if (delay <= 0) {
                            var duration = last.animationEnd - last.animationStart;
                            0 != duration ? delay += duration * (1 + (last.trackTime / duration | 0)) - this.data.getMix(last.animation, animation) : delay = 0;
                        }
                    }
                    entry.delay = delay;
                    return entry;
                };
                AnimationState.prototype.setEmptyAnimation = function(trackIndex, mixDuration) {
                    var entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);
                    entry.mixDuration = mixDuration;
                    entry.trackEnd = mixDuration;
                    return entry;
                };
                AnimationState.prototype.addEmptyAnimation = function(trackIndex, mixDuration, delay) {
                    delay <= 0 && (delay -= mixDuration);
                    var entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);
                    entry.mixDuration = mixDuration;
                    entry.trackEnd = mixDuration;
                    return entry;
                };
                AnimationState.prototype.setEmptyAnimations = function(mixDuration) {
                    this.queue.drainDisabled = true;
                    for (var i = 0, n = this.tracks.length; i < n; i++) {
                        var current = this.tracks[i];
                        null != current && this.setEmptyAnimation(current.trackIndex, mixDuration);
                    }
                    this.queue.drainDisabled = false;
                    this.queue.drain();
                };
                AnimationState.prototype.expandToIndex = function(index) {
                    if (index < this.tracks.length) {
                        return this.tracks[index];
                    }
                    spine.Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);
                    this.tracks.length = index + 1;
                    return null;
                };
                AnimationState.prototype.trackEntry = function(trackIndex, animation, loop, last) {
                    var entry = this.trackEntryPool.obtain();
                    entry.trackIndex = trackIndex;
                    entry.animation = animation;
                    entry.loop = loop;
                    entry.eventThreshold = 0;
                    entry.attachmentThreshold = 0;
                    entry.drawOrderThreshold = 0;
                    entry.animationStart = 0;
                    entry.animationEnd = animation.duration;
                    entry.animationLast = -1;
                    entry.nextAnimationLast = -1;
                    entry.delay = 0;
                    entry.trackTime = 0;
                    entry.trackLast = -1;
                    entry.nextTrackLast = -1;
                    entry.trackEnd = Number.MAX_VALUE;
                    entry.timeScale = 1;
                    entry.alpha = 1;
                    entry.mixAlpha = 1;
                    entry.mixTime = 0;
                    entry.mixDuration = null == last ? 0 : this.data.getMix(last.animation, animation);
                    return entry;
                };
                AnimationState.prototype.disposeNext = function(entry) {
                    var next = entry.next;
                    while (null != next) {
                        this.queue.dispose(next);
                        next = next.next;
                    }
                    entry.next = null;
                };
                AnimationState.prototype._animationsChanged = function() {
                    this.animationsChanged = false;
                    var propertyIDs = this.propertyIDs;
                    var i = 0, n = this.tracks.length;
                    propertyIDs.clear();
                    for (;i < n; i++) {
                        var entry = this.tracks[i];
                        if (null == entry) {
                            continue;
                        }
                        this.setTimelinesFirst(entry);
                        i++;
                        break;
                    }
                    for (;i < n; i++) {
                        var entry = this.tracks[i];
                        null != entry && this.checkTimelinesFirst(entry);
                    }
                };
                AnimationState.prototype.setTimelinesFirst = function(entry) {
                    if (null != entry.mixingFrom) {
                        this.setTimelinesFirst(entry.mixingFrom);
                        this.checkTimelinesUsage(entry, entry.timelinesFirst);
                        return;
                    }
                    var propertyIDs = this.propertyIDs;
                    var timelines = entry.animation.timelines;
                    var n = timelines.length;
                    var usage = spine.Utils.setArraySize(entry.timelinesFirst, n, false);
                    for (var i = 0; i < n; i++) {
                        propertyIDs.add(timelines[i].getPropertyId());
                        usage[i] = true;
                    }
                };
                AnimationState.prototype.checkTimelinesFirst = function(entry) {
                    null != entry.mixingFrom && this.checkTimelinesFirst(entry.mixingFrom);
                    this.checkTimelinesUsage(entry, entry.timelinesFirst);
                };
                AnimationState.prototype.checkTimelinesUsage = function(entry, usageArray) {
                    var propertyIDs = this.propertyIDs;
                    var timelines = entry.animation.timelines;
                    var n = timelines.length;
                    var usage = spine.Utils.setArraySize(usageArray, n);
                    for (var i = 0; i < n; i++) {
                        usage[i] = propertyIDs.add(timelines[i].getPropertyId());
                    }
                };
                AnimationState.prototype.getCurrent = function(trackIndex) {
                    if (trackIndex >= this.tracks.length) {
                        return null;
                    }
                    return this.tracks[trackIndex];
                };
                AnimationState.prototype.addListener = function(listener) {
                    if (null == listener) {
                        throw new Error("listener cannot be null.");
                    }
                    this.listeners.push(listener);
                };
                AnimationState.prototype.removeListener = function(listener) {
                    var index = this.listeners.indexOf(listener);
                    index >= 0 && this.listeners.splice(index, 1);
                };
                AnimationState.prototype.clearListeners = function() {
                    this.listeners.length = 0;
                };
                AnimationState.prototype.clearListenerNotifications = function() {
                    this.queue.clear();
                };
                AnimationState.emptyAnimation = new spine.Animation("<empty>", [], 0);
                return AnimationState;
            })();
            spine.AnimationState = AnimationState;
            var TrackEntry = (function() {
                function TrackEntry() {
                    this.timelinesFirst = new Array();
                    this.timelinesRotation = new Array();
                }
                TrackEntry.prototype.reset = function() {
                    this.next = null;
                    this.mixingFrom = null;
                    this.animation = null;
                    this.listener = null;
                    this.timelinesFirst.length = 0;
                    this.timelinesRotation.length = 0;
                };
                TrackEntry.prototype.getAnimationTime = function() {
                    if (this.loop) {
                        var duration = this.animationEnd - this.animationStart;
                        if (0 == duration) {
                            return this.animationStart;
                        }
                        return this.trackTime % duration + this.animationStart;
                    }
                    return Math.min(this.trackTime + this.animationStart, this.animationEnd);
                };
                TrackEntry.prototype.setAnimationLast = function(animationLast) {
                    this.animationLast = animationLast;
                    this.nextAnimationLast = animationLast;
                };
                TrackEntry.prototype.isComplete = function() {
                    return this.trackTime >= this.animationEnd - this.animationStart;
                };
                TrackEntry.prototype.resetRotationDirections = function() {
                    this.timelinesRotation.length = 0;
                };
                return TrackEntry;
            })();
            spine.TrackEntry = TrackEntry;
            var EventQueue = (function() {
                function EventQueue(animState) {
                    this.objects = [];
                    this.drainDisabled = false;
                    this.animState = animState;
                }
                EventQueue.prototype.start = function(entry) {
                    this.objects.push(EventType.start);
                    this.objects.push(entry);
                    this.animState.animationsChanged = true;
                };
                EventQueue.prototype.interrupt = function(entry) {
                    this.objects.push(EventType.interrupt);
                    this.objects.push(entry);
                };
                EventQueue.prototype.end = function(entry) {
                    this.objects.push(EventType.end);
                    this.objects.push(entry);
                    this.animState.animationsChanged = true;
                };
                EventQueue.prototype.dispose = function(entry) {
                    this.objects.push(EventType.dispose);
                    this.objects.push(entry);
                };
                EventQueue.prototype.complete = function(entry) {
                    this.objects.push(EventType.complete);
                    this.objects.push(entry);
                };
                EventQueue.prototype.event = function(entry, event) {
                    this.objects.push(EventType.event);
                    this.objects.push(entry);
                    this.objects.push(event);
                };
                EventQueue.prototype.drain = function() {
                    if (this.drainDisabled) {
                        return;
                    }
                    this.drainDisabled = true;
                    var objects = this.objects;
                    var listeners = this.animState.listeners;
                    for (var i = 0; i < objects.length; i += 2) {
                        var type = objects[i];
                        var entry = objects[i + 1];
                        switch (type) {
                          case EventType.start:
                            null != entry.listener && entry.listener.start && entry.listener.start(entry);
                            for (var ii = 0; ii < listeners.length; ii++) {
                                listeners[ii].start && listeners[ii].start(entry);
                            }
                            break;

                          case EventType.interrupt:
                            null != entry.listener && entry.listener.interrupt && entry.listener.interrupt(entry);
                            for (var ii = 0; ii < listeners.length; ii++) {
                                listeners[ii].interrupt && listeners[ii].interrupt(entry);
                            }
                            break;

                          case EventType.end:
                            null != entry.listener && entry.listener.end && entry.listener.end(entry);
                            for (var ii = 0; ii < listeners.length; ii++) {
                                listeners[ii].end && listeners[ii].end(entry);
                            }

                          case EventType.dispose:
                            null != entry.listener && entry.listener.dispose && entry.listener.dispose(entry);
                            for (var ii = 0; ii < listeners.length; ii++) {
                                listeners[ii].dispose && listeners[ii].dispose(entry);
                            }
                            this.animState.trackEntryPool.free(entry);
                            break;

                          case EventType.complete:
                            null != entry.listener && entry.listener.complete && entry.listener.complete(entry);
                            for (var ii = 0; ii < listeners.length; ii++) {
                                listeners[ii].complete && listeners[ii].complete(entry);
                            }
                            break;

                          case EventType.event:
                            var event_3 = objects[i++ + 2];
                            null != entry.listener && entry.listener.event && entry.listener.event(entry, event_3);
                            for (var ii = 0; ii < listeners.length; ii++) {
                                listeners[ii].event && listeners[ii].event(entry, event_3);
                            }
                        }
                    }
                    this.clear();
                    this.drainDisabled = false;
                };
                EventQueue.prototype.clear = function() {
                    this.objects.length = 0;
                };
                return EventQueue;
            })();
            spine.EventQueue = EventQueue;
            (function(EventType) {
                EventType[EventType["start"] = 0] = "start";
                EventType[EventType["interrupt"] = 1] = "interrupt";
                EventType[EventType["end"] = 2] = "end";
                EventType[EventType["dispose"] = 3] = "dispose";
                EventType[EventType["complete"] = 4] = "complete";
                EventType[EventType["event"] = 5] = "event";
            })(spine.EventType || (spine.EventType = {}));
            var EventType = spine.EventType;
            var AnimationStateAdapter2 = (function() {
                function AnimationStateAdapter2() {}
                AnimationStateAdapter2.prototype.start = function(entry) {};
                AnimationStateAdapter2.prototype.interrupt = function(entry) {};
                AnimationStateAdapter2.prototype.end = function(entry) {};
                AnimationStateAdapter2.prototype.dispose = function(entry) {};
                AnimationStateAdapter2.prototype.complete = function(entry) {};
                AnimationStateAdapter2.prototype.event = function(entry, event) {};
                return AnimationStateAdapter2;
            })();
            spine.AnimationStateAdapter2 = AnimationStateAdapter2;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var AnimationStateData = (function() {
                function AnimationStateData(skeletonData) {
                    this.animationToMixTime = {};
                    this.defaultMix = 0;
                    if (null == skeletonData) {
                        throw new Error("skeletonData cannot be null.");
                    }
                    this.skeletonData = skeletonData;
                }
                AnimationStateData.prototype.setMix = function(fromName, toName, duration) {
                    var from = this.skeletonData.findAnimation(fromName);
                    if (null == from) {
                        throw new Error("Animation not found: " + fromName);
                    }
                    var to = this.skeletonData.findAnimation(toName);
                    if (null == to) {
                        throw new Error("Animation not found: " + toName);
                    }
                    this.setMixWith(from, to, duration);
                };
                AnimationStateData.prototype.setMixWith = function(from, to, duration) {
                    if (null == from) {
                        throw new Error("from cannot be null.");
                    }
                    if (null == to) {
                        throw new Error("to cannot be null.");
                    }
                    var key = from.name + to.name;
                    this.animationToMixTime[key] = duration;
                };
                AnimationStateData.prototype.getMix = function(from, to) {
                    var key = from.name + to.name;
                    var value = this.animationToMixTime[key];
                    return void 0 === value ? this.defaultMix : value;
                };
                return AnimationStateData;
            })();
            spine.AnimationStateData = AnimationStateData;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var AssetManager = (function() {
                function AssetManager(textureLoader, pathPrefix) {
                    void 0 === pathPrefix && (pathPrefix = "");
                    this.assets = {};
                    this.errors = {};
                    this.toLoad = 0;
                    this.loaded = 0;
                    this.textureLoader = textureLoader;
                    this.pathPrefix = pathPrefix;
                }
                AssetManager.prototype.loadText = function(path, success, error) {
                    var _this = this;
                    void 0 === success && (success = null);
                    void 0 === error && (error = null);
                    path = this.pathPrefix + path;
                    this.toLoad++;
                    var request = new XMLHttpRequest();
                    request.onreadystatechange = function() {
                        if (request.readyState == XMLHttpRequest.DONE) {
                            if (request.status >= 200 && request.status < 300) {
                                _this.assets[path] = request.responseText;
                                success && success(path, request.responseText);
                            } else {
                                _this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText;
                                error && error(path, "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText);
                            }
                            _this.toLoad--;
                            _this.loaded++;
                        }
                    };
                    request.open("GET", path, true);
                    request.send();
                };
                AssetManager.prototype.loadTexture = function(path, success, error) {
                    var _this = this;
                    void 0 === success && (success = null);
                    void 0 === error && (error = null);
                    path = this.pathPrefix + path;
                    this.toLoad++;
                    var img = new Image();
                    img.crossOrigin = "anonymous";
                    img.src = path;
                    img.onload = function(ev) {
                        var texture = _this.textureLoader(img);
                        _this.assets[path] = texture;
                        _this.toLoad--;
                        _this.loaded++;
                        success && success(path, img);
                    };
                    img.onerror = function(ev) {
                        _this.errors[path] = "Couldn't load image " + path;
                        _this.toLoad--;
                        _this.loaded++;
                        error && error(path, "Couldn't load image " + path);
                    };
                };
                AssetManager.prototype.get = function(path) {
                    path = this.pathPrefix + path;
                    return this.assets[path];
                };
                AssetManager.prototype.remove = function(path) {
                    path = this.pathPrefix + path;
                    var asset = this.assets[path];
                    asset.dispose && asset.dispose();
                    this.assets[path] = null;
                };
                AssetManager.prototype.removeAll = function() {
                    for (var key in this.assets) {
                        var asset = this.assets[key];
                        asset.dispose && asset.dispose();
                    }
                    this.assets = {};
                };
                AssetManager.prototype.isLoadingComplete = function() {
                    return 0 == this.toLoad;
                };
                AssetManager.prototype.getToLoad = function() {
                    return this.toLoad;
                };
                AssetManager.prototype.getLoaded = function() {
                    return this.loaded;
                };
                AssetManager.prototype.dispose = function() {
                    this.removeAll();
                };
                AssetManager.prototype.hasErrors = function() {
                    return Object.keys(this.errors).length > 0;
                };
                AssetManager.prototype.getErrors = function() {
                    return this.errors;
                };
                return AssetManager;
            })();
            spine.AssetManager = AssetManager;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var AtlasAttachmentLoader = (function() {
                function AtlasAttachmentLoader(atlas) {
                    this.atlas = atlas;
                }
                AtlasAttachmentLoader.prototype.newRegionAttachment = function(skin, name, path) {
                    var region = this.atlas.findRegion(path);
                    if (null == region) {
                        throw new Error("Region not found in atlas: " + path + " (region attachment: " + name + ")");
                    }
                    region.renderObject = region;
                    var attachment = new spine.RegionAttachment(name);
                    attachment.setRegion(region);
                    return attachment;
                };
                AtlasAttachmentLoader.prototype.newMeshAttachment = function(skin, name, path) {
                    var region = this.atlas.findRegion(path);
                    if (null == region) {
                        throw new Error("Region not found in atlas: " + path + " (mesh attachment: " + name + ")");
                    }
                    region.renderObject = region;
                    var attachment = new spine.MeshAttachment(name);
                    attachment.region = region;
                    return attachment;
                };
                AtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function(skin, name) {
                    return new spine.BoundingBoxAttachment(name);
                };
                AtlasAttachmentLoader.prototype.newPathAttachment = function(skin, name) {
                    return new spine.PathAttachment(name);
                };
                return AtlasAttachmentLoader;
            })();
            spine.AtlasAttachmentLoader = AtlasAttachmentLoader;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var Attachment = (function() {
                function Attachment(name) {
                    if (null == name) {
                        throw new Error("name cannot be null.");
                    }
                    this.name = name;
                }
                return Attachment;
            })();
            spine.Attachment = Attachment;
            var VertexAttachment = (function(_super) {
                __extends(VertexAttachment, _super);
                function VertexAttachment(name) {
                    _super.call(this, name);
                    this.worldVerticesLength = 0;
                }
                VertexAttachment.prototype.computeWorldVertices = function(slot, worldVertices) {
                    this.computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);
                };
                VertexAttachment.prototype.computeWorldVerticesWith = function(slot, start, count, worldVertices, offset) {
                    count += offset;
                    var skeleton = slot.bone.skeleton;
                    var deformArray = slot.attachmentVertices;
                    var vertices = this.vertices;
                    var bones = this.bones;
                    if (null == bones) {
                        deformArray.length > 0 && (vertices = deformArray);
                        var bone = slot.bone;
                        var x = bone.worldX;
                        var y = bone.worldY;
                        var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                        for (var v_1 = start, w = offset; w < count; v_1 += 2, w += 2) {
                            var vx = vertices[v_1], vy = vertices[v_1 + 1];
                            worldVertices[w] = vx * a + vy * b + x;
                            worldVertices[w + 1] = vx * c + vy * d + y;
                        }
                        return;
                    }
                    var v = 0, skip = 0;
                    for (var i = 0; i < start; i += 2) {
                        var n = bones[v];
                        v += n + 1;
                        skip += n;
                    }
                    var skeletonBones = skeleton.bones;
                    if (0 == deformArray.length) {
                        for (var w = offset, b = 3 * skip; w < count; w += 2) {
                            var wx = 0, wy = 0;
                            var n = bones[v++];
                            n += v;
                            for (;v < n; v++, b += 3) {
                                var bone = skeletonBones[bones[v]];
                                var vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];
                                wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
                                wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
                            }
                            worldVertices[w] = wx;
                            worldVertices[w + 1] = wy;
                        }
                    } else {
                        var deform = deformArray;
                        for (var w = offset, b = 3 * skip, f = skip << 1; w < count; w += 2) {
                            var wx = 0, wy = 0;
                            var n = bones[v++];
                            n += v;
                            for (;v < n; v++, b += 3, f += 2) {
                                var bone = skeletonBones[bones[v]];
                                var vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];
                                wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
                                wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
                            }
                            worldVertices[w] = wx;
                            worldVertices[w + 1] = wy;
                        }
                    }
                };
                VertexAttachment.prototype.applyDeform = function(sourceAttachment) {
                    return this == sourceAttachment;
                };
                return VertexAttachment;
            })(Attachment);
            spine.VertexAttachment = VertexAttachment;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            (function(AttachmentType) {
                AttachmentType[AttachmentType["Region"] = 0] = "Region";
                AttachmentType[AttachmentType["BoundingBox"] = 1] = "BoundingBox";
                AttachmentType[AttachmentType["Mesh"] = 2] = "Mesh";
                AttachmentType[AttachmentType["LinkedMesh"] = 3] = "LinkedMesh";
                AttachmentType[AttachmentType["Path"] = 4] = "Path";
            })(spine.AttachmentType || (spine.AttachmentType = {}));
            var AttachmentType = spine.AttachmentType;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var BoundingBoxAttachment = (function(_super) {
                __extends(BoundingBoxAttachment, _super);
                function BoundingBoxAttachment(name) {
                    _super.call(this, name);
                    this.color = new spine.Color(1, 1, 1, 1);
                }
                return BoundingBoxAttachment;
            })(spine.VertexAttachment);
            spine.BoundingBoxAttachment = BoundingBoxAttachment;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var MeshAttachment = (function(_super) {
                __extends(MeshAttachment, _super);
                function MeshAttachment(name) {
                    _super.call(this, name);
                    this.color = new spine.Color(1, 1, 1, 1);
                    this.inheritDeform = false;
                    this.tempColor = new spine.Color(0, 0, 0, 0);
                }
                MeshAttachment.prototype.updateUVs = function() {
                    var regionUVs = this.regionUVs;
                    var verticesLength = regionUVs.length;
                    var worldVerticesLength = 8 * (verticesLength >> 1);
                    null != this.worldVertices && this.worldVertices.length == worldVerticesLength || (this.worldVertices = spine.Utils.newFloatArray(worldVerticesLength));
                    var u = 0, v = 0, width = 0, height = 0;
                    if (null == this.region) {
                        u = v = 0;
                        width = height = 1;
                    } else {
                        u = this.region.u;
                        v = this.region.v;
                        width = this.region.u2 - u;
                        height = this.region.v2 - v;
                    }
                    if (this.region.rotate) {
                        for (var i = 0, w = 6; i < verticesLength; i += 2, w += 8) {
                            this.worldVertices[w] = u + regionUVs[i + 1] * width;
                            this.worldVertices[w + 1] = v + height - regionUVs[i] * height;
                        }
                    } else {
                        for (var i = 0, w = 6; i < verticesLength; i += 2, w += 8) {
                            this.worldVertices[w] = u + regionUVs[i] * width;
                            this.worldVertices[w + 1] = v + regionUVs[i + 1] * height;
                        }
                    }
                };
                MeshAttachment.prototype.updateWorldVertices = function(slot, premultipliedAlpha) {
                    var skeleton = slot.bone.skeleton;
                    var skeletonColor = skeleton.color, slotColor = slot.color, meshColor = this.color;
                    var alpha = skeletonColor.a * slotColor.a * meshColor.a;
                    var multiplier = premultipliedAlpha ? alpha : 1;
                    var color = this.tempColor;
                    color.set(skeletonColor.r * slotColor.r * meshColor.r * multiplier, skeletonColor.g * slotColor.g * meshColor.g * multiplier, skeletonColor.b * slotColor.b * meshColor.b * multiplier, alpha);
                    var deformArray = slot.attachmentVertices;
                    var vertices = this.vertices, worldVertices = this.worldVertices;
                    var bones = this.bones;
                    if (null == bones) {
                        var verticesLength = vertices.length;
                        deformArray.length > 0 && (vertices = deformArray);
                        var bone = slot.bone;
                        var x = bone.worldX;
                        var y = bone.worldY;
                        var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                        for (var v = 0, w = 0; v < verticesLength; v += 2, w += 8) {
                            var vx = vertices[v], vy = vertices[v + 1];
                            worldVertices[w] = vx * a + vy * b + x;
                            worldVertices[w + 1] = vx * c + vy * d + y;
                            worldVertices[w + 2] = color.r;
                            worldVertices[w + 3] = color.g;
                            worldVertices[w + 4] = color.b;
                            worldVertices[w + 5] = color.a;
                        }
                        return worldVertices;
                    }
                    var skeletonBones = skeleton.bones;
                    if (0 == deformArray.length) {
                        for (var w = 0, v = 0, b = 0, n = bones.length; v < n; w += 8) {
                            var wx = 0, wy = 0;
                            var nn = bones[v++] + v;
                            for (;v < nn; v++, b += 3) {
                                var bone = skeletonBones[bones[v]];
                                var vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];
                                wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
                                wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
                            }
                            worldVertices[w] = wx;
                            worldVertices[w + 1] = wy;
                            worldVertices[w + 2] = color.r;
                            worldVertices[w + 3] = color.g;
                            worldVertices[w + 4] = color.b;
                            worldVertices[w + 5] = color.a;
                        }
                    } else {
                        var deform = deformArray;
                        for (var w = 0, v = 0, b = 0, f = 0, n = bones.length; v < n; w += 8) {
                            var wx = 0, wy = 0;
                            var nn = bones[v++] + v;
                            for (;v < nn; v++, b += 3, f += 2) {
                                var bone = skeletonBones[bones[v]];
                                var vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];
                                wx += (vx * bone.a + vy * bone.b + bone.worldX) * weight;
                                wy += (vx * bone.c + vy * bone.d + bone.worldY) * weight;
                            }
                            worldVertices[w] = wx;
                            worldVertices[w + 1] = wy;
                            worldVertices[w + 2] = color.r;
                            worldVertices[w + 3] = color.g;
                            worldVertices[w + 4] = color.b;
                            worldVertices[w + 5] = color.a;
                        }
                    }
                    return worldVertices;
                };
                MeshAttachment.prototype.applyDeform = function(sourceAttachment) {
                    return this == sourceAttachment || this.inheritDeform && this.parentMesh == sourceAttachment;
                };
                MeshAttachment.prototype.getParentMesh = function() {
                    return this.parentMesh;
                };
                MeshAttachment.prototype.setParentMesh = function(parentMesh) {
                    this.parentMesh = parentMesh;
                    if (null != parentMesh) {
                        this.bones = parentMesh.bones;
                        this.vertices = parentMesh.vertices;
                        this.regionUVs = parentMesh.regionUVs;
                        this.triangles = parentMesh.triangles;
                        this.hullLength = parentMesh.hullLength;
                    }
                };
                return MeshAttachment;
            })(spine.VertexAttachment);
            spine.MeshAttachment = MeshAttachment;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var PathAttachment = (function(_super) {
                __extends(PathAttachment, _super);
                function PathAttachment(name) {
                    _super.call(this, name);
                    this.closed = false;
                    this.constantSpeed = false;
                    this.color = new spine.Color(1, 1, 1, 1);
                }
                return PathAttachment;
            })(spine.VertexAttachment);
            spine.PathAttachment = PathAttachment;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var RegionAttachment = (function(_super) {
                __extends(RegionAttachment, _super);
                function RegionAttachment(name) {
                    _super.call(this, name);
                    this.x = 0;
                    this.y = 0;
                    this.scaleX = 1;
                    this.scaleY = 1;
                    this.rotation = 0;
                    this.width = 0;
                    this.height = 0;
                    this.color = new spine.Color(1, 1, 1, 1);
                    this.offset = spine.Utils.newFloatArray(8);
                    this.vertices = spine.Utils.newFloatArray(32);
                    this.tempColor = new spine.Color(1, 1, 1, 1);
                }
                RegionAttachment.prototype.setRegion = function(region) {
                    var vertices = this.vertices;
                    if (region.rotate) {
                        vertices[RegionAttachment.U2] = region.u;
                        vertices[RegionAttachment.V2] = region.v2;
                        vertices[RegionAttachment.U3] = region.u;
                        vertices[RegionAttachment.V3] = region.v;
                        vertices[RegionAttachment.U4] = region.u2;
                        vertices[RegionAttachment.V4] = region.v;
                        vertices[RegionAttachment.U1] = region.u2;
                        vertices[RegionAttachment.V1] = region.v2;
                    } else {
                        vertices[RegionAttachment.U1] = region.u;
                        vertices[RegionAttachment.V1] = region.v2;
                        vertices[RegionAttachment.U2] = region.u;
                        vertices[RegionAttachment.V2] = region.v;
                        vertices[RegionAttachment.U3] = region.u2;
                        vertices[RegionAttachment.V3] = region.v;
                        vertices[RegionAttachment.U4] = region.u2;
                        vertices[RegionAttachment.V4] = region.v2;
                    }
                    this.region = region;
                };
                RegionAttachment.prototype.updateOffset = function() {
                    var regionScaleX = this.width / this.region.originalWidth * this.scaleX;
                    var regionScaleY = this.height / this.region.originalHeight * this.scaleY;
                    var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;
                    var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;
                    var localX2 = localX + this.region.width * regionScaleX;
                    var localY2 = localY + this.region.height * regionScaleY;
                    var radians = this.rotation * Math.PI / 180;
                    var cos = Math.cos(radians);
                    var sin = Math.sin(radians);
                    var localXCos = localX * cos + this.x;
                    var localXSin = localX * sin;
                    var localYCos = localY * cos + this.y;
                    var localYSin = localY * sin;
                    var localX2Cos = localX2 * cos + this.x;
                    var localX2Sin = localX2 * sin;
                    var localY2Cos = localY2 * cos + this.y;
                    var localY2Sin = localY2 * sin;
                    var offset = this.offset;
                    offset[RegionAttachment.OX1] = localXCos - localYSin;
                    offset[RegionAttachment.OY1] = localYCos + localXSin;
                    offset[RegionAttachment.OX2] = localXCos - localY2Sin;
                    offset[RegionAttachment.OY2] = localY2Cos + localXSin;
                    offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;
                    offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;
                    offset[RegionAttachment.OX4] = localX2Cos - localYSin;
                    offset[RegionAttachment.OY4] = localYCos + localX2Sin;
                };
                RegionAttachment.prototype.updateWorldVertices = function(slot, premultipliedAlpha) {
                    var skeleton = slot.bone.skeleton;
                    var skeletonColor = skeleton.color;
                    var slotColor = slot.color;
                    var regionColor = this.color;
                    var alpha = skeletonColor.a * slotColor.a * regionColor.a;
                    var multiplier = premultipliedAlpha ? alpha : 1;
                    var color = this.tempColor;
                    color.set(skeletonColor.r * slotColor.r * regionColor.r * multiplier, skeletonColor.g * slotColor.g * regionColor.g * multiplier, skeletonColor.b * slotColor.b * regionColor.b * multiplier, alpha);
                    var vertices = this.vertices;
                    var offset = this.offset;
                    var bone = slot.bone;
                    var x = bone.worldX, y = bone.worldY;
                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                    var offsetX = 0, offsetY = 0;
                    offsetX = offset[RegionAttachment.OX1];
                    offsetY = offset[RegionAttachment.OY1];
                    vertices[RegionAttachment.X1] = offsetX * a + offsetY * b + x;
                    vertices[RegionAttachment.Y1] = offsetX * c + offsetY * d + y;
                    vertices[RegionAttachment.C1R] = color.r;
                    vertices[RegionAttachment.C1G] = color.g;
                    vertices[RegionAttachment.C1B] = color.b;
                    vertices[RegionAttachment.C1A] = color.a;
                    offsetX = offset[RegionAttachment.OX2];
                    offsetY = offset[RegionAttachment.OY2];
                    vertices[RegionAttachment.X2] = offsetX * a + offsetY * b + x;
                    vertices[RegionAttachment.Y2] = offsetX * c + offsetY * d + y;
                    vertices[RegionAttachment.C2R] = color.r;
                    vertices[RegionAttachment.C2G] = color.g;
                    vertices[RegionAttachment.C2B] = color.b;
                    vertices[RegionAttachment.C2A] = color.a;
                    offsetX = offset[RegionAttachment.OX3];
                    offsetY = offset[RegionAttachment.OY3];
                    vertices[RegionAttachment.X3] = offsetX * a + offsetY * b + x;
                    vertices[RegionAttachment.Y3] = offsetX * c + offsetY * d + y;
                    vertices[RegionAttachment.C3R] = color.r;
                    vertices[RegionAttachment.C3G] = color.g;
                    vertices[RegionAttachment.C3B] = color.b;
                    vertices[RegionAttachment.C3A] = color.a;
                    offsetX = offset[RegionAttachment.OX4];
                    offsetY = offset[RegionAttachment.OY4];
                    vertices[RegionAttachment.X4] = offsetX * a + offsetY * b + x;
                    vertices[RegionAttachment.Y4] = offsetX * c + offsetY * d + y;
                    vertices[RegionAttachment.C4R] = color.r;
                    vertices[RegionAttachment.C4G] = color.g;
                    vertices[RegionAttachment.C4B] = color.b;
                    vertices[RegionAttachment.C4A] = color.a;
                    return vertices;
                };
                RegionAttachment.OX1 = 0;
                RegionAttachment.OY1 = 1;
                RegionAttachment.OX2 = 2;
                RegionAttachment.OY2 = 3;
                RegionAttachment.OX3 = 4;
                RegionAttachment.OY3 = 5;
                RegionAttachment.OX4 = 6;
                RegionAttachment.OY4 = 7;
                RegionAttachment.X1 = 0;
                RegionAttachment.Y1 = 1;
                RegionAttachment.C1R = 2;
                RegionAttachment.C1G = 3;
                RegionAttachment.C1B = 4;
                RegionAttachment.C1A = 5;
                RegionAttachment.U1 = 6;
                RegionAttachment.V1 = 7;
                RegionAttachment.X2 = 8;
                RegionAttachment.Y2 = 9;
                RegionAttachment.C2R = 10;
                RegionAttachment.C2G = 11;
                RegionAttachment.C2B = 12;
                RegionAttachment.C2A = 13;
                RegionAttachment.U2 = 14;
                RegionAttachment.V2 = 15;
                RegionAttachment.X3 = 16;
                RegionAttachment.Y3 = 17;
                RegionAttachment.C3R = 18;
                RegionAttachment.C3G = 19;
                RegionAttachment.C3B = 20;
                RegionAttachment.C3A = 21;
                RegionAttachment.U3 = 22;
                RegionAttachment.V3 = 23;
                RegionAttachment.X4 = 24;
                RegionAttachment.Y4 = 25;
                RegionAttachment.C4R = 26;
                RegionAttachment.C4G = 27;
                RegionAttachment.C4B = 28;
                RegionAttachment.C4A = 29;
                RegionAttachment.U4 = 30;
                RegionAttachment.V4 = 31;
                return RegionAttachment;
            })(spine.Attachment);
            spine.RegionAttachment = RegionAttachment;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            (function(BlendMode) {
                BlendMode[BlendMode["Normal"] = 0] = "Normal";
                BlendMode[BlendMode["Additive"] = 1] = "Additive";
                BlendMode[BlendMode["Multiply"] = 2] = "Multiply";
                BlendMode[BlendMode["Screen"] = 3] = "Screen";
            })(spine.BlendMode || (spine.BlendMode = {}));
            var BlendMode = spine.BlendMode;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var Bone = (function() {
                function Bone(data, skeleton, parent) {
                    this.children = new Array();
                    this.x = 0;
                    this.y = 0;
                    this.rotation = 0;
                    this.scaleX = 0;
                    this.scaleY = 0;
                    this.shearX = 0;
                    this.shearY = 0;
                    this.ax = 0;
                    this.ay = 0;
                    this.arotation = 0;
                    this.ascaleX = 0;
                    this.ascaleY = 0;
                    this.ashearX = 0;
                    this.ashearY = 0;
                    this.appliedValid = false;
                    this.a = 0;
                    this.b = 0;
                    this.worldX = 0;
                    this.c = 0;
                    this.d = 0;
                    this.worldY = 0;
                    this.sorted = false;
                    if (null == data) {
                        throw new Error("data cannot be null.");
                    }
                    if (null == skeleton) {
                        throw new Error("skeleton cannot be null.");
                    }
                    this.data = data;
                    this.skeleton = skeleton;
                    this.parent = parent;
                    this.setToSetupPose();
                }
                Bone.prototype.update = function() {
                    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
                };
                Bone.prototype.updateWorldTransform = function() {
                    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);
                };
                Bone.prototype.updateWorldTransformWith = function(x, y, rotation, scaleX, scaleY, shearX, shearY) {
                    this.ax = x;
                    this.ay = y;
                    this.arotation = rotation;
                    this.ascaleX = scaleX;
                    this.ascaleY = scaleY;
                    this.ashearX = shearX;
                    this.ashearY = shearY;
                    this.appliedValid = true;
                    var parent = this.parent;
                    if (null == parent) {
                        var rotationY = rotation + 90 + shearY;
                        var la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;
                        var lb = spine.MathUtils.cosDeg(rotationY) * scaleY;
                        var lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;
                        var ld = spine.MathUtils.sinDeg(rotationY) * scaleY;
                        var skeleton = this.skeleton;
                        if (skeleton.flipX) {
                            x = -x;
                            la = -la;
                            lb = -lb;
                        }
                        if (skeleton.flipY) {
                            y = -y;
                            lc = -lc;
                            ld = -ld;
                        }
                        this.a = la;
                        this.b = lb;
                        this.c = lc;
                        this.d = ld;
                        this.worldX = x + skeleton.x;
                        this.worldY = y + skeleton.y;
                        return;
                    }
                    var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
                    this.worldX = pa * x + pb * y + parent.worldX;
                    this.worldY = pc * x + pd * y + parent.worldY;
                    switch (this.data.transformMode) {
                      case spine.TransformMode.Normal:
                        var rotationY = rotation + 90 + shearY;
                        var la = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;
                        var lb = spine.MathUtils.cosDeg(rotationY) * scaleY;
                        var lc = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;
                        var ld = spine.MathUtils.sinDeg(rotationY) * scaleY;
                        this.a = pa * la + pb * lc;
                        this.b = pa * lb + pb * ld;
                        this.c = pc * la + pd * lc;
                        this.d = pc * lb + pd * ld;
                        return;

                      case spine.TransformMode.OnlyTranslation:
                        var rotationY = rotation + 90 + shearY;
                        this.a = spine.MathUtils.cosDeg(rotation + shearX) * scaleX;
                        this.b = spine.MathUtils.cosDeg(rotationY) * scaleY;
                        this.c = spine.MathUtils.sinDeg(rotation + shearX) * scaleX;
                        this.d = spine.MathUtils.sinDeg(rotationY) * scaleY;
                        break;

                      case spine.TransformMode.NoRotationOrReflection:
                        var s = pa * pa + pc * pc;
                        var prx = 0;
                        if (s > 1e-4) {
                            s = Math.abs(pa * pd - pb * pc) / s;
                            pb = pc * s;
                            pd = pa * s;
                            prx = Math.atan2(pc, pa) * spine.MathUtils.radDeg;
                        } else {
                            pa = 0;
                            pc = 0;
                            prx = 90 - Math.atan2(pd, pb) * spine.MathUtils.radDeg;
                        }
                        var rx = rotation + shearX - prx;
                        var ry = rotation + shearY - prx + 90;
                        var la = spine.MathUtils.cosDeg(rx) * scaleX;
                        var lb = spine.MathUtils.cosDeg(ry) * scaleY;
                        var lc = spine.MathUtils.sinDeg(rx) * scaleX;
                        var ld = spine.MathUtils.sinDeg(ry) * scaleY;
                        this.a = pa * la - pb * lc;
                        this.b = pa * lb - pb * ld;
                        this.c = pc * la + pd * lc;
                        this.d = pc * lb + pd * ld;
                        break;

                      case spine.TransformMode.NoScale:
                      case spine.TransformMode.NoScaleOrReflection:
                        var cos = spine.MathUtils.cosDeg(rotation);
                        var sin = spine.MathUtils.sinDeg(rotation);
                        var za = pa * cos + pb * sin;
                        var zc = pc * cos + pd * sin;
                        var s = Math.sqrt(za * za + zc * zc);
                        s > 1e-5 && (s = 1 / s);
                        za *= s;
                        zc *= s;
                        s = Math.sqrt(za * za + zc * zc);
                        var r = Math.PI / 2 + Math.atan2(zc, za);
                        var zb = Math.cos(r) * s;
                        var zd = Math.sin(r) * s;
                        var la = spine.MathUtils.cosDeg(shearX) * scaleX;
                        var lb = spine.MathUtils.cosDeg(90 + shearY) * scaleY;
                        var lc = spine.MathUtils.sinDeg(shearX) * scaleX;
                        var ld = spine.MathUtils.sinDeg(90 + shearY) * scaleY;
                        this.a = za * la + zb * lc;
                        this.b = za * lb + zb * ld;
                        this.c = zc * la + zd * lc;
                        this.d = zc * lb + zd * ld;
                        if (this.data.transformMode != spine.TransformMode.NoScaleOrReflection ? pa * pd - pb * pc < 0 : this.skeleton.flipX != this.skeleton.flipY) {
                            this.b = -this.b;
                            this.d = -this.d;
                        }
                        return;
                    }
                    if (this.skeleton.flipX) {
                        this.a = -this.a;
                        this.b = -this.b;
                    }
                    if (this.skeleton.flipY) {
                        this.c = -this.c;
                        this.d = -this.d;
                    }
                };
                Bone.prototype.setToSetupPose = function() {
                    var data = this.data;
                    this.x = data.x;
                    this.y = data.y;
                    this.rotation = data.rotation;
                    this.scaleX = data.scaleX;
                    this.scaleY = data.scaleY;
                    this.shearX = data.shearX;
                    this.shearY = data.shearY;
                };
                Bone.prototype.getWorldRotationX = function() {
                    return Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;
                };
                Bone.prototype.getWorldRotationY = function() {
                    return Math.atan2(this.d, this.b) * spine.MathUtils.radDeg;
                };
                Bone.prototype.getWorldScaleX = function() {
                    return Math.sqrt(this.a * this.a + this.c * this.c);
                };
                Bone.prototype.getWorldScaleY = function() {
                    return Math.sqrt(this.b * this.b + this.d * this.d);
                };
                Bone.prototype.worldToLocalRotationX = function() {
                    var parent = this.parent;
                    if (null == parent) {
                        return this.arotation;
                    }
                    var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d, a = this.a, c = this.c;
                    return Math.atan2(pa * c - pc * a, pd * a - pb * c) * spine.MathUtils.radDeg;
                };
                Bone.prototype.worldToLocalRotationY = function() {
                    var parent = this.parent;
                    if (null == parent) {
                        return this.arotation;
                    }
                    var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d, b = this.b, d = this.d;
                    return Math.atan2(pa * d - pc * b, pd * b - pb * d) * spine.MathUtils.radDeg;
                };
                Bone.prototype.rotateWorld = function(degrees) {
                    var a = this.a, b = this.b, c = this.c, d = this.d;
                    var cos = spine.MathUtils.cosDeg(degrees), sin = spine.MathUtils.sinDeg(degrees);
                    this.a = cos * a - sin * c;
                    this.b = cos * b - sin * d;
                    this.c = sin * a + cos * c;
                    this.d = sin * b + cos * d;
                    this.appliedValid = false;
                };
                Bone.prototype.updateAppliedTransform = function() {
                    this.appliedValid = true;
                    var parent = this.parent;
                    if (null == parent) {
                        this.ax = this.worldX;
                        this.ay = this.worldY;
                        this.arotation = Math.atan2(this.c, this.a) * spine.MathUtils.radDeg;
                        this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c);
                        this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d);
                        this.ashearX = 0;
                        this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * spine.MathUtils.radDeg;
                        return;
                    }
                    var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
                    var pid = 1 / (pa * pd - pb * pc);
                    var dx = this.worldX - parent.worldX, dy = this.worldY - parent.worldY;
                    this.ax = dx * pd * pid - dy * pb * pid;
                    this.ay = dy * pa * pid - dx * pc * pid;
                    var ia = pid * pd;
                    var id = pid * pa;
                    var ib = pid * pb;
                    var ic = pid * pc;
                    var ra = ia * this.a - ib * this.c;
                    var rb = ia * this.b - ib * this.d;
                    var rc = id * this.c - ic * this.a;
                    var rd = id * this.d - ic * this.b;
                    this.ashearX = 0;
                    this.ascaleX = Math.sqrt(ra * ra + rc * rc);
                    if (this.ascaleX > 1e-4) {
                        var det = ra * rd - rb * rc;
                        this.ascaleY = det / this.ascaleX;
                        this.ashearY = Math.atan2(ra * rb + rc * rd, det) * spine.MathUtils.radDeg;
                        this.arotation = Math.atan2(rc, ra) * spine.MathUtils.radDeg;
                    } else {
                        this.ascaleX = 0;
                        this.ascaleY = Math.sqrt(rb * rb + rd * rd);
                        this.ashearY = 0;
                        this.arotation = 90 - Math.atan2(rd, rb) * spine.MathUtils.radDeg;
                    }
                };
                Bone.prototype.worldToLocal = function(world) {
                    var a = this.a, b = this.b, c = this.c, d = this.d;
                    var invDet = 1 / (a * d - b * c);
                    var x = world.x - this.worldX, y = world.y - this.worldY;
                    world.x = x * d * invDet - y * b * invDet;
                    world.y = y * a * invDet - x * c * invDet;
                    return world;
                };
                Bone.prototype.localToWorld = function(local) {
                    var x = local.x, y = local.y;
                    local.x = x * this.a + y * this.b + this.worldX;
                    local.y = x * this.c + y * this.d + this.worldY;
                    return local;
                };
                return Bone;
            })();
            spine.Bone = Bone;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var BoneData = (function() {
                function BoneData(index, name, parent) {
                    this.x = 0;
                    this.y = 0;
                    this.rotation = 0;
                    this.scaleX = 1;
                    this.scaleY = 1;
                    this.shearX = 0;
                    this.shearY = 0;
                    this.transformMode = TransformMode.Normal;
                    if (index < 0) {
                        throw new Error("index must be >= 0.");
                    }
                    if (null == name) {
                        throw new Error("name cannot be null.");
                    }
                    this.index = index;
                    this.name = name;
                    this.parent = parent;
                }
                return BoneData;
            })();
            spine.BoneData = BoneData;
            (function(TransformMode) {
                TransformMode[TransformMode["Normal"] = 0] = "Normal";
                TransformMode[TransformMode["OnlyTranslation"] = 1] = "OnlyTranslation";
                TransformMode[TransformMode["NoRotationOrReflection"] = 2] = "NoRotationOrReflection";
                TransformMode[TransformMode["NoScale"] = 3] = "NoScale";
                TransformMode[TransformMode["NoScaleOrReflection"] = 4] = "NoScaleOrReflection";
            })(spine.TransformMode || (spine.TransformMode = {}));
            var TransformMode = spine.TransformMode;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var Event = (function() {
                function Event(time, data) {
                    if (null == data) {
                        throw new Error("data cannot be null.");
                    }
                    this.time = time;
                    this.data = data;
                }
                return Event;
            })();
            spine.Event = Event;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var EventData = (function() {
                function EventData(name) {
                    this.name = name;
                }
                return EventData;
            })();
            spine.EventData = EventData;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var IkConstraint = (function() {
                function IkConstraint(data, skeleton) {
                    this.mix = 1;
                    this.bendDirection = 0;
                    if (null == data) {
                        throw new Error("data cannot be null.");
                    }
                    if (null == skeleton) {
                        throw new Error("skeleton cannot be null.");
                    }
                    this.data = data;
                    this.mix = data.mix;
                    this.bendDirection = data.bendDirection;
                    this.bones = new Array();
                    for (var i = 0; i < data.bones.length; i++) {
                        this.bones.push(skeleton.findBone(data.bones[i].name));
                    }
                    this.target = skeleton.findBone(data.target.name);
                }
                IkConstraint.prototype.getOrder = function() {
                    return this.data.order;
                };
                IkConstraint.prototype.apply = function() {
                    this.update();
                };
                IkConstraint.prototype.update = function() {
                    var target = this.target;
                    var bones = this.bones;
                    switch (bones.length) {
                      case 1:
                        this.apply1(bones[0], target.worldX, target.worldY, this.mix);
                        break;

                      case 2:
                        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);
                    }
                };
                IkConstraint.prototype.apply1 = function(bone, targetX, targetY, alpha) {
                    bone.appliedValid || bone.updateAppliedTransform();
                    var p = bone.parent;
                    var id = 1 / (p.a * p.d - p.b * p.c);
                    var x = targetX - p.worldX, y = targetY - p.worldY;
                    var tx = (x * p.d - y * p.b) * id - bone.ax, ty = (y * p.a - x * p.c) * id - bone.ay;
                    var rotationIK = Math.atan2(ty, tx) * spine.MathUtils.radDeg - bone.ashearX - bone.arotation;
                    bone.ascaleX < 0 && (rotationIK += 180);
                    rotationIK > 180 ? rotationIK -= 360 : rotationIK < -180 && (rotationIK += 360);
                    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, bone.ascaleX, bone.ascaleY, bone.ashearX, bone.ashearY);
                };
                IkConstraint.prototype.apply2 = function(parent, child, targetX, targetY, bendDir, alpha) {
                    if (0 == alpha) {
                        child.updateWorldTransform();
                        return;
                    }
                    parent.appliedValid || parent.updateAppliedTransform();
                    child.appliedValid || child.updateAppliedTransform();
                    var px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, csx = child.ascaleX;
                    var os1 = 0, os2 = 0, s2 = 0;
                    if (psx < 0) {
                        psx = -psx;
                        os1 = 180;
                        s2 = -1;
                    } else {
                        os1 = 0;
                        s2 = 1;
                    }
                    if (psy < 0) {
                        psy = -psy;
                        s2 = -s2;
                    }
                    if (csx < 0) {
                        csx = -csx;
                        os2 = 180;
                    } else {
                        os2 = 0;
                    }
                    var cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = parent.a, b = parent.b, c = parent.c, d = parent.d;
                    var u = Math.abs(psx - psy) <= 1e-4;
                    if (u) {
                        cy = child.ay;
                        cwx = a * cx + b * cy + parent.worldX;
                        cwy = c * cx + d * cy + parent.worldY;
                    } else {
                        cy = 0;
                        cwx = a * cx + parent.worldX;
                        cwy = c * cx + parent.worldY;
                    }
                    var pp = parent.parent;
                    a = pp.a;
                    b = pp.b;
                    c = pp.c;
                    d = pp.d;
                    var id = 1 / (a * d - b * c), x = targetX - pp.worldX, y = targetY - pp.worldY;
                    var tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;
                    x = cwx - pp.worldX;
                    y = cwy - pp.worldY;
                    var dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;
                    var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;
                    outer: if (u) {
                        l2 *= psx;
                        var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);
                        cos < -1 ? cos = -1 : cos > 1 && (cos = 1);
                        a2 = Math.acos(cos) * bendDir;
                        a = l1 + l2 * cos;
                        b = l2 * Math.sin(a2);
                        a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
                    } else {
                        a = psx * l2;
                        b = psy * l2;
                        var aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);
                        c = bb * l1 * l1 + aa * dd - aa * bb;
                        var c1 = -2 * bb * l1, c2 = bb - aa;
                        d = c1 * c1 - 4 * c2 * c;
                        if (d >= 0) {
                            var q = Math.sqrt(d);
                            c1 < 0 && (q = -q);
                            q = -(c1 + q) / 2;
                            var r0 = q / c2, r1 = c / q;
                            var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
                            if (r * r <= dd) {
                                y = Math.sqrt(dd - r * r) * bendDir;
                                a1 = ta - Math.atan2(y, r);
                                a2 = Math.atan2(y / psy, (r - l1) / psx);
                                break outer;
                            }
                        }
                        var minAngle = 0, minDist = Number.MAX_VALUE, minX = 0, minY = 0;
                        var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;
                        x = l1 + a;
                        d = x * x;
                        if (d > maxDist) {
                            maxAngle = 0;
                            maxDist = d;
                            maxX = x;
                        }
                        x = l1 - a;
                        d = x * x;
                        if (d < minDist) {
                            minAngle = spine.MathUtils.PI;
                            minDist = d;
                            minX = x;
                        }
                        var angle = Math.acos(-a * l1 / (aa - bb));
                        x = a * Math.cos(angle) + l1;
                        y = b * Math.sin(angle);
                        d = x * x + y * y;
                        if (d < minDist) {
                            minAngle = angle;
                            minDist = d;
                            minX = x;
                            minY = y;
                        }
                        if (d > maxDist) {
                            maxAngle = angle;
                            maxDist = d;
                            maxX = x;
                            maxY = y;
                        }
                        if (dd <= (minDist + maxDist) / 2) {
                            a1 = ta - Math.atan2(minY * bendDir, minX);
                            a2 = minAngle * bendDir;
                        } else {
                            a1 = ta - Math.atan2(maxY * bendDir, maxX);
                            a2 = maxAngle * bendDir;
                        }
                    }
                    var os = Math.atan2(cy, cx) * s2;
                    var rotation = parent.arotation;
                    a1 = (a1 - os) * spine.MathUtils.radDeg + os1 - rotation;
                    a1 > 180 ? a1 -= 360 : a1 < -180 && (a1 += 360);
                    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.ascaleX, parent.ascaleY, 0, 0);
                    rotation = child.arotation;
                    a2 = ((a2 + os) * spine.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;
                    a2 > 180 ? a2 -= 360 : a2 < -180 && (a2 += 360);
                    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);
                };
                return IkConstraint;
            })();
            spine.IkConstraint = IkConstraint;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var IkConstraintData = (function() {
                function IkConstraintData(name) {
                    this.order = 0;
                    this.bones = new Array();
                    this.bendDirection = 1;
                    this.mix = 1;
                    this.name = name;
                }
                return IkConstraintData;
            })();
            spine.IkConstraintData = IkConstraintData;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var PathConstraint = (function() {
                function PathConstraint(data, skeleton) {
                    this.position = 0;
                    this.spacing = 0;
                    this.rotateMix = 0;
                    this.translateMix = 0;
                    this.spaces = new Array();
                    this.positions = new Array();
                    this.world = new Array();
                    this.curves = new Array();
                    this.lengths = new Array();
                    this.segments = new Array();
                    if (null == data) {
                        throw new Error("data cannot be null.");
                    }
                    if (null == skeleton) {
                        throw new Error("skeleton cannot be null.");
                    }
                    this.data = data;
                    this.bones = new Array();
                    for (var i = 0, n = data.bones.length; i < n; i++) {
                        this.bones.push(skeleton.findBone(data.bones[i].name));
                    }
                    this.target = skeleton.findSlot(data.target.name);
                    this.position = data.position;
                    this.spacing = data.spacing;
                    this.rotateMix = data.rotateMix;
                    this.translateMix = data.translateMix;
                }
                PathConstraint.prototype.apply = function() {
                    this.update();
                };
                PathConstraint.prototype.update = function() {
                    var attachment = this.target.getAttachment();
                    if (!(attachment instanceof spine.PathAttachment)) {
                        return;
                    }
                    var rotateMix = this.rotateMix, translateMix = this.translateMix;
                    var translate = translateMix > 0, rotate = rotateMix > 0;
                    if (!translate && !rotate) {
                        return;
                    }
                    var data = this.data;
                    var spacingMode = data.spacingMode;
                    var lengthSpacing = spacingMode == spine.SpacingMode.Length;
                    var rotateMode = data.rotateMode;
                    var tangents = rotateMode == spine.RotateMode.Tangent, scale = rotateMode == spine.RotateMode.ChainScale;
                    var boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;
                    var bones = this.bones;
                    var spaces = spine.Utils.setArraySize(this.spaces, spacesCount), lengths = null;
                    var spacing = this.spacing;
                    if (scale || lengthSpacing) {
                        scale && (lengths = spine.Utils.setArraySize(this.lengths, boneCount));
                        for (var i = 0, n = spacesCount - 1; i < n; ) {
                            var bone = bones[i];
                            var length_1 = bone.data.length, x = length_1 * bone.a, y = length_1 * bone.c;
                            length_1 = Math.sqrt(x * x + y * y);
                            scale && (lengths[i] = length_1);
                            spaces[++i] = lengthSpacing ? Math.max(0, length_1 + spacing) : spacing;
                        }
                    } else {
                        for (var i = 1; i < spacesCount; i++) {
                            spaces[i] = spacing;
                        }
                    }
                    var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == spine.PositionMode.Percent, spacingMode == spine.SpacingMode.Percent);
                    var boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;
                    var tip = false;
                    if (0 == offsetRotation) {
                        tip = rotateMode == spine.RotateMode.Chain;
                    } else {
                        tip = false;
                        var p = this.target.bone;
                        offsetRotation *= p.a * p.d - p.b * p.c > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;
                    }
                    for (var i = 0, p = 3; i < boneCount; i++, p += 3) {
                        var bone = bones[i];
                        bone.worldX += (boneX - bone.worldX) * translateMix;
                        bone.worldY += (boneY - bone.worldY) * translateMix;
                        var x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;
                        if (scale) {
                            var length_2 = lengths[i];
                            if (0 != length_2) {
                                var s = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;
                                bone.a *= s;
                                bone.c *= s;
                            }
                        }
                        boneX = x;
                        boneY = y;
                        if (rotate) {
                            var a = bone.a, b = bone.b, c = bone.c, d = bone.d, r = 0, cos = 0, sin = 0;
                            r = tangents ? positions[p - 1] : 0 == spaces[i + 1] ? positions[p + 2] : Math.atan2(dy, dx);
                            r -= Math.atan2(c, a);
                            if (tip) {
                                cos = Math.cos(r);
                                sin = Math.sin(r);
                                var length_3 = bone.data.length;
                                boneX += (length_3 * (cos * a - sin * c) - dx) * rotateMix;
                                boneY += (length_3 * (sin * a + cos * c) - dy) * rotateMix;
                            } else {
                                r += offsetRotation;
                            }
                            r > spine.MathUtils.PI ? r -= spine.MathUtils.PI2 : r < -spine.MathUtils.PI && (r += spine.MathUtils.PI2);
                            r *= rotateMix;
                            cos = Math.cos(r);
                            sin = Math.sin(r);
                            bone.a = cos * a - sin * c;
                            bone.b = cos * b - sin * d;
                            bone.c = sin * a + cos * c;
                            bone.d = sin * b + cos * d;
                        }
                        bone.appliedValid = false;
                    }
                };
                PathConstraint.prototype.computeWorldPositions = function(path, spacesCount, tangents, percentPosition, percentSpacing) {
                    var target = this.target;
                    var position = this.position;
                    var spaces = this.spaces, out = spine.Utils.setArraySize(this.positions, 3 * spacesCount + 2), world = null;
                    var closed = path.closed;
                    var verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;
                    if (!path.constantSpeed) {
                        var lengths = path.lengths;
                        curveCount -= closed ? 1 : 2;
                        var pathLength_1 = lengths[curveCount];
                        percentPosition && (position *= pathLength_1);
                        if (percentSpacing) {
                            for (var i = 0; i < spacesCount; i++) {
                                spaces[i] *= pathLength_1;
                            }
                        }
                        world = spine.Utils.setArraySize(this.world, 8);
                        for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {
                            var space = spaces[i];
                            position += space;
                            var p = position;
                            if (closed) {
                                p %= pathLength_1;
                                p < 0 && (p += pathLength_1);
                                curve = 0;
                            } else {
                                if (p < 0) {
                                    if (prevCurve != PathConstraint.BEFORE) {
                                        prevCurve = PathConstraint.BEFORE;
                                        path.computeWorldVerticesWith(target, 2, 4, world, 0);
                                    }
                                    this.addBeforePosition(p, world, 0, out, o);
                                    continue;
                                }
                                if (p > pathLength_1) {
                                    if (prevCurve != PathConstraint.AFTER) {
                                        prevCurve = PathConstraint.AFTER;
                                        path.computeWorldVerticesWith(target, verticesLength - 6, 4, world, 0);
                                    }
                                    this.addAfterPosition(p - pathLength_1, world, 0, out, o);
                                    continue;
                                }
                            }
                            for (;;curve++) {
                                var length_4 = lengths[curve];
                                if (p > length_4) {
                                    continue;
                                }
                                if (0 == curve) {
                                    p /= length_4;
                                } else {
                                    var prev = lengths[curve - 1];
                                    p = (p - prev) / (length_4 - prev);
                                }
                                break;
                            }
                            if (curve != prevCurve) {
                                prevCurve = curve;
                                if (closed && curve == curveCount) {
                                    path.computeWorldVerticesWith(target, verticesLength - 4, 4, world, 0);
                                    path.computeWorldVerticesWith(target, 0, 4, world, 4);
                                } else {
                                    path.computeWorldVerticesWith(target, 6 * curve + 2, 8, world, 0);
                                }
                            }
                            this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && 0 == space);
                        }
                        return out;
                    }
                    if (closed) {
                        verticesLength += 2;
                        world = spine.Utils.setArraySize(this.world, verticesLength);
                        path.computeWorldVerticesWith(target, 2, verticesLength - 4, world, 0);
                        path.computeWorldVerticesWith(target, 0, 2, world, verticesLength - 4);
                        world[verticesLength - 2] = world[0];
                        world[verticesLength - 1] = world[1];
                    } else {
                        curveCount--;
                        verticesLength -= 4;
                        world = spine.Utils.setArraySize(this.world, verticesLength);
                        path.computeWorldVerticesWith(target, 2, verticesLength, world, 0);
                    }
                    var curves = spine.Utils.setArraySize(this.curves, curveCount);
                    var pathLength = 0;
                    var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
                    var tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;
                    for (var i = 0, w = 2; i < curveCount; i++, w += 6) {
                        cx1 = world[w];
                        cy1 = world[w + 1];
                        cx2 = world[w + 2];
                        cy2 = world[w + 3];
                        x2 = world[w + 4];
                        y2 = world[w + 5];
                        tmpx = .1875 * (x1 - 2 * cx1 + cx2);
                        tmpy = .1875 * (y1 - 2 * cy1 + cy2);
                        dddfx = .09375 * (3 * (cx1 - cx2) - x1 + x2);
                        dddfy = .09375 * (3 * (cy1 - cy2) - y1 + y2);
                        ddfx = 2 * tmpx + dddfx;
                        ddfy = 2 * tmpy + dddfy;
                        dfx = .75 * (cx1 - x1) + tmpx + .16666667 * dddfx;
                        dfy = .75 * (cy1 - y1) + tmpy + .16666667 * dddfy;
                        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        dfx += ddfx;
                        dfy += ddfy;
                        ddfx += dddfx;
                        ddfy += dddfy;
                        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        dfx += ddfx;
                        dfy += ddfy;
                        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        dfx += ddfx + dddfx;
                        dfy += ddfy + dddfy;
                        pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
                        curves[i] = pathLength;
                        x1 = x2;
                        y1 = y2;
                    }
                    percentPosition && (position *= pathLength);
                    if (percentSpacing) {
                        for (var i = 0; i < spacesCount; i++) {
                            spaces[i] *= pathLength;
                        }
                    }
                    var segments = this.segments;
                    var curveLength = 0;
                    for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {
                        var space = spaces[i];
                        position += space;
                        var p = position;
                        if (closed) {
                            p %= pathLength;
                            p < 0 && (p += pathLength);
                            curve = 0;
                        } else {
                            if (p < 0) {
                                this.addBeforePosition(p, world, 0, out, o);
                                continue;
                            }
                            if (p > pathLength) {
                                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
                                continue;
                            }
                        }
                        for (;;curve++) {
                            var length_5 = curves[curve];
                            if (p > length_5) {
                                continue;
                            }
                            if (0 == curve) {
                                p /= length_5;
                            } else {
                                var prev = curves[curve - 1];
                                p = (p - prev) / (length_5 - prev);
                            }
                            break;
                        }
                        if (curve != prevCurve) {
                            prevCurve = curve;
                            var ii = 6 * curve;
                            x1 = world[ii];
                            y1 = world[ii + 1];
                            cx1 = world[ii + 2];
                            cy1 = world[ii + 3];
                            cx2 = world[ii + 4];
                            cy2 = world[ii + 5];
                            x2 = world[ii + 6];
                            y2 = world[ii + 7];
                            tmpx = .03 * (x1 - 2 * cx1 + cx2);
                            tmpy = .03 * (y1 - 2 * cy1 + cy2);
                            dddfx = .006 * (3 * (cx1 - cx2) - x1 + x2);
                            dddfy = .006 * (3 * (cy1 - cy2) - y1 + y2);
                            ddfx = 2 * tmpx + dddfx;
                            ddfy = 2 * tmpy + dddfy;
                            dfx = .3 * (cx1 - x1) + tmpx + .16666667 * dddfx;
                            dfy = .3 * (cy1 - y1) + tmpy + .16666667 * dddfy;
                            curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
                            segments[0] = curveLength;
                            for (ii = 1; ii < 8; ii++) {
                                dfx += ddfx;
                                dfy += ddfy;
                                ddfx += dddfx;
                                ddfy += dddfy;
                                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                                segments[ii] = curveLength;
                            }
                            dfx += ddfx;
                            dfy += ddfy;
                            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                            segments[8] = curveLength;
                            dfx += ddfx + dddfx;
                            dfy += ddfy + dddfy;
                            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
                            segments[9] = curveLength;
                            segment = 0;
                        }
                        p *= curveLength;
                        for (;;segment++) {
                            var length_6 = segments[segment];
                            if (p > length_6) {
                                continue;
                            }
                            if (0 == segment) {
                                p /= length_6;
                            } else {
                                var prev = segments[segment - 1];
                                p = segment + (p - prev) / (length_6 - prev);
                            }
                            break;
                        }
                        this.addCurvePosition(.1 * p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && 0 == space);
                    }
                    return out;
                };
                PathConstraint.prototype.addBeforePosition = function(p, temp, i, out, o) {
                    var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);
                    out[o] = x1 + p * Math.cos(r);
                    out[o + 1] = y1 + p * Math.sin(r);
                    out[o + 2] = r;
                };
                PathConstraint.prototype.addAfterPosition = function(p, temp, i, out, o) {
                    var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);
                    out[o] = x1 + p * Math.cos(r);
                    out[o + 1] = y1 + p * Math.sin(r);
                    out[o + 2] = r;
                };
                PathConstraint.prototype.addCurvePosition = function(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
                    (0 == p || isNaN(p)) && (p = 1e-4);
                    var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;
                    var ut = u * p, ut3 = 3 * ut, uut3 = u * ut3, utt3 = ut3 * p;
                    var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
                    out[o] = x;
                    out[o + 1] = y;
                    tangents && (out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt)));
                };
                PathConstraint.prototype.getOrder = function() {
                    return this.data.order;
                };
                PathConstraint.NONE = -1;
                PathConstraint.BEFORE = -2;
                PathConstraint.AFTER = -3;
                return PathConstraint;
            })();
            spine.PathConstraint = PathConstraint;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var PathConstraintData = (function() {
                function PathConstraintData(name) {
                    this.order = 0;
                    this.bones = new Array();
                    this.name = name;
                }
                return PathConstraintData;
            })();
            spine.PathConstraintData = PathConstraintData;
            (function(PositionMode) {
                PositionMode[PositionMode["Fixed"] = 0] = "Fixed";
                PositionMode[PositionMode["Percent"] = 1] = "Percent";
            })(spine.PositionMode || (spine.PositionMode = {}));
            var PositionMode = spine.PositionMode;
            (function(SpacingMode) {
                SpacingMode[SpacingMode["Length"] = 0] = "Length";
                SpacingMode[SpacingMode["Fixed"] = 1] = "Fixed";
                SpacingMode[SpacingMode["Percent"] = 2] = "Percent";
            })(spine.SpacingMode || (spine.SpacingMode = {}));
            var SpacingMode = spine.SpacingMode;
            (function(RotateMode) {
                RotateMode[RotateMode["Tangent"] = 0] = "Tangent";
                RotateMode[RotateMode["Chain"] = 1] = "Chain";
                RotateMode[RotateMode["ChainScale"] = 2] = "ChainScale";
            })(spine.RotateMode || (spine.RotateMode = {}));
            var RotateMode = spine.RotateMode;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var Assets = (function() {
                function Assets(clientId) {
                    this.toLoad = new Array();
                    this.assets = {};
                    this.clientId = clientId;
                }
                Assets.prototype.loaded = function() {
                    var i = 0;
                    for (var v in this.assets) {
                        i++;
                    }
                    return i;
                };
                return Assets;
            })();
            var SharedAssetManager = (function() {
                function SharedAssetManager(pathPrefix) {
                    void 0 === pathPrefix && (pathPrefix = "");
                    this.clientAssets = {};
                    this.queuedAssets = {};
                    this.rawAssets = {};
                    this.errors = {};
                    this.pathPrefix = pathPrefix;
                }
                SharedAssetManager.prototype.queueAsset = function(clientId, textureLoader, path) {
                    var clientAssets = this.clientAssets[clientId];
                    if (null === clientAssets || void 0 === clientAssets) {
                        clientAssets = new Assets(clientId);
                        this.clientAssets[clientId] = clientAssets;
                    }
                    null !== textureLoader && (clientAssets.textureLoader = textureLoader);
                    clientAssets.toLoad.push(path);
                    if (this.queuedAssets[path] === path) {
                        return false;
                    }
                    this.queuedAssets[path] = path;
                    return true;
                };
                SharedAssetManager.prototype.loadText = function(clientId, path) {
                    var _this = this;
                    path = this.pathPrefix + path;
                    if (!this.queueAsset(clientId, null, path)) {
                        return;
                    }
                    var request = new XMLHttpRequest();
                    request.onreadystatechange = function() {
                        request.readyState == XMLHttpRequest.DONE && (request.status >= 200 && request.status < 300 ? _this.rawAssets[path] = request.responseText : _this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText);
                    };
                    request.open("GET", path, true);
                    request.send();
                };
                SharedAssetManager.prototype.loadJson = function(clientId, path) {
                    var _this = this;
                    path = this.pathPrefix + path;
                    if (!this.queueAsset(clientId, null, path)) {
                        return;
                    }
                    var request = new XMLHttpRequest();
                    request.onreadystatechange = function() {
                        request.readyState == XMLHttpRequest.DONE && (request.status >= 200 && request.status < 300 ? _this.rawAssets[path] = JSON.parse(request.responseText) : _this.errors[path] = "Couldn't load text " + path + ": status " + request.status + ", " + request.responseText);
                    };
                    request.open("GET", path, true);
                    request.send();
                };
                SharedAssetManager.prototype.loadTexture = function(clientId, textureLoader, path) {
                    var _this = this;
                    path = this.pathPrefix + path;
                    if (!this.queueAsset(clientId, textureLoader, path)) {
                        return;
                    }
                    var img = new Image();
                    img.src = path;
                    img.crossOrigin = "anonymous";
                    img.onload = function(ev) {
                        _this.rawAssets[path] = img;
                    };
                    img.onerror = function(ev) {
                        _this.errors[path] = "Couldn't load image " + path;
                    };
                };
                SharedAssetManager.prototype.get = function(clientId, path) {
                    path = this.pathPrefix + path;
                    var clientAssets = this.clientAssets[clientId];
                    if (null === clientAssets || void 0 === clientAssets) {
                        return true;
                    }
                    return clientAssets.assets[path];
                };
                SharedAssetManager.prototype.updateClientAssets = function(clientAssets) {
                    for (var i = 0; i < clientAssets.toLoad.length; i++) {
                        var path = clientAssets.toLoad[i];
                        var asset = clientAssets.assets[path];
                        if (null === asset || void 0 === asset) {
                            var rawAsset = this.rawAssets[path];
                            if (null === rawAsset || void 0 === rawAsset) {
                                continue;
                            }
                            rawAsset instanceof HTMLImageElement ? clientAssets.assets[path] = clientAssets.textureLoader(rawAsset) : clientAssets.assets[path] = rawAsset;
                        }
                    }
                };
                SharedAssetManager.prototype.isLoadingComplete = function(clientId) {
                    var clientAssets = this.clientAssets[clientId];
                    if (null === clientAssets || void 0 === clientAssets) {
                        return true;
                    }
                    this.updateClientAssets(clientAssets);
                    return clientAssets.toLoad.length == clientAssets.loaded();
                };
                SharedAssetManager.prototype.dispose = function() {};
                SharedAssetManager.prototype.hasErrors = function() {
                    return Object.keys(this.errors).length > 0;
                };
                SharedAssetManager.prototype.getErrors = function() {
                    return this.errors;
                };
                return SharedAssetManager;
            })();
            spine.SharedAssetManager = SharedAssetManager;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var Skeleton = (function() {
                function Skeleton(data) {
                    this._updateCache = new Array();
                    this.updateCacheReset = new Array();
                    this.time = 0;
                    this.flipX = false;
                    this.flipY = false;
                    this.x = 0;
                    this.y = 0;
                    if (null == data) {
                        throw new Error("data cannot be null.");
                    }
                    this.data = data;
                    this.bones = new Array();
                    for (var i = 0; i < data.bones.length; i++) {
                        var boneData = data.bones[i];
                        var bone = void 0;
                        if (null == boneData.parent) {
                            bone = new spine.Bone(boneData, this, null);
                        } else {
                            var parent_1 = this.bones[boneData.parent.index];
                            bone = new spine.Bone(boneData, this, parent_1);
                            parent_1.children.push(bone);
                        }
                        this.bones.push(bone);
                    }
                    this.slots = new Array();
                    this.drawOrder = new Array();
                    for (var i = 0; i < data.slots.length; i++) {
                        var slotData = data.slots[i];
                        var bone = this.bones[slotData.boneData.index];
                        var slot = new spine.Slot(slotData, bone);
                        this.slots.push(slot);
                        this.drawOrder.push(slot);
                    }
                    this.ikConstraints = new Array();
                    for (var i = 0; i < data.ikConstraints.length; i++) {
                        var ikConstraintData = data.ikConstraints[i];
                        this.ikConstraints.push(new spine.IkConstraint(ikConstraintData, this));
                    }
                    this.transformConstraints = new Array();
                    for (var i = 0; i < data.transformConstraints.length; i++) {
                        var transformConstraintData = data.transformConstraints[i];
                        this.transformConstraints.push(new spine.TransformConstraint(transformConstraintData, this));
                    }
                    this.pathConstraints = new Array();
                    for (var i = 0; i < data.pathConstraints.length; i++) {
                        var pathConstraintData = data.pathConstraints[i];
                        this.pathConstraints.push(new spine.PathConstraint(pathConstraintData, this));
                    }
                    this.color = new spine.Color(1, 1, 1, 1);
                    this.updateCache();
                }
                Skeleton.prototype.updateCache = function() {
                    var updateCache = this._updateCache;
                    updateCache.length = 0;
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        bones[i].sorted = false;
                    }
                    var ikConstraints = this.ikConstraints;
                    var transformConstraints = this.transformConstraints;
                    var pathConstraints = this.pathConstraints;
                    var ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;
                    var constraintCount = ikCount + transformCount + pathCount;
                    outer: for (var i = 0; i < constraintCount; i++) {
                        for (var ii = 0; ii < ikCount; ii++) {
                            var constraint = ikConstraints[ii];
                            if (constraint.data.order == i) {
                                this.sortIkConstraint(constraint);
                                continue outer;
                            }
                        }
                        for (var ii = 0; ii < transformCount; ii++) {
                            var constraint = transformConstraints[ii];
                            if (constraint.data.order == i) {
                                this.sortTransformConstraint(constraint);
                                continue outer;
                            }
                        }
                        for (var ii = 0; ii < pathCount; ii++) {
                            var constraint = pathConstraints[ii];
                            if (constraint.data.order == i) {
                                this.sortPathConstraint(constraint);
                                continue outer;
                            }
                        }
                    }
                    for (var i = 0, n = bones.length; i < n; i++) {
                        this.sortBone(bones[i]);
                    }
                };
                Skeleton.prototype.sortIkConstraint = function(constraint) {
                    var target = constraint.target;
                    this.sortBone(target);
                    var constrained = constraint.bones;
                    var parent = constrained[0];
                    this.sortBone(parent);
                    if (constrained.length > 1) {
                        var child = constrained[constrained.length - 1];
                        this._updateCache.indexOf(child) > -1 || this.updateCacheReset.push(child);
                    }
                    this._updateCache.push(constraint);
                    this.sortReset(parent.children);
                    constrained[constrained.length - 1].sorted = true;
                };
                Skeleton.prototype.sortPathConstraint = function(constraint) {
                    var slot = constraint.target;
                    var slotIndex = slot.data.index;
                    var slotBone = slot.bone;
                    null != this.skin && this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);
                    null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);
                    for (var ii = 0, nn = this.data.skins.length; ii < nn; ii++) {
                        this.sortPathConstraintAttachment(this.data.skins[ii], slotIndex, slotBone);
                    }
                    var attachment = slot.getAttachment();
                    attachment instanceof spine.PathAttachment && this.sortPathConstraintAttachmentWith(attachment, slotBone);
                    var constrained = constraint.bones;
                    var boneCount = constrained.length;
                    for (var ii = 0; ii < boneCount; ii++) {
                        this.sortBone(constrained[ii]);
                    }
                    this._updateCache.push(constraint);
                    for (var ii = 0; ii < boneCount; ii++) {
                        this.sortReset(constrained[ii].children);
                    }
                    for (var ii = 0; ii < boneCount; ii++) {
                        constrained[ii].sorted = true;
                    }
                };
                Skeleton.prototype.sortTransformConstraint = function(constraint) {
                    this.sortBone(constraint.target);
                    var constrained = constraint.bones;
                    var boneCount = constrained.length;
                    for (var ii = 0; ii < boneCount; ii++) {
                        this.sortBone(constrained[ii]);
                    }
                    this._updateCache.push(constraint);
                    for (var ii = 0; ii < boneCount; ii++) {
                        this.sortReset(constrained[ii].children);
                    }
                    for (var ii = 0; ii < boneCount; ii++) {
                        constrained[ii].sorted = true;
                    }
                };
                Skeleton.prototype.sortPathConstraintAttachment = function(skin, slotIndex, slotBone) {
                    var attachments = skin.attachments[slotIndex];
                    if (!attachments) {
                        return;
                    }
                    for (var key in attachments) {
                        this.sortPathConstraintAttachmentWith(attachments[key], slotBone);
                    }
                };
                Skeleton.prototype.sortPathConstraintAttachmentWith = function(attachment, slotBone) {
                    if (!(attachment instanceof spine.PathAttachment)) {
                        return;
                    }
                    var pathBones = attachment.bones;
                    if (null == pathBones) {
                        this.sortBone(slotBone);
                    } else {
                        var bones = this.bones;
                        var i = 0;
                        while (i < pathBones.length) {
                            var boneCount = pathBones[i++];
                            for (var n = i + boneCount; i < n; i++) {
                                var boneIndex = pathBones[i];
                                this.sortBone(bones[boneIndex]);
                            }
                        }
                    }
                };
                Skeleton.prototype.sortBone = function(bone) {
                    if (bone.sorted) {
                        return;
                    }
                    var parent = bone.parent;
                    null != parent && this.sortBone(parent);
                    bone.sorted = true;
                    this._updateCache.push(bone);
                };
                Skeleton.prototype.sortReset = function(bones) {
                    for (var i = 0, n = bones.length; i < n; i++) {
                        var bone = bones[i];
                        bone.sorted && this.sortReset(bone.children);
                        bone.sorted = false;
                    }
                };
                Skeleton.prototype.updateWorldTransform = function() {
                    var updateCacheReset = this.updateCacheReset;
                    for (var i = 0, n = updateCacheReset.length; i < n; i++) {
                        var bone = updateCacheReset[i];
                        bone.ax = bone.x;
                        bone.ay = bone.y;
                        bone.arotation = bone.rotation;
                        bone.ascaleX = bone.scaleX;
                        bone.ascaleY = bone.scaleY;
                        bone.ashearX = bone.shearX;
                        bone.ashearY = bone.shearY;
                        bone.appliedValid = true;
                    }
                    var updateCache = this._updateCache;
                    for (var i = 0, n = updateCache.length; i < n; i++) {
                        updateCache[i].update();
                    }
                };
                Skeleton.prototype.setToSetupPose = function() {
                    this.setBonesToSetupPose();
                    this.setSlotsToSetupPose();
                };
                Skeleton.prototype.setBonesToSetupPose = function() {
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        bones[i].setToSetupPose();
                    }
                    var ikConstraints = this.ikConstraints;
                    for (var i = 0, n = ikConstraints.length; i < n; i++) {
                        var constraint = ikConstraints[i];
                        constraint.bendDirection = constraint.data.bendDirection;
                        constraint.mix = constraint.data.mix;
                    }
                    var transformConstraints = this.transformConstraints;
                    for (var i = 0, n = transformConstraints.length; i < n; i++) {
                        var constraint = transformConstraints[i];
                        var data = constraint.data;
                        constraint.rotateMix = data.rotateMix;
                        constraint.translateMix = data.translateMix;
                        constraint.scaleMix = data.scaleMix;
                        constraint.shearMix = data.shearMix;
                    }
                    var pathConstraints = this.pathConstraints;
                    for (var i = 0, n = pathConstraints.length; i < n; i++) {
                        var constraint = pathConstraints[i];
                        var data = constraint.data;
                        constraint.position = data.position;
                        constraint.spacing = data.spacing;
                        constraint.rotateMix = data.rotateMix;
                        constraint.translateMix = data.translateMix;
                    }
                };
                Skeleton.prototype.setSlotsToSetupPose = function() {
                    var slots = this.slots;
                    spine.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);
                    for (var i = 0, n = slots.length; i < n; i++) {
                        slots[i].setToSetupPose();
                    }
                };
                Skeleton.prototype.getRootBone = function() {
                    if (0 == this.bones.length) {
                        return null;
                    }
                    return this.bones[0];
                };
                Skeleton.prototype.findBone = function(boneName) {
                    if (null == boneName) {
                        throw new Error("boneName cannot be null.");
                    }
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        var bone = bones[i];
                        if (bone.data.name == boneName) {
                            return bone;
                        }
                    }
                    return null;
                };
                Skeleton.prototype.findBoneIndex = function(boneName) {
                    if (null == boneName) {
                        throw new Error("boneName cannot be null.");
                    }
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        if (bones[i].data.name == boneName) {
                            return i;
                        }
                    }
                    return -1;
                };
                Skeleton.prototype.findSlot = function(slotName) {
                    if (null == slotName) {
                        throw new Error("slotName cannot be null.");
                    }
                    var slots = this.slots;
                    for (var i = 0, n = slots.length; i < n; i++) {
                        var slot = slots[i];
                        if (slot.data.name == slotName) {
                            return slot;
                        }
                    }
                    return null;
                };
                Skeleton.prototype.findSlotIndex = function(slotName) {
                    if (null == slotName) {
                        throw new Error("slotName cannot be null.");
                    }
                    var slots = this.slots;
                    for (var i = 0, n = slots.length; i < n; i++) {
                        if (slots[i].data.name == slotName) {
                            return i;
                        }
                    }
                    return -1;
                };
                Skeleton.prototype.setSkinByName = function(skinName) {
                    var skin = this.data.findSkin(skinName);
                    if (null == skin) {
                        throw new Error("Skin not found: " + skinName);
                    }
                    this.setSkin(skin);
                };
                Skeleton.prototype.setSkin = function(newSkin) {
                    if (null != newSkin) {
                        if (null != this.skin) {
                            newSkin.attachAll(this, this.skin);
                        } else {
                            var slots = this.slots;
                            for (var i = 0, n = slots.length; i < n; i++) {
                                var slot = slots[i];
                                var name_1 = slot.data.attachmentName;
                                if (null != name_1) {
                                    var attachment = newSkin.getAttachment(i, name_1);
                                    null != attachment && slot.setAttachment(attachment);
                                }
                            }
                        }
                    }
                    this.skin = newSkin;
                };
                Skeleton.prototype.getAttachmentByName = function(slotName, attachmentName) {
                    return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);
                };
                Skeleton.prototype.getAttachment = function(slotIndex, attachmentName) {
                    if (null == attachmentName) {
                        throw new Error("attachmentName cannot be null.");
                    }
                    if (null != this.skin) {
                        var attachment = this.skin.getAttachment(slotIndex, attachmentName);
                        if (null != attachment) {
                            return attachment;
                        }
                    }
                    if (null != this.data.defaultSkin) {
                        return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);
                    }
                    return null;
                };
                Skeleton.prototype.setAttachment = function(slotName, attachmentName) {
                    if (null == slotName) {
                        throw new Error("slotName cannot be null.");
                    }
                    var slots = this.slots;
                    for (var i = 0, n = slots.length; i < n; i++) {
                        var slot = slots[i];
                        if (slot.data.name == slotName) {
                            var attachment = null;
                            if (null != attachmentName) {
                                attachment = this.getAttachment(i, attachmentName);
                                if (null == attachment) {
                                    throw new Error("Attachment not found: " + attachmentName + ", for slot: " + slotName);
                                }
                            }
                            slot.setAttachment(attachment);
                            return;
                        }
                    }
                    throw new Error("Slot not found: " + slotName);
                };
                Skeleton.prototype.findIkConstraint = function(constraintName) {
                    if (null == constraintName) {
                        throw new Error("constraintName cannot be null.");
                    }
                    var ikConstraints = this.ikConstraints;
                    for (var i = 0, n = ikConstraints.length; i < n; i++) {
                        var ikConstraint = ikConstraints[i];
                        if (ikConstraint.data.name == constraintName) {
                            return ikConstraint;
                        }
                    }
                    return null;
                };
                Skeleton.prototype.findTransformConstraint = function(constraintName) {
                    if (null == constraintName) {
                        throw new Error("constraintName cannot be null.");
                    }
                    var transformConstraints = this.transformConstraints;
                    for (var i = 0, n = transformConstraints.length; i < n; i++) {
                        var constraint = transformConstraints[i];
                        if (constraint.data.name == constraintName) {
                            return constraint;
                        }
                    }
                    return null;
                };
                Skeleton.prototype.findPathConstraint = function(constraintName) {
                    if (null == constraintName) {
                        throw new Error("constraintName cannot be null.");
                    }
                    var pathConstraints = this.pathConstraints;
                    for (var i = 0, n = pathConstraints.length; i < n; i++) {
                        var constraint = pathConstraints[i];
                        if (constraint.data.name == constraintName) {
                            return constraint;
                        }
                    }
                    return null;
                };
                Skeleton.prototype.getBounds = function(offset, size) {
                    if (null == offset) {
                        throw new Error("offset cannot be null.");
                    }
                    if (null == size) {
                        throw new Error("size cannot be null.");
                    }
                    var drawOrder = this.drawOrder;
                    var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
                    for (var i = 0, n = drawOrder.length; i < n; i++) {
                        var slot = drawOrder[i];
                        var vertices = null;
                        var attachment = slot.getAttachment();
                        attachment instanceof spine.RegionAttachment ? vertices = attachment.updateWorldVertices(slot, false) : attachment instanceof spine.MeshAttachment && (vertices = attachment.updateWorldVertices(slot, true));
                        if (null != vertices) {
                            for (var ii = 0, nn = vertices.length; ii < nn; ii += 8) {
                                var x = vertices[ii], y = vertices[ii + 1];
                                minX = Math.min(minX, x);
                                minY = Math.min(minY, y);
                                maxX = Math.max(maxX, x);
                                maxY = Math.max(maxY, y);
                            }
                        }
                    }
                    offset.set(minX, minY);
                    size.set(maxX - minX, maxY - minY);
                };
                Skeleton.prototype.update = function(delta) {
                    this.time += delta;
                };
                return Skeleton;
            })();
            spine.Skeleton = Skeleton;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var SkeletonBounds = (function() {
                function SkeletonBounds() {
                    this.minX = 0;
                    this.minY = 0;
                    this.maxX = 0;
                    this.maxY = 0;
                    this.boundingBoxes = new Array();
                    this.polygons = new Array();
                    this.polygonPool = new spine.Pool(function() {
                        return spine.Utils.newFloatArray(16);
                    });
                }
                SkeletonBounds.prototype.update = function(skeleton, updateAabb) {
                    if (null == skeleton) {
                        throw new Error("skeleton cannot be null.");
                    }
                    var boundingBoxes = this.boundingBoxes;
                    var polygons = this.polygons;
                    var polygonPool = this.polygonPool;
                    var slots = skeleton.slots;
                    var slotCount = slots.length;
                    boundingBoxes.length = 0;
                    polygonPool.freeAll(polygons);
                    polygons.length = 0;
                    for (var i = 0; i < slotCount; i++) {
                        var slot = slots[i];
                        var attachment = slot.getAttachment();
                        if (attachment instanceof spine.BoundingBoxAttachment) {
                            var boundingBox = attachment;
                            boundingBoxes.push(boundingBox);
                            var polygon = polygonPool.obtain();
                            polygon.length != boundingBox.worldVerticesLength && (polygon = spine.Utils.newFloatArray(boundingBox.worldVerticesLength));
                            polygons.push(polygon);
                            boundingBox.computeWorldVertices(slot, polygon);
                        }
                    }
                    if (updateAabb) {
                        this.aabbCompute();
                    } else {
                        this.minX = Number.POSITIVE_INFINITY;
                        this.minY = Number.POSITIVE_INFINITY;
                        this.maxX = Number.NEGATIVE_INFINITY;
                        this.maxY = Number.NEGATIVE_INFINITY;
                    }
                };
                SkeletonBounds.prototype.aabbCompute = function() {
                    var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
                    var polygons = this.polygons;
                    for (var i = 0, n = polygons.length; i < n; i++) {
                        var polygon = polygons[i];
                        var vertices = polygon;
                        for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {
                            var x = vertices[ii];
                            var y = vertices[ii + 1];
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                    }
                    this.minX = minX;
                    this.minY = minY;
                    this.maxX = maxX;
                    this.maxY = maxY;
                };
                SkeletonBounds.prototype.aabbContainsPoint = function(x, y) {
                    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;
                };
                SkeletonBounds.prototype.aabbIntersectsSegment = function(x1, y1, x2, y2) {
                    var minX = this.minX;
                    var minY = this.minY;
                    var maxX = this.maxX;
                    var maxY = this.maxY;
                    if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) {
                        return false;
                    }
                    var m = (y2 - y1) / (x2 - x1);
                    var y = m * (minX - x1) + y1;
                    if (y > minY && y < maxY) {
                        return true;
                    }
                    y = m * (maxX - x1) + y1;
                    if (y > minY && y < maxY) {
                        return true;
                    }
                    var x = (minY - y1) / m + x1;
                    if (x > minX && x < maxX) {
                        return true;
                    }
                    x = (maxY - y1) / m + x1;
                    if (x > minX && x < maxX) {
                        return true;
                    }
                    return false;
                };
                SkeletonBounds.prototype.aabbIntersectsSkeleton = function(bounds) {
                    return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;
                };
                SkeletonBounds.prototype.containsPoint = function(x, y) {
                    var polygons = this.polygons;
                    for (var i = 0, n = polygons.length; i < n; i++) {
                        if (this.containsPointPolygon(polygons[i], x, y)) {
                            return this.boundingBoxes[i];
                        }
                    }
                    return null;
                };
                SkeletonBounds.prototype.containsPointPolygon = function(polygon, x, y) {
                    var vertices = polygon;
                    var nn = polygon.length;
                    var prevIndex = nn - 2;
                    var inside = false;
                    for (var ii = 0; ii < nn; ii += 2) {
                        var vertexY = vertices[ii + 1];
                        var prevY = vertices[prevIndex + 1];
                        if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {
                            var vertexX = vertices[ii];
                            vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x && (inside = !inside);
                        }
                        prevIndex = ii;
                    }
                    return inside;
                };
                SkeletonBounds.prototype.intersectsSegment = function(x1, y1, x2, y2) {
                    var polygons = this.polygons;
                    for (var i = 0, n = polygons.length; i < n; i++) {
                        if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) {
                            return this.boundingBoxes[i];
                        }
                    }
                    return null;
                };
                SkeletonBounds.prototype.intersectsSegmentPolygon = function(polygon, x1, y1, x2, y2) {
                    var vertices = polygon;
                    var nn = polygon.length;
                    var width12 = x1 - x2, height12 = y1 - y2;
                    var det1 = x1 * y2 - y1 * x2;
                    var x3 = vertices[nn - 2], y3 = vertices[nn - 1];
                    for (var ii = 0; ii < nn; ii += 2) {
                        var x4 = vertices[ii], y4 = vertices[ii + 1];
                        var det2 = x3 * y4 - y3 * x4;
                        var width34 = x3 - x4, height34 = y3 - y4;
                        var det3 = width12 * height34 - height12 * width34;
                        var x = (det1 * width34 - width12 * det2) / det3;
                        if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {
                            var y = (det1 * height34 - height12 * det2) / det3;
                            if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1)) {
                                return true;
                            }
                        }
                        x3 = x4;
                        y3 = y4;
                    }
                    return false;
                };
                SkeletonBounds.prototype.getPolygon = function(boundingBox) {
                    if (null == boundingBox) {
                        throw new Error("boundingBox cannot be null.");
                    }
                    var index = this.boundingBoxes.indexOf(boundingBox);
                    return index == -1 ? null : this.polygons[index];
                };
                SkeletonBounds.prototype.getWidth = function() {
                    return this.maxX - this.minX;
                };
                SkeletonBounds.prototype.getHeight = function() {
                    return this.maxY - this.minY;
                };
                return SkeletonBounds;
            })();
            spine.SkeletonBounds = SkeletonBounds;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var SkeletonData = (function() {
                function SkeletonData() {
                    this.bones = new Array();
                    this.slots = new Array();
                    this.skins = new Array();
                    this.events = new Array();
                    this.animations = new Array();
                    this.ikConstraints = new Array();
                    this.transformConstraints = new Array();
                    this.pathConstraints = new Array();
                    this.fps = 0;
                }
                SkeletonData.prototype.findBone = function(boneName) {
                    if (null == boneName) {
                        throw new Error("boneName cannot be null.");
                    }
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        var bone = bones[i];
                        if (bone.name == boneName) {
                            return bone;
                        }
                    }
                    return null;
                };
                SkeletonData.prototype.findBoneIndex = function(boneName) {
                    if (null == boneName) {
                        throw new Error("boneName cannot be null.");
                    }
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        if (bones[i].name == boneName) {
                            return i;
                        }
                    }
                    return -1;
                };
                SkeletonData.prototype.findSlot = function(slotName) {
                    if (null == slotName) {
                        throw new Error("slotName cannot be null.");
                    }
                    var slots = this.slots;
                    for (var i = 0, n = slots.length; i < n; i++) {
                        var slot = slots[i];
                        if (slot.name == slotName) {
                            return slot;
                        }
                    }
                    return null;
                };
                SkeletonData.prototype.findSlotIndex = function(slotName) {
                    if (null == slotName) {
                        throw new Error("slotName cannot be null.");
                    }
                    var slots = this.slots;
                    for (var i = 0, n = slots.length; i < n; i++) {
                        if (slots[i].name == slotName) {
                            return i;
                        }
                    }
                    return -1;
                };
                SkeletonData.prototype.findSkin = function(skinName) {
                    if (null == skinName) {
                        throw new Error("skinName cannot be null.");
                    }
                    var skins = this.skins;
                    for (var i = 0, n = skins.length; i < n; i++) {
                        var skin = skins[i];
                        if (skin.name == skinName) {
                            return skin;
                        }
                    }
                    return null;
                };
                SkeletonData.prototype.findEvent = function(eventDataName) {
                    if (null == eventDataName) {
                        throw new Error("eventDataName cannot be null.");
                    }
                    var events = this.events;
                    for (var i = 0, n = events.length; i < n; i++) {
                        var event_4 = events[i];
                        if (event_4.name == eventDataName) {
                            return event_4;
                        }
                    }
                    return null;
                };
                SkeletonData.prototype.findAnimation = function(animationName) {
                    if (null == animationName) {
                        throw new Error("animationName cannot be null.");
                    }
                    var animations = this.animations;
                    for (var i = 0, n = animations.length; i < n; i++) {
                        var animation = animations[i];
                        if (animation.name == animationName) {
                            return animation;
                        }
                    }
                    return null;
                };
                SkeletonData.prototype.findIkConstraint = function(constraintName) {
                    if (null == constraintName) {
                        throw new Error("constraintName cannot be null.");
                    }
                    var ikConstraints = this.ikConstraints;
                    for (var i = 0, n = ikConstraints.length; i < n; i++) {
                        var constraint = ikConstraints[i];
                        if (constraint.name == constraintName) {
                            return constraint;
                        }
                    }
                    return null;
                };
                SkeletonData.prototype.findTransformConstraint = function(constraintName) {
                    if (null == constraintName) {
                        throw new Error("constraintName cannot be null.");
                    }
                    var transformConstraints = this.transformConstraints;
                    for (var i = 0, n = transformConstraints.length; i < n; i++) {
                        var constraint = transformConstraints[i];
                        if (constraint.name == constraintName) {
                            return constraint;
                        }
                    }
                    return null;
                };
                SkeletonData.prototype.findPathConstraint = function(constraintName) {
                    if (null == constraintName) {
                        throw new Error("constraintName cannot be null.");
                    }
                    var pathConstraints = this.pathConstraints;
                    for (var i = 0, n = pathConstraints.length; i < n; i++) {
                        var constraint = pathConstraints[i];
                        if (constraint.name == constraintName) {
                            return constraint;
                        }
                    }
                    return null;
                };
                SkeletonData.prototype.findPathConstraintIndex = function(pathConstraintName) {
                    if (null == pathConstraintName) {
                        throw new Error("pathConstraintName cannot be null.");
                    }
                    var pathConstraints = this.pathConstraints;
                    for (var i = 0, n = pathConstraints.length; i < n; i++) {
                        if (pathConstraints[i].name == pathConstraintName) {
                            return i;
                        }
                    }
                    return -1;
                };
                return SkeletonData;
            })();
            spine.SkeletonData = SkeletonData;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var SkeletonJson = (function() {
                function SkeletonJson(attachmentLoader) {
                    this.scale = 1;
                    this.linkedMeshes = new Array();
                    this.attachmentLoader = attachmentLoader;
                }
                SkeletonJson.prototype.readSkeletonData = function(json) {
                    var scale = this.scale;
                    var skeletonData = new spine.SkeletonData();
                    var root = "string" === typeof json ? JSON.parse(json) : json;
                    var skeletonMap = root.skeleton;
                    if (null != skeletonMap) {
                        skeletonData.hash = skeletonMap.hash;
                        skeletonData.version = skeletonMap.spine;
                        skeletonData.width = skeletonMap.width;
                        skeletonData.height = skeletonMap.height;
                        skeletonData.fps = skeletonMap.fps;
                        skeletonData.imagesPath = skeletonMap.images;
                    }
                    if (root.bones) {
                        for (var i = 0; i < root.bones.length; i++) {
                            var boneMap = root.bones[i];
                            var parent_2 = null;
                            var parentName = this.getValue(boneMap, "parent", null);
                            if (null != parentName) {
                                parent_2 = skeletonData.findBone(parentName);
                                if (null == parent_2) {
                                    throw new Error("Parent bone not found: " + parentName);
                                }
                            }
                            var data = new spine.BoneData(skeletonData.bones.length, boneMap.name, parent_2);
                            data.length = this.getValue(boneMap, "length", 0) * scale;
                            data.x = this.getValue(boneMap, "x", 0) * scale;
                            data.y = this.getValue(boneMap, "y", 0) * scale;
                            data.rotation = this.getValue(boneMap, "rotation", 0);
                            data.scaleX = this.getValue(boneMap, "scaleX", 1);
                            data.scaleY = this.getValue(boneMap, "scaleY", 1);
                            data.shearX = this.getValue(boneMap, "shearX", 0);
                            data.shearY = this.getValue(boneMap, "shearY", 0);
                            data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, "transform", "normal"));
                            skeletonData.bones.push(data);
                        }
                    }
                    if (root.slots) {
                        for (var i = 0; i < root.slots.length; i++) {
                            var slotMap = root.slots[i];
                            var slotName = slotMap.name;
                            var boneName = slotMap.bone;
                            var boneData = skeletonData.findBone(boneName);
                            if (null == boneData) {
                                throw new Error("Slot bone not found: " + boneName);
                            }
                            var data = new spine.SlotData(skeletonData.slots.length, slotName, boneData);
                            var color = this.getValue(slotMap, "color", null);
                            null != color && data.color.setFromString(color);
                            data.attachmentName = this.getValue(slotMap, "attachment", null);
                            data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, "blend", "normal"));
                            skeletonData.slots.push(data);
                        }
                    }
                    if (root.ik) {
                        for (var i = 0; i < root.ik.length; i++) {
                            var constraintMap = root.ik[i];
                            var data = new spine.IkConstraintData(constraintMap.name);
                            data.order = this.getValue(constraintMap, "order", 0);
                            for (var j = 0; j < constraintMap.bones.length; j++) {
                                var boneName = constraintMap.bones[j];
                                var bone = skeletonData.findBone(boneName);
                                if (null == bone) {
                                    throw new Error("IK bone not found: " + boneName);
                                }
                                data.bones.push(bone);
                            }
                            var targetName = constraintMap.target;
                            data.target = skeletonData.findBone(targetName);
                            if (null == data.target) {
                                throw new Error("IK target bone not found: " + targetName);
                            }
                            data.bendDirection = this.getValue(constraintMap, "bendPositive", true) ? 1 : -1;
                            data.mix = this.getValue(constraintMap, "mix", 1);
                            skeletonData.ikConstraints.push(data);
                        }
                    }
                    if (root.transform) {
                        for (var i = 0; i < root.transform.length; i++) {
                            var constraintMap = root.transform[i];
                            var data = new spine.TransformConstraintData(constraintMap.name);
                            data.order = this.getValue(constraintMap, "order", 0);
                            for (var j = 0; j < constraintMap.bones.length; j++) {
                                var boneName = constraintMap.bones[j];
                                var bone = skeletonData.findBone(boneName);
                                if (null == bone) {
                                    throw new Error("Transform constraint bone not found: " + boneName);
                                }
                                data.bones.push(bone);
                            }
                            var targetName = constraintMap.target;
                            data.target = skeletonData.findBone(targetName);
                            if (null == data.target) {
                                throw new Error("Transform constraint target bone not found: " + targetName);
                            }
                            data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
                            data.offsetX = this.getValue(constraintMap, "x", 0) * scale;
                            data.offsetY = this.getValue(constraintMap, "y", 0) * scale;
                            data.offsetScaleX = this.getValue(constraintMap, "scaleX", 0);
                            data.offsetScaleY = this.getValue(constraintMap, "scaleY", 0);
                            data.offsetShearY = this.getValue(constraintMap, "shearY", 0);
                            data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
                            data.translateMix = this.getValue(constraintMap, "translateMix", 1);
                            data.scaleMix = this.getValue(constraintMap, "scaleMix", 1);
                            data.shearMix = this.getValue(constraintMap, "shearMix", 1);
                            skeletonData.transformConstraints.push(data);
                        }
                    }
                    if (root.path) {
                        for (var i = 0; i < root.path.length; i++) {
                            var constraintMap = root.path[i];
                            var data = new spine.PathConstraintData(constraintMap.name);
                            data.order = this.getValue(constraintMap, "order", 0);
                            for (var j = 0; j < constraintMap.bones.length; j++) {
                                var boneName = constraintMap.bones[j];
                                var bone = skeletonData.findBone(boneName);
                                if (null == bone) {
                                    throw new Error("Transform constraint bone not found: " + boneName);
                                }
                                data.bones.push(bone);
                            }
                            var targetName = constraintMap.target;
                            data.target = skeletonData.findSlot(targetName);
                            if (null == data.target) {
                                throw new Error("Path target slot not found: " + targetName);
                            }
                            data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, "positionMode", "percent"));
                            data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, "spacingMode", "length"));
                            data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, "rotateMode", "tangent"));
                            data.offsetRotation = this.getValue(constraintMap, "rotation", 0);
                            data.position = this.getValue(constraintMap, "position", 0);
                            data.positionMode == spine.PositionMode.Fixed && (data.position *= scale);
                            data.spacing = this.getValue(constraintMap, "spacing", 0);
                            data.spacingMode != spine.SpacingMode.Length && data.spacingMode != spine.SpacingMode.Fixed || (data.spacing *= scale);
                            data.rotateMix = this.getValue(constraintMap, "rotateMix", 1);
                            data.translateMix = this.getValue(constraintMap, "translateMix", 1);
                            skeletonData.pathConstraints.push(data);
                        }
                    }
                    if (root.skins) {
                        for (var skinName in root.skins) {
                            var skinMap = root.skins[skinName];
                            var skin = new spine.Skin(skinName);
                            for (var slotName in skinMap) {
                                var slotIndex = skeletonData.findSlotIndex(slotName);
                                if (slotIndex == -1) {
                                    throw new Error("Slot not found: " + slotName);
                                }
                                var slotMap = skinMap[slotName];
                                for (var entryName in slotMap) {
                                    var attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName);
                                    null != attachment && skin.addAttachment(slotIndex, entryName, attachment);
                                }
                            }
                            skeletonData.skins.push(skin);
                            "default" == skin.name && (skeletonData.defaultSkin = skin);
                        }
                    }
                    for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {
                        var linkedMesh = this.linkedMeshes[i];
                        var skin = null == linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);
                        if (null == skin) {
                            throw new Error("Skin not found: " + linkedMesh.skin);
                        }
                        var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);
                        if (null == parent_3) {
                            throw new Error("Parent mesh not found: " + linkedMesh.parent);
                        }
                        linkedMesh.mesh.setParentMesh(parent_3);
                        linkedMesh.mesh.updateUVs();
                    }
                    this.linkedMeshes.length = 0;
                    if (root.events) {
                        for (var eventName in root.events) {
                            var eventMap = root.events[eventName];
                            var data = new spine.EventData(eventName);
                            data.intValue = this.getValue(eventMap, "int", 0);
                            data.floatValue = this.getValue(eventMap, "float", 0);
                            data.stringValue = this.getValue(eventMap, "string", "");
                            skeletonData.events.push(data);
                        }
                    }
                    if (root.animations) {
                        for (var animationName in root.animations) {
                            var animationMap = root.animations[animationName];
                            this.readAnimation(animationMap, animationName, skeletonData);
                        }
                    }
                    return skeletonData;
                };
                SkeletonJson.prototype.readAttachment = function(map, skin, slotIndex, name) {
                    var scale = this.scale;
                    name = this.getValue(map, "name", name);
                    var type = this.getValue(map, "type", "region");
                    switch (type) {
                      case "region":
                        var path = this.getValue(map, "path", name);
                        var region = this.attachmentLoader.newRegionAttachment(skin, name, path);
                        if (null == region) {
                            return null;
                        }
                        region.path = path;
                        region.x = this.getValue(map, "x", 0) * scale;
                        region.y = this.getValue(map, "y", 0) * scale;
                        region.scaleX = this.getValue(map, "scaleX", 1);
                        region.scaleY = this.getValue(map, "scaleY", 1);
                        region.rotation = this.getValue(map, "rotation", 0);
                        region.width = map.width * scale;
                        region.height = map.height * scale;
                        var color = this.getValue(map, "color", null);
                        null != color && region.color.setFromString(color);
                        region.updateOffset();
                        return region;

                      case "boundingbox":
                        var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);
                        if (null == box) {
                            return null;
                        }
                        this.readVertices(map, box, map.vertexCount << 1);
                        var color = this.getValue(map, "color", null);
                        null != color && box.color.setFromString(color);
                        return box;

                      case "mesh":
                      case "linkedmesh":
                        var path = this.getValue(map, "path", name);
                        var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);
                        if (null == mesh) {
                            return null;
                        }
                        mesh.path = path;
                        var color = this.getValue(map, "color", null);
                        null != color && mesh.color.setFromString(color);
                        var parent_4 = this.getValue(map, "parent", null);
                        if (null != parent_4) {
                            mesh.inheritDeform = this.getValue(map, "deform", true);
                            this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, "skin", null), slotIndex, parent_4));
                            return mesh;
                        }
                        var uvs = map.uvs;
                        this.readVertices(map, mesh, uvs.length);
                        mesh.triangles = map.triangles;
                        mesh.regionUVs = uvs;
                        mesh.updateUVs();
                        mesh.hullLength = 2 * this.getValue(map, "hull", 0);
                        return mesh;

                      case "path":
                        var path = this.attachmentLoader.newPathAttachment(skin, name);
                        if (null == path) {
                            return null;
                        }
                        path.closed = this.getValue(map, "closed", false);
                        path.constantSpeed = this.getValue(map, "constantSpeed", true);
                        var vertexCount = map.vertexCount;
                        this.readVertices(map, path, vertexCount << 1);
                        var lengths = spine.Utils.newArray(vertexCount / 3, 0);
                        for (var i = 0; i < map.lengths.length; i++) {
                            lengths[i++] = map.lengths[i] * scale;
                        }
                        path.lengths = lengths;
                        var color = this.getValue(map, "color", null);
                        null != color && path.color.setFromString(color);
                        return path;
                    }
                    return null;
                };
                SkeletonJson.prototype.readVertices = function(map, attachment, verticesLength) {
                    var scale = this.scale;
                    attachment.worldVerticesLength = verticesLength;
                    var vertices = map.vertices;
                    if (verticesLength == vertices.length) {
                        if (1 != scale) {
                            for (var i = 0, n = vertices.length; i < n; i++) {
                                vertices[i] *= scale;
                            }
                        }
                        attachment.vertices = spine.Utils.toFloatArray(vertices);
                        return;
                    }
                    var weights = new Array();
                    var bones = new Array();
                    for (var i = 0, n = vertices.length; i < n; ) {
                        var boneCount = vertices[i++];
                        bones.push(boneCount);
                        for (var nn = i + 4 * boneCount; i < nn; i += 4) {
                            bones.push(vertices[i]);
                            weights.push(vertices[i + 1] * scale);
                            weights.push(vertices[i + 2] * scale);
                            weights.push(vertices[i + 3]);
                        }
                    }
                    attachment.bones = bones;
                    attachment.vertices = spine.Utils.toFloatArray(weights);
                };
                SkeletonJson.prototype.readAnimation = function(map, name, skeletonData) {
                    var scale = this.scale;
                    var timelines = new Array();
                    var duration = 0;
                    if (map.slots) {
                        for (var slotName in map.slots) {
                            var slotMap = map.slots[slotName];
                            var slotIndex = skeletonData.findSlotIndex(slotName);
                            if (slotIndex == -1) {
                                throw new Error("Slot not found: " + slotName);
                            }
                            for (var timelineName in slotMap) {
                                var timelineMap = slotMap[timelineName];
                                if ("color" == timelineName) {
                                    var timeline = new spine.ColorTimeline(timelineMap.length);
                                    timeline.slotIndex = slotIndex;
                                    var frameIndex = 0;
                                    for (var i = 0; i < timelineMap.length; i++) {
                                        var valueMap = timelineMap[i];
                                        var color = new spine.Color();
                                        color.setFromString(valueMap.color);
                                        timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);
                                        this.readCurve(valueMap, timeline, frameIndex);
                                        frameIndex++;
                                    }
                                    timelines.push(timeline);
                                    duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.ColorTimeline.ENTRIES]);
                                } else {
                                    if (!(timelineName = "attachment")) {
                                        throw new Error("Invalid timeline type for a slot: " + timelineName + " (" + slotName + ")");
                                    }
                                    var timeline = new spine.AttachmentTimeline(timelineMap.length);
                                    timeline.slotIndex = slotIndex;
                                    var frameIndex = 0;
                                    for (var i = 0; i < timelineMap.length; i++) {
                                        var valueMap = timelineMap[i];
                                        timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);
                                    }
                                    timelines.push(timeline);
                                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                                }
                            }
                        }
                    }
                    if (map.bones) {
                        for (var boneName in map.bones) {
                            var boneMap = map.bones[boneName];
                            var boneIndex = skeletonData.findBoneIndex(boneName);
                            if (boneIndex == -1) {
                                throw new Error("Bone not found: " + boneName);
                            }
                            for (var timelineName in boneMap) {
                                var timelineMap = boneMap[timelineName];
                                if ("rotate" === timelineName) {
                                    var timeline = new spine.RotateTimeline(timelineMap.length);
                                    timeline.boneIndex = boneIndex;
                                    var frameIndex = 0;
                                    for (var i = 0; i < timelineMap.length; i++) {
                                        var valueMap = timelineMap[i];
                                        timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);
                                        this.readCurve(valueMap, timeline, frameIndex);
                                        frameIndex++;
                                    }
                                    timelines.push(timeline);
                                    duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.RotateTimeline.ENTRIES]);
                                } else {
                                    if ("translate" !== timelineName && "scale" !== timelineName && "shear" !== timelineName) {
                                        throw new Error("Invalid timeline type for a bone: " + timelineName + " (" + boneName + ")");
                                    }
                                    var timeline = null;
                                    var timelineScale = 1;
                                    if ("scale" === timelineName) {
                                        timeline = new spine.ScaleTimeline(timelineMap.length);
                                    } else {
                                        if ("shear" === timelineName) {
                                            timeline = new spine.ShearTimeline(timelineMap.length);
                                        } else {
                                            timeline = new spine.TranslateTimeline(timelineMap.length);
                                            timelineScale = scale;
                                        }
                                    }
                                    timeline.boneIndex = boneIndex;
                                    var frameIndex = 0;
                                    for (var i = 0; i < timelineMap.length; i++) {
                                        var valueMap = timelineMap[i];
                                        var x = this.getValue(valueMap, "x", 0), y = this.getValue(valueMap, "y", 0);
                                        timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);
                                        this.readCurve(valueMap, timeline, frameIndex);
                                        frameIndex++;
                                    }
                                    timelines.push(timeline);
                                    duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TranslateTimeline.ENTRIES]);
                                }
                            }
                        }
                    }
                    if (map.ik) {
                        for (var constraintName in map.ik) {
                            var constraintMap = map.ik[constraintName];
                            var constraint = skeletonData.findIkConstraint(constraintName);
                            var timeline = new spine.IkConstraintTimeline(constraintMap.length);
                            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);
                            var frameIndex = 0;
                            for (var i = 0; i < constraintMap.length; i++) {
                                var valueMap = constraintMap[i];
                                timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "mix", 1), this.getValue(valueMap, "bendPositive", true) ? 1 : -1);
                                this.readCurve(valueMap, timeline, frameIndex);
                                frameIndex++;
                            }
                            timelines.push(timeline);
                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.IkConstraintTimeline.ENTRIES]);
                        }
                    }
                    if (map.transform) {
                        for (var constraintName in map.transform) {
                            var constraintMap = map.transform[constraintName];
                            var constraint = skeletonData.findTransformConstraint(constraintName);
                            var timeline = new spine.TransformConstraintTimeline(constraintMap.length);
                            timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);
                            var frameIndex = 0;
                            for (var i = 0; i < constraintMap.length; i++) {
                                var valueMap = constraintMap[i];
                                timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1), this.getValue(valueMap, "scaleMix", 1), this.getValue(valueMap, "shearMix", 1));
                                this.readCurve(valueMap, timeline, frameIndex);
                                frameIndex++;
                            }
                            timelines.push(timeline);
                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.TransformConstraintTimeline.ENTRIES]);
                        }
                    }
                    if (map.paths) {
                        for (var constraintName in map.paths) {
                            var constraintMap = map.paths[constraintName];
                            var index = skeletonData.findPathConstraintIndex(constraintName);
                            if (index == -1) {
                                throw new Error("Path constraint not found: " + constraintName);
                            }
                            var data = skeletonData.pathConstraints[index];
                            for (var timelineName in constraintMap) {
                                var timelineMap = constraintMap[timelineName];
                                if ("position" === timelineName || "spacing" === timelineName) {
                                    var timeline = null;
                                    var timelineScale = 1;
                                    if ("spacing" === timelineName) {
                                        timeline = new spine.PathConstraintSpacingTimeline(timelineMap.length);
                                        data.spacingMode != spine.SpacingMode.Length && data.spacingMode != spine.SpacingMode.Fixed || (timelineScale = scale);
                                    } else {
                                        timeline = new spine.PathConstraintPositionTimeline(timelineMap.length);
                                        data.positionMode == spine.PositionMode.Fixed && (timelineScale = scale);
                                    }
                                    timeline.pathConstraintIndex = index;
                                    var frameIndex = 0;
                                    for (var i = 0; i < timelineMap.length; i++) {
                                        var valueMap = timelineMap[i];
                                        timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);
                                        this.readCurve(valueMap, timeline, frameIndex);
                                        frameIndex++;
                                    }
                                    timelines.push(timeline);
                                    duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintPositionTimeline.ENTRIES]);
                                } else {
                                    if ("mix" === timelineName) {
                                        var timeline = new spine.PathConstraintMixTimeline(timelineMap.length);
                                        timeline.pathConstraintIndex = index;
                                        var frameIndex = 0;
                                        for (var i = 0; i < timelineMap.length; i++) {
                                            var valueMap = timelineMap[i];
                                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, "rotateMix", 1), this.getValue(valueMap, "translateMix", 1));
                                            this.readCurve(valueMap, timeline, frameIndex);
                                            frameIndex++;
                                        }
                                        timelines.push(timeline);
                                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * spine.PathConstraintMixTimeline.ENTRIES]);
                                    }
                                }
                            }
                        }
                    }
                    if (map.deform) {
                        for (var deformName in map.deform) {
                            var deformMap = map.deform[deformName];
                            var skin = skeletonData.findSkin(deformName);
                            if (null == skin) {
                                throw new Error("Skin not found: " + deformName);
                            }
                            for (var slotName in deformMap) {
                                var slotMap = deformMap[slotName];
                                var slotIndex = skeletonData.findSlotIndex(slotName);
                                if (slotIndex == -1) {
                                    throw new Error("Slot not found: " + slotMap.name);
                                }
                                for (var timelineName in slotMap) {
                                    var timelineMap = slotMap[timelineName];
                                    var attachment = skin.getAttachment(slotIndex, timelineName);
                                    if (null == attachment) {
                                        throw new Error("Deform attachment not found: " + timelineMap.name);
                                    }
                                    var weighted = null != attachment.bones;
                                    var vertices = attachment.vertices;
                                    var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;
                                    var timeline = new spine.DeformTimeline(timelineMap.length);
                                    timeline.slotIndex = slotIndex;
                                    timeline.attachment = attachment;
                                    var frameIndex = 0;
                                    for (var j = 0; j < timelineMap.length; j++) {
                                        var valueMap = timelineMap[j];
                                        var deform = void 0;
                                        var verticesValue = this.getValue(valueMap, "vertices", null);
                                        if (null == verticesValue) {
                                            deform = weighted ? spine.Utils.newFloatArray(deformLength) : vertices;
                                        } else {
                                            deform = spine.Utils.newFloatArray(deformLength);
                                            var start = this.getValue(valueMap, "offset", 0);
                                            spine.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);
                                            if (1 != scale) {
                                                for (var i = start, n = i + verticesValue.length; i < n; i++) {
                                                    deform[i] *= scale;
                                                }
                                            }
                                            if (!weighted) {
                                                for (var i = 0; i < deformLength; i++) {
                                                    deform[i] += vertices[i];
                                                }
                                            }
                                        }
                                        timeline.setFrame(frameIndex, valueMap.time, deform);
                                        this.readCurve(valueMap, timeline, frameIndex);
                                        frameIndex++;
                                    }
                                    timelines.push(timeline);
                                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                                }
                            }
                        }
                    }
                    var drawOrderNode = map.drawOrder;
                    null == drawOrderNode && (drawOrderNode = map.draworder);
                    if (null != drawOrderNode) {
                        var timeline = new spine.DrawOrderTimeline(drawOrderNode.length);
                        var slotCount = skeletonData.slots.length;
                        var frameIndex = 0;
                        for (var j = 0; j < drawOrderNode.length; j++) {
                            var drawOrderMap = drawOrderNode[j];
                            var drawOrder = null;
                            var offsets = this.getValue(drawOrderMap, "offsets", null);
                            if (null != offsets) {
                                drawOrder = spine.Utils.newArray(slotCount, -1);
                                var unchanged = spine.Utils.newArray(slotCount - offsets.length, 0);
                                var originalIndex = 0, unchangedIndex = 0;
                                for (var i = 0; i < offsets.length; i++) {
                                    var offsetMap = offsets[i];
                                    var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);
                                    if (slotIndex == -1) {
                                        throw new Error("Slot not found: " + offsetMap.slot);
                                    }
                                    while (originalIndex != slotIndex) {
                                        unchanged[unchangedIndex++] = originalIndex++;
                                    }
                                    drawOrder[originalIndex + offsetMap.offset] = originalIndex++;
                                }
                                while (originalIndex < slotCount) {
                                    unchanged[unchangedIndex++] = originalIndex++;
                                }
                                for (var i = slotCount - 1; i >= 0; i--) {
                                    drawOrder[i] == -1 && (drawOrder[i] = unchanged[--unchangedIndex]);
                                }
                            }
                            timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);
                        }
                        timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                    }
                    if (map.events) {
                        var timeline = new spine.EventTimeline(map.events.length);
                        var frameIndex = 0;
                        for (var i = 0; i < map.events.length; i++) {
                            var eventMap = map.events[i];
                            var eventData = skeletonData.findEvent(eventMap.name);
                            if (null == eventData) {
                                throw new Error("Event not found: " + eventMap.name);
                            }
                            var event_5 = new spine.Event(eventMap.time, eventData);
                            event_5.intValue = this.getValue(eventMap, "int", eventData.intValue);
                            event_5.floatValue = this.getValue(eventMap, "float", eventData.floatValue);
                            event_5.stringValue = this.getValue(eventMap, "string", eventData.stringValue);
                            timeline.setFrame(frameIndex++, event_5);
                        }
                        timelines.push(timeline);
                        duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);
                    }
                    if (isNaN(duration)) {
                        throw new Error("Error while parsing animation, duration is NaN");
                    }
                    skeletonData.animations.push(new spine.Animation(name, timelines, duration));
                };
                SkeletonJson.prototype.readCurve = function(map, timeline, frameIndex) {
                    if (!map.curve) {
                        return;
                    }
                    if ("stepped" === map.curve) {
                        timeline.setStepped(frameIndex);
                    } else {
                        if ("[object Array]" === Object.prototype.toString.call(map.curve)) {
                            var curve = map.curve;
                            timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);
                        }
                    }
                };
                SkeletonJson.prototype.getValue = function(map, prop, defaultValue) {
                    return void 0 !== map[prop] ? map[prop] : defaultValue;
                };
                SkeletonJson.blendModeFromString = function(str) {
                    str = str.toLowerCase();
                    if ("normal" == str) {
                        return spine.BlendMode.Normal;
                    }
                    if ("additive" == str) {
                        return spine.BlendMode.Additive;
                    }
                    if ("multiply" == str) {
                        return spine.BlendMode.Multiply;
                    }
                    if ("screen" == str) {
                        return spine.BlendMode.Screen;
                    }
                    throw new Error("Unknown blend mode: " + str);
                };
                SkeletonJson.positionModeFromString = function(str) {
                    str = str.toLowerCase();
                    if ("fixed" == str) {
                        return spine.PositionMode.Fixed;
                    }
                    if ("percent" == str) {
                        return spine.PositionMode.Percent;
                    }
                    throw new Error("Unknown position mode: " + str);
                };
                SkeletonJson.spacingModeFromString = function(str) {
                    str = str.toLowerCase();
                    if ("length" == str) {
                        return spine.SpacingMode.Length;
                    }
                    if ("fixed" == str) {
                        return spine.SpacingMode.Fixed;
                    }
                    if ("percent" == str) {
                        return spine.SpacingMode.Percent;
                    }
                    throw new Error("Unknown position mode: " + str);
                };
                SkeletonJson.rotateModeFromString = function(str) {
                    str = str.toLowerCase();
                    if ("tangent" == str) {
                        return spine.RotateMode.Tangent;
                    }
                    if ("chain" == str) {
                        return spine.RotateMode.Chain;
                    }
                    if ("chainscale" == str) {
                        return spine.RotateMode.ChainScale;
                    }
                    throw new Error("Unknown rotate mode: " + str);
                };
                SkeletonJson.transformModeFromString = function(str) {
                    str = str.toLowerCase();
                    if ("normal" == str) {
                        return spine.TransformMode.Normal;
                    }
                    if ("onlytranslation" == str) {
                        return spine.TransformMode.OnlyTranslation;
                    }
                    if ("norotationorreflection" == str) {
                        return spine.TransformMode.NoRotationOrReflection;
                    }
                    if ("noscale" == str) {
                        return spine.TransformMode.NoScale;
                    }
                    if ("noscaleorreflection" == str) {
                        return spine.TransformMode.NoScaleOrReflection;
                    }
                    throw new Error("Unknown transform mode: " + str);
                };
                return SkeletonJson;
            })();
            spine.SkeletonJson = SkeletonJson;
            var LinkedMesh = (function() {
                function LinkedMesh(mesh, skin, slotIndex, parent) {
                    this.mesh = mesh;
                    this.skin = skin;
                    this.slotIndex = slotIndex;
                    this.parent = parent;
                }
                return LinkedMesh;
            })();
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var Skin = (function() {
                function Skin(name) {
                    this.attachments = new Array();
                    if (null == name) {
                        throw new Error("name cannot be null.");
                    }
                    this.name = name;
                }
                Skin.prototype.addAttachment = function(slotIndex, name, attachment) {
                    if (null == attachment) {
                        throw new Error("attachment cannot be null.");
                    }
                    var attachments = this.attachments;
                    slotIndex >= attachments.length && (attachments.length = slotIndex + 1);
                    attachments[slotIndex] || (attachments[slotIndex] = {});
                    attachments[slotIndex][name] = attachment;
                };
                Skin.prototype.getAttachment = function(slotIndex, name) {
                    var dictionary = this.attachments[slotIndex];
                    return dictionary ? dictionary[name] : null;
                };
                Skin.prototype.attachAll = function(skeleton, oldSkin) {
                    var slotIndex = 0;
                    for (var i = 0; i < skeleton.slots.length; i++) {
                        var slot = skeleton.slots[i];
                        var slotAttachment = slot.getAttachment();
                        if (slotAttachment && slotIndex < oldSkin.attachments.length) {
                            var dictionary = oldSkin.attachments[slotIndex];
                            for (var key in dictionary) {
                                var skinAttachment = dictionary[key];
                                if (slotAttachment == skinAttachment) {
                                    var attachment = this.getAttachment(slotIndex, key);
                                    null != attachment && slot.setAttachment(attachment);
                                    break;
                                }
                            }
                        }
                        slotIndex++;
                    }
                };
                return Skin;
            })();
            spine.Skin = Skin;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var Slot = (function() {
                function Slot(data, bone) {
                    this.attachmentVertices = new Array();
                    if (null == data) {
                        throw new Error("data cannot be null.");
                    }
                    if (null == bone) {
                        throw new Error("bone cannot be null.");
                    }
                    this.data = data;
                    this.bone = bone;
                    this.color = new spine.Color();
                    this.setToSetupPose();
                }
                Slot.prototype.getAttachment = function() {
                    return this.attachment;
                };
                Slot.prototype.setAttachment = function(attachment) {
                    if (this.attachment == attachment) {
                        return;
                    }
                    this.attachment = attachment;
                    this.attachmentTime = this.bone.skeleton.time;
                    this.attachmentVertices.length = 0;
                };
                Slot.prototype.setAttachmentTime = function(time) {
                    this.attachmentTime = this.bone.skeleton.time - time;
                };
                Slot.prototype.getAttachmentTime = function() {
                    return this.bone.skeleton.time - this.attachmentTime;
                };
                Slot.prototype.setToSetupPose = function() {
                    this.color.setFromColor(this.data.color);
                    if (null == this.data.attachmentName) {
                        this.attachment = null;
                    } else {
                        this.attachment = null;
                        this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));
                    }
                };
                return Slot;
            })();
            spine.Slot = Slot;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var SlotData = (function() {
                function SlotData(index, name, boneData) {
                    this.color = new spine.Color(1, 1, 1, 1);
                    if (index < 0) {
                        throw new Error("index must be >= 0.");
                    }
                    if (null == name) {
                        throw new Error("name cannot be null.");
                    }
                    if (null == boneData) {
                        throw new Error("boneData cannot be null.");
                    }
                    this.index = index;
                    this.name = name;
                    this.boneData = boneData;
                }
                return SlotData;
            })();
            spine.SlotData = SlotData;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var Texture = (function() {
                function Texture(image) {
                    this._image = image;
                }
                Texture.prototype.getImage = function() {
                    return this._image;
                };
                Texture.filterFromString = function(text) {
                    switch (text.toLowerCase()) {
                      case "nearest":
                        return TextureFilter.Nearest;

                      case "linear":
                        return TextureFilter.Linear;

                      case "mipmap":
                        return TextureFilter.MipMap;

                      case "mipmapnearestnearest":
                        return TextureFilter.MipMapNearestNearest;

                      case "mipmaplinearnearest":
                        return TextureFilter.MipMapLinearNearest;

                      case "mipmapnearestlinear":
                        return TextureFilter.MipMapNearestLinear;

                      case "mipmaplinearlinear":
                        return TextureFilter.MipMapLinearLinear;

                      default:
                        throw new Error("Unknown texture filter " + text);
                    }
                };
                Texture.wrapFromString = function(text) {
                    switch (text.toLowerCase()) {
                      case "mirroredtepeat":
                        return TextureWrap.MirroredRepeat;

                      case "clamptoedge":
                        return TextureWrap.ClampToEdge;

                      case "repeat":
                        return TextureWrap.Repeat;

                      default:
                        throw new Error("Unknown texture wrap " + text);
                    }
                };
                return Texture;
            })();
            spine.Texture = Texture;
            (function(TextureFilter) {
                TextureFilter[TextureFilter["Nearest"] = 9728] = "Nearest";
                TextureFilter[TextureFilter["Linear"] = 9729] = "Linear";
                TextureFilter[TextureFilter["MipMap"] = 9987] = "MipMap";
                TextureFilter[TextureFilter["MipMapNearestNearest"] = 9984] = "MipMapNearestNearest";
                TextureFilter[TextureFilter["MipMapLinearNearest"] = 9985] = "MipMapLinearNearest";
                TextureFilter[TextureFilter["MipMapNearestLinear"] = 9986] = "MipMapNearestLinear";
                TextureFilter[TextureFilter["MipMapLinearLinear"] = 9987] = "MipMapLinearLinear";
            })(spine.TextureFilter || (spine.TextureFilter = {}));
            var TextureFilter = spine.TextureFilter;
            (function(TextureWrap) {
                TextureWrap[TextureWrap["MirroredRepeat"] = 33648] = "MirroredRepeat";
                TextureWrap[TextureWrap["ClampToEdge"] = 33071] = "ClampToEdge";
                TextureWrap[TextureWrap["Repeat"] = 10497] = "Repeat";
            })(spine.TextureWrap || (spine.TextureWrap = {}));
            var TextureWrap = spine.TextureWrap;
            var TextureRegion = (function() {
                function TextureRegion() {
                    this.u = 0;
                    this.v = 0;
                    this.u2 = 0;
                    this.v2 = 0;
                    this.width = 0;
                    this.height = 0;
                    this.rotate = false;
                    this.offsetX = 0;
                    this.offsetY = 0;
                    this.originalWidth = 0;
                    this.originalHeight = 0;
                }
                return TextureRegion;
            })();
            spine.TextureRegion = TextureRegion;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var TextureAtlas = (function() {
                function TextureAtlas(atlasText, textureLoader) {
                    this.pages = new Array();
                    this.regions = new Array();
                    this.load(atlasText, textureLoader);
                }
                TextureAtlas.prototype.load = function(atlasText, textureLoader) {
                    if (null == textureLoader) {
                        throw new Error("textureLoader cannot be null.");
                    }
                    var reader = new TextureAtlasReader(atlasText);
                    var tuple = new Array(4);
                    var page = null;
                    while (true) {
                        var line = reader.readLine();
                        if (null == line) {
                            break;
                        }
                        line = line.trim();
                        if (0 == line.length) {
                            page = null;
                        } else {
                            if (page) {
                                var region = new TextureAtlasRegion();
                                region.name = line;
                                region.page = page;
                                region.rotate = "true" == reader.readValue();
                                reader.readTuple(tuple);
                                var x = parseInt(tuple[0]);
                                var y = parseInt(tuple[1]);
                                reader.readTuple(tuple);
                                var width = parseInt(tuple[0]);
                                var height = parseInt(tuple[1]);
                                region.u = x / page.width;
                                region.v = y / page.height;
                                if (region.rotate) {
                                    region.u2 = (x + height) / page.width;
                                    region.v2 = (y + width) / page.height;
                                } else {
                                    region.u2 = (x + width) / page.width;
                                    region.v2 = (y + height) / page.height;
                                }
                                region.x = x;
                                region.y = y;
                                region.width = Math.abs(width);
                                region.height = Math.abs(height);
                                4 == reader.readTuple(tuple) && 4 == reader.readTuple(tuple) && reader.readTuple(tuple);
                                region.originalWidth = parseInt(tuple[0]);
                                region.originalHeight = parseInt(tuple[1]);
                                reader.readTuple(tuple);
                                region.offsetX = parseInt(tuple[0]);
                                region.offsetY = parseInt(tuple[1]);
                                region.index = parseInt(reader.readValue());
                                region.texture = page.texture;
                                this.regions.push(region);
                            } else {
                                page = new TextureAtlasPage();
                                page.name = line;
                                if (2 == reader.readTuple(tuple)) {
                                    page.width = parseInt(tuple[0]);
                                    page.height = parseInt(tuple[1]);
                                    reader.readTuple(tuple);
                                }
                                reader.readTuple(tuple);
                                page.minFilter = spine.Texture.filterFromString(tuple[0]);
                                page.magFilter = spine.Texture.filterFromString(tuple[1]);
                                var direction = reader.readValue();
                                page.uWrap = spine.TextureWrap.ClampToEdge;
                                page.vWrap = spine.TextureWrap.ClampToEdge;
                                "x" == direction ? page.uWrap = spine.TextureWrap.Repeat : "y" == direction ? page.vWrap = spine.TextureWrap.Repeat : "xy" == direction && (page.uWrap = page.vWrap = spine.TextureWrap.Repeat);
                                page.texture = textureLoader(line);
                                page.texture.setFilters(page.minFilter, page.magFilter);
                                page.texture.setWraps(page.uWrap, page.vWrap);
                                page.width = page.texture.getImage().width;
                                page.height = page.texture.getImage().height;
                                this.pages.push(page);
                            }
                        }
                    }
                };
                TextureAtlas.prototype.findRegion = function(name) {
                    for (var i = 0; i < this.regions.length; i++) {
                        if (this.regions[i].name == name) {
                            return this.regions[i];
                        }
                    }
                    return null;
                };
                TextureAtlas.prototype.dispose = function() {
                    for (var i = 0; i < this.pages.length; i++) {
                        this.pages[i].texture.dispose();
                    }
                };
                return TextureAtlas;
            })();
            spine.TextureAtlas = TextureAtlas;
            var TextureAtlasReader = (function() {
                function TextureAtlasReader(text) {
                    this.index = 0;
                    this.lines = text.split(/\r\n|\r|\n/);
                }
                TextureAtlasReader.prototype.readLine = function() {
                    if (this.index >= this.lines.length) {
                        return null;
                    }
                    return this.lines[this.index++];
                };
                TextureAtlasReader.prototype.readValue = function() {
                    var line = this.readLine();
                    var colon = line.indexOf(":");
                    if (colon == -1) {
                        throw new Error("Invalid line: " + line);
                    }
                    return line.substring(colon + 1).trim();
                };
                TextureAtlasReader.prototype.readTuple = function(tuple) {
                    var line = this.readLine();
                    var colon = line.indexOf(":");
                    if (colon == -1) {
                        throw new Error("Invalid line: " + line);
                    }
                    var i = 0, lastMatch = colon + 1;
                    for (;i < 3; i++) {
                        var comma = line.indexOf(",", lastMatch);
                        if (comma == -1) {
                            break;
                        }
                        tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();
                        lastMatch = comma + 1;
                    }
                    tuple[i] = line.substring(lastMatch).trim();
                    return i + 1;
                };
                return TextureAtlasReader;
            })();
            var TextureAtlasPage = (function() {
                function TextureAtlasPage() {}
                return TextureAtlasPage;
            })();
            spine.TextureAtlasPage = TextureAtlasPage;
            var TextureAtlasRegion = (function(_super) {
                __extends(TextureAtlasRegion, _super);
                function TextureAtlasRegion() {
                    _super.apply(this, arguments);
                }
                return TextureAtlasRegion;
            })(spine.TextureRegion);
            spine.TextureAtlasRegion = TextureAtlasRegion;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var TransformConstraint = (function() {
                function TransformConstraint(data, skeleton) {
                    this.rotateMix = 0;
                    this.translateMix = 0;
                    this.scaleMix = 0;
                    this.shearMix = 0;
                    this.temp = new spine.Vector2();
                    if (null == data) {
                        throw new Error("data cannot be null.");
                    }
                    if (null == skeleton) {
                        throw new Error("skeleton cannot be null.");
                    }
                    this.data = data;
                    this.rotateMix = data.rotateMix;
                    this.translateMix = data.translateMix;
                    this.scaleMix = data.scaleMix;
                    this.shearMix = data.shearMix;
                    this.bones = new Array();
                    for (var i = 0; i < data.bones.length; i++) {
                        this.bones.push(skeleton.findBone(data.bones[i].name));
                    }
                    this.target = skeleton.findBone(data.target.name);
                }
                TransformConstraint.prototype.apply = function() {
                    this.update();
                };
                TransformConstraint.prototype.update = function() {
                    var rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix, shearMix = this.shearMix;
                    var target = this.target;
                    var ta = target.a, tb = target.b, tc = target.c, td = target.d;
                    var degRadReflect = ta * td - tb * tc > 0 ? spine.MathUtils.degRad : -spine.MathUtils.degRad;
                    var offsetRotation = this.data.offsetRotation * degRadReflect;
                    var offsetShearY = this.data.offsetShearY * degRadReflect;
                    var bones = this.bones;
                    for (var i = 0, n = bones.length; i < n; i++) {
                        var bone = bones[i];
                        var modified = false;
                        if (0 != rotateMix) {
                            var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                            var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;
                            r > spine.MathUtils.PI ? r -= spine.MathUtils.PI2 : r < -spine.MathUtils.PI && (r += spine.MathUtils.PI2);
                            r *= rotateMix;
                            var cos = Math.cos(r), sin = Math.sin(r);
                            bone.a = cos * a - sin * c;
                            bone.b = cos * b - sin * d;
                            bone.c = sin * a + cos * c;
                            bone.d = sin * b + cos * d;
                            modified = true;
                        }
                        if (0 != translateMix) {
                            var temp = this.temp;
                            target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));
                            bone.worldX += (temp.x - bone.worldX) * translateMix;
                            bone.worldY += (temp.y - bone.worldY) * translateMix;
                            modified = true;
                        }
                        if (scaleMix > 0) {
                            var s = Math.sqrt(bone.a * bone.a + bone.c * bone.c);
                            var ts = Math.sqrt(ta * ta + tc * tc);
                            s > 1e-5 && (s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s);
                            bone.a *= s;
                            bone.c *= s;
                            s = Math.sqrt(bone.b * bone.b + bone.d * bone.d);
                            ts = Math.sqrt(tb * tb + td * td);
                            s > 1e-5 && (s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s);
                            bone.b *= s;
                            bone.d *= s;
                            modified = true;
                        }
                        if (shearMix > 0) {
                            var b = bone.b, d = bone.d;
                            var by = Math.atan2(d, b);
                            var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(bone.c, bone.a));
                            r > spine.MathUtils.PI ? r -= spine.MathUtils.PI2 : r < -spine.MathUtils.PI && (r += spine.MathUtils.PI2);
                            r = by + (r + offsetShearY) * shearMix;
                            var s = Math.sqrt(b * b + d * d);
                            bone.b = Math.cos(r) * s;
                            bone.d = Math.sin(r) * s;
                            modified = true;
                        }
                        modified && (bone.appliedValid = false);
                    }
                };
                TransformConstraint.prototype.getOrder = function() {
                    return this.data.order;
                };
                return TransformConstraint;
            })();
            spine.TransformConstraint = TransformConstraint;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var TransformConstraintData = (function() {
                function TransformConstraintData(name) {
                    this.order = 0;
                    this.bones = new Array();
                    this.rotateMix = 0;
                    this.translateMix = 0;
                    this.scaleMix = 0;
                    this.shearMix = 0;
                    this.offsetRotation = 0;
                    this.offsetX = 0;
                    this.offsetY = 0;
                    this.offsetScaleX = 0;
                    this.offsetScaleY = 0;
                    this.offsetShearY = 0;
                    if (null == name) {
                        throw new Error("name cannot be null.");
                    }
                    this.name = name;
                }
                return TransformConstraintData;
            })();
            spine.TransformConstraintData = TransformConstraintData;
        })(spine || (spine = {}));
        var spine;
        (function(spine) {
            var IntSet = (function() {
                function IntSet() {
                    this.array = new Array();
                }
                IntSet.prototype.add = function(value) {
                    var contains = this.contains(value);
                    this.array[0 | value] = 0 | value;
                    return !contains;
                };
                IntSet.prototype.contains = function(value) {
                    return void 0 != this.array[0 | value];
                };
                IntSet.prototype.remove = function(value) {
                    this.array[0 | value] = void 0;
                };
                IntSet.prototype.clear = function() {
                    this.array.length = 0;
                };
                return IntSet;
            })();
            spine.IntSet = IntSet;
            var Color = (function() {
                function Color(r, g, b, a) {
                    void 0 === r && (r = 0);
                    void 0 === g && (g = 0);
                    void 0 === b && (b = 0);
                    void 0 === a && (a = 0);
                    this.r = r;
                    this.g = g;
                    this.b = b;
                    this.a = a;
                }
                Color.prototype.set = function(r, g, b, a) {
                    this.r = r;
                    this.g = g;
                    this.b = b;
                    this.a = a;
                    this.clamp();
                    return this;
                };
                Color.prototype.setFromColor = function(c) {
                    this.r = c.r;
                    this.g = c.g;
                    this.b = c.b;
                    this.a = c.a;
                    return this;
                };
                Color.prototype.setFromString = function(hex) {
                    hex = "#" == hex.charAt(0) ? hex.substr(1) : hex;
                    this.r = parseInt(hex.substr(0, 2), 16) / 255;
                    this.g = parseInt(hex.substr(2, 2), 16) / 255;
                    this.b = parseInt(hex.substr(4, 2), 16) / 255;
                    this.a = (8 != hex.length ? 255 : parseInt(hex.substr(6, 2), 16)) / 255;
                    return this;
                };
                Color.prototype.add = function(r, g, b, a) {
                    this.r += r;
                    this.g += g;
                    this.b += b;
                    this.a += a;
                    this.clamp();
                    return this;
                };
                Color.prototype.clamp = function() {
                    this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1);
                    this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1);
                    this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1);
                    this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1);
                    return this;
                };
                Color.WHITE = new Color(1, 1, 1, 1);
                Color.RED = new Color(1, 0, 0, 1);
                Color.GREEN = new Color(0, 1, 0, 1);
                Color.BLUE = new Color(0, 0, 1, 1);
                Color.MAGENTA = new Color(1, 0, 1, 1);
                return Color;
            })();
            spine.Color = Color;
            var MathUtils = (function() {
                function MathUtils() {}
                MathUtils.clamp = function(value, min, max) {
                    if (value < min) {
                        return min;
                    }
                    if (value > max) {
                        return max;
                    }
                    return value;
                };
                MathUtils.cosDeg = function(degrees) {
                    return Math.cos(degrees * MathUtils.degRad);
                };
                MathUtils.sinDeg = function(degrees) {
                    return Math.sin(degrees * MathUtils.degRad);
                };
                MathUtils.signum = function(value) {
                    return value > 0 ? 1 : value < 0 ? -1 : 0;
                };
                MathUtils.toInt = function(x) {
                    return x > 0 ? Math.floor(x) : Math.ceil(x);
                };
                MathUtils.cbrt = function(x) {
                    var y = Math.pow(Math.abs(x), 1 / 3);
                    return x < 0 ? -y : y;
                };
                MathUtils.PI = 3.1415927;
                MathUtils.PI2 = 2 * MathUtils.PI;
                MathUtils.radiansToDegrees = 180 / MathUtils.PI;
                MathUtils.radDeg = MathUtils.radiansToDegrees;
                MathUtils.degreesToRadians = MathUtils.PI / 180;
                MathUtils.degRad = MathUtils.degreesToRadians;
                return MathUtils;
            })();
            spine.MathUtils = MathUtils;
            var Utils = (function() {
                function Utils() {}
                Utils.arrayCopy = function(source, sourceStart, dest, destStart, numElements) {
                    for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {
                        dest[j] = source[i];
                    }
                };
                Utils.setArraySize = function(array, size, value) {
                    void 0 === value && (value = 0);
                    var oldSize = array.length;
                    if (oldSize == size) {
                        return array;
                    }
                    array.length = size;
                    if (oldSize < size) {
                        for (var i = oldSize; i < size; i++) {
                            array[i] = value;
                        }
                    }
                    return array;
                };
                Utils.ensureArrayCapacity = function(array, size, value) {
                    void 0 === value && (value = 0);
                    if (array.length >= size) {
                        return array;
                    }
                    return Utils.setArraySize(array, size, value);
                };
                Utils.newArray = function(size, defaultValue) {
                    var array = new Array(size);
                    for (var i = 0; i < size; i++) {
                        array[i] = defaultValue;
                    }
                    return array;
                };
                Utils.newFloatArray = function(size) {
                    if (Utils.SUPPORTS_TYPED_ARRAYS) {
                        return new Float32Array(size);
                    }
                    var array = new Array(size);
                    for (var i = 0; i < array.length; i++) {
                        array[i] = 0;
                    }
                    return array;
                };
                Utils.toFloatArray = function(array) {
                    return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;
                };
                Utils.SUPPORTS_TYPED_ARRAYS = "undefined" !== typeof Float32Array;
                return Utils;
            })();
            spine.Utils = Utils;
            var DebugUtils = (function() {
                function DebugUtils() {}
                DebugUtils.logBones = function(skeleton) {
                    for (var i = 0; i < skeleton.bones.length; i++) {
                        var bone = skeleton.bones[i];
                        console.log(bone.data.name + ", " + bone.a + ", " + bone.b + ", " + bone.c + ", " + bone.d + ", " + bone.worldX + ", " + bone.worldY);
                    }
                };
                return DebugUtils;
            })();
            spine.DebugUtils = DebugUtils;
            var Pool = (function() {
                function Pool(instantiator) {
                    this.items = new Array();
                    this.instantiator = instantiator;
                }
                Pool.prototype.obtain = function() {
                    return this.items.length > 0 ? this.items.pop() : this.instantiator();
                };
                Pool.prototype.free = function(item) {
                    item.reset && item.reset();
                    this.items.push(item);
                };
                Pool.prototype.freeAll = function(items) {
                    for (var i = 0; i < items.length; i++) {
                        items[i].reset && items[i].reset();
                        this.items[i] = items[i];
                    }
                };
                Pool.prototype.clear = function() {
                    this.items.length = 0;
                };
                return Pool;
            })();
            spine.Pool = Pool;
            var Vector2 = (function() {
                function Vector2(x, y) {
                    void 0 === x && (x = 0);
                    void 0 === y && (y = 0);
                    this.x = x;
                    this.y = y;
                }
                Vector2.prototype.set = function(x, y) {
                    this.x = x;
                    this.y = y;
                    return this;
                };
                Vector2.prototype.length = function() {
                    var x = this.x;
                    var y = this.y;
                    return Math.sqrt(x * x + y * y);
                };
                Vector2.prototype.normalize = function() {
                    var len = this.length();
                    if (0 != len) {
                        this.x /= len;
                        this.y /= len;
                    }
                    return this;
                };
                return Vector2;
            })();
            spine.Vector2 = Vector2;
            var TimeKeeper = (function() {
                function TimeKeeper() {
                    this.maxDelta = .064;
                    this.framesPerSecond = 0;
                    this.delta = 0;
                    this.totalTime = 0;
                    this.lastTime = Date.now() / 1e3;
                    this.frameCount = 0;
                    this.frameTime = 0;
                }
                TimeKeeper.prototype.update = function() {
                    var now = Date.now() / 1e3;
                    this.delta = now - this.lastTime;
                    this.frameTime += this.delta;
                    this.totalTime += this.delta;
                    this.delta > this.maxDelta && (this.delta = this.maxDelta);
                    this.lastTime = now;
                    this.frameCount++;
                    if (this.frameTime > 1) {
                        this.framesPerSecond = this.frameCount / this.frameTime;
                        this.frameTime = 0;
                        this.frameCount = 0;
                    }
                };
                return TimeKeeper;
            })();
            spine.TimeKeeper = TimeKeeper;
        })(spine || (spine = {}));
        module.exports = spine;
    }), {} ],
    310: [ (function(require, module, exports) {
        (function() {
            "use strict";
            Function.prototype._extend = function(parent) {
                this.prototype.parent = parent;
                for (var x in parent.prototype) {
                    this.prototype[x] || (this.prototype[x] = parent.prototype[x]);
                }
            };
            Function.prototype._implement = function(parent) {
                return this._extend(parent);
            };
            var b2Profiler = (function() {
                "undefined" === typeof performance && (window["performance"] = {
                    now: function() {
                        return +new Date();
                    }
                });
                function profileStruct(name, parent) {
                    this.name = name;
                    this.parent = parent;
                    this.children = {};
                    this.startTime = 0;
                    this.elapsedTime = 0;
                    this.totalTime = 0;
                    this.running = false;
                    this.childrenCount = 0;
                }
                profileStruct.prototype = {
                    start: function() {
                        this.startTime = performance.now();
                        this.running = true;
                    },
                    stop: function(reset) {
                        if (!this.running) {
                            return;
                        }
                        this.running = false;
                        this.elapsedTime += performance.now() - this.startTime;
                        reset && this.start();
                        for (var x in this.children) {
                            this.children[x].stop();
                        }
                    },
                    reset: function(dontRun) {
                        if (!dontRun) {
                            this.running = true;
                            this.totalTime += this.elapsedTime;
                            this.start();
                        }
                        this.elapsedTime = 0;
                        for (var x in this.children) {
                            this.children[x].reset(true);
                        }
                    }
                };
                var profiles = [];
                var root = new profileStruct("root");
                function create(name, parent) {
                    if (!profiles) {
                        throw new Error("late profile creation not allowed");
                    }
                    var s = new profileStruct(name, parent || "root");
                    profiles.push(s);
                    return s;
                }
                function destroy(profile) {
                    profile.childrenCount--;
                    delete profile.children[profile.name];
                }
                function recursiveParentCheck(node, profile) {
                    if (node.name === profile.parent) {
                        return node;
                    }
                    for (var x in node.children) {
                        var n;
                        if (n = recursiveParentCheck(node.children[x], profile)) {
                            return n;
                        }
                    }
                    return null;
                }
                function init() {
                    while (profiles.length) {
                        var p = profiles.pop();
                        if (p.parentNode = recursiveParentCheck(root, p)) {
                            p.parentNode.children[p.name] = p;
                            p.parentNode.childrenCount++;
                        } else {
                            profiles.unshift(p);
                        }
                    }
                    profiles = null;
                }
                function resetAll() {
                    root.reset(true);
                }
                return {
                    create: create,
                    destroy: destroy,
                    init: init,
                    reset: resetAll,
                    profileRoot: root
                };
            })();
            function b2Assert(A) {
                if (!A) {
                    console.log("Assertion failed! Pls debug.");
                    debugger;
                }
            }
            var b2_maxFloat = Number.MAX_VALUE;
            var b2_epsilon = 2.220446049250313e-16;
            var b2_pi = Math.PI;
            var b2_maxManifoldPoints = 2;
            var b2_maxPolygonVertices = 8;
            var b2_aabbExtension = .1;
            var b2_aabbMultiplier = 2;
            var b2_linearSlop = .005;
            var b2_angularSlop = 2 / 180 * b2_pi;
            var b2_polygonRadius = 2 * b2_linearSlop;
            var b2_maxSubSteps = 8;
            var b2_maxTOIContacts = 32;
            var b2_velocityThreshold = 1;
            var b2_maxLinearCorrection = .2;
            var b2_maxAngularCorrection = 8 / 180 * b2_pi;
            var b2_maxTranslation = 2;
            var b2_maxTranslationSquared = b2_maxTranslation * b2_maxTranslation;
            var b2_maxRotation = .5 * b2_pi;
            var b2_maxRotationSquared = b2_maxRotation * b2_maxRotation;
            var b2_baumgarte = .2;
            var b2_toiBaugarte = .75;
            var b2_timeToSleep = .5;
            var b2_linearSleepTolerance = .01;
            var b2_angularSleepTolerance = 2 / 180 * b2_pi;
            function b2Version(ma, mi, re) {
                this.major = ma;
                this.minor = mi;
                this.revision = re;
            }
            b2Version.prototype = {
                toString: function() {
                    return this.major + "." + this.minor + "." + this.revision;
                }
            };
            var b2_version = new b2Version(2, 3, 1);
            function b2IsValid(x) {
                return isFinite(x) && !isNaN(x);
            }
            var sqrtf = Math.sqrt;
            var atan2f = Math.atan2;
            var sinf = Math.sin;
            var cosf = Math.cos;
            var floorf = Math.floor;
            var ceilf = Math.ceil;
            var b2Sqrt = sqrtf;
            var b2Atan2 = atan2f;
            function b2InvSqrt(x) {
                return 1 / sqrtf(x);
            }
            function b2Vec2(x, y) {
                if ("undefined" !== typeof x) {
                    this.x = x;
                    this.y = y;
                } else {
                    this.x = this.y = 0;
                }
            }
            b2Vec2.prototype = {
                Clone: function() {
                    return new b2Vec2(this.x, this.y);
                },
                SetZero: function() {
                    this.x = 0;
                    this.y = 0;
                    return this;
                },
                Set: function(x_, y_) {
                    this.x = x_;
                    this.y = y_;
                    return this;
                },
                Assign: function(l) {
                    this.x = l.x;
                    this.y = l.y;
                    return this;
                },
                Negate: function() {
                    var v = new b2Vec2();
                    v.Set(-this.x, -this.y);
                    return v;
                },
                get_i: function(i) {
                    switch (i) {
                      case 0:
                        return this.x;

                      case 1:
                        return this.y;
                    }
                },
                set_i: function(i, v) {
                    switch (i) {
                      case 0:
                        return this.x = v;

                      case 1:
                        return this.y = v;
                    }
                },
                Add: function(v) {
                    this.x += v.x;
                    this.y += v.y;
                    return this;
                },
                Subtract: function(v) {
                    this.x -= v.x;
                    this.y -= v.y;
                    return this;
                },
                Multiply: function(a) {
                    this.x *= a;
                    this.y *= a;
                    return this;
                },
                Length: function() {
                    return b2Sqrt(this.x * this.x + this.y * this.y);
                },
                LengthSquared: function() {
                    return this.x * this.x + this.y * this.y;
                },
                Normalize: function() {
                    var length = this.Length();
                    if (length < b2_epsilon) {
                        return 0;
                    }
                    var invLength = 1 / length;
                    this.x *= invLength;
                    this.y *= invLength;
                    return length;
                },
                IsValid: function() {
                    return b2IsValid(this.x) && b2IsValid(this.y);
                },
                Skew: function() {
                    return new b2Vec2(-this.y, this.x);
                },
                _serialize: function(out) {
                    var obj = out || [];
                    obj[0] = this.x;
                    obj[1] = this.y;
                    return obj;
                },
                _deserialize: function(data) {
                    this.x = data[0];
                    this.y = data[1];
                }
            };
            b2Vec2.Add = function(a, b) {
                return new b2Vec2(a.x + b.x, a.y + b.y);
            };
            b2Vec2.Subtract = function(a, b) {
                return new b2Vec2(a.x - b.x, a.y - b.y);
            };
            b2Vec2.Equals = function(a, b) {
                return a.x == b.x && a.y == b.y;
            };
            b2Vec2.Multiply = function(s, a) {
                return new b2Vec2(s * a.x, s * a.y);
            };
            b2Vec2.Negate = function(a) {
                return new b2Vec2(-a.x, -a.y);
            };
            function b2Vec3(x, y, z) {
                if ("undefined" !== typeof x) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                }
            }
            b2Vec3.prototype = {
                Clone: function() {
                    return new b2Vec3(this.x, this.y, this.z);
                },
                SetZero: function() {
                    this.x = 0;
                    this.y = 0;
                    this.z = 0;
                },
                Set: function(x_, y_, z_) {
                    this.x = x_;
                    this.y = y_;
                    this.z = z_;
                },
                Negate: function() {
                    var v = new b2Vec3();
                    v.Set(-this.x, -this.y, -this.z);
                    return v;
                },
                Add: function(v) {
                    this.x += v.x;
                    this.y += v.y;
                    this.z += v.z;
                },
                Subtract: function(v) {
                    this.x -= v.x;
                    this.y -= v.y;
                    this.z -= v.z;
                },
                Multiply: function(s) {
                    this.x *= s;
                    this.y *= s;
                    this.z *= s;
                },
                Invert: function() {
                    this.x = -this.x;
                    this.y = -this.y;
                    this.z = -this.z;
                    return this;
                },
                x: 0,
                y: 0,
                z: 0
            };
            b2Vec3.Multiply = function(s, a) {
                return new b2Vec3(s * a.x, s * a.y, s * a.z);
            };
            b2Vec3.Add = function(a, b) {
                return new b2Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
            };
            b2Vec3.Subtract = function(a, b) {
                return new b2Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
            };
            function b2Mat22(c1, c2) {
                this.ex = c1 ? c1.Clone() : new b2Vec2();
                this.ey = c2 ? c2.Clone() : new b2Vec2();
            }
            b2Mat22.prototype = {
                Set: function(c1, c2) {
                    this.ex.Assign(c1);
                    this.ey.Assign(c2);
                },
                Assign: function(mat) {
                    this.ex.Assign(mat.ex);
                    this.ey.Assign(mat.ey);
                },
                SetIdentity: function() {
                    this.ex.x = 1;
                    this.ey.x = 0;
                    this.ex.y = 0;
                    this.ey.y = 1;
                },
                SetZero: function() {
                    this.ex.x = 0;
                    this.ey.x = 0;
                    this.ex.y = 0;
                    this.ey.y = 0;
                },
                GetInverse: function() {
                    var a = this.ex.x, b = this.ey.x, c = this.ex.y, d = this.ey.y;
                    var B = new b2Mat22();
                    var det = a * d - b * c;
                    0 != det && (det = 1 / det);
                    B.ex.x = det * d;
                    B.ey.x = -det * b;
                    B.ex.y = -det * c;
                    B.ey.y = det * a;
                    return B;
                },
                Solve: function(b) {
                    var a11 = this.ex.x, a12 = this.ey.x, a21 = this.ex.y, a22 = this.ey.y;
                    var det = a11 * a22 - a12 * a21;
                    0 != det && (det = 1 / det);
                    var x = new b2Vec2();
                    x.x = det * (a22 * b.x - a12 * b.y);
                    x.y = det * (a11 * b.y - a21 * b.x);
                    return x;
                }
            };
            b2Mat22.Add = function(A, B) {
                return new b2Mat22(b2Vec2.Add(A.ex, B.ex), b2Vec2.Add(A.ey, B.ey));
            };
            function b2Mat33(c1, c2, c3) {
                this.ex = c1 ? c1.Clone() : new b2Vec3();
                this.ey = c2 ? c2.Clone() : new b2Vec3();
                this.ez = c3 ? c3.Clone() : new b2Vec3();
            }
            b2Mat33.prototype = {
                SetZero: function() {
                    this.ex.SetZero();
                    this.ey.SetZero();
                    this.ez.SetZero();
                },
                Solve33: function(b) {
                    var det = b2Dot_v3_v3(this.ex, b2Cross_v3_v3(this.ey, this.ez));
                    0 != det && (det = 1 / det);
                    var x = new b2Vec3();
                    x.x = det * b2Dot_v3_v3(b, b2Cross_v3_v3(this.ey, this.ez));
                    x.y = det * b2Dot_v3_v3(this.ex, b2Cross_v3_v3(b, this.ez));
                    x.z = det * b2Dot_v3_v3(this.ex, b2Cross_v3_v3(this.ey, b));
                    return x;
                },
                Solve22: function(b) {
                    var a11 = this.ex.x, a12 = this.ey.x, a21 = this.ex.y, a22 = this.ey.y;
                    var det = a11 * a22 - a12 * a21;
                    0 != det && (det = 1 / det);
                    var x = new b2Vec2();
                    x.x = det * (a22 * b.x - a12 * b.y);
                    x.y = det * (a11 * b.y - a21 * b.x);
                    return x;
                },
                GetInverse22: function(M) {
                    var a = this.ex.x, b = this.ey.x, c = this.ex.y, d = this.ey.y;
                    var det = a * d - b * c;
                    0 != det && (det = 1 / det);
                    M.ex.x = det * d;
                    M.ey.x = -det * b;
                    M.ex.z = 0;
                    M.ex.y = -det * c;
                    M.ey.y = det * a;
                    M.ey.z = 0;
                    M.ez.x = 0;
                    M.ez.y = 0;
                    M.ez.z = 0;
                },
                GetSymInverse33: function(M) {
                    var det = b2Dot_v3_v3(this.ex, b2Cross_v3_v3(this.ey, this.ez));
                    0 != det && (det = 1 / det);
                    var a11 = this.ex.x, a12 = this.ey.x, a13 = this.ez.x;
                    var a22 = this.ey.y, a23 = this.ez.y;
                    var a33 = this.ez.z;
                    M.ex.x = det * (a22 * a33 - a23 * a23);
                    M.ex.y = det * (a13 * a23 - a12 * a33);
                    M.ex.z = det * (a12 * a23 - a13 * a22);
                    M.ey.x = M.ex.y;
                    M.ey.y = det * (a11 * a33 - a13 * a13);
                    M.ey.z = det * (a13 * a12 - a11 * a23);
                    M.ez.x = M.ex.z;
                    M.ez.y = M.ey.z;
                    M.ez.z = det * (a11 * a22 - a12 * a12);
                }
            };
            function b2Rot(angle, c) {
                if ("undefined" !== typeof c) {
                    this.s = angle;
                    this.c = c;
                } else {
                    "undefined" !== typeof angle && this.Set(angle);
                }
            }
            b2Rot.prototype = {
                Clone: function() {
                    return new b2Rot(this.s, this.c);
                },
                Assign: function(l) {
                    this.s = l.s;
                    this.c = l.c;
                },
                Set: function(x) {
                    this.s = sinf(x);
                    this.c = cosf(x);
                },
                SetIdentity: function() {
                    this.s = 0;
                    this.c = 1;
                },
                GetAngle: function() {
                    return b2Atan2(this.s, this.c);
                },
                GetXAxis: function() {
                    return new b2Vec2(this.c, this.s);
                },
                GetYAxis: function() {
                    return new b2Vec2(-this.s, this.c);
                },
                s: 0,
                c: 1
            };
            function b2Transform(position, rotation) {
                this.p = new b2Vec2();
                this.q = new b2Rot();
                if (position) {
                    this.p.Assign(position);
                    this.q.Assign(rotation);
                }
            }
            b2Transform.prototype = {
                Clone: function() {
                    var xf = new b2Transform(this.p, this.q);
                    return xf;
                },
                Assign: function(xf) {
                    this.p.Assign(xf.p);
                    this.q.Assign(xf.q);
                },
                SetIdentity: function() {
                    this.p.SetZero();
                    this.q.SetIdentity();
                },
                Set: function(position, angle) {
                    this.p.Assign(position);
                    this.q.Set(angle);
                }
            };
            function b2Sweep() {
                this.localCenter = new b2Vec2();
                this.c0 = new b2Vec2();
                this.c = new b2Vec2();
            }
            b2Sweep.prototype = {
                Assign: function(sweep) {
                    this.localCenter.Assign(sweep.localCenter);
                    this.c0.Assign(sweep.c0);
                    this.c.Assign(sweep.c);
                    this.a = sweep.a;
                    this.a0 = sweep.a0;
                    this.alpha0 = sweep.alpha0;
                },
                Clone: function() {
                    var sweep = new b2Sweep();
                    sweep.localCenter.Assign(this.localCenter);
                    sweep.c0.Assign(this.c0);
                    sweep.c.Assign(this.c);
                    sweep.a = this.a;
                    sweep.a0 = this.a0;
                    sweep.alpha0 = this.alpha0;
                    return sweep;
                },
                GetTransform: function(xf, beta) {
                    xf.p.x = (1 - beta) * this.c0.x + beta * this.c.x;
                    xf.p.y = (1 - beta) * this.c0.y + beta * this.c.y;
                    var angle = (1 - beta) * this.a0 + beta * this.a;
                    xf.q.Set(angle);
                    xf.p.x -= xf.q.c * this.localCenter.x - xf.q.s * this.localCenter.y;
                    xf.p.y -= xf.q.s * this.localCenter.x + xf.q.c * this.localCenter.y;
                },
                Advance: function(alpha) {
                    b2Assert(this.alpha0 < 1);
                    var beta = (alpha - this.alpha0) / (1 - this.alpha0);
                    this.c0.Add(b2Vec2.Multiply(beta, b2Vec2.Subtract(this.c, this.c0)));
                    this.a0 += beta * (this.a - this.a0);
                    this.alpha0 = alpha;
                },
                Normalize: function() {
                    var twoPi = 2 * b2_pi;
                    var d = twoPi * floorf(this.a0 / twoPi);
                    this.a0 -= d;
                    this.a -= d;
                },
                a0: 0,
                a: 0,
                alpha0: 0
            };
            function b2Dot_v2_v2(a, b) {
                return a.x * b.x + a.y * b.y;
            }
            function b2Cross_v2_v2(a, b) {
                return a.x * b.y - a.y * b.x;
            }
            function b2Cross_v2_f(a, s) {
                return new b2Vec2(s * a.y, -s * a.x);
            }
            function b2Cross_f_v2(s, a) {
                return new b2Vec2(-s * a.y, s * a.x);
            }
            function b2Mul_m22_v2(A, v) {
                return new b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
            }
            function b2MulT_m22_v2(A, v) {
                return new b2Vec2(b2Dot_v2_v2(v, A.ex), b2Dot_v2_v2(v, A.ey));
            }
            function b2Distance(a, b) {
                var c = b2Vec2.Subtract(a, b);
                return c.Length();
            }
            function b2DistanceSquared(a, b) {
                var c = b2Vec2.Subtract(a, b);
                return b2Dot_v2_v2(c, c);
            }
            function b2Dot_v3_v3(a, b) {
                return a.x * b.x + a.y * b.y + a.z * b.z;
            }
            function b2Cross_v3_v3(a, b) {
                return new b2Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
            }
            function b2Mul_m22_m22(A, B) {
                return new b2Mat22(b2Mul_m22_v2(A, B.ex), b2Mul_m22_v2(A, B.ey));
            }
            function b2MulT_m22_m22(A, B) {
                var c1 = new b2Vec2(b2Dot_v2_v2(A.ex, B.ex), b2Dot_v2_v2(A.ey, B.ex));
                var c2 = new b2Vec2(b2Dot_v2_v2(A.ex, B.ey), b2Dot_v2_v2(A.ey, B.ey));
                return new b2Mat22(c1, c2);
            }
            function b2Mul_m33_v3(A, v) {
                return b2Vec3.Add(b2Vec3.Add(b2Vec3.Multiply(v.x, A.ex), b2Vec3.Multiply(v.y, A.ey)), b2Vec3.Multiply(v.z, A.ez));
            }
            function b2Mul22_m33_v2(A, v) {
                return new b2Vec2(A.ex.x * v.x + A.ey.x * v.y, A.ex.y * v.x + A.ey.y * v.y);
            }
            function b2Mul_r_r(q, r) {
                var qr = new b2Rot();
                qr.s = q.s * r.c + q.c * r.s;
                qr.c = q.c * r.c - q.s * r.s;
                return qr;
            }
            function b2MulT_r_r(q, r) {
                var qr = new b2Rot();
                qr.s = q.c * r.s - q.s * r.c;
                qr.c = q.c * r.c + q.s * r.s;
                return qr;
            }
            function b2Mul_r_v2(q, v) {
                return new b2Vec2(q.c * v.x - q.s * v.y, q.s * v.x + q.c * v.y);
            }
            function b2MulT_r_v2(q, v) {
                return new b2Vec2(q.c * v.x + q.s * v.y, -q.s * v.x + q.c * v.y);
            }
            function b2Mul_t_v2(T, v) {
                return new b2Vec2(T.q.c * v.x - T.q.s * v.y + T.p.x, T.q.s * v.x + T.q.c * v.y + T.p.y);
            }
            function b2MulT_t_v2(T, v) {
                var px = v.x - T.p.x;
                var py = v.y - T.p.y;
                var x = T.q.c * px + T.q.s * py;
                var y = -T.q.s * px + T.q.c * py;
                return new b2Vec2(x, y);
            }
            function b2Mul_t_t(A, B) {
                var C = new b2Transform();
                C.q = b2Mul_r_r(A.q, B.q);
                C.p = b2Vec2.Add(b2Mul_r_v2(A.q, B.p), A.p);
                return C;
            }
            function b2MulT_t_t(A, B) {
                var C = new b2Transform();
                C.q = b2MulT_r_r(A.q, B.q);
                var tvx = B.p.x - A.p.x;
                var tvy = B.p.y - A.p.y;
                C.p.x = A.q.c * tvx + A.q.s * tvy;
                C.p.y = -A.q.s * tvx + A.q.c * tvy;
                return C;
            }
            var b2Abs = Math.abs;
            function b2Abs_v2(a) {
                return new b2Vec2(b2Abs(a.x), b2Abs(a.y));
            }
            function b2Abs_m22(A) {
                return new b2Mat22(b2Abs_v2(A.ex), b2Abs_v2(A.ey));
            }
            var b2Min = Math.min;
            function b2Min_v2(a, b) {
                return new b2Vec2(b2Min(a.x, b.x), b2Min(a.y, b.y));
            }
            var b2Max = Math.max;
            function b2Max_v2(a, b) {
                return new b2Vec2(b2Max(a.x, b.x), b2Max(a.y, b.y));
            }
            function b2Clamp(a, low, high) {
                return b2Max(low, b2Min(a, high));
            }
            function b2Clamp_v2(a, low, high) {
                return b2Max_v2(low, b2Min_v2(a, high));
            }
            function b2NextPowerOfTwo(x) {
                x |= x >> 1;
                x |= x >> 2;
                x |= x >> 4;
                x |= x >> 8;
                x |= x >> 16;
                return x + 1;
            }
            function b2IsPowerOfTwo(x) {
                var result = x > 0 && 0 == (x & x - 1);
                return result;
            }
            var RAND_LIMIT = 32767;
            function b2RandomFloat(lo, hi) {
                var r = Math.random();
                r = "undefined" !== typeof lo ? (hi - lo) * r + lo : 2 * r - 1;
                return r;
            }
            function b2Color(r, g, b) {
                this.r = r || 0;
                this.g = g || 0;
                this.b = b || 0;
            }
            b2Color.prototype = {
                Set: function(r, g, b) {
                    this.r = r;
                    this.g = g;
                    this.b = b;
                }
            };
            function b2Draw() {}
            b2Draw.prototype = {
                ClearDraw: function() {},
                SetFlags: function(flags) {
                    this.m_drawFlags = flags;
                },
                GetFlags: function() {
                    return this.m_drawFlags;
                },
                AppendFlags: function(flags) {
                    this.m_drawFlags |= flags;
                },
                ClearFlags: function(flags) {
                    this.m_drawFlags &= ~flags;
                },
                ToggleFlags: function(flags) {
                    this.m_drawFlags ^= flags;
                },
                DrawPolygon: function(vertices, vertexCount, color) {},
                DrawSolidPolygon: function(vertices, vertexCount, color) {},
                DrawCircle: function(center, radius, color) {},
                DrawSolidCircle: function(center, radius, axis, color) {},
                DrawSegment: function(p1, p2, color) {},
                DrawTransform: function(xf) {},
                m_drawFlags: 0
            };
            b2Draw.e_shapeBit = 1;
            b2Draw.e_jointBit = 2;
            b2Draw.e_aabbBit = 4;
            b2Draw.e_centerOfMassBit = 8;
            b2Draw.e_contactPoints = 16;
            b2Draw.e_contactNormals = 32;
            b2Draw.e_contactImpulses = 64;
            b2Draw.e_frictionImpulses = 128;
            b2Draw.e_statistics = 256;
            b2Draw.e_profile = 512;
            b2Draw.e_pairBit = 1024;
            "undefined" === typeof performance && (window.performance = {
                now: function() {
                    return +new Date();
                }
            });
            function b2Timer() {
                this.Reset();
            }
            b2Timer.prototype = {
                Reset: function() {
                    this.m_start = performance.now();
                },
                GetMilliseconds: function() {
                    return performance.now() - this.m_start;
                }
            };
            function b2MassData() {
                this.mass = 0;
                this.center = new b2Vec2();
                this.I = 0;
            }
            function b2Shape() {
                this.m_type = 0;
                this.m_radius = 0;
            }
            b2Shape.prototype = {
                Clone: function() {},
                GetType: function() {
                    return this.m_type;
                },
                GetChildCount: function() {},
                TestPoint: function(xf, p) {},
                RayCast: function(output, input, transform, childIndex) {},
                ComputeAABB: function(aabb, xf, childIndex) {},
                ComputeMass: function(massData, density) {},
                _serialize: function(out) {
                    var obj = out || {};
                    obj["m_type"] = this.m_type;
                    obj["m_radius"] = this.m_radius;
                    return obj;
                },
                _deserialize: function(data) {
                    this.m_radius = data["m_radius"];
                }
            };
            b2Shape.e_circle = 0;
            b2Shape.e_edge = 1;
            b2Shape.e_polygon = 2;
            b2Shape.e_chain = 3;
            b2Shape.e_typeCount = 4;
            function b2CircleShape() {
                this.parent.call(this);
                this.m_type = b2Shape.e_circle;
                this.m_radius = 0;
                this.m_p = new b2Vec2();
                Object.seal(this);
            }
            b2CircleShape.prototype = {
                Clone: function() {
                    var shape = new b2CircleShape();
                    shape.m_radius = this.m_radius;
                    shape.m_p = this.m_p.Clone();
                    return shape;
                },
                GetChildCount: function() {
                    return 1;
                },
                TestPoint: function(transform, p) {
                    var center = b2Vec2.Add(transform.p, b2Mul_r_v2(transform.q, this.m_p));
                    var d = b2Vec2.Subtract(p, center);
                    return b2Dot_v2_v2(d, d) <= this.m_radius * this.m_radius;
                },
                RayCast: function(output, input, transform, childIndex) {
                    var position = b2Vec2.Add(transform.p, b2Mul_r_v2(transform.q, this.m_p));
                    var s = b2Vec2.Subtract(input.p1, position);
                    var b = b2Dot_v2_v2(s, s) - this.m_radius * this.m_radius;
                    var r = b2Vec2.Subtract(input.p2, input.p1);
                    var c = b2Dot_v2_v2(s, r);
                    var rr = b2Dot_v2_v2(r, r);
                    var sigma = c * c - rr * b;
                    if (sigma < 0 || rr < b2_epsilon) {
                        return false;
                    }
                    var a = -(c + b2Sqrt(sigma));
                    if (0 <= a && a <= input.maxFraction * rr) {
                        a /= rr;
                        output.fraction = a;
                        output.normal = b2Vec2.Add(s, b2Vec2.Multiply(a, r));
                        output.normal.Normalize();
                        return true;
                    }
                    return false;
                },
                ComputeAABB: function(aabb, transform, childIndex) {
                    var px = transform.p.x + (transform.q.c * this.m_p.x - transform.q.s * this.m_p.y);
                    var py = transform.p.y + (transform.q.s * this.m_p.x + transform.q.c * this.m_p.y);
                    aabb.lowerBound.x = px - this.m_radius;
                    aabb.lowerBound.y = py - this.m_radius;
                    aabb.upperBound.x = px + this.m_radius;
                    aabb.upperBound.y = py + this.m_radius;
                },
                ComputeMass: function(massData, density) {
                    massData.mass = density * b2_pi * this.m_radius * this.m_radius;
                    massData.center = this.m_p;
                    massData.I = massData.mass * (.5 * this.m_radius * this.m_radius + b2Dot_v2_v2(this.m_p, this.m_p));
                },
                GetSupport: function(d) {
                    return 0;
                },
                GetSupportVertex: function(d) {
                    return this.m_p;
                },
                GetVertexCount: function() {
                    return 1;
                },
                GetVertex: function(index) {
                    b2Assert(0 == index);
                    return this.m_p;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    this.parent.prototype._serialize.call(this, obj);
                    obj["m_p"] = this.m_p._serialize();
                    return obj;
                },
                _deserialize: function(data) {
                    this.parent.prototype._deserialize.call(this, data);
                    this.m_p._deserialize(data["m_p"]);
                }
            };
            b2CircleShape._extend(b2Shape);
            function b2EdgeShape() {
                this.parent.call(this);
                this.m_type = b2Shape.e_edge;
                this.m_radius = b2_polygonRadius;
                this.m_vertex0 = new b2Vec2();
                this.m_vertex1 = new b2Vec2();
                this.m_vertex2 = new b2Vec2();
                this.m_vertex3 = new b2Vec2();
                this.m_hasVertex0 = false;
                this.m_hasVertex3 = false;
                Object.seal(this);
            }
            b2EdgeShape.prototype = {
                Set: function(v1, v2) {
                    this.m_vertex1.Assign(v1);
                    this.m_vertex2.Assign(v2);
                    this.m_hasVertex0 = false;
                    this.m_hasVertex3 = false;
                },
                Clone: function() {
                    var shape = new b2EdgeShape();
                    shape.m_vertex0 = this.m_vertex0.Clone();
                    shape.m_vertex1 = this.m_vertex1.Clone();
                    shape.m_vertex2 = this.m_vertex2.Clone();
                    shape.m_vertex3 = this.m_vertex3.Clone();
                    shape.m_hasVertex0 = this.m_hasVertex0;
                    shape.m_hasVertex3 = this.m_hasVertex3;
                    return shape;
                },
                GetChildCount: function() {
                    return 1;
                },
                TestPoint: function(transform, p) {
                    return false;
                },
                RayCast: function(output, input, xf, childIndex) {
                    var p1 = b2MulT_r_v2(xf.q, b2Vec2.Subtract(input.p1, xf.p));
                    var p2 = b2MulT_r_v2(xf.q, b2Vec2.Subtract(input.p2, xf.p));
                    var d = b2Vec2.Subtract(p2, p1);
                    var v1 = this.m_vertex1;
                    var v2 = this.m_vertex2;
                    var e = b2Vec2.Subtract(v2, v1);
                    var normal = new b2Vec2(e.y, -e.x);
                    normal.Normalize();
                    var numerator = b2Dot_v2_v2(normal, b2Vec2.Subtract(v1, p1));
                    var denominator = b2Dot_v2_v2(normal, d);
                    if (0 == denominator) {
                        return false;
                    }
                    var t = numerator / denominator;
                    if (t < 0 || input.maxFraction < t) {
                        return false;
                    }
                    var q = b2Vec2.Add(p1, b2Vec2.Multiply(t, d));
                    var r = b2Vec2.Subtract(v2, v1);
                    var rr = b2Dot_v2_v2(r, r);
                    if (0 == rr) {
                        return false;
                    }
                    var s = b2Dot_v2_v2(b2Vec2.Subtract(q, v1), r) / rr;
                    if (s < 0 || 1 < s) {
                        return false;
                    }
                    output.fraction = t;
                    numerator > 0 ? output.normal = b2Mul_r_v2(xf.q, normal).Negate() : output.normal = b2Mul_r_v2(xf.q, normal);
                    return true;
                },
                ComputeAABB: function(aabb, xf, childIndex) {
                    var v1x = xf.q.c * this.m_vertex1.x - xf.q.s * this.m_vertex1.y + xf.p.x;
                    var v1y = xf.q.s * this.m_vertex1.x + xf.q.c * this.m_vertex1.y + xf.p.y;
                    var v2x = xf.q.c * this.m_vertex2.x - xf.q.s * this.m_vertex2.y + xf.p.x;
                    var v2y = xf.q.s * this.m_vertex2.x + xf.q.c * this.m_vertex2.y + xf.p.y;
                    var lowerx = b2Min(v1x, v2x);
                    var lowery = b2Min(v1y, v2y);
                    var upperx = b2Max(v1x, v2x);
                    var uppery = b2Max(v1y, v2y);
                    aabb.lowerBound.x = lowerx - this.m_radius;
                    aabb.lowerBound.y = lowery - this.m_radius;
                    aabb.upperBound.x = upperx + this.m_radius;
                    aabb.upperBound.y = uppery + this.m_radius;
                },
                ComputeMass: function(massData, density) {
                    massData.mass = 0;
                    massData.center = b2Vec2.Multiply(.5, b2Vec2.Add(this.m_vertex1, this.m_vertex2));
                    massData.I = 0;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    this.parent.prototype._serialize.call(this, obj);
                    obj["m_vertex1"] = this.m_vertex1._serialize();
                    obj["m_vertex2"] = this.m_vertex2._serialize();
                    obj["m_hasVertex0"] = this.m_hasVertex0;
                    this.m_hasVertex0 && (obj["m_vertex0"] = this.m_vertex0._serialize());
                    obj["m_hasVertex3"] = this.m_hasVertex3;
                    this.m_hasVertex3 && (obj["m_vertex3"] = this.m_vertex3._serialize());
                    return obj;
                },
                _deserialize: function(data) {
                    this.parent.prototype._deserialize.call(this, data);
                    this.m_vertex1._deserialize(data["m_vertex1"]);
                    this.m_vertex2._deserialize(data["m_vertex2"]);
                    this.m_hasVertex0 = data["m_hasVertex0"];
                    this.m_hasVertex0 && this.m_vertex0._deserialize(data["m_vertex0"]);
                    this.m_hasVertex3 = data["m_hasVertex3"];
                    this.m_hasVertex3 && this.m_vertex3._deserialize(data["m_vertex3"]);
                }
            };
            b2EdgeShape._extend(b2Shape);
            function b2ChainShape() {
                this.parent.call(this);
                this.m_type = b2Shape.e_chain;
                this.m_radius = b2_polygonRadius;
                this.m_prevVertex = new b2Vec2();
                this.m_nextVertex = new b2Vec2();
                this.m_hasPrevVertex = false;
                this.m_hasNextVertex = false;
                this.Clear();
                Object.seal(this);
            }
            b2ChainShape._tempEdge = new b2EdgeShape();
            b2ChainShape.prototype = {
                Clear: function() {
                    this.m_vertices = null;
                    this.m_count = 0;
                },
                CreateLoop: function(vertices, count) {
                    b2Assert(null == this.m_vertices && 0 == this.m_count);
                    b2Assert(count >= 3);
                    for (var i = 1; i < count; ++i) {
                        b2Assert(b2DistanceSquared(vertices[i - 1], vertices[i]) > b2_linearSlop * b2_linearSlop);
                    }
                    this.m_count = count + 1;
                    this.m_vertices = new Array(this.m_count);
                    for (var i = 0; i < count; ++i) {
                        this.m_vertices[i] = vertices[i].Clone();
                    }
                    this.m_vertices[count] = this.m_vertices[0].Clone();
                    this.m_prevVertex.Assign(this.m_vertices[this.m_count - 2]);
                    this.m_nextVertex.Assign(this.m_vertices[1]);
                    this.m_hasPrevVertex = true;
                    this.m_hasNextVertex = true;
                },
                CreateChain: function(vertices, count) {
                    b2Assert(null == this.m_vertices && 0 == this.m_count);
                    b2Assert(count >= 2);
                    for (var i = 1; i < count; ++i) {
                        var v1 = vertices[i - 1];
                        var v2 = vertices[i];
                        b2Assert(b2DistanceSquared(v1, v2) > b2_linearSlop * b2_linearSlop);
                    }
                    this.m_count = count;
                    this.m_vertices = new Array(count);
                    for (var i = 0; i < count; ++i) {
                        this.m_vertices[i] = vertices[i].Clone();
                    }
                    this.m_hasPrevVertex = false;
                    this.m_hasNextVertex = false;
                    this.m_prevVertex.SetZero();
                    this.m_nextVertex.SetZero();
                },
                SetPrevVertex: function(prevVertex) {
                    this.m_prevVertex.Assign(prevVertex);
                    this.m_hasPrevVertex = true;
                },
                SetNextVertex: function(nextVertex) {
                    this.m_nextVertex.Assign(nextVertex);
                    this.m_hasNextVertex = true;
                },
                Clone: function() {
                    var shape = new b2ChainShape();
                    shape.m_count = this.m_count;
                    shape.m_vertices = new Array(this.m_count);
                    for (var i = 0; i < this.m_count; ++i) {
                        shape.m_vertices[i] = this.m_vertices[i].Clone();
                    }
                    shape.m_prevVertex = this.m_prevVertex.Clone();
                    shape.m_nextVertex = this.m_nextVertex.Clone();
                    shape.m_hasPrevVertex = this.m_hasPrevVertex;
                    shape.m_hasNextVertex = this.m_hasNextVertex;
                    return shape;
                },
                GetChildCount: function() {
                    return this.m_count - 1;
                },
                GetChildEdge: function(edge, index) {
                    b2Assert(0 <= index && index < this.m_count - 1);
                    edge.m_type = b2Shape.e_edge;
                    edge.m_radius = this.m_radius;
                    edge.m_vertex1 = this.m_vertices[index + 0];
                    edge.m_vertex2 = this.m_vertices[index + 1];
                    if (index > 0) {
                        edge.m_vertex0 = this.m_vertices[index - 1];
                        edge.m_hasVertex0 = true;
                    } else {
                        edge.m_vertex0 = this.m_prevVertex;
                        edge.m_hasVertex0 = this.m_hasPrevVertex;
                    }
                    if (index < this.m_count - 2) {
                        edge.m_vertex3 = this.m_vertices[index + 2];
                        edge.m_hasVertex3 = true;
                    } else {
                        edge.m_vertex3 = this.m_nextVertex;
                        edge.m_hasVertex3 = this.m_hasNextVertex;
                    }
                },
                TestPoint: function(transform, p) {
                    return false;
                },
                RayCast: function(output, input, xf, childIndex) {
                    b2Assert(childIndex < this.m_count);
                    var i1 = childIndex;
                    var i2 = childIndex + 1;
                    i2 == this.m_count && (i2 = 0);
                    b2ChainShape._tempEdge.m_vertex1 = this.m_vertices[i1].Clone();
                    b2ChainShape._tempEdge.m_vertex2 = this.m_vertices[i2].Clone();
                    return b2ChainShape._tempEdge.RayCast(output, input, xf, 0);
                },
                ComputeAABB: function(aabb, xf, childIndex) {
                    b2Assert(childIndex < this.m_count);
                    var i1 = childIndex;
                    var i2 = childIndex + 1;
                    i2 == this.m_count && (i2 = 0);
                    var v1x = xf.q.c * this.m_vertices[i1].x - xf.q.s * this.m_vertices[i1].y + xf.p.x;
                    var v1y = xf.q.s * this.m_vertices[i1].x + xf.q.c * this.m_vertices[i1].y + xf.p.y;
                    var v2x = xf.q.c * this.m_vertices[i2].x - xf.q.s * this.m_vertices[i2].y + xf.p.x;
                    var v2y = xf.q.s * this.m_vertices[i2].x + xf.q.c * this.m_vertices[i2].y + xf.p.y;
                    aabb.lowerBound.x = b2Min(v1x, v2x);
                    aabb.lowerBound.y = b2Min(v1y, v2y);
                    aabb.upperBound.x = b2Max(v1x, v2x);
                    aabb.upperBound.y = b2Max(v1y, v2y);
                },
                ComputeMass: function(massData, density) {
                    massData.mass = 0;
                    massData.center.SetZero();
                    massData.I = 0;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    this.parent.prototype._serialize.call(this, obj);
                    obj["m_count"] = this.m_count;
                    obj["m_vertices"] = [];
                    for (var i = 0; i < this.m_count; ++i) {
                        obj["m_vertices"].push(this.m_vertices[i]._serialize());
                    }
                    obj["m_hasPrevVertex"] = this.m_hasPrevVertex;
                    this.m_hasPrevVertex && (obj["m_prevVertex"] = this.m_prevVertex._serialize());
                    obj["m_hasNextVertex"] = this.m_hasNextVertex;
                    this.m_hasNextVertex && (obj["m_nextVertex"] = this.m_nextVertex._serialize());
                    return obj;
                },
                _deserialize: function(data) {
                    this.parent.prototype._deserialize.call(this, data);
                    this.m_count = data["m_count"];
                    this.m_vertices = [];
                    for (var i = 0; i < this.m_count; ++i) {
                        this.m_vertices[i] = new b2Vec2();
                        this.m_vertices[i]._deserialize(data["m_vertices"][i]);
                    }
                    this.m_hasPrevVertex = data["m_hasPrevVertex"];
                    this.m_hasPrevVertex && this.m_prevVertex._deserialize(data["m_prevVertex"]);
                    this.m_hasNextVertex = data["m_hasNextVertex"];
                    this.m_hasNextVertex && this.m_nextVertex._deserialize(data["m_nextVertex"]);
                }
            };
            b2ChainShape._extend(b2Shape);
            function b2PolygonShape() {
                this.parent.call(this);
                this.m_type = b2Shape.e_polygon;
                this.m_radius = b2_polygonRadius;
                this.m_count = 0;
                this.m_centroid = new b2Vec2();
                this.m_vertices = new Array(b2_maxPolygonVertices);
                this.m_normals = new Array(b2_maxPolygonVertices);
                Object.seal(this);
            }
            b2PolygonShape.prototype = {
                Clone: function() {
                    var shape = new b2PolygonShape();
                    shape.m_count = this.m_count;
                    shape.m_centroid = this.m_centroid.Clone();
                    for (var i = 0; i < this.m_count; ++i) {
                        shape.m_vertices[i] = this.m_vertices[i].Clone();
                        shape.m_normals[i] = this.m_normals[i].Clone();
                    }
                    return shape;
                },
                GetChildCount: function() {
                    return 1;
                },
                Set: function(vertices, count) {
                    b2Assert(3 <= count && count <= b2_maxPolygonVertices);
                    if (count < 3) {
                        this.SetAsBox(1, 1);
                        return;
                    }
                    var n = b2Min(count, b2_maxPolygonVertices);
                    var ps = new Array(b2_maxPolygonVertices);
                    var tempCount = 0;
                    for (var i = 0; i < n; ++i) {
                        var v = vertices[i];
                        var unique = true;
                        for (var j = 0; j < tempCount; ++j) {
                            if (b2DistanceSquared(v, ps[j]) < .5 * b2_linearSlop) {
                                unique = false;
                                break;
                            }
                        }
                        unique && (ps[tempCount++] = v.Clone());
                    }
                    n = tempCount;
                    if (n < 3) {
                        b2Assert(false);
                        this.SetAsBox(1, 1);
                        return;
                    }
                    var i0 = 0;
                    var x0 = ps[0].x;
                    for (i = 1; i < n; ++i) {
                        var x = ps[i].x;
                        if (x > x0 || x == x0 && ps[i].y < ps[i0].y) {
                            i0 = i;
                            x0 = x;
                        }
                    }
                    var hull = new Array(b2_maxPolygonVertices);
                    var m = 0;
                    var ih = i0;
                    for (;;) {
                        hull[m] = ih;
                        var ie = 0;
                        for (j = 1; j < n; ++j) {
                            if (ie == ih) {
                                ie = j;
                                continue;
                            }
                            var r = b2Vec2.Subtract(ps[ie], ps[hull[m]]);
                            var v = b2Vec2.Subtract(ps[j], ps[hull[m]]);
                            var c = b2Cross_v2_v2(r, v);
                            c < 0 && (ie = j);
                            0 == c && v.LengthSquared() > r.LengthSquared() && (ie = j);
                        }
                        ++m;
                        ih = ie;
                        if (ie == i0) {
                            break;
                        }
                    }
                    if (m < 3) {
                        b2Assert(false);
                        this.SetAsBox(1, 1);
                        return;
                    }
                    this.m_count = m;
                    for (i = 0; i < m; ++i) {
                        this.m_vertices[i] = ps[hull[i]].Clone();
                    }
                    for (i = 0; i < m; ++i) {
                        var i1 = i;
                        var i2 = i + 1 < m ? i + 1 : 0;
                        var edge = b2Vec2.Subtract(this.m_vertices[i2], this.m_vertices[i1]);
                        b2Assert(edge.LengthSquared() > b2_epsilon * b2_epsilon);
                        this.m_normals[i] = b2Cross_v2_f(edge, 1).Clone();
                        this.m_normals[i].Normalize();
                    }
                    this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, m);
                },
                SetAsBox: function(hx, hy, center, angle) {
                    this.m_count = 4;
                    this.m_vertices[0] = new b2Vec2(-hx, -hy);
                    this.m_vertices[1] = new b2Vec2(hx, -hy);
                    this.m_vertices[2] = new b2Vec2(hx, hy);
                    this.m_vertices[3] = new b2Vec2(-hx, hy);
                    this.m_normals[0] = new b2Vec2(0, -1);
                    this.m_normals[1] = new b2Vec2(1, 0);
                    this.m_normals[2] = new b2Vec2(0, 1);
                    this.m_normals[3] = new b2Vec2(-1, 0);
                    if (!center) {
                        return;
                    }
                    this.m_centroid.Assign(center);
                    var xf = new b2Transform();
                    xf.p = center;
                    xf.q.Set(angle);
                    for (var i = 0; i < this.m_count; ++i) {
                        this.m_vertices[i].Assign(b2Mul_t_v2(xf, this.m_vertices[i]));
                        this.m_normals[i].Assign(b2Mul_r_v2(xf.q, this.m_normals[i]));
                    }
                },
                TestPoint: function(xf, p) {
                    var pLocal = b2MulT_r_v2(xf.q, b2Vec2.Subtract(p, xf.p));
                    for (var i = 0; i < this.m_count; ++i) {
                        var dot = b2Dot_v2_v2(this.m_normals[i], b2Vec2.Subtract(pLocal, this.m_vertices[i]));
                        if (dot > 0) {
                            return false;
                        }
                    }
                    return true;
                },
                RayCast: function(output, input, xf, childIndex) {
                    var p1 = b2MulT_r_v2(xf.q, b2Vec2.Subtract(input.p1, xf.p));
                    var p2 = b2MulT_r_v2(xf.q, b2Vec2.Subtract(input.p2, xf.p));
                    var d = b2Vec2.Subtract(p2, p1);
                    var lower = 0, upper = input.maxFraction;
                    var index = -1;
                    for (var i = 0; i < this.m_count; ++i) {
                        var numerator = b2Dot_v2_v2(this.m_normals[i], b2Vec2.Subtract(this.m_vertices[i], p1));
                        var denominator = b2Dot_v2_v2(this.m_normals[i], d);
                        if (0 == denominator) {
                            if (numerator < 0) {
                                return false;
                            }
                        } else {
                            if (denominator < 0 && numerator < lower * denominator) {
                                lower = numerator / denominator;
                                index = i;
                            } else {
                                denominator > 0 && numerator < upper * denominator && (upper = numerator / denominator);
                            }
                        }
                        if (upper < lower) {
                            return false;
                        }
                    }
                    b2Assert(0 <= lower && lower <= input.maxFraction);
                    if (index >= 0) {
                        output.fraction = lower;
                        output.normal = b2Mul_r_v2(xf.q, this.m_normals[index]);
                        return true;
                    }
                    return false;
                },
                ComputeAABB: function(aabb, xf, childIndex) {
                    var lowerx = xf.q.c * this.m_vertices[0].x - xf.q.s * this.m_vertices[0].y + xf.p.x;
                    var lowery = xf.q.s * this.m_vertices[0].x + xf.q.c * this.m_vertices[0].y + xf.p.y;
                    var upperx = lowerx;
                    var uppery = lowery;
                    for (var i = 1; i < this.m_count; ++i) {
                        var vx = xf.q.c * this.m_vertices[i].x - xf.q.s * this.m_vertices[i].y + xf.p.x;
                        var vy = xf.q.s * this.m_vertices[i].x + xf.q.c * this.m_vertices[i].y + xf.p.y;
                        lowerx = b2Min(lowerx, vx);
                        lowery = b2Min(lowery, vy);
                        upperx = b2Max(upperx, vx);
                        uppery = b2Max(uppery, vy);
                    }
                    aabb.lowerBound.x = lowerx - this.m_radius;
                    aabb.lowerBound.y = lowery - this.m_radius;
                    aabb.upperBound.x = upperx + this.m_radius;
                    aabb.upperBound.y = uppery + this.m_radius;
                },
                ComputeMass: function(massData, density) {
                    b2Assert(this.m_count >= 3);
                    var center = new b2Vec2(0, 0);
                    var area = 0;
                    var I = 0;
                    var s = new b2Vec2(0, 0);
                    for (var i = 0; i < this.m_count; ++i) {
                        s.Add(this.m_vertices[i]);
                    }
                    s.Multiply(1 / this.m_count);
                    var k_inv3 = 1 / 3;
                    for (var i = 0; i < this.m_count; ++i) {
                        var e1 = b2Vec2.Subtract(this.m_vertices[i], s);
                        var e2 = i + 1 < this.m_count ? b2Vec2.Subtract(this.m_vertices[i + 1], s) : b2Vec2.Subtract(this.m_vertices[0], s);
                        var D = b2Cross_v2_v2(e1, e2);
                        var triangleArea = .5 * D;
                        area += triangleArea;
                        center.Add(b2Vec2.Multiply(triangleArea * k_inv3, b2Vec2.Add(e1, e2)));
                        var ex1 = e1.x, ey1 = e1.y;
                        var ex2 = e2.x, ey2 = e2.y;
                        var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;
                        var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;
                        I += .25 * k_inv3 * D * (intx2 + inty2);
                    }
                    massData.mass = density * area;
                    b2Assert(area > b2_epsilon);
                    center.Multiply(1 / area);
                    massData.center = b2Vec2.Add(center, s);
                    massData.I = density * I;
                    massData.I += massData.mass * (b2Dot_v2_v2(massData.center, massData.center) - b2Dot_v2_v2(center, center));
                },
                GetVertexCount: function() {
                    return this.m_count;
                },
                GetVertex: function(index) {
                    b2Assert(0 <= index && index < this.m_count);
                    return this.m_vertices[index];
                },
                Validate: function() {
                    for (var i = 0; i < this.m_count; ++i) {
                        var i1 = i;
                        var i2 = i < this.m_count - 1 ? i1 + 1 : 0;
                        var p = this.m_vertices[i1];
                        var e = b2Vec2.Subtract(this.m_vertices[i2], p);
                        for (var j = 0; j < this.m_count; ++j) {
                            if (j == i1 || j == i2) {
                                continue;
                            }
                            var v = b2Vec2.Subtract(this.m_vertices[j], p);
                            var c = b2Cross_v2_v2(e, v);
                            if (c < 0) {
                                return false;
                            }
                        }
                    }
                    return true;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    this.parent.prototype._serialize.call(this, obj);
                    obj["m_count"] = this.m_count;
                    obj["m_centroid"] = this.m_centroid._serialize();
                    obj["m_vertices"] = [];
                    obj["m_normals"] = [];
                    for (var i = 0; i < this.m_count; ++i) {
                        obj["m_vertices"].push(this.m_vertices[i]._serialize());
                        obj["m_normals"].push(this.m_normals[i]._serialize());
                    }
                    return obj;
                },
                _deserialize: function(data) {
                    this.parent.prototype._deserialize.call(this, data);
                    this.m_count = data["m_count"];
                    this.m_centroid._deserialize(data["m_centroid"]);
                    this.m_vertices = [];
                    this.m_normals = [];
                    for (var i = 0; i < this.m_count; ++i) {
                        this.m_vertices[i] = new b2Vec2();
                        this.m_vertices[i]._deserialize(data["m_vertices"][i]);
                        this.m_normals[i] = new b2Vec2();
                        this.m_normals[i]._deserialize(data["m_normals"][i]);
                    }
                }
            };
            b2PolygonShape.ComputeCentroid = function(vs, count) {
                b2Assert(count >= 3);
                var c = new b2Vec2();
                var area = 0;
                var pRef = new b2Vec2(0, 0);
                var inv3 = 1 / 3;
                for (var i = 0; i < count; ++i) {
                    var p1 = pRef;
                    var p2 = vs[i];
                    var p3 = i + 1 < count ? vs[i + 1] : vs[0];
                    var e1 = b2Vec2.Subtract(p2, p1);
                    var e2 = b2Vec2.Subtract(p3, p1);
                    var D = b2Cross_v2_v2(e1, e2);
                    var triangleArea = .5 * D;
                    area += triangleArea;
                    c.Add(b2Vec2.Multiply(triangleArea, b2Vec2.Multiply(inv3, b2Vec2.Add(b2Vec2.Add(p1, p2), p3))));
                }
                b2Assert(area > b2_epsilon);
                c.Multiply(1 / area);
                return c;
            };
            b2PolygonShape._extend(b2Shape);
            function b2Pair() {
                this.proxyIdA = 0;
                this.proxyIdB = 0;
            }
            function b2PairLessThan(pair1, pair2) {
                if (pair1.proxyIdA == pair2.proxyIdA) {
                    return pair1.proxyIdB - pair2.proxyIdB;
                }
                return pair1.proxyIdA - pair2.proxyIdA;
            }
            function b2BroadPhase() {
                this.m_tree = new b2DynamicTree();
                this.m_queryProxyId = 0;
                this.m_proxyCount = 0;
                this.m_pairCount = 0;
                this.m_pairBuffer = [];
                this.m_moveCount = 0;
                this.m_moveBuffer = [];
            }
            b2BroadPhase.prototype = {
                CreateProxy: function(aabb, userData) {
                    var proxyId = this.m_tree.CreateProxy(aabb, userData);
                    ++this.m_proxyCount;
                    this.BufferMove(proxyId);
                    return proxyId;
                },
                DestroyProxy: function(proxyId) {
                    this.UnBufferMove(proxyId);
                    --this.m_proxyCount;
                    this.m_tree.DestroyProxy(proxyId);
                },
                MoveProxy: function(proxyId, aabb, displacement) {
                    var buffer = this.m_tree.MoveProxy(proxyId, aabb, displacement);
                    buffer && this.BufferMove(proxyId);
                },
                TouchProxy: function(proxyId) {
                    this.BufferMove(proxyId);
                },
                GetFatAABB: function(proxyId) {
                    return this.m_tree.GetFatAABB(proxyId);
                },
                GetUserData: function(proxyId) {
                    return this.m_tree.GetUserData(proxyId);
                },
                TestOverlap: function(proxyIdA, proxyIdB) {
                    var aabbA = this.m_tree.GetFatAABB(proxyIdA);
                    var aabbB = this.m_tree.GetFatAABB(proxyIdB);
                    return b2TestOverlap(aabbA, aabbB);
                },
                GetProxyCount: function() {
                    return this.m_proxyCount;
                },
                UpdatePairs: function(callback) {
                    this.m_pairCount = 0;
                    this.m_pairBuffer.length = 0;
                    for (var i = 0; i < this.m_moveCount; ++i) {
                        this.m_queryProxyId = this.m_moveBuffer[i];
                        if (this.m_queryProxyId == b2BroadPhase.e_nullProxy) {
                            continue;
                        }
                        var fatAABB = this.m_tree.GetFatAABB(this.m_queryProxyId);
                        this.m_tree.Query(this, fatAABB);
                    }
                    this.m_moveCount = 0;
                    this.m_pairBuffer.sort(b2PairLessThan);
                    var i = 0;
                    while (i < this.m_pairCount) {
                        var primaryPair = this.m_pairBuffer[i];
                        var userDataA = this.m_tree.GetUserData(primaryPair.proxyIdA);
                        var userDataB = this.m_tree.GetUserData(primaryPair.proxyIdB);
                        callback.AddPair(userDataA, userDataB);
                        ++i;
                        while (i < this.m_pairCount) {
                            var pair = this.m_pairBuffer[i];
                            if (pair.proxyIdA != primaryPair.proxyIdA || pair.proxyIdB != primaryPair.proxyIdB) {
                                break;
                            }
                            ++i;
                        }
                    }
                },
                Query: function(callback, aabb) {
                    this.m_tree.Query(callback, aabb);
                },
                RayCast: function(callback, input) {
                    this.m_tree.RayCast(callback, input);
                },
                GetTreeHeight: function() {
                    return this.m_tree.GetHeight();
                },
                GetTreeBalance: function() {
                    return this.m_tree.GetMaxBalance();
                },
                GetTreeQuality: function() {
                    return this.m_tree.GetAreaRatio();
                },
                ShiftOrigin: function(newOrigin) {
                    this.m_tree.ShiftOrigin(newOrigin);
                },
                BufferMove: function(proxyId) {
                    this.m_moveBuffer[this.m_moveCount] = proxyId;
                    ++this.m_moveCount;
                },
                UnBufferMove: function(proxyId) {
                    for (var i = 0; i < this.m_moveCount; ++i) {
                        this.m_moveBuffer[i] == proxyId && (this.m_moveBuffer[i] = b2BroadPhase.e_nullProxy);
                    }
                },
                QueryCallback: function(proxyId) {
                    if (proxyId == this.m_queryProxyId) {
                        return true;
                    }
                    this.m_pairBuffer[this.m_pairCount] = new b2Pair();
                    this.m_pairBuffer[this.m_pairCount].proxyIdA = b2Min(proxyId, this.m_queryProxyId);
                    this.m_pairBuffer[this.m_pairCount].proxyIdB = b2Max(proxyId, this.m_queryProxyId);
                    ++this.m_pairCount;
                    return true;
                }
            };
            b2BroadPhase.e_nullProxy = -1;
            function b2DistanceProxy() {
                this.m_vertices = null;
                this.m_count = 0;
                this.m_radius = 0;
            }
            b2DistanceProxy.prototype = {
                Assign: function(l) {
                    this.m_vertices = l.m_vertices;
                    this.m_count = l.m_count;
                    this.m_radius = l.m_radius;
                },
                Set: function(shape, index) {
                    switch (shape.GetType()) {
                      case b2Shape.e_circle:
                        var circle = shape;
                        this.m_vertices = [ circle.m_p ];
                        this.m_count = 1;
                        this.m_radius = circle.m_radius;
                        break;

                      case b2Shape.e_polygon:
                        var polygon = shape;
                        this.m_vertices = polygon.m_vertices;
                        this.m_count = polygon.m_count;
                        this.m_radius = polygon.m_radius;
                        break;

                      case b2Shape.e_chain:
                        var chain = shape;
                        b2Assert(0 <= index && index < chain.m_count);
                        this.m_vertices = [ chain.m_vertices[index] ];
                        index + 1 < chain.m_count ? this.m_vertices[1] = chain.m_vertices[index + 1] : this.m_vertices[1] = chain.m_vertices[0];
                        this.m_count = 2;
                        this.m_radius = chain.m_radius;
                        break;

                      case b2Shape.e_edge:
                        var edge = shape;
                        this.m_vertices = [ edge.m_vertex1, edge.m_vertex2 ];
                        this.m_count = 2;
                        this.m_radius = edge.m_radius;
                        break;

                      default:
                        b2Assert(false);
                    }
                },
                GetSupport: function(dx, dy) {
                    var bestIndex = 0;
                    var bestValue = this.m_vertices[0].x * dx + this.m_vertices[0].y * dy;
                    for (var i = 1; i < this.m_count; ++i) {
                        var value = this.m_vertices[i].x * dx + this.m_vertices[i].y * dy;
                        if (value > bestValue) {
                            bestIndex = i;
                            bestValue = value;
                        }
                    }
                    return bestIndex;
                },
                GetSupportVertex: function(dx, dy) {
                    return this.m_vertices[this.GetSupport(dx, dy)];
                },
                GetVertexCount: function() {
                    return this.m_count;
                },
                GetVertex: function(index) {
                    b2Assert(0 <= index && index < this.m_count);
                    return this.m_vertices[index];
                }
            };
            function b2SimplexCache() {
                this.metric = 0;
                this.count = 0;
                this.indexA = [ 0, 0, 0 ];
                this.indexB = [ 0, 0, 0 ];
            }
            function b2DistanceInput() {
                this.proxyA = new b2DistanceProxy();
                this.proxyB = new b2DistanceProxy();
                this.transformA = new b2Transform();
                this.transformB = new b2Transform();
                this.useRadii = false;
            }
            function b2DistanceOutput() {
                this.pointA = new b2Vec2();
                this.pointB = new b2Vec2();
                this.distance = 0;
                this.iterations = 0;
            }
            function b2SimplexVertex() {
                this.wA = new b2Vec2();
                this.wB = new b2Vec2();
                this.w = new b2Vec2();
                this.a = 0;
                this.indexA = 0;
                this.indexB = 0;
            }
            b2SimplexVertex.prototype = {
                Assign: function(l) {
                    this.wA.x = l.wA.x;
                    this.wA.y = l.wA.y;
                    this.wB.x = l.wB.x;
                    this.wB.y = l.wB.y;
                    this.w.x = l.w.x;
                    this.w.y = l.w.y;
                    this.a = l.a;
                    this.indexA = l.indexA;
                    this.indexB = l.indexB;
                }
            };
            function b2Simplex() {
                this.m_v = [ new b2SimplexVertex(), new b2SimplexVertex(), new b2SimplexVertex() ];
                this.m_count = 0;
            }
            b2Simplex.prototype = {
                ReadCache: function(cache, proxyA, transformA, proxyB, transformB) {
                    b2Assert(cache.count <= 3);
                    this.m_count = cache.count;
                    var vertices = this.m_v;
                    for (var i = 0; i < this.m_count; ++i) {
                        var v = vertices[i];
                        v.indexA = cache.indexA[i];
                        v.indexB = cache.indexB[i];
                        var wALocal = proxyA.GetVertex(v.indexA);
                        var wBLocal = proxyB.GetVertex(v.indexB);
                        v.wA.x = transformA.q.c * wALocal.x - transformA.q.s * wALocal.y + transformA.p.x;
                        v.wA.y = transformA.q.s * wALocal.x + transformA.q.c * wALocal.y + transformA.p.y;
                        v.wB.x = transformB.q.c * wBLocal.x - transformB.q.s * wBLocal.y + transformB.p.x;
                        v.wB.y = transformB.q.s * wBLocal.x + transformB.q.c * wBLocal.y + transformB.p.y;
                        v.w.x = v.wB.x - v.wA.x;
                        v.w.y = v.wB.y - v.wA.y;
                        v.a = 0;
                    }
                    if (this.m_count > 1) {
                        var metric1 = cache.metric;
                        var metric2 = this.GetMetric();
                        (metric2 < .5 * metric1 || 2 * metric1 < metric2 || metric2 < b2_epsilon) && (this.m_count = 0);
                    }
                    if (0 == this.m_count) {
                        var v = vertices[0];
                        v.indexA = 0;
                        v.indexB = 0;
                        var wALocal = proxyA.GetVertex(0);
                        var wBLocal = proxyB.GetVertex(0);
                        v.wA.x = transformA.q.c * wALocal.x - transformA.q.s * wALocal.y + transformA.p.x;
                        v.wA.y = transformA.q.s * wALocal.x + transformA.q.c * wALocal.y + transformA.p.y;
                        v.wB.x = transformB.q.c * wBLocal.x - transformB.q.s * wBLocal.y + transformB.p.x;
                        v.wB.y = transformB.q.s * wBLocal.x + transformB.q.c * wBLocal.y + transformB.p.y;
                        v.w.x = v.wB.x - v.wA.x;
                        v.w.y = v.wB.y - v.wA.y;
                        v.a = 1;
                        this.m_count = 1;
                    }
                },
                WriteCache: function(cache) {
                    cache.metric = this.GetMetric();
                    cache.count = this.m_count;
                    var vertices = this.m_v;
                    for (var i = 0; i < this.m_count; ++i) {
                        cache.indexA[i] = vertices[i].indexA;
                        cache.indexB[i] = vertices[i].indexB;
                    }
                },
                GetSearchDirection: function(p) {
                    switch (this.m_count) {
                      case 1:
                        p.x = -this.m_v[0].w.x;
                        p.y = -this.m_v[0].w.y;
                        break;

                      case 2:
                        var e12x = this.m_v[1].w.x - this.m_v[0].w.x;
                        var e12y = this.m_v[1].w.y - this.m_v[0].w.y;
                        var sgn = e12x * -this.m_v[0].w.y - e12y * -this.m_v[0].w.x;
                        if (sgn > 0) {
                            p.x = -1 * e12y;
                            p.y = 1 * e12x;
                        } else {
                            p.x = 1 * e12y;
                            p.y = -1 * e12x;
                        }
                        break;

                      default:
                        b2Assert(false);
                        p.x = p.y = 0;
                    }
                },
                GetClosestPoint: function(p) {
                    switch (this.m_count) {
                      case 1:
                        p.x = this.m_v[0].w.x;
                        p.y = this.m_v[0].w.y;
                        break;

                      case 2:
                        p.x = this.m_v[0].a * this.m_v[0].w.x + this.m_v[1].a * this.m_v[1].w.x;
                        p.y = this.m_v[0].a * this.m_v[0].w.y + this.m_v[1].a * this.m_v[1].w.y;
                        break;

                      case 3:
                        p.x = p.y = 0;
                        break;

                      default:
                        b2Assert(false);
                        p.x = p.y = 0;
                    }
                },
                GetWitnessPoints: function(pA, pB) {
                    switch (this.m_count) {
                      case 1:
                        pA.x = this.m_v[0].wA.x;
                        pA.y = this.m_v[0].wA.y;
                        pB.x = this.m_v[0].wB.x;
                        pB.y = this.m_v[0].wB.y;
                        break;

                      case 2:
                        pA.x = this.m_v[0].a * this.m_v[0].wA.x + this.m_v[1].a * this.m_v[1].wA.x;
                        pA.y = this.m_v[0].a * this.m_v[0].wA.y + this.m_v[1].a * this.m_v[1].wA.y;
                        pB.x = this.m_v[0].a * this.m_v[0].wB.x + this.m_v[1].a * this.m_v[1].wB.x;
                        pB.y = this.m_v[0].a * this.m_v[0].wB.y + this.m_v[1].a * this.m_v[1].wB.y;
                        break;

                      case 3:
                        pA.x = this.m_v[0].a * this.m_v[0].wA.x + this.m_v[1].a * this.m_v[1].wA.x + this.m_v[2].a * this.m_v[2].wA.x;
                        pA.y = this.m_v[0].a * this.m_v[0].wA.y + this.m_v[1].a * this.m_v[1].wA.y + this.m_v[2].a * this.m_v[2].wA.y;
                        pB.x = pA.x;
                        pB.y = pA.y;
                        break;

                      default:
                        b2Assert(false);
                    }
                },
                GetMetric: function() {
                    switch (this.m_count) {
                      case 1:
                        return 0;

                      case 2:
                        return b2Distance(this.m_v[0].w, this.m_v[1].w);

                      case 3:
                        return (this.m_v[1].w.x - this.m_v[0].w.x) * (this.m_v[2].w.y - this.m_v[0].w.y) - (this.m_v[1].w.y - this.m_v[0].w.y) * (this.m_v[2].w.x - this.m_v[0].w.x);

                      default:
                        b2Assert(false);
                        return 0;
                    }
                },
                Solve2: function() {
                    var w1 = this.m_v[0].w;
                    var w2 = this.m_v[1].w;
                    var e12x = w2.x - w1.x;
                    var e12y = w2.y - w1.y;
                    var d12_2 = -(w1.x * e12x + w1.y * e12y);
                    if (d12_2 <= 0) {
                        this.m_v[0].a = 1;
                        this.m_count = 1;
                        return;
                    }
                    var d12_1 = w2.x * e12x + w2.y * e12y;
                    if (d12_1 <= 0) {
                        this.m_v[1].a = 1;
                        this.m_count = 1;
                        this.m_v[0].Assign(this.m_v[1]);
                        return;
                    }
                    var inv_d12 = 1 / (d12_1 + d12_2);
                    this.m_v[0].a = d12_1 * inv_d12;
                    this.m_v[1].a = d12_2 * inv_d12;
                    this.m_count = 2;
                },
                Solve3: function() {
                    var w1 = this.m_v[0].w;
                    var w2 = this.m_v[1].w;
                    var w3 = this.m_v[2].w;
                    var e12x = w2.x - w1.x;
                    var e12y = w2.y - w1.y;
                    var w1e12 = w1.x * e12x + w1.y * e12y;
                    var w2e12 = w2.x * e12x + w2.y * e12y;
                    var d12_1 = w2e12;
                    var d12_2 = -w1e12;
                    var e13x = w3.x - w1.x;
                    var e13y = w3.y - w1.y;
                    var w1e13 = w1.x * e13x + w1.y * e13y;
                    var w3e13 = w3.x * e13x + w3.y * e13y;
                    var d13_1 = w3e13;
                    var d13_2 = -w1e13;
                    var e23x = w3.x - w2.x;
                    var e23y = w3.y - w2.y;
                    var w2e23 = w2.x * e23x + w2.y * e23y;
                    var w3e23 = w3.x * e23x + w3.y * e23y;
                    var d23_1 = w3e23;
                    var d23_2 = -w2e23;
                    var n123 = e12x * e13y - e12y * e13x;
                    var d123_1 = n123 * (w2.x * w3.y - w2.y * w3.x);
                    var d123_2 = n123 * (w3.x * w1.y - w3.y * w1.x);
                    var d123_3 = n123 * (w1.x * w2.y - w1.y * w2.x);
                    if (d12_2 <= 0 && d13_2 <= 0) {
                        this.m_v[0].a = 1;
                        this.m_count = 1;
                        return;
                    }
                    if (d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {
                        var inv_d12 = 1 / (d12_1 + d12_2);
                        this.m_v[0].a = d12_1 * inv_d12;
                        this.m_v[1].a = d12_2 * inv_d12;
                        this.m_count = 2;
                        return;
                    }
                    if (d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {
                        var inv_d13 = 1 / (d13_1 + d13_2);
                        this.m_v[0].a = d13_1 * inv_d13;
                        this.m_v[2].a = d13_2 * inv_d13;
                        this.m_count = 2;
                        this.m_v[1].Assign(this.m_v[2]);
                        return;
                    }
                    if (d12_1 <= 0 && d23_2 <= 0) {
                        this.m_v[1].a = 1;
                        this.m_count = 1;
                        this.m_v[0].Assign(this.m_v[1]);
                        return;
                    }
                    if (d13_1 <= 0 && d23_1 <= 0) {
                        this.m_v[2].a = 1;
                        this.m_count = 1;
                        this.m_v[0].Assign(this.m_v[2]);
                        return;
                    }
                    if (d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {
                        var inv_d23 = 1 / (d23_1 + d23_2);
                        this.m_v[1].a = d23_1 * inv_d23;
                        this.m_v[2].a = d23_2 * inv_d23;
                        this.m_count = 2;
                        this.m_v[0].Assign(this.m_v[2]);
                        return;
                    }
                    var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
                    this.m_v[0].a = d123_1 * inv_d123;
                    this.m_v[1].a = d123_2 * inv_d123;
                    this.m_v[2].a = d123_3 * inv_d123;
                    this.m_count = 3;
                }
            };
            var _b2Distance_simplex = new b2Simplex();
            var _b2Distance_normal = new b2Vec2();
            var _b2Distance_p = new b2Vec2();
            function b2DistanceFunc(output, cache, input) {
                ++b2DistanceFunc.b2_gjkCalls;
                var proxyA = input.proxyA;
                var proxyB = input.proxyB;
                var transformA = input.transformA;
                var transformB = input.transformB;
                _b2Distance_simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
                var vertices = _b2Distance_simplex.m_v;
                var k_maxIters = 20;
                var saveA = [ 0, 0, 0 ], saveB = [ 0, 0, 0 ];
                var saveCount = 0;
                var distanceSqr1 = b2_maxFloat;
                var distanceSqr2 = distanceSqr1;
                var iter = 0;
                while (iter < k_maxIters) {
                    saveCount = _b2Distance_simplex.m_count;
                    for (var i = 0; i < saveCount; ++i) {
                        saveA[i] = vertices[i].indexA;
                        saveB[i] = vertices[i].indexB;
                    }
                    switch (_b2Distance_simplex.m_count) {
                      case 1:
                        break;

                      case 2:
                        _b2Distance_simplex.Solve2();
                        break;

                      case 3:
                        _b2Distance_simplex.Solve3();
                        break;

                      default:
                        b2Assert(false);
                    }
                    if (3 == _b2Distance_simplex.m_count) {
                        break;
                    }
                    _b2Distance_simplex.GetClosestPoint(_b2Distance_p);
                    distanceSqr2 = _b2Distance_p.LengthSquared();
                    distanceSqr2 >= distanceSqr1;
                    distanceSqr1 = distanceSqr2;
                    _b2Distance_simplex.GetSearchDirection(_b2Distance_p);
                    if (_b2Distance_p.LengthSquared() < b2_epsilon * b2_epsilon) {
                        break;
                    }
                    var vertex = vertices[_b2Distance_simplex.m_count];
                    vertex.indexA = proxyA.GetSupport(transformA.q.c * -_b2Distance_p.x + transformA.q.s * -_b2Distance_p.y, -transformA.q.s * -_b2Distance_p.x + transformA.q.c * -_b2Distance_p.y);
                    var pva = proxyA.GetVertex(vertex.indexA);
                    vertex.wA.x = transformA.q.c * pva.x - transformA.q.s * pva.y + transformA.p.x;
                    vertex.wA.y = transformA.q.s * pva.x + transformA.q.c * pva.y + transformA.p.y;
                    vertex.indexB = proxyB.GetSupport(transformB.q.c * _b2Distance_p.x + transformB.q.s * _b2Distance_p.y, -transformB.q.s * _b2Distance_p.x + transformB.q.c * _b2Distance_p.y);
                    var pvb = proxyB.GetVertex(vertex.indexB);
                    vertex.wB.x = transformB.q.c * pvb.x - transformB.q.s * pvb.y + transformB.p.x;
                    vertex.wB.y = transformB.q.s * pvb.x + transformB.q.c * pvb.y + transformB.p.y;
                    vertex.w.x = vertex.wB.x - vertex.wA.x;
                    vertex.w.y = vertex.wB.y - vertex.wA.y;
                    ++iter;
                    ++b2DistanceFunc.b2_gjkIters;
                    var duplicate = false;
                    for (var i = 0; i < saveCount; ++i) {
                        if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
                            duplicate = true;
                            break;
                        }
                    }
                    if (duplicate) {
                        break;
                    }
                    ++_b2Distance_simplex.m_count;
                }
                b2DistanceFunc.b2_gjkMaxIters = b2Max(b2DistanceFunc.b2_gjkMaxIters, iter);
                _b2Distance_simplex.GetWitnessPoints(output.pointA, output.pointB);
                output.distance = b2Distance(output.pointA, output.pointB);
                output.iterations = iter;
                _b2Distance_simplex.WriteCache(cache);
                if (input.useRadii) {
                    var rA = proxyA.m_radius;
                    var rB = proxyB.m_radius;
                    if (output.distance > rA + rB && output.distance > b2_epsilon) {
                        output.distance -= rA + rB;
                        _b2Distance_normal.x = output.pointB.x - output.pointA.x;
                        _b2Distance_normal.y = output.pointB.y - output.pointA.y;
                        _b2Distance_normal.Normalize();
                        output.pointA.x += rA * _b2Distance_normal.x;
                        output.pointA.y += rA * _b2Distance_normal.y;
                        output.pointB.x -= rB * _b2Distance_normal.x;
                        output.pointB.y -= rB * _b2Distance_normal.y;
                    } else {
                        var px = .5 * (output.pointA.x + output.pointB.x);
                        var py = .5 * (output.pointA.y + output.pointB.y);
                        output.pointA.x = px;
                        output.pointA.y = py;
                        output.pointB.x = px;
                        output.pointB.y = py;
                        output.distance = 0;
                    }
                }
            }
            b2DistanceFunc.b2_gjkCalls = 0;
            b2DistanceFunc.b2_gjkIters = 0;
            b2DistanceFunc.b2_gjkMaxIters = 0;
            var b2_nullFeature = 255;
            function b2ContactID() {}
            b2ContactID.prototype = {
                indexA: 0,
                indexB: 0,
                typeA: 0,
                typeB: 0,
                Reset: function() {
                    this.indexA = this.indexB = this.typeA = this.typeB = 0;
                },
                Get: function() {
                    return this.indexA | this.indexB << 8 | this.typeA << 16 | this.typeB << 24;
                },
                Assign: function(k) {
                    this.indexA = k.indexA;
                    this.indexB = k.indexB;
                    this.typeA = k.typeA;
                    this.typeB = k.typeB;
                }
            };
            b2ContactID.e_vertex = 0;
            b2ContactID.e_face = 1;
            function b2ManifoldPoint() {
                this.localPoint = new b2Vec2();
                this.normalImpulse = 0;
                this.tangentImpulse = 0;
                this.id = new b2ContactID();
            }
            b2ManifoldPoint.prototype = {
                Clone: function() {
                    var point = new b2ManifoldPoint();
                    point.localPoint.x = this.localPoint.x;
                    point.localPoint.y = this.localPoint.y;
                    point.normalImpulse = this.normalImpulse;
                    point.tangentImpulse = this.tangentImpulse;
                    point.id.Assign(this.id);
                    return point;
                }
            };
            function b2Manifold() {
                this.points = new Array(b2_maxManifoldPoints);
                this.localNormal = new b2Vec2();
                this.localPoint = new b2Vec2();
                this.type = 0;
                this.pointCount = 0;
            }
            b2Manifold.prototype = {
                Clone: function() {
                    var manifold = new b2Manifold();
                    manifold.pointCount = this.pointCount;
                    manifold.type = this.type;
                    manifold.localPoint.x = this.localPoint.x;
                    manifold.localPoint.y = this.localPoint.y;
                    manifold.localNormal.x = this.localNormal.x;
                    manifold.localNormal.y = this.localNormal.y;
                    for (var i = 0; i < this.pointCount; ++i) {
                        manifold.points[i] = this.points[i].Clone();
                    }
                    return manifold;
                },
                Assign: function(manifold) {
                    this.pointCount = manifold.pointCount;
                    this.type = manifold.type;
                    this.localPoint.x = manifold.localPoint.x;
                    this.localPoint.y = manifold.localPoint.y;
                    this.localNormal.x = manifold.localNormal.x;
                    this.localNormal.y = manifold.localNormal.y;
                    for (var i = 0; i < this.pointCount; ++i) {
                        this.points[i] = manifold.points[i].Clone();
                    }
                }
            };
            b2Manifold.e_circles = 0;
            b2Manifold.e_faceA = 1;
            b2Manifold.e_faceB = 2;
            b2Manifold.b2_nullState = 0;
            b2Manifold.b2_addState = 1;
            b2Manifold.b2_persistState = 2;
            b2Manifold.b2_removeState = 3;
            function b2WorldManifold() {
                this.normal = new b2Vec2();
                this.points = new Array(b2_maxManifoldPoints);
                this.separations = new Array(b2_maxManifoldPoints);
            }
            b2WorldManifold.prototype = {
                Initialize: function(manifold, xfA, radiusA, xfB, radiusB) {
                    if (0 == manifold.pointCount) {
                        return;
                    }
                    switch (manifold.type) {
                      case b2Manifold.e_circles:
                        this.normal.x = 1;
                        this.normal.y = 0;
                        var pointAx = xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y + xfA.p.x;
                        var pointAy = xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y + xfA.p.y;
                        var pointBx = xfB.q.c * manifold.points[0].localPoint.x - xfB.q.s * manifold.points[0].localPoint.y + xfB.p.x;
                        var pointBy = xfB.q.s * manifold.points[0].localPoint.x + xfB.q.c * manifold.points[0].localPoint.y + xfB.p.y;
                        var cx = pointAx - pointBx;
                        var cy = pointAy - pointBy;
                        if (cx * cx + cy * cy > b2_epsilon * b2_epsilon) {
                            this.normal.x = pointBx - pointAx;
                            this.normal.y = pointBy - pointAy;
                            this.normal.Normalize();
                        }
                        var cAx = pointAx + radiusA * this.normal.x;
                        var cAy = pointAy + radiusA * this.normal.y;
                        var cBx = pointBx - radiusB * this.normal.x;
                        var cBy = pointBy - radiusB * this.normal.y;
                        this.points[0] = new b2Vec2(.5 * (cAx + cBx), .5 * (cAy + cBy));
                        this.separations[0] = (cBx - cAx) * this.normal.x + (cBy - cAy) * this.normal.y;
                        break;

                      case b2Manifold.e_faceA:
                        this.normal.x = xfA.q.c * manifold.localNormal.x - xfA.q.s * manifold.localNormal.y;
                        this.normal.y = xfA.q.s * manifold.localNormal.x + xfA.q.c * manifold.localNormal.y;
                        var planePointx = xfA.q.c * manifold.localPoint.x - xfA.q.s * manifold.localPoint.y + xfA.p.x;
                        var planePointy = xfA.q.s * manifold.localPoint.x + xfA.q.c * manifold.localPoint.y + xfA.p.y;
                        for (var i = 0; i < manifold.pointCount; ++i) {
                            var clipPointx = xfB.q.c * manifold.points[i].localPoint.x - xfB.q.s * manifold.points[i].localPoint.y + xfB.p.x;
                            var clipPointy = xfB.q.s * manifold.points[i].localPoint.x + xfB.q.c * manifold.points[i].localPoint.y + xfB.p.y;
                            var d = (clipPointx - planePointx) * this.normal.x + (clipPointy - planePointy) * this.normal.y;
                            var cAx = clipPointx + (radiusA - d) * this.normal.x;
                            var cAy = clipPointy + (radiusA - d) * this.normal.y;
                            var cBx = clipPointx - radiusB * this.normal.x;
                            var cBy = clipPointy - radiusB * this.normal.y;
                            this.points[i] = new b2Vec2(.5 * (cAx + cBx), .5 * (cAy + cBy));
                            this.separations[i] = (cBx - cAx) * this.normal.x + (cBy - cAy) * this.normal.y;
                        }
                        break;

                      case b2Manifold.e_faceB:
                        this.normal.x = xfB.q.c * manifold.localNormal.x - xfB.q.s * manifold.localNormal.y;
                        this.normal.y = xfB.q.s * manifold.localNormal.x + xfB.q.c * manifold.localNormal.y;
                        var planePointx = xfB.q.c * manifold.localPoint.x - xfB.q.s * manifold.localPoint.y + xfB.p.x;
                        var planePointy = xfB.q.s * manifold.localPoint.x + xfB.q.c * manifold.localPoint.y + xfB.p.y;
                        for (var i = 0; i < manifold.pointCount; ++i) {
                            var clipPointx = xfA.q.c * manifold.points[i].localPoint.x - xfA.q.s * manifold.points[i].localPoint.y + xfA.p.x;
                            var clipPointy = xfA.q.s * manifold.points[i].localPoint.x + xfA.q.c * manifold.points[i].localPoint.y + xfA.p.y;
                            var d = (clipPointx - planePointx) * this.normal.x + (clipPointy - planePointy) * this.normal.y;
                            var cBx = clipPointx + (radiusB - d) * this.normal.x;
                            var cBy = clipPointy + (radiusB - d) * this.normal.y;
                            var cAx = clipPointx - radiusA * this.normal.x;
                            var cAy = clipPointy - radiusA * this.normal.y;
                            this.points[i] = new b2Vec2(.5 * (cAx + cBx), .5 * (cAy + cBy));
                            this.separations[i] = (cAx - cBx) * this.normal.x + (cAy - cBy) * this.normal.y;
                        }
                        this.normal.x = -this.normal.x;
                        this.normal.y = -this.normal.y;
                    }
                }
            };
            function b2GetPointStates(state1, state2, manifold1, manifold2) {
                for (var i = 0; i < b2_maxManifoldPoints; ++i) {
                    state1[i] = b2Manifold.b2_nullState;
                    state2[i] = b2Manifold.b2_nullState;
                }
                for (var i = 0; i < manifold1.pointCount; ++i) {
                    var id = manifold1.points[i].id;
                    state1[i] = b2Manifold.b2_removeState;
                    for (var j = 0; j < manifold2.pointCount; ++j) {
                        if (manifold2.points[j].id.Get() == id.Get()) {
                            state1[i] = b2Manifold.b2_persistState;
                            break;
                        }
                    }
                }
                for (var i = 0; i < manifold2.pointCount; ++i) {
                    var id = manifold2.points[i].id;
                    state2[i] = b2Manifold.b2_addState;
                    for (var j = 0; j < manifold1.pointCount; ++j) {
                        if (manifold1.points[j].id.Get() == id.Get()) {
                            state2[i] = b2Manifold.b2_persistState;
                            break;
                        }
                    }
                }
            }
            function b2ClipVertex() {
                this.v = new b2Vec2();
                this.id = new b2ContactID();
            }
            function b2RayCastInput() {
                this.p1 = new b2Vec2(), this.p2 = new b2Vec2();
                this.maxFraction = 0;
            }
            function b2RayCastOutput() {
                this.normal = new b2Vec2();
                this.fraction = 0;
            }
            function b2AABB() {
                this.lowerBound = new b2Vec2();
                this.upperBound = new b2Vec2();
            }
            b2AABB.prototype = {
                Assign: function(other) {
                    this.lowerBound.x = other.lowerBound.x;
                    this.lowerBound.y = other.lowerBound.y;
                    this.upperBound.x = other.upperBound.x;
                    this.upperBound.y = other.upperBound.y;
                },
                Clone: function() {
                    var clone = new b2AABB();
                    clone.lowerBound.x = this.lowerBound.x;
                    clone.lowerBound.y = this.lowerBound.y;
                    clone.upperBound.x = this.upperBound.x;
                    clone.upperBound.y = this.upperBound.y;
                    return clone;
                },
                IsValid: function() {
                    return this.upperBound.x - this.lowerBound.x >= 0 && this.upperBound.y - this.lowerBound.y >= 0 && this.lowerBound.IsValid() && this.upperBound.IsValid();
                },
                GetCenter: function() {
                    return new b2Vec2(.5 * (this.lowerBound.x + this.upperBound.x), .5 * (this.lowerBound.y + this.upperBound.y));
                },
                GetExtents: function() {
                    return new b2Vec2(.5 * (this.upperBound.x - this.lowerBound.x), .5 * (this.upperBound.y - this.lowerBound.y));
                },
                GetPerimeter: function() {
                    return 2 * (this.upperBound.x - this.lowerBound.x + (this.upperBound.y - this.lowerBound.y));
                },
                Combine: function(aabb1, aabb2) {
                    if (aabb2) {
                        this.lowerBound.x = b2Min(aabb1.lowerBound.x, aabb2.lowerBound.x);
                        this.lowerBound.y = b2Min(aabb1.lowerBound.y, aabb2.lowerBound.y);
                        this.upperBound.x = b2Max(aabb1.upperBound.x, aabb2.upperBound.x);
                        this.upperBound.y = b2Max(aabb1.upperBound.y, aabb2.upperBound.y);
                    } else {
                        this.lowerBound.x = b2Min(this.lowerBound.x, aabb1.lowerBound.x);
                        this.lowerBound.y = b2Min(this.lowerBound.y, aabb1.lowerBound.y);
                        this.upperBound.x = b2Max(this.upperBound.x, aabb1.upperBound.x);
                        this.upperBound.y = b2Max(this.upperBound.y, aabb1.upperBound.y);
                    }
                },
                Contains: function(aabb) {
                    return this.lowerBound.x <= aabb.lowerBound.x && this.lowerBound.y <= aabb.lowerBound.y && aabb.upperBound.x <= this.upperBound.x && aabb.upperBound.y <= this.upperBound.y;
                },
                RayCast: function(output, input) {
                    var tmin = -b2_maxFloat;
                    var tmax = b2_maxFloat;
                    var p = input.p1;
                    var d = b2Vec2.Subtract(input.p2, input.p1);
                    var absD = b2Abs_v2(d);
                    var normal = new b2Vec2();
                    for (var i = 0; i < 2; ++i) {
                        if (absD.get_i(i) < b2_epsilon) {
                            if (p.get_i(i) < this.lowerBound.get_i(i) || this.upperBound.get_i(i) < p.get_i(i)) {
                                return false;
                            }
                        } else {
                            var inv_d = 1 / d.get_i(i);
                            var t1 = (this.lowerBound.get_i(i) - p.get_i(i)) * inv_d;
                            var t2 = (this.upperBound.get_i(i) - p.get_i(i)) * inv_d;
                            var s = -1;
                            if (t1 > t2) {
                                var temp = t2;
                                t2 = t1;
                                t1 = temp;
                                s = 1;
                            }
                            if (t1 > tmin) {
                                normal.x = normal.y = 0;
                                normal.set_i(i, s);
                                tmin = t1;
                            }
                            tmax = b2Min(tmax, t2);
                            if (tmin > tmax) {
                                return false;
                            }
                        }
                    }
                    if (tmin < 0 || input.maxFraction < tmin) {
                        return false;
                    }
                    output.fraction = tmin;
                    output.normal.x = normal.x;
                    output.normal.y = normal.y;
                    return true;
                }
            };
            function b2CollideCircles(manifold, circleA, xfA, circleB, xfB) {
                manifold.pointCount = 0;
                var pA = b2Mul_t_v2(xfA, circleA.m_p);
                var pB = b2Mul_t_v2(xfB, circleB.m_p);
                var dx = pB.x - pA.x;
                var dy = pB.y - pA.y;
                var distSqr = dx * dx + dy * dy;
                var rA = circleA.m_radius, rB = circleB.m_radius;
                var radius = rA + rB;
                if (distSqr > radius * radius) {
                    return;
                }
                manifold.type = b2Manifold.e_circles;
                manifold.localPoint.x = circleA.m_p.x;
                manifold.localPoint.y = circleA.m_p.y;
                manifold.localNormal.x = manifold.localNormal.y = 0;
                manifold.pointCount = 1;
                manifold.points[0] = new b2ManifoldPoint();
                manifold.points[0].localPoint.x = circleB.m_p.x;
                manifold.points[0].localPoint.y = circleB.m_p.y;
                manifold.points[0].id.Reset();
            }
            function b2CollidePolygonAndCircle(manifold, polygonA, xfA, circleB, xfB) {
                manifold.pointCount = 0;
                var c = b2Mul_t_v2(xfB, circleB.m_p);
                var cLocal = b2MulT_t_v2(xfA, c);
                var normalIndex = 0;
                var separation = -b2_maxFloat;
                var radius = polygonA.m_radius + circleB.m_radius;
                var vertexCount = polygonA.m_count;
                var vertices = polygonA.m_vertices;
                var normals = polygonA.m_normals;
                for (var i = 0; i < vertexCount; ++i) {
                    var s = normals[i].x * (cLocal.x - vertices[i].x) + normals[i].y * (cLocal.y - vertices[i].y);
                    if (s > radius) {
                        return;
                    }
                    if (s > separation) {
                        separation = s;
                        normalIndex = i;
                    }
                }
                var vertIndex1 = normalIndex;
                var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
                var v1 = vertices[vertIndex1];
                var v2 = vertices[vertIndex2];
                if (separation < b2_epsilon) {
                    manifold.pointCount = 1;
                    manifold.type = b2Manifold.e_faceA;
                    manifold.localNormal.x = normals[normalIndex].x;
                    manifold.localNormal.y = normals[normalIndex].y;
                    manifold.localPoint.x = .5 * (v1.x + v2.x);
                    manifold.localPoint.y = .5 * (v1.y + v2.y);
                    manifold.points[0] = new b2ManifoldPoint();
                    manifold.points[0].localPoint.x = circleB.m_p.x;
                    manifold.points[0].localPoint.y = circleB.m_p.y;
                    manifold.points[0].id.Reset();
                    return;
                }
                var u1 = (cLocal.x - v1.x) * (v2.x - v1.x) + (cLocal.y - v1.y) * (v2.y - v1.y);
                var u2 = (cLocal.x - v2.x) * (v1.x - v2.x) + (cLocal.y - v2.y) * (v1.y - v2.y);
                if (u1 <= 0) {
                    if (b2DistanceSquared(cLocal, v1) > radius * radius) {
                        return;
                    }
                    manifold.pointCount = 1;
                    manifold.type = b2Manifold.e_faceA;
                    manifold.localNormal.x = cLocal.x - v1.x;
                    manifold.localNormal.y = cLocal.y - v1.y;
                    manifold.localNormal.Normalize();
                    manifold.localPoint.x = v1.x;
                    manifold.localPoint.y = v1.y;
                    manifold.points[0] = new b2ManifoldPoint();
                    manifold.points[0].localPoint.x = circleB.m_p.x;
                    manifold.points[0].localPoint.y = circleB.m_p.y;
                    manifold.points[0].id.Reset();
                } else {
                    if (u2 <= 0) {
                        if (b2DistanceSquared(cLocal, v2) > radius * radius) {
                            return;
                        }
                        manifold.pointCount = 1;
                        manifold.type = b2Manifold.e_faceA;
                        manifold.localNormal.x = cLocal.x - v2.x;
                        manifold.localNormal.y = cLocal.y - v2.y;
                        manifold.localNormal.Normalize();
                        manifold.localPoint.x = v2.x;
                        manifold.localPoint.y = v2.y;
                        manifold.points[0] = new b2ManifoldPoint();
                        manifold.points[0].localPoint.x = circleB.m_p.x;
                        manifold.points[0].localPoint.y = circleB.m_p.y;
                        manifold.points[0].id.Reset();
                    } else {
                        var faceCenterx = .5 * (v1.x + v2.x);
                        var faceCentery = .5 * (v1.y + v2.y);
                        var separation = (cLocal.x - faceCenterx) * normals[vertIndex1].x + (cLocal.y - faceCentery) * normals[vertIndex1].y;
                        if (separation > radius) {
                            return;
                        }
                        manifold.pointCount = 1;
                        manifold.type = b2Manifold.e_faceA;
                        manifold.localNormal.x = normals[vertIndex1].x;
                        manifold.localNormal.y = normals[vertIndex1].y;
                        manifold.localPoint.x = faceCenterx;
                        manifold.localPoint.y = faceCentery;
                        manifold.points[0] = new b2ManifoldPoint();
                        manifold.points[0].localPoint.x = circleB.m_p.x;
                        manifold.points[0].localPoint.y = circleB.m_p.y;
                        manifold.points[0].id.Reset();
                    }
                }
            }
            function b2FindMaxSeparation(edgeIndex, poly1, xf1, poly2, xf2) {
                var count1 = poly1.m_count;
                var count2 = poly2.m_count;
                var n1s = poly1.m_normals;
                var v1s = poly1.m_vertices;
                var v2s = poly2.m_vertices;
                var xf = b2MulT_t_t(xf2, xf1);
                var bestIndex = 0;
                var maxSeparation = -b2_maxFloat;
                for (var i = 0; i < count1; ++i) {
                    var nx = xf.q.c * n1s[i].x - xf.q.s * n1s[i].y;
                    var ny = xf.q.s * n1s[i].x + xf.q.c * n1s[i].y;
                    var v1x = xf.q.c * v1s[i].x - xf.q.s * v1s[i].y + xf.p.x;
                    var v1y = xf.q.s * v1s[i].x + xf.q.c * v1s[i].y + xf.p.y;
                    var si = b2_maxFloat;
                    for (var j = 0; j < count2; ++j) {
                        var sij = nx * (v2s[j].x - v1x) + ny * (v2s[j].y - v1y);
                        sij < si && (si = sij);
                    }
                    if (si > maxSeparation) {
                        maxSeparation = si;
                        bestIndex = i;
                    }
                }
                edgeIndex[0] = bestIndex;
                return maxSeparation;
            }
            function b2FindIncidentEdge(c, poly1, xf1, edge1, poly2, xf2) {
                var normals1 = poly1.m_normals;
                var count2 = poly2.m_count;
                var vertices2 = poly2.m_vertices;
                var normals2 = poly2.m_normals;
                b2Assert(0 <= edge1 && edge1 < poly1.m_count);
                var t1x = xf1.q.c * normals1[edge1].x - xf1.q.s * normals1[edge1].y;
                var t1y = xf1.q.s * normals1[edge1].x + xf1.q.c * normals1[edge1].y;
                var normal1x = xf2.q.c * t1x + xf2.q.s * t1y;
                var normal1y = -xf2.q.s * t1x + xf2.q.c * t1y;
                var index = 0;
                var minDot = b2_maxFloat;
                for (var i = 0; i < count2; ++i) {
                    var dot = normal1x * normals2[i].x + normal1y * normals2[i].y;
                    if (dot < minDot) {
                        minDot = dot;
                        index = i;
                    }
                }
                var i1 = index;
                var i2 = i1 + 1 < count2 ? i1 + 1 : 0;
                c[0].v.x = xf2.q.c * vertices2[i1].x - xf2.q.s * vertices2[i1].y + xf2.p.x;
                c[0].v.y = xf2.q.s * vertices2[i1].x + xf2.q.c * vertices2[i1].y + xf2.p.y;
                c[0].id.indexA = edge1;
                c[0].id.indexB = i1;
                c[0].id.typeA = b2ContactID.e_face;
                c[0].id.typeB = b2ContactID.e_vertex;
                c[1].v.x = xf2.q.c * vertices2[i2].x - xf2.q.s * vertices2[i2].y + xf2.p.x;
                c[1].v.y = xf2.q.s * vertices2[i2].x + xf2.q.c * vertices2[i2].y + xf2.p.y;
                c[1].id.indexA = edge1;
                c[1].id.indexB = i2;
                c[1].id.typeA = b2ContactID.e_face;
                c[1].id.typeB = b2ContactID.e_vertex;
            }
            function b2CollidePolygons(manifold, polyA, xfA, polyB, xfB) {
                manifold.pointCount = 0;
                var totalRadius = polyA.m_radius + polyB.m_radius;
                var edgeA = [ 0 ];
                var separationA = b2FindMaxSeparation(edgeA, polyA, xfA, polyB, xfB);
                if (separationA > totalRadius) {
                    return;
                }
                var edgeB = [ 0 ];
                var separationB = b2FindMaxSeparation(edgeB, polyB, xfB, polyA, xfA);
                if (separationB > totalRadius) {
                    return;
                }
                var poly1;
                var poly2;
                var xf1, xf2;
                var edge1 = 0;
                var flip = 0;
                var k_tol = .1 * b2_linearSlop;
                if (separationB > separationA + k_tol) {
                    poly1 = polyB;
                    poly2 = polyA;
                    xf1 = xfB;
                    xf2 = xfA;
                    edge1 = edgeB[0];
                    manifold.type = b2Manifold.e_faceB;
                    flip = 1;
                } else {
                    poly1 = polyA;
                    poly2 = polyB;
                    xf1 = xfA;
                    xf2 = xfB;
                    edge1 = edgeA[0];
                    manifold.type = b2Manifold.e_faceA;
                    flip = 0;
                }
                b2FindIncidentEdge(b2CollidePolygons._local_incidentEdges, poly1, xf1, edge1, poly2, xf2);
                var count1 = poly1.m_count;
                var vertices1 = poly1.m_vertices;
                var iv1 = edge1;
                var iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;
                var v11 = vertices1[iv1];
                var v12 = vertices1[iv2];
                b2CollidePolygons._localTangent.x = v12.x - v11.x;
                b2CollidePolygons._localTangent.y = v12.y - v11.y;
                b2CollidePolygons._localTangent.Normalize();
                var localNormalx = 1 * b2CollidePolygons._localTangent.y;
                var localNormaly = -1 * b2CollidePolygons._localTangent.x;
                var planePointx = .5 * (v11.x + v12.x);
                var planePointy = .5 * (v11.y + v12.y);
                var tangentx = xf1.q.c * b2CollidePolygons._localTangent.x - xf1.q.s * b2CollidePolygons._localTangent.y;
                var tangenty = xf1.q.s * b2CollidePolygons._localTangent.x + xf1.q.c * b2CollidePolygons._localTangent.y;
                var normalx = 1 * tangenty;
                var normaly = -1 * tangentx;
                v11 = b2Mul_t_v2(xf1, v11);
                v12 = b2Mul_t_v2(xf1, v12);
                var frontOffset = normalx * v11.x + normaly * v11.y;
                var sideOffset1 = -(tangentx * v11.x + tangenty * v11.y) + totalRadius;
                var sideOffset2 = tangentx * v12.x + tangenty * v12.y + totalRadius;
                var clipPoints1 = new Array(2);
                var clipPoints2 = new Array(2);
                var np;
                np = b2ClipSegmentToLine(clipPoints1, b2CollidePolygons._local_incidentEdges, -tangentx, -tangenty, sideOffset1, iv1);
                if (np < 2) {
                    return;
                }
                np = b2ClipSegmentToLine(clipPoints2, clipPoints1, tangentx, tangenty, sideOffset2, iv2);
                if (np < 2) {
                    return;
                }
                manifold.localNormal.x = localNormalx;
                manifold.localNormal.y = localNormaly;
                manifold.localPoint.x = planePointx;
                manifold.localPoint.y = planePointy;
                var pointCount = 0;
                for (var i = 0; i < b2_maxManifoldPoints; ++i) {
                    var separation = normalx * clipPoints2[i].v.x + normaly * clipPoints2[i].v.y - frontOffset;
                    if (separation <= totalRadius) {
                        var cp = manifold.points[pointCount] = new b2ManifoldPoint();
                        cp.localPoint.Assign(b2MulT_t_v2(xf2, clipPoints2[i].v));
                        cp.id.Assign(clipPoints2[i].id);
                        if (flip) {
                            var cf = new b2ContactID();
                            cf.Assign(cp.id);
                            cp.id.indexA = cf.indexB;
                            cp.id.indexB = cf.indexA;
                            cp.id.typeA = cf.typeB;
                            cp.id.typeB = cf.typeA;
                        }
                        ++pointCount;
                    }
                }
                manifold.pointCount = pointCount;
            }
            b2CollidePolygons._localTangent = new b2Vec2();
            b2CollidePolygons._local_incidentEdges = [ new b2ClipVertex(), new b2ClipVertex() ];
            function b2CollideEdgeAndCircle(manifold, edgeA, xfA, circleB, xfB) {
                manifold.pointCount = 0;
                var Q = b2MulT_t_v2(xfA, b2Mul_t_v2(xfB, circleB.m_p));
                var A = edgeA.m_vertex1, B = edgeA.m_vertex2;
                var ex = B.x - A.x;
                var ey = B.y - A.y;
                var u = ex * (B.x - Q.x) + ey * (B.y - Q.y);
                var v = ex * (Q.x - A.x) + ey * (Q.y - A.y);
                var radius = edgeA.m_radius + circleB.m_radius;
                var cf = new b2ContactID();
                cf.indexB = 0;
                cf.typeB = b2ContactID.e_vertex;
                if (v <= 0) {
                    var P = A;
                    var dx = Q.x - P.x;
                    var dy = Q.y - P.y;
                    var dd = dx * dx + dy * dy;
                    if (dd > radius * radius) {
                        return;
                    }
                    if (edgeA.m_hasVertex0) {
                        var A1 = edgeA.m_vertex0;
                        var B1 = A;
                        var e1x = B1.x - A1.x;
                        var e1y = B1.y - A1.y;
                        var u1 = e1x * (B1.x - Q.x) + e1y * (B1.y - Q.y);
                        if (u1 > 0) {
                            return;
                        }
                    }
                    cf.indexA = 0;
                    cf.typeA = b2ContactID.e_vertex;
                    manifold.pointCount = 1;
                    manifold.type = b2Manifold.e_circles;
                    manifold.localNormal.x = manifold.localNormal.y = 0;
                    manifold.localPoint.x = P.x;
                    manifold.localPoint.y = P.y;
                    manifold.points[0] = new b2ManifoldPoint();
                    manifold.points[0].id.Assign(cf);
                    manifold.points[0].localPoint.x = circleB.m_p.x;
                    manifold.points[0].localPoint.y = circleB.m_p.y;
                    return;
                }
                if (u <= 0) {
                    var P = B;
                    var dx = Q.x - P.x;
                    var dy = Q.y - P.y;
                    var dd = dx * dx + dy * dy;
                    if (dd > radius * radius) {
                        return;
                    }
                    if (edgeA.m_hasVertex3) {
                        var B2 = edgeA.m_vertex3;
                        var A2 = B;
                        var e2x = B2.x - A2.x;
                        var e2y = B2.y - A2.y;
                        var v2 = e2x * (Q.x - A2.x) + e2y * (Q.y - A2.y);
                        if (v2 > 0) {
                            return;
                        }
                    }
                    cf.indexA = 1;
                    cf.typeA = b2ContactID.e_vertex;
                    manifold.pointCount = 1;
                    manifold.type = b2Manifold.e_circles;
                    manifold.localNormal.x = manifold.localNormal.y = 0;
                    manifold.localPoint.x = P.x;
                    manifold.localPoint.y = P.y;
                    manifold.points[0] = new b2ManifoldPoint();
                    manifold.points[0].id.Assign(cf);
                    manifold.points[0].localPoint.x = circleB.m_p.x;
                    manifold.points[0].localPoint.y = circleB.m_p.y;
                    return;
                }
                var den = ex * ex + ey * ey;
                b2Assert(den > 0);
                var Px = 1 / den * (u * A.x + v * B.x);
                var Py = 1 / den * (u * A.y + v * B.y);
                var dx = Q.x - Px;
                var dy = Q.y - Py;
                var dd = dx * dx + dy * dy;
                if (dd > radius * radius) {
                    return;
                }
                var nx = -ey;
                var ny = ex;
                if (nx * (Q.x - A.x) + ny * (Q.y - A.y) < 0) {
                    nx = -nx;
                    ny = -ny;
                }
                cf.indexA = 0;
                cf.typeA = b2ContactID.e_face;
                manifold.pointCount = 1;
                manifold.type = b2Manifold.e_faceA;
                manifold.localNormal.x = nx;
                manifold.localNormal.y = ny;
                manifold.localNormal.Normalize();
                manifold.localPoint.x = A.x;
                manifold.localPoint.y = A.y;
                manifold.points[0] = new b2ManifoldPoint();
                manifold.points[0].id.Assign(cf);
                manifold.points[0].localPoint.x = circleB.m_p.x;
                manifold.points[0].localPoint.y = circleB.m_p.y;
            }
            function b2EPAxis() {
                this.type = 0;
                this.index = 0;
                this.separation = 0;
            }
            b2EPAxis.e_unknown = 0;
            b2EPAxis.e_edgeA = 1;
            b2EPAxis.e_edgeB = 2;
            function b2TempPolygon() {
                this.vertices = new Array(b2_maxPolygonVertices);
                this.normals = new Array(b2_maxPolygonVertices);
                this.count = 0;
            }
            function b2ReferenceFace() {
                this.i1 = 0, this.i2 = 0;
                this.v1 = new b2Vec2(), this.v2 = new b2Vec2();
                this.normal = new b2Vec2();
                this.sideNormal1 = new b2Vec2();
                this.sideOffset1 = 0;
                this.sideNormal2 = new b2Vec2();
                this.sideOffset2 = 0;
            }
            function b2EPCollider() {
                this.m_polygonB = new b2TempPolygon();
                this.m_xf = new b2Transform();
                this.m_centroidB = new b2Vec2();
                this.m_v0 = new b2Vec2(), this.m_v1 = new b2Vec2(), this.m_v2 = new b2Vec2(), this.m_v3 = new b2Vec2();
                this.m_normal0 = new b2Vec2(), this.m_normal1 = new b2Vec2(), this.m_normal2 = new b2Vec2();
                this.m_normal = new b2Vec2();
                this.m_type1 = 0, this.m_type2 = 0;
                this.m_lowerLimit = new b2Vec2(), this.m_upperLimit = new b2Vec2();
                this.m_radius = 0;
                this.m_front = false;
            }
            b2EPCollider._temp_edge = new b2Vec2();
            b2EPCollider._temp_edge0 = new b2Vec2();
            b2EPCollider._temp_edge2 = new b2Vec2();
            b2EPCollider.prototype = {
                Collide: function(manifold, edgeA, xfA, polygonB, xfB) {
                    this.m_xf.Assign(b2MulT_t_t(xfA, xfB));
                    this.m_centroidB.x = this.m_xf.q.c * polygonB.m_centroid.x - this.m_xf.q.s * polygonB.m_centroid.y + this.m_xf.p.x;
                    this.m_centroidB.y = this.m_xf.q.s * polygonB.m_centroid.x + this.m_xf.q.c * polygonB.m_centroid.y + this.m_xf.p.y;
                    this.m_v0.x = edgeA.m_vertex0.x;
                    this.m_v0.y = edgeA.m_vertex0.y;
                    this.m_v1.x = edgeA.m_vertex1.x;
                    this.m_v1.y = edgeA.m_vertex1.y;
                    this.m_v2.x = edgeA.m_vertex2.x;
                    this.m_v2.y = edgeA.m_vertex2.y;
                    this.m_v3.x = edgeA.m_vertex3.x;
                    this.m_v3.y = edgeA.m_vertex3.y;
                    var hasVertex0 = edgeA.m_hasVertex0;
                    var hasVertex3 = edgeA.m_hasVertex3;
                    b2EPCollider._temp_edge.x = this.m_v2.x - this.m_v1.x;
                    b2EPCollider._temp_edge.y = this.m_v2.y - this.m_v1.y;
                    b2EPCollider._temp_edge.Normalize();
                    this.m_normal1.x = b2EPCollider._temp_edge.y;
                    this.m_normal1.y = -b2EPCollider._temp_edge.x;
                    var offset1 = this.m_normal1.x * (this.m_centroidB.x - this.m_v1.x) + this.m_normal1.y * (this.m_centroidB.y - this.m_v1.y);
                    var offset0 = 0, offset2 = 0;
                    var convex1 = false, convex2 = false;
                    if (hasVertex0) {
                        b2EPCollider._temp_edge0.x = this.m_v1.x - this.m_v0.x;
                        b2EPCollider._temp_edge0.y = this.m_v1.y - this.m_v0.y;
                        b2EPCollider._temp_edge0.Normalize();
                        this.m_normal0.x = b2EPCollider._temp_edge0.y;
                        this.m_normal0.y = -b2EPCollider._temp_edge0.x;
                        convex1 = b2EPCollider._temp_edge0.x * b2EPCollider._temp_edge.y - b2EPCollider._temp_edge0.y * b2EPCollider._temp_edge.x >= 0;
                        offset0 = this.m_normal0.x * (this.m_centroidB.x - this.m_v0.x) + this.m_normal0.y * (this.m_centroidB.y - this.m_v0.y);
                    }
                    if (hasVertex3) {
                        b2EPCollider._temp_edge2.x = this.m_v3.x - this.m_v2.x;
                        b2EPCollider._temp_edge2.y = this.m_v3.y - this.m_v2.y;
                        b2EPCollider._temp_edge2.Normalize();
                        this.m_normal2.x = b2EPCollider._temp_edge2.y;
                        this.m_normal2.y = -b2EPCollider._temp_edge2.x;
                        convex2 = b2EPCollider._temp_edge.x * b2EPCollider._temp_edge2.y - b2EPCollider._temp_edge.y * b2EPCollider._temp_edge2.x > 0;
                        offset2 = this.m_normal2.x * (this.m_centroidB.x - this.m_v2.x) + this.m_normal2.y * (this.m_centroidB.y - this.m_v2.y);
                    }
                    if (hasVertex0 && hasVertex3) {
                        if (convex1 && convex2) {
                            this.m_front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;
                            if (this.m_front) {
                                this.m_normal.x = this.m_normal1.x;
                                this.m_normal.y = this.m_normal1.y;
                                this.m_lowerLimit.x = this.m_normal0.x;
                                this.m_lowerLimit.y = this.m_normal0.y;
                                this.m_upperLimit.x = this.m_normal2.x;
                                this.m_upperLimit.y = this.m_normal2.y;
                            } else {
                                this.m_normal.x = -this.m_normal1.x;
                                this.m_normal.y = -this.m_normal1.y;
                                this.m_lowerLimit.x = -this.m_normal1.x;
                                this.m_lowerLimit.y = -this.m_normal1.y;
                                this.m_upperLimit.x = -this.m_normal1.x;
                                this.m_upperLimit.y = -this.m_normal1.y;
                            }
                        } else {
                            if (convex1) {
                                this.m_front = offset0 >= 0 || offset1 >= 0 && offset2 >= 0;
                                if (this.m_front) {
                                    this.m_normal.x = this.m_normal1.x;
                                    this.m_normal.y = this.m_normal1.y;
                                    this.m_lowerLimit.x = this.m_normal0.x;
                                    this.m_lowerLimit.y = this.m_normal0.y;
                                    this.m_upperLimit.x = this.m_normal1.x;
                                    this.m_upperLimit.y = this.m_normal1.y;
                                } else {
                                    this.m_normal.x = -this.m_normal1.x;
                                    this.m_normal.y = -this.m_normal1.y;
                                    this.m_lowerLimit.x = -this.m_normal2.x;
                                    this.m_lowerLimit.y = -this.m_normal2.y;
                                    this.m_upperLimit.x = -this.m_normal1.x;
                                    this.m_upperLimit.y = -this.m_normal1.y;
                                }
                            } else {
                                if (convex2) {
                                    this.m_front = offset2 >= 0 || offset0 >= 0 && offset1 >= 0;
                                    if (this.m_front) {
                                        this.m_normal.x = this.m_normal1.x;
                                        this.m_normal.y = this.m_normal1.y;
                                        this.m_lowerLimit.x = this.m_normal1.x;
                                        this.m_lowerLimit.y = this.m_normal1.y;
                                        this.m_upperLimit.x = this.m_normal2.x;
                                        this.m_upperLimit.y = this.m_normal2.y;
                                    } else {
                                        this.m_normal.x = -this.m_normal1.x;
                                        this.m_normal.y = -this.m_normal1.y;
                                        this.m_lowerLimit.x = -this.m_normal1.x;
                                        this.m_lowerLimit.y = -this.m_normal1.y;
                                        this.m_upperLimit.x = -this.m_normal0.x;
                                        this.m_upperLimit.y = -this.m_normal0.y;
                                    }
                                } else {
                                    this.m_front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;
                                    if (this.m_front) {
                                        this.m_normal.x = this.m_normal1.x;
                                        this.m_normal.y = this.m_normal1.y;
                                        this.m_lowerLimit.x = this.m_normal1.x;
                                        this.m_lowerLimit.y = this.m_normal1.y;
                                        this.m_upperLimit.x = this.m_normal1.x;
                                        this.m_upperLimit.y = this.m_normal1.y;
                                    } else {
                                        this.m_normal.x = -this.m_normal1.x;
                                        this.m_normal.y = -this.m_normal1.y;
                                        this.m_lowerLimit.x = -this.m_normal2.x;
                                        this.m_lowerLimit.y = -this.m_normal2.y;
                                        this.m_upperLimit.x = -this.m_normal0.x;
                                        this.m_upperLimit.y = -this.m_normal0.y;
                                    }
                                }
                            }
                        }
                    } else {
                        if (hasVertex0) {
                            if (convex1) {
                                this.m_front = offset0 >= 0 || offset1 >= 0;
                                if (this.m_front) {
                                    this.m_normal.x = this.m_normal1.x;
                                    this.m_normal.y = this.m_normal1.y;
                                    this.m_lowerLimit.x = this.m_normal0.x;
                                    this.m_lowerLimit.y = this.m_normal0.y;
                                    this.m_upperLimit.x = -this.m_normal1.x;
                                    this.m_upperLimit.y = -this.m_normal1.y;
                                } else {
                                    this.m_normal.x = -this.m_normal1.x;
                                    this.m_normal.y = -this.m_normal1.y;
                                    this.m_lowerLimit.x = this.m_normal1.x;
                                    this.m_lowerLimit.y = this.m_normal1.y;
                                    this.m_upperLimit.x = -this.m_normal1.x;
                                    this.m_upperLimit.y = -this.m_normal1.y;
                                }
                            } else {
                                this.m_front = offset0 >= 0 && offset1 >= 0;
                                if (this.m_front) {
                                    this.m_normal.x = this.m_normal1.x;
                                    this.m_normal.y = this.m_normal1.y;
                                    this.m_lowerLimit.x = this.m_normal1.x;
                                    this.m_lowerLimit.y = this.m_normal1.y;
                                    this.m_upperLimit.x = -this.m_normal1.x;
                                    this.m_upperLimit.y = -this.m_normal1.y;
                                } else {
                                    this.m_normal.x = -this.m_normal1.x;
                                    this.m_normal.y = -this.m_normal1.y;
                                    this.m_lowerLimit.x = this.m_normal1.x;
                                    this.m_lowerLimit.y = this.m_normal1.y;
                                    this.m_upperLimit.x = -this.m_normal0.x;
                                    this.m_upperLimit.y = -this.m_normal0.y;
                                }
                            }
                        } else {
                            if (hasVertex3) {
                                if (convex2) {
                                    this.m_front = offset1 >= 0 || offset2 >= 0;
                                    if (this.m_front) {
                                        this.m_normal.x = this.m_normal1.x;
                                        this.m_normal.y = this.m_normal1.y;
                                        this.m_lowerLimit.x = -this.m_normal1.x;
                                        this.m_lowerLimit.y = -this.m_normal1.y;
                                        this.m_upperLimit.x = this.m_normal2.x;
                                        this.m_upperLimit.y = this.m_normal2.y;
                                    } else {
                                        this.m_normal.x = -this.m_normal1.x;
                                        this.m_normal.y = -this.m_normal1.y;
                                        this.m_lowerLimit.x = -this.m_normal1.x;
                                        this.m_lowerLimit.y = -this.m_normal1.y;
                                        this.m_upperLimit.x = this.m_normal1.x;
                                        this.m_upperLimit.y = this.m_normal1.y;
                                    }
                                } else {
                                    this.m_front = offset1 >= 0 && offset2 >= 0;
                                    if (this.m_front) {
                                        this.m_normal.x = this.m_normal1.x;
                                        this.m_normal.y = this.m_normal1.y;
                                        this.m_lowerLimit.x = -this.m_normal1.x;
                                        this.m_lowerLimit.y = -this.m_normal1.y;
                                        this.m_upperLimit.x = this.m_normal1.x;
                                        this.m_upperLimit.y = this.m_normal1.y;
                                    } else {
                                        this.m_normal.x = -this.m_normal1.x;
                                        this.m_normal.y = -this.m_normal1.y;
                                        this.m_lowerLimit.x = -this.m_normal2.x;
                                        this.m_lowerLimit.y = -this.m_normal2.y;
                                        this.m_upperLimit.x = this.m_normal1.x;
                                        this.m_upperLimit.y = this.m_normal1.y;
                                    }
                                }
                            } else {
                                this.m_front = offset1 >= 0;
                                if (this.m_front) {
                                    this.m_normal.x = this.m_normal1.x;
                                    this.m_normal.y = this.m_normal1.y;
                                    this.m_lowerLimit.x = -this.m_normal1.x;
                                    this.m_lowerLimit.y = -this.m_normal1.y;
                                    this.m_upperLimit.x = -this.m_normal1.x;
                                    this.m_upperLimit.y = -this.m_normal1.y;
                                } else {
                                    this.m_normal.x = -this.m_normal1.x;
                                    this.m_normal.y = -this.m_normal1.y;
                                    this.m_lowerLimit.x = this.m_normal1.x;
                                    this.m_lowerLimit.y = this.m_normal1.y;
                                    this.m_upperLimit.x = this.m_normal1.x;
                                    this.m_upperLimit.y = this.m_normal1.y;
                                }
                            }
                        }
                    }
                    this.m_polygonB.count = polygonB.m_count;
                    for (var i = 0; i < polygonB.m_count; ++i) {
                        this.m_polygonB.vertices[i] = b2Mul_t_v2(this.m_xf, polygonB.m_vertices[i]);
                        this.m_polygonB.normals[i] = b2Mul_r_v2(this.m_xf.q, polygonB.m_normals[i]);
                    }
                    this.m_radius = 2 * b2_polygonRadius;
                    manifold.pointCount = 0;
                    var edgeAxis = this.ComputeEdgeSeparation();
                    if (edgeAxis.type == b2EPAxis.e_unknown) {
                        return;
                    }
                    if (edgeAxis.separation > this.m_radius) {
                        return;
                    }
                    var polygonAxis = this.ComputePolygonSeparation();
                    if (polygonAxis.type != b2EPAxis.e_unknown && polygonAxis.separation > this.m_radius) {
                        return;
                    }
                    var k_relativeTol = .98;
                    var k_absoluteTol = .001;
                    var primaryAxis = new b2EPAxis();
                    primaryAxis = polygonAxis.type == b2EPAxis.e_unknown ? edgeAxis : polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol ? polygonAxis : edgeAxis;
                    var ie = new Array(2);
                    var rf = new b2ReferenceFace();
                    if (primaryAxis.type == b2EPAxis.e_edgeA) {
                        manifold.type = b2Manifold.e_faceA;
                        var bestIndex = 0;
                        var bestValue = this.m_normal.x * this.m_polygonB.normals[0].x + this.m_normal.y * this.m_polygonB.normals[0].y;
                        for (var i = 1; i < this.m_polygonB.count; ++i) {
                            var value = this.m_normal.x * this.m_polygonB.normals[i].x + this.m_normal.y * this.m_polygonB.normals[i].y;
                            if (value < bestValue) {
                                bestValue = value;
                                bestIndex = i;
                            }
                        }
                        var i1 = bestIndex;
                        var i2 = i1 + 1 < this.m_polygonB.count ? i1 + 1 : 0;
                        ie[0] = new b2ClipVertex();
                        ie[0].v.x = this.m_polygonB.vertices[i1].x;
                        ie[0].v.y = this.m_polygonB.vertices[i1].y;
                        ie[0].id.indexA = 0;
                        ie[0].id.indexB = i1;
                        ie[0].id.typeA = b2ContactID.e_face;
                        ie[0].id.typeB = b2ContactID.e_vertex;
                        ie[1] = new b2ClipVertex();
                        ie[1].v.x = this.m_polygonB.vertices[i2].x;
                        ie[1].v.y = this.m_polygonB.vertices[i2].y;
                        ie[1].id.indexA = 0;
                        ie[1].id.indexB = i2;
                        ie[1].id.typeA = b2ContactID.e_face;
                        ie[1].id.typeB = b2ContactID.e_vertex;
                        if (this.m_front) {
                            rf.i1 = 0;
                            rf.i2 = 1;
                            rf.v1.x = this.m_v1.x;
                            rf.v1.y = this.m_v1.y;
                            rf.v2.x = this.m_v2.x;
                            rf.v2.y = this.m_v2.y;
                            rf.normal.x = this.m_normal1.x;
                            rf.normal.y = this.m_normal1.y;
                        } else {
                            rf.i1 = 1;
                            rf.i2 = 0;
                            rf.v1.x = this.m_v2.x;
                            rf.v1.y = this.m_v2.y;
                            rf.v2.x = this.m_v1.x;
                            rf.v2.y = this.m_v1.y;
                            rf.normal.x = -this.m_normal1.x;
                            rf.normal.y = -this.m_normal1.y;
                        }
                    } else {
                        manifold.type = b2Manifold.e_faceB;
                        ie[0] = new b2ClipVertex();
                        ie[0].v = this.m_v1;
                        ie[0].id.indexA = 0;
                        ie[0].id.indexB = primaryAxis.index;
                        ie[0].id.typeA = b2ContactID.e_vertex;
                        ie[0].id.typeB = b2ContactID.e_face;
                        ie[1] = new b2ClipVertex();
                        ie[1].v = this.m_v2;
                        ie[1].id.indexA = 0;
                        ie[1].id.indexB = primaryAxis.index;
                        ie[1].id.typeA = b2ContactID.e_vertex;
                        ie[1].id.typeB = b2ContactID.e_face;
                        rf.i1 = primaryAxis.index;
                        rf.i2 = rf.i1 + 1 < this.m_polygonB.count ? rf.i1 + 1 : 0;
                        rf.v1.x = this.m_polygonB.vertices[rf.i1].x;
                        rf.v1.y = this.m_polygonB.vertices[rf.i1].y;
                        rf.v2.x = this.m_polygonB.vertices[rf.i2].x;
                        rf.v2.y = this.m_polygonB.vertices[rf.i2].y;
                        rf.normal.x = this.m_polygonB.normals[rf.i1].x;
                        rf.normal.y = this.m_polygonB.normals[rf.i1].y;
                    }
                    rf.sideNormal1.x = rf.normal.y;
                    rf.sideNormal1.y = -rf.normal.x;
                    rf.sideNormal2.x = -rf.sideNormal1.x;
                    rf.sideNormal2.y = -rf.sideNormal1.y;
                    rf.sideOffset1 = rf.sideNormal1.x * rf.v1.x + rf.sideNormal1.y * rf.v1.y;
                    rf.sideOffset2 = rf.sideNormal2.x * rf.v2.x + rf.sideNormal2.y * rf.v2.y;
                    var clipPoints1 = new Array(2);
                    var clipPoints2 = new Array(2);
                    var np;
                    np = b2ClipSegmentToLine(clipPoints1, ie, rf.sideNormal1.x, rf.sideNormal1.y, rf.sideOffset1, rf.i1);
                    if (np < b2_maxManifoldPoints) {
                        return;
                    }
                    np = b2ClipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2.x, rf.sideNormal2.y, rf.sideOffset2, rf.i2);
                    if (np < b2_maxManifoldPoints) {
                        return;
                    }
                    if (primaryAxis.type == b2EPAxis.e_edgeA) {
                        manifold.localNormal.x = rf.normal.x;
                        manifold.localNormal.y = rf.normal.y;
                        manifold.localPoint.x = rf.v1.x;
                        manifold.localPoint.y = rf.v1.y;
                    } else {
                        manifold.localNormal.x = polygonB.m_normals[rf.i1].x;
                        manifold.localNormal.y = polygonB.m_normals[rf.i1].y;
                        manifold.localPoint.x = polygonB.m_vertices[rf.i1].x;
                        manifold.localPoint.y = polygonB.m_vertices[rf.i1].y;
                    }
                    var pointCount = 0;
                    for (var i = 0; i < b2_maxManifoldPoints; ++i) {
                        var separation = rf.normal.x * (clipPoints2[i].v.x - rf.v1.x) + rf.normal.y * (clipPoints2[i].v.y - rf.v1.y);
                        if (separation <= this.m_radius) {
                            var cp = manifold.points[pointCount] = new b2ManifoldPoint();
                            if (primaryAxis.type == b2EPAxis.e_edgeA) {
                                cp.localPoint.Assign(b2MulT_t_v2(this.m_xf, clipPoints2[i].v));
                                cp.id.Assign(clipPoints2[i].id);
                            } else {
                                cp.localPoint.x = clipPoints2[i].v.x;
                                cp.localPoint.y = clipPoints2[i].v.y;
                                cp.id.typeA = clipPoints2[i].id.typeB;
                                cp.id.typeB = clipPoints2[i].id.typeA;
                                cp.id.indexA = clipPoints2[i].id.indexB;
                                cp.id.indexB = clipPoints2[i].id.indexA;
                            }
                            ++pointCount;
                        }
                    }
                    manifold.pointCount = pointCount;
                },
                ComputeEdgeSeparation: function() {
                    var axis = new b2EPAxis();
                    axis.type = b2EPAxis.e_edgeA;
                    axis.index = this.m_front ? 0 : 1;
                    axis.separation = Number.MAX_VALUE;
                    for (var i = 0; i < this.m_polygonB.count; ++i) {
                        var s = this.m_normal.x * (this.m_polygonB.vertices[i].x - this.m_v1.x) + this.m_normal.y * (this.m_polygonB.vertices[i].y - this.m_v1.y);
                        s < axis.separation && (axis.separation = s);
                    }
                    return axis;
                },
                ComputePolygonSeparation: function() {
                    var axis = new b2EPAxis();
                    axis.type = b2EPAxis.e_unknown;
                    axis.index = -1;
                    axis.separation = -Number.MAX_VALUE;
                    var perpx = -this.m_normal.y;
                    var perpy = this.m_normal.x;
                    for (var i = 0; i < this.m_polygonB.count; ++i) {
                        var nx = -this.m_polygonB.normals[i].x;
                        var ny = -this.m_polygonB.normals[i].y;
                        var s1 = nx * (this.m_polygonB.vertices[i].x - this.m_v1.x) + ny * (this.m_polygonB.vertices[i].y - this.m_v1.y);
                        var s2 = nx * (this.m_polygonB.vertices[i].x - this.m_v2.x) + ny * (this.m_polygonB.vertices[i].y - this.m_v2.y);
                        var s = b2Min(s1, s2);
                        if (s > this.m_radius) {
                            axis.type = b2EPAxis.e_edgeB;
                            axis.index = i;
                            axis.separation = s;
                            return axis;
                        }
                        if (nx * perpx + ny * perpy >= 0) {
                            if ((nx - this.m_upperLimit.x) * this.m_normal.x + (ny - this.m_upperLimit.y) * this.m_normal.y < -b2_angularSlop) {
                                continue;
                            }
                        } else {
                            if ((nx - this.m_lowerLimit.x) * this.m_normal.x + (ny - this.m_lowerLimit.y) * this.m_normal.y < -b2_angularSlop) {
                                continue;
                            }
                        }
                        if (s > axis.separation) {
                            axis.type = b2EPAxis.e_edgeB;
                            axis.index = i;
                            axis.separation = s;
                        }
                    }
                    return axis;
                }
            };
            b2EPCollider.e_isolated = 0;
            b2EPCollider.e_concave = 1;
            b2EPCollider.e_convex = 2;
            function b2CollideEdgeAndPolygon(manifold, edgeA, xfA, polygonB, xfB) {
                b2CollideEdgeAndPolygon.collider.Collide(manifold, edgeA, xfA, polygonB, xfB);
            }
            b2CollideEdgeAndPolygon.collider = new b2EPCollider();
            function b2ClipSegmentToLine(vOut, vIn, normalx, normaly, offset, vertexIndexA) {
                var numOut = 0;
                var distance0 = normalx * vIn[0].v.x + normaly * vIn[0].v.y - offset;
                var distance1 = normalx * vIn[1].v.x + normaly * vIn[1].v.y - offset;
                distance0 <= 0 && (vOut[numOut++] = vIn[0]);
                distance1 <= 0 && (vOut[numOut++] = vIn[1]);
                if (distance0 * distance1 < 0) {
                    var interp = distance0 / (distance0 - distance1);
                    vOut[numOut] = new b2ClipVertex();
                    vOut[numOut].v.x = vIn[0].v.x + interp * (vIn[1].v.x - vIn[0].v.x);
                    vOut[numOut].v.y = vIn[0].v.y + interp * (vIn[1].v.y - vIn[0].v.y);
                    vOut[numOut].id.indexA = vertexIndexA;
                    vOut[numOut].id.indexB = vIn[0].id.indexB;
                    vOut[numOut].id.typeA = b2ContactID.e_vertex;
                    vOut[numOut].id.typeB = b2ContactID.e_face;
                    ++numOut;
                }
                return numOut;
            }
            function b2TestShapeOverlap(shapeA, indexA, shapeB, indexB, xfA, xfB) {
                b2TestShapeOverlap.input.proxyA.Set(shapeA, indexA);
                b2TestShapeOverlap.input.proxyB.Set(shapeB, indexB);
                b2TestShapeOverlap.input.transformA = xfA;
                b2TestShapeOverlap.input.transformB = xfB;
                b2TestShapeOverlap.input.useRadii = true;
                b2TestShapeOverlap.cache.count = 0;
                b2DistanceFunc(b2TestShapeOverlap.output, b2TestShapeOverlap.cache, b2TestShapeOverlap.input);
                return b2TestShapeOverlap.output.distance < 10 * b2_epsilon;
            }
            b2TestShapeOverlap.input = new b2DistanceInput();
            b2TestShapeOverlap.cache = new b2SimplexCache();
            b2TestShapeOverlap.output = new b2DistanceOutput();
            function b2TestOverlap(a, b) {
                return !(b.lowerBound.x - a.upperBound.x > 0 || b.lowerBound.y - a.upperBound.y > 0 || a.lowerBound.x - b.upperBound.x > 0 || a.lowerBound.y - b.upperBound.y > 0);
            }
            var b2_nullNode = -1;
            function b2TreeNode() {
                this.aabb = new b2AABB();
                this.userData = null;
                this.parent = 0;
                this.child1 = this.child2 = this.height = 0;
            }
            b2TreeNode.prototype = {
                IsLeaf: function() {
                    return this.child1 == b2_nullNode;
                }
            };
            function b2DynamicTree() {
                this.m_root = b2_nullNode;
                this.m_nodeCapacity = 16;
                this.m_nodeCount = 0;
                this.m_nodes = new Array(this.m_nodeCapacity);
                for (var i = 0; i < this.m_nodeCapacity - 1; ++i) {
                    this.m_nodes[i] = new b2TreeNode();
                    this.m_nodes[i].parent = i + 1;
                    this.m_nodes[i].height = -1;
                }
                this.m_nodes[this.m_nodeCapacity - 1] = new b2TreeNode();
                this.m_nodes[this.m_nodeCapacity - 1].parent = b2_nullNode;
                this.m_nodes[this.m_nodeCapacity - 1].height = -1;
                this.m_freeList = 0;
                this.m_path = 0;
                this.m_insertionCount = 0;
            }
            b2DynamicTree.aabbExtensionFattener = new b2Vec2(b2_aabbExtension, b2_aabbExtension);
            b2DynamicTree.prototype = {
                CreateProxy: function(aabb, userData) {
                    var proxyId = this.AllocateNode();
                    this.m_nodes[proxyId].aabb.lowerBound.Assign(b2Vec2.Subtract(aabb.lowerBound, b2DynamicTree.aabbExtensionFattener));
                    this.m_nodes[proxyId].aabb.upperBound.Assign(b2Vec2.Add(aabb.upperBound, b2DynamicTree.aabbExtensionFattener));
                    this.m_nodes[proxyId].userData = userData;
                    this.m_nodes[proxyId].height = 0;
                    this.InsertLeaf(proxyId);
                    return proxyId;
                },
                DestroyProxy: function(proxyId) {
                    b2Assert(0 <= proxyId && proxyId < this.m_nodeCapacity);
                    b2Assert(this.m_nodes[proxyId].IsLeaf());
                    this.RemoveLeaf(proxyId);
                    this.FreeNode(proxyId);
                },
                MoveProxy: function(proxyId, aabb, displacement) {
                    b2Assert(0 <= proxyId && proxyId < this.m_nodeCapacity);
                    b2Assert(this.m_nodes[proxyId].IsLeaf());
                    if (this.m_nodes[proxyId].aabb.Contains(aabb)) {
                        return false;
                    }
                    this.RemoveLeaf(proxyId);
                    this.m_nodes[proxyId].aabb.Assign(aabb);
                    this.m_nodes[proxyId].aabb.lowerBound.Subtract(b2DynamicTree.aabbExtensionFattener);
                    this.m_nodes[proxyId].aabb.upperBound.Add(b2DynamicTree.aabbExtensionFattener);
                    var d = b2Vec2.Multiply(b2_aabbMultiplier, displacement);
                    d.x < 0 ? this.m_nodes[proxyId].aabb.lowerBound.x += d.x : this.m_nodes[proxyId].aabb.upperBound.x += d.x;
                    d.y < 0 ? this.m_nodes[proxyId].aabb.lowerBound.y += d.y : this.m_nodes[proxyId].aabb.upperBound.y += d.y;
                    this.InsertLeaf(proxyId);
                    return true;
                },
                GetUserData: function(proxyId) {
                    b2Assert(0 <= proxyId && proxyId < this.m_nodeCapacity);
                    return this.m_nodes[proxyId].userData;
                },
                GetFatAABB: function(proxyId) {
                    b2Assert(0 <= proxyId && proxyId < this.m_nodeCapacity);
                    return this.m_nodes[proxyId].aabb;
                },
                Query: function(callback, aabb) {
                    var stack = [];
                    stack.push(this.m_root);
                    while (stack.length > 0) {
                        var nodeId = stack.pop();
                        if (nodeId == b2_nullNode) {
                            continue;
                        }
                        var node = this.m_nodes[nodeId];
                        if (b2TestOverlap(node.aabb, aabb)) {
                            if (node.IsLeaf()) {
                                var proceed = callback.QueryCallback(nodeId);
                                if (false == proceed) {
                                    return;
                                }
                            } else {
                                stack.push(node.child1);
                                stack.push(node.child2);
                            }
                        }
                    }
                },
                RayCast: function(callback, input) {
                    var p1 = input.p1;
                    var p2 = input.p2;
                    var r = b2Vec2.Subtract(p2, p1);
                    b2Assert(r.LengthSquared() > 0);
                    r.Normalize();
                    var v = b2Cross_f_v2(1, r);
                    var abs_v = b2Abs_v2(v);
                    var maxFraction = input.maxFraction;
                    var segmentAABB = new b2AABB();
                    var t = b2Vec2.Add(p1, b2Vec2.Multiply(maxFraction, b2Vec2.Subtract(p2, p1)));
                    segmentAABB.lowerBound.Assign(b2Min_v2(p1, t));
                    segmentAABB.upperBound.Assign(b2Max_v2(p1, t));
                    var stack = [];
                    stack.push(this.m_root);
                    while (stack.length > 0) {
                        var nodeId = stack.pop();
                        if (nodeId == b2_nullNode) {
                            continue;
                        }
                        var node = this.m_nodes[nodeId];
                        if (false == b2TestOverlap(node.aabb, segmentAABB)) {
                            continue;
                        }
                        var c = node.aabb.GetCenter();
                        var h = node.aabb.GetExtents();
                        var separation = b2Abs(b2Dot_v2_v2(v, b2Vec2.Subtract(p1, c))) - b2Dot_v2_v2(abs_v, h);
                        if (separation > 0) {
                            continue;
                        }
                        if (node.IsLeaf()) {
                            var subInput = new b2RayCastInput();
                            subInput.p1.Assign(input.p1);
                            subInput.p2.Assign(input.p2);
                            subInput.maxFraction = maxFraction;
                            var value = callback.RayCastCallback(subInput, nodeId);
                            if (0 == value) {
                                return;
                            }
                            if (value > 0) {
                                maxFraction = value;
                                var t = b2Vec2.Add(p1, b2Vec2.Multiply(maxFraction, b2Vec2.Subtract(p2, p1)));
                                segmentAABB.lowerBound.Assign(b2Min_v2(p1, t));
                                segmentAABB.upperBound.Assign(b2Max_v2(p1, t));
                            }
                        } else {
                            stack.push(node.child1);
                            stack.push(node.child2);
                        }
                    }
                },
                Validate: function() {
                    this.ValidateStructure(this.m_root);
                    this.ValidateMetrics(this.m_root);
                    var freeCount = 0;
                    var freeIndex = this.m_freeList;
                    while (freeIndex != b2_nullNode) {
                        b2Assert(0 <= freeIndex && freeIndex < this.m_nodeCapacity);
                        freeIndex = this.m_nodes[freeIndex].parent;
                        ++freeCount;
                    }
                    b2Assert(this.GetHeight() == this.ComputeHeight());
                    b2Assert(this.m_nodeCount + freeCount == this.m_nodeCapacity);
                },
                GetHeight: function() {
                    if (this.m_root == b2_nullNode) {
                        return 0;
                    }
                    return this.m_nodes[this.m_root].height;
                },
                GetMaxBalance: function() {
                    var maxBalance = 0;
                    for (var i = 0; i < this.m_nodeCapacity; ++i) {
                        var node = this.m_nodes[i];
                        if (node.height <= 1) {
                            continue;
                        }
                        b2Assert(false == node.IsLeaf());
                        var child1 = node.child1;
                        var child2 = node.child2;
                        var balance = b2Abs(this.m_nodes[child2].height - this.m_nodes[child1].height);
                        maxBalance = b2Max(maxBalance, balance);
                    }
                    return maxBalance;
                },
                GetAreaRatio: function() {
                    if (this.m_root == b2_nullNode) {
                        return 0;
                    }
                    var root = this.m_nodes[this.m_root];
                    var rootArea = root.aabb.GetPerimeter();
                    var totalArea = 0;
                    for (var i = 0; i < this.m_nodeCapacity; ++i) {
                        var node = this.m_nodes[i];
                        if (node.height < 0) {
                            continue;
                        }
                        totalArea += node.aabb.GetPerimeter();
                    }
                    return totalArea / rootArea;
                },
                RebuildBottomUp: function() {
                    var nodes = new Array(this.m_nodeCount);
                    var count = 0;
                    for (var i = 0; i < this.m_nodeCapacity; ++i) {
                        if (this.m_nodes[i].height < 0) {
                            continue;
                        }
                        if (this.m_nodes[i].IsLeaf()) {
                            this.m_nodes[i].parent = b2_nullNode;
                            nodes[count] = i;
                            ++count;
                        } else {
                            this.FreeNode(i);
                        }
                    }
                    while (count > 1) {
                        var minCost = b2_maxFloat;
                        var iMin = -1, jMin = -1;
                        for (i = 0; i < count; ++i) {
                            var aabbi = this.m_nodes[nodes[i]].aabb;
                            for (var j = i + 1; j < count; ++j) {
                                var aabbj = this.m_nodes[nodes[j]].aabb;
                                var b = new b2AABB();
                                b.Combine(aabbi, aabbj);
                                var cost = b.GetPerimeter();
                                if (cost < minCost) {
                                    iMin = i;
                                    jMin = j;
                                    minCost = cost;
                                }
                            }
                        }
                        var index1 = nodes[iMin];
                        var index2 = nodes[jMin];
                        var child1 = this.m_nodes[index1];
                        var child2 = this.m_nodes[index2];
                        var parentIndex = this.AllocateNode();
                        var parent = this.m_nodes[parentIndex];
                        parent.child1 = index1;
                        parent.child2 = index2;
                        parent.height = 1 + b2Max(child1.height, child2.height);
                        parent.aabb.Combine(child1.aabb, child2.aabb);
                        parent.parent = b2_nullNode;
                        child1.parent = parentIndex;
                        child2.parent = parentIndex;
                        nodes[jMin] = nodes[count - 1];
                        nodes[iMin] = parentIndex;
                        --count;
                    }
                    this.m_root = nodes[0];
                    this.Validate();
                },
                ShiftOrigin: function(newOrigin) {
                    for (var i = 0; i < this.m_nodeCapacity; ++i) {
                        this.m_nodes[i].aabb.lowerBound.Subtract(newOrigin);
                        this.m_nodes[i].aabb.upperBound.Subtract(newOrigin);
                    }
                },
                AllocateNode: function() {
                    if (this.m_freeList == b2_nullNode) {
                        b2Assert(this.m_nodeCount == this.m_nodeCapacity);
                        var oldNodes = this.m_nodes;
                        this.m_nodeCapacity *= 2;
                        this.m_nodes = oldNodes.concat(new Array(this.m_nodeCapacity - this.m_nodeCount));
                        for (var i = this.m_nodeCount; i < this.m_nodeCapacity - 1; ++i) {
                            this.m_nodes[i] = new b2TreeNode();
                            this.m_nodes[i].parent = i + 1;
                            this.m_nodes[i].height = -1;
                        }
                        this.m_nodes[this.m_nodeCapacity - 1] = new b2TreeNode();
                        this.m_nodes[this.m_nodeCapacity - 1].parent = b2_nullNode;
                        this.m_nodes[this.m_nodeCapacity - 1].height = -1;
                        this.m_freeList = this.m_nodeCount;
                    }
                    var nodeId = this.m_freeList;
                    this.m_freeList = this.m_nodes[nodeId].parent;
                    this.m_nodes[nodeId].parent = b2_nullNode;
                    this.m_nodes[nodeId].child1 = b2_nullNode;
                    this.m_nodes[nodeId].child2 = b2_nullNode;
                    this.m_nodes[nodeId].height = 0;
                    this.m_nodes[nodeId].userData = null;
                    ++this.m_nodeCount;
                    return nodeId;
                },
                FreeNode: function(nodeId) {
                    b2Assert(0 <= nodeId && nodeId < this.m_nodeCapacity);
                    b2Assert(0 < this.m_nodeCount);
                    this.m_nodes[nodeId].parent = this.m_freeList;
                    this.m_nodes[nodeId].height = -1;
                    this.m_freeList = nodeId;
                    --this.m_nodeCount;
                },
                InsertLeaf: function(leaf) {
                    ++this.m_insertionCount;
                    if (this.m_root == b2_nullNode) {
                        this.m_root = leaf;
                        this.m_nodes[this.m_root].parent = b2_nullNode;
                        return;
                    }
                    var leafAABB = this.m_nodes[leaf].aabb;
                    var index = this.m_root;
                    while (false == this.m_nodes[index].IsLeaf()) {
                        var child1 = this.m_nodes[index].child1;
                        var child2 = this.m_nodes[index].child2;
                        var area = this.m_nodes[index].aabb.GetPerimeter();
                        var combinedAABB = new b2AABB();
                        combinedAABB.Combine(this.m_nodes[index].aabb, leafAABB);
                        var combinedArea = combinedAABB.GetPerimeter();
                        var cost = 2 * combinedArea;
                        var inheritanceCost = 2 * (combinedArea - area);
                        var cost1;
                        var aabb;
                        if (this.m_nodes[child1].IsLeaf()) {
                            aabb = new b2AABB();
                            aabb.Combine(leafAABB, this.m_nodes[child1].aabb);
                            cost1 = aabb.GetPerimeter() + inheritanceCost;
                        } else {
                            aabb = new b2AABB();
                            aabb.Combine(leafAABB, this.m_nodes[child1].aabb);
                            var oldArea = this.m_nodes[child1].aabb.GetPerimeter();
                            var newArea = aabb.GetPerimeter();
                            cost1 = newArea - oldArea + inheritanceCost;
                        }
                        var cost2;
                        if (this.m_nodes[child2].IsLeaf()) {
                            aabb = new b2AABB();
                            aabb.Combine(leafAABB, this.m_nodes[child2].aabb);
                            cost2 = aabb.GetPerimeter() + inheritanceCost;
                        } else {
                            aabb = new b2AABB();
                            aabb.Combine(leafAABB, this.m_nodes[child2].aabb);
                            var oldArea = this.m_nodes[child2].aabb.GetPerimeter();
                            var newArea = aabb.GetPerimeter();
                            cost2 = newArea - oldArea + inheritanceCost;
                        }
                        if (cost < cost1 && cost < cost2) {
                            break;
                        }
                        index = cost1 < cost2 ? child1 : child2;
                    }
                    var sibling = index;
                    var oldParent = this.m_nodes[sibling].parent;
                    var newParent = this.AllocateNode();
                    this.m_nodes[newParent].parent = oldParent;
                    this.m_nodes[newParent].userData = null;
                    this.m_nodes[newParent].aabb.Combine(leafAABB, this.m_nodes[sibling].aabb);
                    this.m_nodes[newParent].height = this.m_nodes[sibling].height + 1;
                    if (oldParent != b2_nullNode) {
                        this.m_nodes[oldParent].child1 == sibling ? this.m_nodes[oldParent].child1 = newParent : this.m_nodes[oldParent].child2 = newParent;
                        this.m_nodes[newParent].child1 = sibling;
                        this.m_nodes[newParent].child2 = leaf;
                        this.m_nodes[sibling].parent = newParent;
                        this.m_nodes[leaf].parent = newParent;
                    } else {
                        this.m_nodes[newParent].child1 = sibling;
                        this.m_nodes[newParent].child2 = leaf;
                        this.m_nodes[sibling].parent = newParent;
                        this.m_nodes[leaf].parent = newParent;
                        this.m_root = newParent;
                    }
                    index = this.m_nodes[leaf].parent;
                    while (index != b2_nullNode) {
                        index = this.Balance(index);
                        var child1 = this.m_nodes[index].child1;
                        var child2 = this.m_nodes[index].child2;
                        b2Assert(child1 != b2_nullNode);
                        b2Assert(child2 != b2_nullNode);
                        this.m_nodes[index].height = 1 + b2Max(this.m_nodes[child1].height, this.m_nodes[child2].height);
                        this.m_nodes[index].aabb.Combine(this.m_nodes[child1].aabb, this.m_nodes[child2].aabb);
                        index = this.m_nodes[index].parent;
                    }
                },
                RemoveLeaf: function(leaf) {
                    if (leaf == this.m_root) {
                        this.m_root = b2_nullNode;
                        return;
                    }
                    var parent = this.m_nodes[leaf].parent;
                    var grandParent = this.m_nodes[parent].parent;
                    var sibling;
                    sibling = this.m_nodes[parent].child1 == leaf ? this.m_nodes[parent].child2 : this.m_nodes[parent].child1;
                    if (grandParent != b2_nullNode) {
                        this.m_nodes[grandParent].child1 == parent ? this.m_nodes[grandParent].child1 = sibling : this.m_nodes[grandParent].child2 = sibling;
                        this.m_nodes[sibling].parent = grandParent;
                        this.FreeNode(parent);
                        var index = grandParent;
                        while (index != b2_nullNode) {
                            index = this.Balance(index);
                            var child1 = this.m_nodes[index].child1;
                            var child2 = this.m_nodes[index].child2;
                            this.m_nodes[index].aabb.Combine(this.m_nodes[child1].aabb, this.m_nodes[child2].aabb);
                            this.m_nodes[index].height = 1 + b2Max(this.m_nodes[child1].height, this.m_nodes[child2].height);
                            index = this.m_nodes[index].parent;
                        }
                    } else {
                        this.m_root = sibling;
                        this.m_nodes[sibling].parent = b2_nullNode;
                        this.FreeNode(parent);
                    }
                },
                Balance: function(iA) {
                    b2Assert(iA != b2_nullNode);
                    var A = this.m_nodes[iA];
                    if (A.IsLeaf() || A.height < 2) {
                        return iA;
                    }
                    var iB = A.child1;
                    var iC = A.child2;
                    b2Assert(0 <= iB && iB < this.m_nodeCapacity);
                    b2Assert(0 <= iC && iC < this.m_nodeCapacity);
                    var B = this.m_nodes[iB];
                    var C = this.m_nodes[iC];
                    var balance = C.height - B.height;
                    if (balance > 1) {
                        var iF = C.child1;
                        var iG = C.child2;
                        var F = this.m_nodes[iF];
                        var G = this.m_nodes[iG];
                        b2Assert(0 <= iF && iF < this.m_nodeCapacity);
                        b2Assert(0 <= iG && iG < this.m_nodeCapacity);
                        C.child1 = iA;
                        C.parent = A.parent;
                        A.parent = iC;
                        if (C.parent != b2_nullNode) {
                            if (this.m_nodes[C.parent].child1 == iA) {
                                this.m_nodes[C.parent].child1 = iC;
                            } else {
                                b2Assert(this.m_nodes[C.parent].child2 == iA);
                                this.m_nodes[C.parent].child2 = iC;
                            }
                        } else {
                            this.m_root = iC;
                        }
                        if (F.height > G.height) {
                            C.child2 = iF;
                            A.child2 = iG;
                            G.parent = iA;
                            A.aabb.Combine(B.aabb, G.aabb);
                            C.aabb.Combine(A.aabb, F.aabb);
                            A.height = 1 + b2Max(B.height, G.height);
                            C.height = 1 + b2Max(A.height, F.height);
                        } else {
                            C.child2 = iG;
                            A.child2 = iF;
                            F.parent = iA;
                            A.aabb.Combine(B.aabb, F.aabb);
                            C.aabb.Combine(A.aabb, G.aabb);
                            A.height = 1 + b2Max(B.height, F.height);
                            C.height = 1 + b2Max(A.height, G.height);
                        }
                        return iC;
                    }
                    if (balance < -1) {
                        var iD = B.child1;
                        var iE = B.child2;
                        var D = this.m_nodes[iD];
                        var E = this.m_nodes[iE];
                        b2Assert(0 <= iD && iD < this.m_nodeCapacity);
                        b2Assert(0 <= iE && iE < this.m_nodeCapacity);
                        B.child1 = iA;
                        B.parent = A.parent;
                        A.parent = iB;
                        if (B.parent != b2_nullNode) {
                            if (this.m_nodes[B.parent].child1 == iA) {
                                this.m_nodes[B.parent].child1 = iB;
                            } else {
                                b2Assert(this.m_nodes[B.parent].child2 == iA);
                                this.m_nodes[B.parent].child2 = iB;
                            }
                        } else {
                            this.m_root = iB;
                        }
                        if (D.height > E.height) {
                            B.child2 = iD;
                            A.child1 = iE;
                            E.parent = iA;
                            A.aabb.Combine(C.aabb, E.aabb);
                            B.aabb.Combine(A.aabb, D.aabb);
                            A.height = 1 + b2Max(C.height, E.height);
                            B.height = 1 + b2Max(A.height, D.height);
                        } else {
                            B.child2 = iE;
                            A.child1 = iD;
                            D.parent = iA;
                            A.aabb.Combine(C.aabb, D.aabb);
                            B.aabb.Combine(A.aabb, E.aabb);
                            A.height = 1 + b2Max(C.height, D.height);
                            B.height = 1 + b2Max(A.height, E.height);
                        }
                        return iB;
                    }
                    return iA;
                },
                ComputeHeight: function(nodeId) {
                    "undefined" === typeof nodeId && (nodeId = this.m_root);
                    b2Assert(0 <= nodeId && nodeId < this.m_nodeCapacity);
                    var node = this.m_nodes[nodeId];
                    if (node.IsLeaf()) {
                        return 0;
                    }
                    var height1 = this.ComputeHeight(node.child1);
                    var height2 = this.ComputeHeight(node.child2);
                    return 1 + b2Max(height1, height2);
                },
                ValidateStructure: function(index) {
                    if (index == b2_nullNode) {
                        return;
                    }
                    index == this.m_root && b2Assert(this.m_nodes[index].parent == b2_nullNode);
                    var node = this.m_nodes[index];
                    var child1 = node.child1;
                    var child2 = node.child2;
                    if (node.IsLeaf()) {
                        b2Assert(child1 == b2_nullNode);
                        b2Assert(child2 == b2_nullNode);
                        b2Assert(0 == node.height);
                        return;
                    }
                    b2Assert(0 <= child1 && child1 < this.m_nodeCapacity);
                    b2Assert(0 <= child2 && child2 < this.m_nodeCapacity);
                    b2Assert(this.m_nodes[child1].parent == index);
                    b2Assert(this.m_nodes[child2].parent == index);
                    this.ValidateStructure(child1);
                    this.ValidateStructure(child2);
                },
                ValidateMetrics: function(index) {
                    if (index == b2_nullNode) {
                        return;
                    }
                    var node = this.m_nodes[index];
                    var child1 = node.child1;
                    var child2 = node.child2;
                    if (node.IsLeaf()) {
                        b2Assert(child1 == b2_nullNode);
                        b2Assert(child2 == b2_nullNode);
                        b2Assert(0 == node.height);
                        return;
                    }
                    b2Assert(0 <= child1 && child1 < this.m_nodeCapacity);
                    b2Assert(0 <= child2 && child2 < this.m_nodeCapacity);
                    var height1 = this.m_nodes[child1].height;
                    var height2 = this.m_nodes[child2].height;
                    var height;
                    height = 1 + b2Max(height1, height2);
                    b2Assert(node.height == height);
                    var aabb = new b2AABB();
                    aabb.Combine(this.m_nodes[child1].aabb, this.m_nodes[child2].aabb);
                    b2Assert(b2Vec2.Equals(aabb.lowerBound, node.aabb.lowerBound));
                    b2Assert(b2Vec2.Equals(aabb.upperBound, node.aabb.upperBound));
                    this.ValidateMetrics(child1);
                    this.ValidateMetrics(child2);
                }
            };
            function b2TOIInput() {
                this.proxyA = new b2DistanceProxy();
                this.proxyB = new b2DistanceProxy();
                this.sweepA = new b2Sweep();
                this.sweepB = new b2Sweep();
                this.tMax = 0;
            }
            function b2TOIOutput() {
                this.state = 0;
                this.t = 0;
            }
            b2TOIOutput.e_unknown = 0;
            b2TOIOutput.e_failed = 1;
            b2TOIOutput.e_overlapped = 2;
            b2TOIOutput.e_touching = 3;
            b2TOIOutput.e_separated = 4;
            function b2SeparationFunction() {
                this.m_proxyA = null;
                this.m_proxyB = null;
                this.m_sweepA = null;
                this.m_sweepB = null;
                this.m_type = 0;
                this.m_localPoint = new b2Vec2();
                this.m_axis = new b2Vec2();
            }
            var _local_xfA = new b2Transform();
            var _local_xfB = new b2Transform();
            b2SeparationFunction.prototype = {
                Initialize: function(cache, proxyA, sweepA, proxyB, sweepB, t1) {
                    this.m_proxyA = proxyA;
                    this.m_proxyB = proxyB;
                    var count = cache.count;
                    b2Assert(0 < count && count < 3);
                    this.m_sweepA = sweepA;
                    this.m_sweepB = sweepB;
                    this.m_sweepA.GetTransform(_local_xfA, t1);
                    this.m_sweepB.GetTransform(_local_xfB, t1);
                    if (1 == count) {
                        this.m_type = b2SeparationFunction.e_points;
                        var localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
                        var localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
                        var pointAx = _local_xfA.q.c * localPointA.x - _local_xfA.q.s * localPointA.y + _local_xfA.p.x;
                        var pointAy = _local_xfA.q.s * localPointA.x + _local_xfA.q.c * localPointA.y + _local_xfA.p.y;
                        var pointBx = _local_xfB.q.c * localPointB.x - _local_xfB.q.s * localPointB.y + _local_xfB.p.x;
                        var pointBy = _local_xfB.q.s * localPointB.x + _local_xfB.q.c * localPointB.y + _local_xfB.p.y;
                        this.m_axis.x = pointBx - pointAx;
                        this.m_axis.y = pointBy - pointAy;
                        var s = this.m_axis.Normalize();
                        return s;
                    }
                    if (cache.indexA[0] == cache.indexA[1]) {
                        this.m_type = b2SeparationFunction.e_faceB;
                        var localPointB1 = proxyB.GetVertex(cache.indexB[0]);
                        var localPointB2 = proxyB.GetVertex(cache.indexB[1]);
                        this.m_axis.x = 1 * (localPointB2.y - localPointB1.y);
                        this.m_axis.y = -1 * (localPointB2.x - localPointB1.x);
                        this.m_axis.Normalize();
                        var normalx = _local_xfB.q.c * this.m_axis.x - _local_xfB.q.s * this.m_axis.y;
                        var normaly = _local_xfB.q.s * this.m_axis.x + _local_xfB.q.c * this.m_axis.y;
                        this.m_localPoint.x = .5 * (localPointB1.x + localPointB2.x);
                        this.m_localPoint.y = .5 * (localPointB1.y + localPointB2.y);
                        var pointBx = _local_xfB.q.c * this.m_localPoint.x - _local_xfB.q.s * this.m_localPoint.y + _local_xfB.p.x;
                        var pointBy = _local_xfB.q.s * this.m_localPoint.x + _local_xfB.q.c * this.m_localPoint.y + _local_xfB.p.y;
                        var localPointA = proxyA.GetVertex(cache.indexA[0]);
                        var pointAx = _local_xfA.q.c * localPointA.x - _local_xfA.q.s * localPointA.y + _local_xfA.p.x;
                        var pointAy = _local_xfA.q.s * localPointA.x + _local_xfA.q.c * localPointA.y + _local_xfA.p.y;
                        var s = (pointAx - pointBx) * normalx + (pointAy - pointBy) * normaly;
                        if (s < 0) {
                            this.m_axis.x = -this.m_axis.x;
                            this.m_axis.y = -this.m_axis.y;
                            s = -s;
                        }
                        return s;
                    }
                    this.m_type = b2SeparationFunction.e_faceA;
                    var localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
                    var localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
                    this.m_axis.x = 1 * (localPointA2.y - localPointA1.y);
                    this.m_axis.y = -1 * (localPointA2.x - localPointA1.x);
                    this.m_axis.Normalize();
                    var normalx = _local_xfA.q.c * this.m_axis.x - _local_xfA.q.s * this.m_axis.y;
                    var normaly = _local_xfA.q.s * this.m_axis.x + _local_xfA.q.c * this.m_axis.y;
                    this.m_localPoint.x = .5 * (localPointA1.x + localPointA2.x);
                    this.m_localPoint.y = .5 * (localPointA1.y + localPointA2.y);
                    var pointAx = _local_xfA.q.c * this.m_localPoint.x - _local_xfA.q.s * this.m_localPoint.y + _local_xfA.p.x;
                    var pointAy = _local_xfA.q.s * this.m_localPoint.x + _local_xfA.q.c * this.m_localPoint.y + _local_xfA.p.y;
                    var localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
                    var pointBx = _local_xfB.q.c * localPointB.x - _local_xfB.q.s * localPointB.y + _local_xfB.p.x;
                    var pointBy = _local_xfB.q.s * localPointB.x + _local_xfB.q.c * localPointB.y + _local_xfB.p.y;
                    var s = (pointBx - pointAx) * normalx + (pointBy - pointAy) * normaly;
                    if (s < 0) {
                        this.m_axis.x = -this.m_axis.x;
                        this.m_axis.y = -this.m_axis.y;
                        s = -s;
                    }
                    return s;
                },
                FindMinSeparation: function(indices, t) {
                    this.m_sweepA.GetTransform(_local_xfA, t);
                    this.m_sweepB.GetTransform(_local_xfB, t);
                    switch (this.m_type) {
                      case b2SeparationFunction.e_points:
                        var axisAx = _local_xfA.q.c * this.m_axis.x + _local_xfA.q.s * this.m_axis.y;
                        var axisAy = -_local_xfA.q.s * this.m_axis.x + _local_xfA.q.c * this.m_axis.y;
                        var axisBx = _local_xfB.q.c * -this.m_axis.x + _local_xfB.q.s * -this.m_axis.y;
                        var axisBy = -_local_xfB.q.s * -this.m_axis.x + _local_xfB.q.c * -this.m_axis.y;
                        indices[0] = this.m_proxyA.GetSupport(axisAx, axisAy);
                        indices[1] = this.m_proxyB.GetSupport(axisBx, axisBy);
                        var localPointA = this.m_proxyA.GetVertex(indices[0]);
                        var localPointB = this.m_proxyB.GetVertex(indices[1]);
                        var pointAx = _local_xfA.q.c * localPointA.x - _local_xfA.q.s * localPointA.y + _local_xfA.p.x;
                        var pointAy = _local_xfA.q.s * localPointA.x + _local_xfA.q.c * localPointA.y + _local_xfA.p.y;
                        var pointBx = _local_xfB.q.c * localPointB.x - _local_xfB.q.s * localPointB.y + _local_xfB.p.x;
                        var pointBy = _local_xfB.q.s * localPointB.x + _local_xfB.q.c * localPointB.y + _local_xfB.p.y;
                        return (pointBx - pointAx) * this.m_axis.x + (pointBy - pointAy) * this.m_axis.y;

                      case b2SeparationFunction.e_faceA:
                        var normalx = _local_xfA.q.c * this.m_axis.x - _local_xfA.q.s * this.m_axis.y;
                        var normaly = _local_xfA.q.s * this.m_axis.x + _local_xfA.q.c * this.m_axis.y;
                        var pointAx = _local_xfA.q.c * this.m_localPoint.x - _local_xfA.q.s * this.m_localPoint.y + _local_xfA.p.x;
                        var pointAy = _local_xfA.q.s * this.m_localPoint.x + _local_xfA.q.c * this.m_localPoint.y + _local_xfA.p.y;
                        var axisBx = _local_xfB.q.c * -normalx + _local_xfB.q.s * -normaly;
                        var axisBy = -_local_xfB.q.s * -normalx + _local_xfB.q.c * -normaly;
                        indices[0] = -1;
                        indices[1] = this.m_proxyB.GetSupport(axisBx, axisBy);
                        var localPointB = this.m_proxyB.GetVertex(indices[1]);
                        var pointBx = _local_xfB.q.c * localPointB.x - _local_xfB.q.s * localPointB.y + _local_xfB.p.x;
                        var pointBy = _local_xfB.q.s * localPointB.x + _local_xfB.q.c * localPointB.y + _local_xfB.p.y;
                        return (pointBx - pointAx) * normalx + (pointBy - pointAy) * normaly;

                      case b2SeparationFunction.e_faceB:
                        var normalx = _local_xfB.q.c * this.m_axis.x - _local_xfB.q.s * this.m_axis.y;
                        var normaly = _local_xfB.q.s * this.m_axis.x + _local_xfB.q.c * this.m_axis.y;
                        var pointBx = _local_xfB.q.c * this.m_localPoint.x - _local_xfB.q.s * this.m_localPoint.y + _local_xfB.p.x;
                        var pointBy = _local_xfB.q.s * this.m_localPoint.x + _local_xfB.q.c * this.m_localPoint.y + _local_xfB.p.y;
                        var axisAx = _local_xfA.q.c * -normalx + _local_xfA.q.s * -normaly;
                        var axisBy = -_local_xfA.q.s * -normalx + _local_xfA.q.c * -normaly;
                        indices[1] = -1;
                        indices[0] = this.m_proxyA.GetSupport(axisAx, axisBy);
                        var localPointA = this.m_proxyA.GetVertex(indices[0]);
                        var pointAx = _local_xfA.q.c * localPointA.x - _local_xfA.q.s * localPointA.y + _local_xfA.p.x;
                        var pointAy = _local_xfA.q.s * localPointA.x + _local_xfA.q.c * localPointA.y + _local_xfA.p.y;
                        return (pointAx - pointBx) * normalx + (pointAy - pointBy) * normaly;

                      default:
                        b2Assert(false);
                        indices[0] = -1;
                        indices[1] = -1;
                        return 0;
                    }
                },
                Evaluate: function(indexA, indexB, t) {
                    this.m_sweepA.GetTransform(_local_xfA, t);
                    this.m_sweepB.GetTransform(_local_xfB, t);
                    switch (this.m_type) {
                      case b2SeparationFunction.e_points:
                        var localPointA = this.m_proxyA.GetVertex(indexA);
                        var localPointB = this.m_proxyB.GetVertex(indexB);
                        var pointAx = _local_xfA.q.c * localPointA.x - _local_xfA.q.s * localPointA.y + _local_xfA.p.x;
                        var pointAy = _local_xfA.q.s * localPointA.x + _local_xfA.q.c * localPointA.y + _local_xfA.p.y;
                        var pointBx = _local_xfB.q.c * localPointB.x - _local_xfB.q.s * localPointB.y + _local_xfB.p.x;
                        var pointBy = _local_xfB.q.s * localPointB.x + _local_xfB.q.c * localPointB.y + _local_xfB.p.y;
                        var separation = (pointBx - pointAx) * this.m_axis.x + (pointBy - pointAy) * this.m_axis.y;
                        return separation;

                      case b2SeparationFunction.e_faceA:
                        var normalx = _local_xfA.q.c * this.m_axis.x - _local_xfA.q.s * this.m_axis.y;
                        var normaly = _local_xfA.q.s * this.m_axis.x + _local_xfA.q.c * this.m_axis.y;
                        var pointAx = _local_xfA.q.c * this.m_localPoint.x - _local_xfA.q.s * this.m_localPoint.y + _local_xfA.p.x;
                        var pointAy = _local_xfA.q.s * this.m_localPoint.x + _local_xfA.q.c * this.m_localPoint.y + _local_xfA.p.y;
                        var localPointB = this.m_proxyB.GetVertex(indexB);
                        var pointBx = _local_xfB.q.c * localPointB.x - _local_xfB.q.s * localPointB.y + _local_xfB.p.x;
                        var pointBy = _local_xfB.q.s * localPointB.x + _local_xfB.q.c * localPointB.y + _local_xfB.p.y;
                        var separation = (pointBx - pointAx) * normalx + (pointBy - pointAy) * normaly;
                        return separation;

                      case b2SeparationFunction.e_faceB:
                        var normalx = _local_xfB.q.c * this.m_axis.x - _local_xfB.q.s * this.m_axis.y;
                        var normaly = _local_xfB.q.s * this.m_axis.x + _local_xfB.q.c * this.m_axis.y;
                        var pointBx = _local_xfB.q.c * this.m_localPoint.x - _local_xfB.q.s * this.m_localPoint.y + _local_xfB.p.x;
                        var pointBy = _local_xfB.q.s * this.m_localPoint.x + _local_xfB.q.c * this.m_localPoint.y + _local_xfB.p.y;
                        var localPointA = this.m_proxyA.GetVertex(indexA);
                        var pointAx = _local_xfA.q.c * localPointA.x - _local_xfA.q.s * localPointA.y + _local_xfA.p.x;
                        var pointAy = _local_xfA.q.s * localPointA.x + _local_xfA.q.c * localPointA.y + _local_xfA.p.y;
                        var separation = (pointAx - pointBx) * normalx + (pointAy - pointBy) * normaly;
                        return separation;

                      default:
                        b2Assert(false);
                        return 0;
                    }
                }
            };
            b2SeparationFunction.e_points = 0;
            b2SeparationFunction.e_faceA = 1;
            b2SeparationFunction.e_faceB = 2;
            var profile_toi = b2Profiler.create("toi", "solveTOI");
            function b2TimeOfImpact(output, input) {
                profile_toi.start();
                ++b2TimeOfImpact.b2_toiCalls;
                output.state = b2TOIOutput.e_unknown;
                output.t = input.tMax;
                var proxyA = input.proxyA;
                var proxyB = input.proxyB;
                b2TimeOfImpact._temp_sweepA.Assign(input.sweepA);
                b2TimeOfImpact._temp_sweepB.Assign(input.sweepB);
                b2TimeOfImpact._temp_sweepA.Normalize();
                b2TimeOfImpact._temp_sweepB.Normalize();
                var tMax = input.tMax;
                var totalRadius = proxyA.m_radius + proxyB.m_radius;
                var target = b2Max(b2_linearSlop, totalRadius - 3 * b2_linearSlop);
                var tolerance = .25 * b2_linearSlop;
                b2Assert(target > tolerance);
                var t1 = 0;
                var k_maxIterations = 20;
                var iter = 0;
                var cache = new b2SimplexCache();
                cache.count = 0;
                var distanceInput = new b2DistanceInput();
                distanceInput.proxyA.Assign(input.proxyA);
                distanceInput.proxyB.Assign(input.proxyB);
                distanceInput.useRadii = false;
                for (;;) {
                    b2TimeOfImpact._temp_sweepA.GetTransform(distanceInput.transformA, t1);
                    b2TimeOfImpact._temp_sweepB.GetTransform(distanceInput.transformB, t1);
                    var distanceOutput = new b2DistanceOutput();
                    b2DistanceFunc(distanceOutput, cache, distanceInput);
                    if (distanceOutput.distance <= 0) {
                        output.state = b2TOIOutput.e_overlapped;
                        output.t = 0;
                        break;
                    }
                    if (distanceOutput.distance < target + tolerance) {
                        output.state = b2TOIOutput.e_touching;
                        output.t = t1;
                        break;
                    }
                    var fcn = new b2SeparationFunction();
                    fcn.Initialize(cache, proxyA, b2TimeOfImpact._temp_sweepA, proxyB, b2TimeOfImpact._temp_sweepB, t1);
                    var done = false;
                    var t2 = tMax;
                    var pushBackIter = 0;
                    for (;;) {
                        var indices = [];
                        var s2 = fcn.FindMinSeparation(indices, t2);
                        if (s2 > target + tolerance) {
                            output.state = b2TOIOutput.e_separated;
                            output.t = tMax;
                            done = true;
                            break;
                        }
                        if (s2 > target - tolerance) {
                            t1 = t2;
                            break;
                        }
                        var s1 = fcn.Evaluate(indices[0], indices[1], t1);
                        if (s1 < target - tolerance) {
                            output.state = b2TOIOutput.e_failed;
                            output.t = t1;
                            done = true;
                            break;
                        }
                        if (s1 <= target + tolerance) {
                            output.state = b2TOIOutput.e_touching;
                            output.t = t1;
                            done = true;
                            break;
                        }
                        var rootIterCount = 0;
                        var a1 = t1, a2 = t2;
                        for (;;) {
                            var t;
                            t = 1 & rootIterCount ? a1 + (target - s1) * (a2 - a1) / (s2 - s1) : .5 * (a1 + a2);
                            ++rootIterCount;
                            ++b2TimeOfImpact.b2_toiRootIters;
                            var s = fcn.Evaluate(indices[0], indices[1], t);
                            if (b2Abs(s - target) < tolerance) {
                                t2 = t;
                                break;
                            }
                            if (s > target) {
                                a1 = t;
                                s1 = s;
                            } else {
                                a2 = t;
                                s2 = s;
                            }
                            if (50 == rootIterCount) {
                                break;
                            }
                        }
                        b2TimeOfImpact.b2_toiMaxRootIters = b2Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
                        ++pushBackIter;
                        if (pushBackIter == b2_maxPolygonVertices) {
                            break;
                        }
                    }
                    ++iter;
                    ++b2TimeOfImpact.b2_toiIters;
                    if (done) {
                        break;
                    }
                    if (iter == k_maxIterations) {
                        output.state = b2TOIOutput.e_failed;
                        output.t = t1;
                        break;
                    }
                }
                b2TimeOfImpact.b2_toiMaxIters = b2Max(b2TimeOfImpact.b2_toiMaxIters, iter);
                profile_toi.stop();
                b2TimeOfImpact.b2_toiMaxTime = b2Max(b2TimeOfImpact.b2_toiMaxTime, profile_toi.elapsedTime);
                b2TimeOfImpact.b2_toiTime += profile_toi.elapsedTime;
            }
            b2TimeOfImpact._temp_sweepA = new b2Sweep();
            b2TimeOfImpact._temp_sweepB = new b2Sweep();
            b2TimeOfImpact.b2_toiTime = 0;
            b2TimeOfImpact.b2_toiMaxTime = 0;
            b2TimeOfImpact.b2_toiCalls = 0;
            b2TimeOfImpact.b2_toiIters = 0;
            b2TimeOfImpact.b2_toiMaxIters = 0;
            b2TimeOfImpact.b2_toiRootIters = 0;
            b2TimeOfImpact.b2_toiMaxRootIters = 0;
            function b2BodyDef() {
                this.type = b2Body.b2_staticBody;
                this.position = new b2Vec2(0, 0);
                this.angle = 0;
                this.linearVelocity = new b2Vec2(0, 0);
                this.angularVelocity = 0;
                this.linearDamping = 0;
                this.angularDamping = 0;
                this.allowSleep = true;
                this.awake = true;
                this.fixedRotation = false;
                this.bullet = false;
                this.active = true;
                this.userData = null;
                this.gravityScale = 1;
                Object.seal(this);
            }
            b2BodyDef.prototype = {
                _deserialize: function(data) {
                    this.type = data["type"];
                    this.position._deserialize(data["position"]);
                    this.angle = data["angle"];
                    this.linearVelocity._deserialize(data["linearVelocity"]);
                    this.angularVelocity = data["angularVelocity"];
                    this.linearDamping = data["linearDamping"];
                    this.angularDamping = data["angularDamping"];
                    this.allowSleep = data["allowSleep"];
                    this.awake = data["awake"];
                    this.fixedRotation = data["fixedRotation"];
                    this.bullet = data["bullet"];
                    this.active = data["active"];
                    this.gravityScale = data["gravityScale"];
                }
            };
            function b2Body(bd, world) {
                b2Assert(bd.position.IsValid());
                b2Assert(bd.linearVelocity.IsValid());
                b2Assert(b2IsValid(bd.angle));
                b2Assert(b2IsValid(bd.angularVelocity));
                b2Assert(b2IsValid(bd.angularDamping) && bd.angularDamping >= 0);
                b2Assert(b2IsValid(bd.linearDamping) && bd.linearDamping >= 0);
                this.m_islandIndex = 0;
                this.m_flags = 0;
                bd.bullet && (this.m_flags |= b2Body.e_bulletFlag);
                bd.fixedRotation && (this.m_flags |= b2Body.e_fixedRotationFlag);
                bd.allowSleep && (this.m_flags |= b2Body.e_autoSleepFlag);
                bd.awake && (this.m_flags |= b2Body.e_awakeFlag);
                bd.active && (this.m_flags |= b2Body.e_activeFlag);
                this.m_world = world;
                this.m_xf = new b2Transform();
                this.m_xf.p.Assign(bd.position);
                this.m_xf.q.Set(bd.angle);
                this.m_sweep = new b2Sweep();
                this.m_sweep.localCenter.SetZero();
                this.m_sweep.c0.Assign(this.m_xf.p);
                this.m_sweep.c.Assign(this.m_xf.p);
                this.m_sweep.a0 = bd.angle;
                this.m_sweep.a = bd.angle;
                this.m_sweep.alpha0 = 0;
                this.m_jointList = null;
                this.m_contactList = null;
                this.m_prev = null;
                this.m_next = null;
                this.m_linearVelocity = bd.linearVelocity.Clone();
                this.m_angularVelocity = bd.angularVelocity;
                this.m_linearDamping = bd.linearDamping;
                this.m_angularDamping = bd.angularDamping;
                this.m_gravityScale = bd.gravityScale;
                this.m_force = new b2Vec2();
                this.m_torque = 0;
                this.m_sleepTime = 0;
                this.m_type = bd.type;
                if (this.m_type == b2Body.b2_dynamicBody) {
                    this.m_mass = 1;
                    this.m_invMass = 1;
                } else {
                    this.m_mass = 0;
                    this.m_invMass = 0;
                }
                this.m_I = 0;
                this.m_invI = 0;
                this.m_userData = bd.userData;
                this.m_fixtureList = null;
                this.m_fixtureCount = 0;
            }
            b2Body.b2_staticBody = 0;
            b2Body.b2_kinematicBody = 1;
            b2Body.b2_dynamicBody = 2;
            b2Body.e_islandFlag = 1;
            b2Body.e_awakeFlag = 2;
            b2Body.e_autoSleepFlag = 4;
            b2Body.e_bulletFlag = 8;
            b2Body.e_fixedRotationFlag = 16;
            b2Body.e_activeFlag = 32;
            b2Body.e_toiFlag = 64;
            b2Body.m_local_oldCenter = new b2Vec2();
            b2Body.m_local_xf1 = new b2Transform();
            b2Body.prototype = {
                CreateFixture: function(def, density) {
                    if ("undefined" !== typeof density) {
                        var ndef = new b2FixtureDef();
                        ndef.shape = def;
                        ndef.density = density;
                        return this.CreateFixture(ndef);
                    }
                    b2Assert(false == this.m_world.IsLocked());
                    if (true == this.m_world.IsLocked()) {
                        return null;
                    }
                    var fixture = new b2Fixture();
                    fixture.Create(this, def);
                    if (this.m_flags & b2Body.e_activeFlag) {
                        var broadPhase = this.m_world.m_contactManager.m_broadPhase;
                        fixture.CreateProxies(broadPhase, this.m_xf);
                    }
                    fixture.m_next = this.m_fixtureList;
                    this.m_fixtureList = fixture;
                    ++this.m_fixtureCount;
                    fixture.m_body = this;
                    fixture.m_density > 0 && this.ResetMassData();
                    this.m_world.m_flags |= b2World.e_newFixture;
                    return fixture;
                },
                DestroyFixture: function(fixture) {
                    b2Assert(false == this.m_world.IsLocked());
                    if (true == this.m_world.IsLocked()) {
                        return;
                    }
                    b2Assert(fixture.m_body == this);
                    b2Assert(this.m_fixtureCount > 0);
                    var node = this.m_fixtureList;
                    var found = false;
                    while (null != node) {
                        if (node == fixture) {
                            this.m_fixtureList = node = fixture.m_next;
                            found = true;
                            break;
                        }
                        node = node.m_next;
                    }
                    b2Assert(found);
                    var edge = this.m_contactList;
                    while (edge) {
                        var c = edge.contact;
                        edge = edge.next;
                        var fixtureA = c.GetFixtureA();
                        var fixtureB = c.GetFixtureB();
                        fixture != fixtureA && fixture != fixtureB || this.m_world.m_contactManager.Destroy(c);
                    }
                    if (this.m_flags & b2Body.e_activeFlag) {
                        var broadPhase = this.m_world.m_contactManager.m_broadPhase;
                        fixture.DestroyProxies(broadPhase);
                    }
                    fixture.Destroy();
                    fixture.m_body = null;
                    fixture.m_next = null;
                    --this.m_fixtureCount;
                    this.ResetMassData();
                },
                SetTransform: function(position, angle) {
                    b2Assert(false == this.m_world.IsLocked());
                    if (true == this.m_world.IsLocked()) {
                        return;
                    }
                    this.m_xf.q.Set(angle);
                    this.m_xf.p.Assign(position);
                    this.m_sweep.c.Assign(b2Mul_t_v2(this.m_xf, this.m_sweep.localCenter));
                    this.m_sweep.a = angle;
                    this.m_sweep.c0.Assign(this.m_sweep.c);
                    this.m_sweep.a0 = angle;
                    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
                    for (var f = this.m_fixtureList; f; f = f.m_next) {
                        f.Synchronize(broadPhase, this.m_xf, this.m_xf);
                    }
                },
                GetTransform: function() {
                    return this.m_xf;
                },
                GetPosition: function() {
                    return this.m_xf.p;
                },
                GetAngle: function() {
                    return this.m_sweep.a;
                },
                GetWorldCenter: function() {
                    return this.m_sweep.c;
                },
                GetLocalCenter: function() {
                    return this.m_sweep.localCenter;
                },
                SetLinearVelocity: function(v) {
                    if (this.m_type == b2Body.b2_staticBody) {
                        return;
                    }
                    b2Dot_v2_v2(v, v) > 0 && this.SetAwake(true);
                    this.m_linearVelocity = v;
                },
                GetLinearVelocity: function() {
                    return this.m_linearVelocity;
                },
                SetAngularVelocity: function(w) {
                    if (this.m_type == b2Body.b2_staticBody) {
                        return;
                    }
                    w * w > 0 && this.SetAwake(true);
                    this.m_angularVelocity = w;
                },
                GetAngularVelocity: function() {
                    return this.m_angularVelocity;
                },
                ApplyForce: function(force, point, wake) {
                    if (this.m_type != b2Body.b2_dynamicBody) {
                        return;
                    }
                    wake && 0 == (this.m_flags & b2Body.e_awakeFlag) && this.SetAwake(true);
                    if (this.m_flags & b2Body.e_awakeFlag) {
                        this.m_force.Add(force);
                        this.m_torque += b2Cross_v2_v2(b2Vec2.Subtract(point, this.m_sweep.c), force);
                    }
                },
                ApplyForceToCenter: function(force, wake) {
                    if (this.m_type != b2Body.b2_dynamicBody) {
                        return;
                    }
                    wake && 0 == (this.m_flags & b2Body.e_awakeFlag) && this.SetAwake(true);
                    this.m_flags & b2Body.e_awakeFlag && this.m_force.Add(force);
                },
                ApplyTorque: function(torque, wake) {
                    if (this.m_type != b2Body.b2_dynamicBody) {
                        return;
                    }
                    wake && 0 == (this.m_flags & b2Body.e_awakeFlag) && this.SetAwake(true);
                    this.m_flags & b2Body.e_awakeFlag && (this.m_torque += torque);
                },
                ApplyLinearImpulse: function(impulse, point, wake) {
                    if (this.m_type != b2Body.b2_dynamicBody) {
                        return;
                    }
                    wake && 0 == (this.m_flags & b2Body.e_awakeFlag) && this.SetAwake(true);
                    if (this.m_flags & b2Body.e_awakeFlag) {
                        this.m_linearVelocity.Add(b2Vec2.Multiply(this.m_invMass, impulse));
                        this.m_angularVelocity += this.m_invI * b2Cross_v2_v2(b2Vec2.Subtract(point, this.m_sweep.c), impulse);
                    }
                },
                ApplyAngularImpulse: function(impulse, wake) {
                    if (this.m_type != b2Body.b2_dynamicBody) {
                        return;
                    }
                    wake && 0 == (this.m_flags & b2Body.e_awakeFlag) && this.SetAwake(true);
                    this.m_flags & b2Body.e_awakeFlag && (this.m_angularVelocity += this.m_invI * impulse);
                },
                GetMass: function() {
                    return this.m_mass;
                },
                GetInertia: function() {
                    return this.m_I + this.m_mass * b2Dot_v2_v2(this.m_sweep.localCenter, this.m_sweep.localCenter);
                },
                GetMassData: function(data) {
                    data.mass = this.m_mass;
                    data.I = this.m_I + this.m_mass * b2Dot_v2_v2(this.m_sweep.localCenter, this.m_sweep.localCenter);
                    data.center = this.m_sweep.localCenter;
                },
                SetMassData: function(massData) {
                    b2Assert(false == this.m_world.IsLocked());
                    if (true == this.m_world.IsLocked()) {
                        return;
                    }
                    if (this.m_type != b2Body.b2_dynamicBody) {
                        return;
                    }
                    this.m_invMass = 0;
                    this.m_I = 0;
                    this.m_invI = 0;
                    this.m_mass = massData.mass;
                    this.m_mass <= 0 && (this.m_mass = 1);
                    this.m_invMass = 1 / this.m_mass;
                    if (massData.I > 0 && 0 == (this.m_flags & b2Body.e_fixedRotationFlag)) {
                        this.m_I = massData.I - this.m_mass * b2Dot_v2_v2(massData.center, massData.center);
                        b2Assert(this.m_I > 0);
                        this.m_invI = 1 / this.m_I;
                    }
                    b2Body.m_local_oldCenter.Assign(this.m_sweep.c);
                    this.m_sweep.localCenter.Assign(massData.center);
                    this.m_sweep.c0.Assign(b2Mul_t_v2(this.m_xf, this.m_sweep.localCenter));
                    this.m_sweep.c.Assign(this.m_sweep.c0);
                    this.m_linearVelocity.Add(b2Cross_f_v2(this.m_angularVelocity, b2Vec2.Subtract(this.m_sweep.c, b2Body.m_local_oldCenter)));
                },
                ResetMassData: function() {
                    this.m_mass = 0;
                    this.m_invMass = 0;
                    this.m_I = 0;
                    this.m_invI = 0;
                    this.m_sweep.localCenter.SetZero();
                    if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
                        this.m_sweep.c0.Assign(this.m_xf.p);
                        this.m_sweep.c.Assign(this.m_xf.p);
                        this.m_sweep.a0 = this.m_sweep.a;
                        return;
                    }
                    b2Assert(this.m_type == b2Body.b2_dynamicBody);
                    var localCenter = new b2Vec2(0, 0);
                    for (var f = this.m_fixtureList; f; f = f.m_next) {
                        if (0 == f.m_density) {
                            continue;
                        }
                        var massData = new b2MassData();
                        f.GetMassData(massData);
                        this.m_mass += massData.mass;
                        localCenter.Add(b2Vec2.Multiply(massData.mass, massData.center));
                        this.m_I += massData.I;
                    }
                    if (this.m_mass > 0) {
                        this.m_invMass = 1 / this.m_mass;
                        localCenter.Multiply(this.m_invMass);
                    } else {
                        this.m_mass = 1;
                        this.m_invMass = 1;
                    }
                    if (this.m_I > 0 && 0 == (this.m_flags & b2Body.e_fixedRotationFlag)) {
                        this.m_I -= this.m_mass * b2Dot_v2_v2(localCenter, localCenter);
                        b2Assert(this.m_I > 0);
                        this.m_invI = 1 / this.m_I;
                    } else {
                        this.m_I = 0;
                        this.m_invI = 0;
                    }
                    b2Body.m_local_oldCenter.Assign(this.m_sweep.c);
                    this.m_sweep.localCenter.Assign(localCenter);
                    this.m_sweep.c0.Assign(b2Mul_t_v2(this.m_xf, this.m_sweep.localCenter));
                    this.m_sweep.c.Assign(this.m_sweep.c0);
                    this.m_linearVelocity.Add(b2Cross_f_v2(this.m_angularVelocity, b2Vec2.Subtract(this.m_sweep.c, b2Body.m_local_oldCenter)));
                },
                GetWorldPoint: function(localPoint) {
                    return b2Mul_t_v2(this.m_xf, localPoint);
                },
                GetWorldVector: function(localVector) {
                    return b2Mul_r_v2(this.m_xf.q, localVector);
                },
                GetLocalPoint: function(worldPoint) {
                    return b2MulT_t_v2(this.m_xf, worldPoint);
                },
                GetLocalVector: function(worldVector) {
                    return b2MulT_r_v2(this.m_xf.q, worldVector);
                },
                GetLinearVelocityFromWorldPoint: function(worldPoint) {
                    return b2Vec2.Add(this.m_linearVelocity, b2Cross_f_v2(this.m_angularVelocity, b2Vec2.Subtract(worldPoint, this.m_sweep.c)));
                },
                GetLinearVelocityFromLocalPoint: function(localPoint) {
                    return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(localPoint));
                },
                GetLinearDamping: function() {
                    return this.m_linearDamping;
                },
                SetLinearDamping: function(linearDamping) {
                    this.m_linearDamping = linearDamping;
                },
                GetAngularDamping: function() {
                    return this.m_angularDamping;
                },
                SetAngularDamping: function(angularDamping) {
                    this.m_angularDamping = angularDamping;
                },
                GetGravityScale: function() {
                    return this.m_gravityScale;
                },
                SetGravityScale: function(scale) {
                    this.m_gravityScale = scale;
                },
                SetType: function(type) {
                    b2Assert(false == this.m_world.IsLocked());
                    if (true == this.m_world.IsLocked()) {
                        return;
                    }
                    if (this.m_type == type) {
                        return;
                    }
                    this.m_type = type;
                    this.ResetMassData();
                    if (this.m_type == b2Body.b2_staticBody) {
                        this.m_linearVelocity.SetZero();
                        this.m_angularVelocity = 0;
                        this.m_sweep.a0 = this.m_sweep.a;
                        this.m_sweep.c0.Assign(this.m_sweep.c);
                        this.SynchronizeFixtures();
                    }
                    this.SetAwake(true);
                    this.m_force.SetZero();
                    this.m_torque = 0;
                    var ce = this.m_contactList;
                    while (ce) {
                        var ce0 = ce;
                        ce = ce.next;
                        this.m_world.m_contactManager.Destroy(ce0.contact);
                    }
                    this.m_contactList = null;
                    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
                    for (var f = this.m_fixtureList; f; f = f.m_next) {
                        var proxyCount = f.m_proxyCount;
                        for (var i = 0; i < proxyCount; ++i) {
                            broadPhase.TouchProxy(f.m_proxies[i].proxyId);
                        }
                    }
                },
                GetType: function() {
                    return this.m_type;
                },
                SetBullet: function(flag) {
                    flag ? this.m_flags |= b2Body.e_bulletFlag : this.m_flags &= ~b2Body.e_bulletFlag;
                },
                IsBullet: function() {
                    return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
                },
                SetSleepingAllowed: function(flag) {
                    if (flag) {
                        this.m_flags |= b2Body.e_autoSleepFlag;
                    } else {
                        this.m_flags &= ~b2Body.e_autoSleepFlag;
                        this.SetAwake(true);
                    }
                },
                IsSleepingAllowed: function() {
                    return (this.m_flags & b2Body.e_autoSleepFlag) == b2Body.e_autoSleepFlag;
                },
                SetAwake: function(flag) {
                    if (flag) {
                        if (0 == (this.m_flags & b2Body.e_awakeFlag)) {
                            this.m_flags |= b2Body.e_awakeFlag;
                            this.m_sleepTime = 0;
                        }
                    } else {
                        this.m_flags &= ~b2Body.e_awakeFlag;
                        this.m_sleepTime = 0;
                        this.m_linearVelocity.SetZero();
                        this.m_angularVelocity = 0;
                        this.m_force.SetZero();
                        this.m_torque = 0;
                    }
                },
                IsAwake: function() {
                    return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
                },
                SetActive: function(flag) {
                    b2Assert(false == this.m_world.IsLocked());
                    if (flag == this.IsActive()) {
                        return;
                    }
                    if (flag) {
                        this.m_flags |= b2Body.e_activeFlag;
                        var broadPhase = this.m_world.m_contactManager.m_broadPhase;
                        for (var f = this.m_fixtureList; f; f = f.m_next) {
                            f.CreateProxies(broadPhase, this.m_xf);
                        }
                    } else {
                        this.m_flags &= ~b2Body.e_activeFlag;
                        var broadPhase = this.m_world.m_contactManager.m_broadPhase;
                        for (var f = this.m_fixtureList; f; f = f.m_next) {
                            f.DestroyProxies(broadPhase);
                        }
                        var ce = this.m_contactList;
                        while (ce) {
                            var ce0 = ce;
                            ce = ce.next;
                            this.m_world.m_contactManager.Destroy(ce0.contact);
                        }
                        this.m_contactList = null;
                    }
                },
                IsActive: function() {
                    return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
                },
                SetFixedRotation: function(flag) {
                    var status = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
                    if (status == flag) {
                        return;
                    }
                    flag ? this.m_flags |= b2Body.e_fixedRotationFlag : this.m_flags &= ~b2Body.e_fixedRotationFlag;
                    this.m_angularVelocity = 0;
                    this.ResetMassData();
                },
                IsFixedRotation: function() {
                    return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
                },
                GetFixtureList: function() {
                    return this.m_fixtureList;
                },
                GetJointList: function() {
                    return this.m_jointList;
                },
                GetContactList: function() {
                    return this.m_contactList;
                },
                GetNext: function() {
                    return this.m_next;
                },
                GetUserData: function() {
                    return this.m_userData;
                },
                SetUserData: function(data) {
                    this.m_userData = data;
                },
                GetWorld: function() {
                    return this.m_world;
                },
                SynchronizeFixtures: function() {
                    b2Body.m_local_xf1.q.Set(this.m_sweep.a0);
                    b2Body.m_local_xf1.p.Assign(b2Vec2.Subtract(this.m_sweep.c0, b2Mul_r_v2(b2Body.m_local_xf1.q, this.m_sweep.localCenter)));
                    var broadPhase = this.m_world.m_contactManager.m_broadPhase;
                    for (var f = this.m_fixtureList; f; f = f.m_next) {
                        f.Synchronize(broadPhase, b2Body.m_local_xf1, this.m_xf);
                    }
                },
                SynchronizeTransform: function() {
                    this.m_xf.q.Set(this.m_sweep.a);
                    this.m_xf.p.Assign(b2Vec2.Subtract(this.m_sweep.c, b2Mul_r_v2(this.m_xf.q, this.m_sweep.localCenter)));
                },
                ShouldCollide: function(other) {
                    if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
                        return false;
                    }
                    for (var jn = this.m_jointList; jn; jn = jn.next) {
                        if (jn.other == other && false == jn.joint.m_collideConnected) {
                            return false;
                        }
                    }
                    return true;
                },
                Advance: function(alpha) {
                    this.m_sweep.Advance(alpha);
                    this.m_sweep.c.Assign(this.m_sweep.c0);
                    this.m_sweep.a = this.m_sweep.a0;
                    this.m_xf.q.Set(this.m_sweep.a);
                    this.m_xf.p.Assign(b2Vec2.Subtract(this.m_sweep.c, b2Mul_r_v2(this.m_xf.q, this.m_sweep.localCenter)));
                },
                _serialize: function(out) {
                    var obj = out || {};
                    obj["fixtures"] = null;
                    obj["type"] = this.m_type;
                    obj["position"] = this.GetPosition()._serialize();
                    obj["angle"] = this.GetAngle();
                    obj["linearVelocity"] = this.GetLinearVelocity()._serialize();
                    obj["angularVelocity"] = this.GetAngularVelocity();
                    obj["linearDamping"] = this.GetLinearDamping();
                    obj["angularDamping"] = this.GetAngularDamping();
                    obj["allowSleep"] = this.IsSleepingAllowed();
                    obj["awake"] = this.IsAwake();
                    obj["fixedRotation"] = this.IsFixedRotation();
                    obj["bullet"] = this.IsBullet();
                    obj["active"] = this.IsActive();
                    obj["gravityScale"] = this.GetGravityScale();
                    return obj;
                }
            };
            function b2Filter() {
                this.categoryBits = 1;
                this.maskBits = 65535;
                this.groupIndex = 0;
            }
            b2Filter.prototype = {
                Clone: function() {
                    var filter = new b2Filter();
                    filter.categoryBits = this.categoryBits;
                    filter.maskBits = this.maskBits;
                    filter.groupIndex = this.groupIndex;
                    return filter;
                },
                Assign: function(filter) {
                    this.categoryBits = filter.categoryBits;
                    this.maskBits = filter.maskBits;
                    this.groupIndex = filter.groupIndex;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    obj["categoryBits"] = this.categoryBits;
                    obj["maskBits"] = this.maskBits;
                    obj["groupIndex"] = this.groupIndex;
                    return obj;
                },
                _deserialize: function(data) {
                    this.categoryBits = data["categoryBits"];
                    this.maskBits = data["maskBits"];
                    this.groupIndex = data["groupIndex"];
                }
            };
            function b2FixtureDef() {
                this.shape = null;
                this.userData = null;
                this.friction = .2;
                this.restitution = 0;
                this.density = 0;
                this.isSensor = false;
                this.filter = new b2Filter();
                Object.seal(this);
            }
            b2FixtureDef.prototype = {
                _deserialize: function(data) {
                    this.friction = data["friction"];
                    this.restitution = data["restitution"];
                    this.density = data["density"];
                    this.isSensor = data["isSensor"];
                    this.filter._deserialize(data["filter"]);
                }
            };
            function b2FixtureProxy() {
                this.aabb = new b2AABB();
                this.fixture = null;
                this.childIndex = 0;
                this.proxyId = 0;
            }
            function b2Fixture() {
                this.m_userData = null;
                this.m_body = null;
                this.m_next = null;
                this.m_proxies = null;
                this.m_proxyCount = 0;
                this.m_shape = null;
                this.m_density = 0;
                this.m_filter = new b2Filter();
                this.m_isSensor = false;
                this.m_friction = 0;
                this.m_restitution = 0;
            }
            b2Fixture.prototype = {
                GetType: function() {
                    return this.m_shape.GetType();
                },
                GetShape: function() {
                    return this.m_shape;
                },
                SetSensor: function(sensor) {
                    if (sensor != this.m_isSensor) {
                        this.m_body.SetAwake(true);
                        this.m_isSensor = sensor;
                    }
                },
                IsSensor: function() {
                    return this.m_isSensor;
                },
                SetFilterData: function(filter) {
                    this.m_filter = filter;
                    this.Refilter();
                },
                GetFilterData: function() {
                    return this.m_filter;
                },
                Refilter: function() {
                    if (null == this.m_body) {
                        return;
                    }
                    var edge = this.m_body.GetContactList();
                    while (edge) {
                        var contact = edge.contact;
                        var fixtureA = contact.GetFixtureA();
                        var fixtureB = contact.GetFixtureB();
                        fixtureA != this && fixtureB != this || contact.FlagForFiltering();
                        edge = edge.next;
                    }
                    var world = this.m_body.GetWorld();
                    if (null == world) {
                        return;
                    }
                    var broadPhase = world.m_contactManager.m_broadPhase;
                    for (var i = 0; i < this.m_proxyCount; ++i) {
                        broadPhase.TouchProxy(this.m_proxies[i].proxyId);
                    }
                },
                GetBody: function() {
                    return this.m_body;
                },
                GetNext: function() {
                    return this.m_next;
                },
                GetUserData: function() {
                    return this.m_userData;
                },
                SetUserData: function(data) {
                    this.m_userData = data;
                },
                TestPoint: function(p) {
                    return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
                },
                RayCast: function(output, input, childIndex) {
                    return this.m_shape.RayCast(output, input, this.m_body.GetTransform(), childIndex);
                },
                GetMassData: function(massData) {
                    this.m_shape.ComputeMass(massData, this.m_density);
                },
                SetDensity: function(density) {
                    b2Assert(b2IsValid(density) && density >= 0);
                    this.m_density = density;
                },
                GetDensity: function() {
                    return this.m_density;
                },
                GetFriction: function() {
                    return this.m_friction;
                },
                SetFriction: function(friction) {
                    this.m_friction = friction;
                },
                GetRestitution: function() {
                    return this.m_restitution;
                },
                SetRestitution: function(restitution) {
                    this.m_restitution = restitution;
                },
                GetAABB: function(childIndex) {
                    b2Assert(0 <= childIndex && childIndex < this.m_proxyCount);
                    return this.m_proxies[childIndex].aabb;
                },
                Create: function(body, def) {
                    this.m_userData = def.userData;
                    this.m_friction = def.friction;
                    this.m_restitution = def.restitution;
                    this.m_body = body;
                    this.m_next = null;
                    this.m_filter.Assign(def.filter);
                    this.m_isSensor = def.isSensor;
                    this.m_shape = def.shape.Clone();
                    var childCount = this.m_shape.GetChildCount();
                    this.m_proxies = new Array(childCount);
                    for (var i = 0; i < childCount; ++i) {
                        this.m_proxies[i] = new b2FixtureProxy();
                        this.m_proxies[i].fixture = null;
                        this.m_proxies[i].proxyId = b2BroadPhase.e_nullProxy;
                    }
                    this.m_proxyCount = 0;
                    this.m_density = def.density;
                },
                Destroy: function() {
                    b2Assert(0 == this.m_proxyCount);
                    this.m_proxies = null;
                    this.m_shape = null;
                },
                CreateProxies: function(broadPhase, xf) {
                    b2Assert(0 == this.m_proxyCount);
                    this.m_proxyCount = this.m_shape.GetChildCount();
                    for (var i = 0; i < this.m_proxyCount; ++i) {
                        var proxy = this.m_proxies[i];
                        this.m_shape.ComputeAABB(proxy.aabb, xf, i);
                        proxy.proxyId = broadPhase.CreateProxy(proxy.aabb, proxy);
                        proxy.fixture = this;
                        proxy.childIndex = i;
                    }
                },
                DestroyProxies: function(broadPhase) {
                    for (var i = 0; i < this.m_proxyCount; ++i) {
                        var proxy = this.m_proxies[i];
                        broadPhase.DestroyProxy(proxy.proxyId);
                        proxy.proxyId = b2BroadPhase.e_nullProxy;
                    }
                    this.m_proxyCount = 0;
                },
                Synchronize: function(broadPhase, transform1, transform2) {
                    if (0 == this.m_proxyCount) {
                        return;
                    }
                    for (var i = 0; i < this.m_proxyCount; ++i) {
                        var proxy = this.m_proxies[i];
                        var aabb1 = new b2AABB(), aabb2 = new b2AABB();
                        this.m_shape.ComputeAABB(aabb1, transform1, proxy.childIndex);
                        this.m_shape.ComputeAABB(aabb2, transform2, proxy.childIndex);
                        proxy.aabb.Combine(aabb1, aabb2);
                        var displacement = b2Vec2.Subtract(transform2.p, transform1.p);
                        broadPhase.MoveProxy(proxy.proxyId, proxy.aabb, displacement);
                    }
                },
                _serialize: function(out) {
                    var obj = out || {};
                    obj["shape"] = null;
                    obj["friction"] = this.m_friction;
                    obj["restitution"] = this.m_restitution;
                    obj["density"] = this.m_density;
                    obj["isSensor"] = this.m_isSensor;
                    obj["filter"] = this.m_filter._serialize();
                    return obj;
                }
            };
            function b2DestructionListener() {}
            b2DestructionListener.prototype = {
                SayGoodbyeJoint: function(joint) {},
                SayGoodbyeFixture: function(fixture) {}
            };
            function b2ContactFilter() {}
            b2ContactFilter.prototype = {
                ShouldCollide: function(fixtureA, fixtureB) {
                    var filterA = fixtureA.GetFilterData();
                    var filterB = fixtureB.GetFilterData();
                    if (filterA.groupIndex == filterB.groupIndex && 0 != filterA.groupIndex) {
                        return filterA.groupIndex > 0;
                    }
                    var collide = 0 != (filterA.maskBits & filterB.categoryBits) && 0 != (filterA.categoryBits & filterB.maskBits);
                    return collide;
                }
            };
            function b2ContactImpulse() {
                this.normalImpulses = new Array(b2_maxManifoldPoints);
                this.tangentImpulses = new Array(b2_maxManifoldPoints);
                this.count = 0;
            }
            function b2ContactListener() {}
            b2ContactListener.prototype = {
                BeginContact: function(contact) {},
                EndContact: function(contact) {},
                PreSolve: function(contact, oldManifold) {},
                PostSolve: function(contact, impulse) {}
            };
            function b2QueryCallback() {}
            b2QueryCallback.prototype = {
                ReportFixture: function(fixture) {
                    return false;
                }
            };
            function b2RayCastCallback() {}
            b2RayCastCallback.prototype = {
                ReportFixture: function(fixture, point, normal, fraction) {}
            };
            function b2TimeStep() {
                this.dt = 0;
                this.inv_dt = 0;
                this.dtRatio = 0;
                this.velocityIterations = 0;
                this.positionIterations = 0;
                this.warmStarting = false;
            }
            function b2Position() {
                this.c = new b2Vec2();
                this.a = 0;
            }
            function b2Velocity() {
                this.v = new b2Vec2();
                this.w = 0;
            }
            function b2SolverData() {
                this.step = new b2TimeStep();
                this.positions = null;
                this.velocities = null;
            }
            var profile_world_step = b2Profiler.create("step");
            var profile_world_collide = b2Profiler.create("collide", "step");
            var profile_world_solve = b2Profiler.create("solve", "step");
            var profile_world_solveTOI = b2Profiler.create("solveTOI", "step");
            var profile_world_broadphase = b2Profiler.create("broadphase", "step");
            function b2World(gravity) {
                this.m_contactManager = new b2ContactManager();
                this.m_destructionListener = null;
                this.g_debugDraw = null;
                this.m_bodyList = null;
                this.m_jointList = null;
                this.m_bodyCount = 0;
                this.m_jointCount = 0;
                this.m_warmStarting = true;
                this.m_continuousPhysics = true;
                this.m_subStepping = false;
                this.m_stepComplete = true;
                this.m_allowSleep = true;
                this.m_gravity = gravity;
                this.m_flags = b2World.e_clearForces;
                this.m_inv_dt0 = 0;
                this.p_step = new b2TimeStep();
                this.p_island = new b2Island();
            }
            function b2WorldQueryWrapper() {
                this.broadPhase = null;
                this.callback = null;
            }
            b2WorldQueryWrapper.prototype = {
                QueryCallback: function(proxyId) {
                    var proxy = this.broadPhase.GetUserData(proxyId);
                    return this.callback.ReportFixture(proxy.fixture);
                }
            };
            function b2WorldRayCastWrapper() {
                this.broadPhase = null;
                this.callback = null;
            }
            b2WorldRayCastWrapper.prototype = {
                RayCastCallback: function(input, proxyId) {
                    var userData = this.broadPhase.GetUserData(proxyId);
                    var proxy = userData;
                    var fixture = proxy.fixture;
                    var index = proxy.childIndex;
                    var output = new b2RayCastOutput();
                    var hit = fixture.RayCast(output, input, index);
                    if (hit) {
                        var fraction = output.fraction;
                        var point = b2Vec2.Add(b2Vec2.Multiply(1 - fraction, input.p1), b2Vec2.Multiply(fraction, input.p2));
                        return this.callback.ReportFixture(fixture, point, output.normal, fraction);
                    }
                    return input.maxFraction;
                }
            };
            b2World.m_local_sweep_backupA = new b2Sweep();
            b2World.m_local_sweep_backupB = new b2Sweep();
            b2World.m_local_sweep_backupC = new b2Sweep();
            b2World.prototype = {
                Destroy: function() {
                    var b = this.m_bodyList;
                    while (b) {
                        var bNext = b.m_next;
                        var f = b.m_fixtureList;
                        while (f) {
                            var fNext = f.m_next;
                            f.m_proxyCount = 0;
                            f.Destroy();
                            f = fNext;
                        }
                        b = bNext;
                    }
                },
                SetDestructionListener: function(listener) {
                    this.m_destructionListener = listener;
                },
                SetContactFilter: function(filter) {
                    this.m_contactManager.m_contactFilter = filter;
                },
                SetContactListener: function(listener) {
                    this.m_contactManager.m_contactListener = listener;
                },
                SetDebugDraw: function(debugDraw) {
                    this.g_debugDraw = debugDraw;
                },
                CreateBody: function(def) {
                    b2Assert(false == this.IsLocked());
                    if (this.IsLocked()) {
                        return null;
                    }
                    var b = new b2Body(def, this);
                    b.m_prev = null;
                    b.m_next = this.m_bodyList;
                    this.m_bodyList && (this.m_bodyList.m_prev = b);
                    this.m_bodyList = b;
                    ++this.m_bodyCount;
                    return b;
                },
                DestroyBody: function(b) {
                    b2Assert(this.m_bodyCount > 0);
                    b2Assert(false == this.IsLocked());
                    if (this.IsLocked()) {
                        return;
                    }
                    var je = b.m_jointList;
                    while (je) {
                        var je0 = je;
                        je = je.next;
                        this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(je0.joint);
                        this.DestroyJoint(je0.joint);
                        b.m_jointList = je;
                    }
                    b.m_jointList = null;
                    var ce = b.m_contactList;
                    while (ce) {
                        var ce0 = ce;
                        ce = ce.next;
                        this.m_contactManager.Destroy(ce0.contact);
                    }
                    b.m_contactList = null;
                    var f = b.m_fixtureList;
                    while (f) {
                        var f0 = f;
                        f = f.m_next;
                        this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(f0);
                        f0.DestroyProxies(this.m_contactManager.m_broadPhase);
                        f0.Destroy();
                        b.m_fixtureList = f;
                        b.m_fixtureCount -= 1;
                    }
                    b.m_fixtureList = null;
                    b.m_fixtureCount = 0;
                    b.m_prev && (b.m_prev.m_next = b.m_next);
                    b.m_next && (b.m_next.m_prev = b.m_prev);
                    b == this.m_bodyList && (this.m_bodyList = b.m_next);
                    b.m_destroyed = true;
                    --this.m_bodyCount;
                },
                CreateJoint: function(def) {
                    b2Assert(false == this.IsLocked());
                    if (this.IsLocked()) {
                        return null;
                    }
                    var j = b2Joint.Create(def);
                    j.m_prev = null;
                    j.m_next = this.m_jointList;
                    this.m_jointList && (this.m_jointList.m_prev = j);
                    this.m_jointList = j;
                    ++this.m_jointCount;
                    j.m_edgeA.joint = j;
                    j.m_edgeA.other = j.m_bodyB;
                    j.m_edgeA.prev = null;
                    j.m_edgeA.next = j.m_bodyA.m_jointList;
                    j.m_bodyA.m_jointList && (j.m_bodyA.m_jointList.prev = j.m_edgeA);
                    j.m_bodyA.m_jointList = j.m_edgeA;
                    j.m_edgeB.joint = j;
                    j.m_edgeB.other = j.m_bodyA;
                    j.m_edgeB.prev = null;
                    j.m_edgeB.next = j.m_bodyB.m_jointList;
                    j.m_bodyB.m_jointList && (j.m_bodyB.m_jointList.prev = j.m_edgeB);
                    j.m_bodyB.m_jointList = j.m_edgeB;
                    var bodyA = def.bodyA;
                    var bodyB = def.bodyB;
                    if (false == def.collideConnected) {
                        var edge = bodyB.GetContactList();
                        while (edge) {
                            edge.other == bodyA && edge.contact.FlagForFiltering();
                            edge = edge.next;
                        }
                    }
                    return j;
                },
                DestroyJoint: function(j) {
                    b2Assert(false == this.IsLocked());
                    if (this.IsLocked()) {
                        return;
                    }
                    var collideConnected = j.m_collideConnected;
                    j.m_prev && (j.m_prev.m_next = j.m_next);
                    j.m_next && (j.m_next.m_prev = j.m_prev);
                    j == this.m_jointList && (this.m_jointList = j.m_next);
                    var bodyA = j.m_bodyA;
                    var bodyB = j.m_bodyB;
                    bodyA.SetAwake(true);
                    bodyB.SetAwake(true);
                    j.m_edgeA.prev && (j.m_edgeA.prev.next = j.m_edgeA.next);
                    j.m_edgeA.next && (j.m_edgeA.next.prev = j.m_edgeA.prev);
                    j.m_edgeA == bodyA.m_jointList && (bodyA.m_jointList = j.m_edgeA.next);
                    j.m_edgeA.prev = null;
                    j.m_edgeA.next = null;
                    j.m_edgeB.prev && (j.m_edgeB.prev.next = j.m_edgeB.next);
                    j.m_edgeB.next && (j.m_edgeB.next.prev = j.m_edgeB.prev);
                    j.m_edgeB == bodyB.m_jointList && (bodyB.m_jointList = j.m_edgeB.next);
                    j.m_edgeB.prev = null;
                    j.m_edgeB.next = null;
                    b2Joint.Destroy(j);
                    b2Assert(this.m_jointCount > 0);
                    --this.m_jointCount;
                    if (false == collideConnected) {
                        var edge = bodyB.GetContactList();
                        while (edge) {
                            edge.other == bodyA && edge.contact.FlagForFiltering();
                            edge = edge.next;
                        }
                    }
                },
                Step: function(dt, velocityIterations, positionIterations) {
                    profile_world_step.start();
                    if (this.m_flags & b2World.e_newFixture) {
                        this.m_contactManager.FindNewContacts();
                        this.m_flags &= ~b2World.e_newFixture;
                    }
                    this.m_flags |= b2World.e_locked;
                    this.p_step.dt = dt;
                    this.p_step.velocityIterations = velocityIterations;
                    this.p_step.positionIterations = positionIterations;
                    dt > 0 ? this.p_step.inv_dt = 1 / dt : this.p_step.inv_dt = 0;
                    this.p_step.dtRatio = this.m_inv_dt0 * dt;
                    this.p_step.warmStarting = this.m_warmStarting;
                    profile_world_collide.start();
                    this.m_contactManager.Collide();
                    profile_world_collide.stop();
                    if (this.m_stepComplete && this.p_step.dt > 0) {
                        profile_world_solve.start();
                        this.Solve(this.p_step);
                        profile_world_solve.stop();
                    }
                    if (this.m_continuousPhysics && this.p_step.dt > 0) {
                        profile_world_solveTOI.start();
                        this.SolveTOI(this.p_step);
                        profile_world_solveTOI.stop();
                    }
                    this.p_step.dt > 0 && (this.m_inv_dt0 = this.p_step.inv_dt);
                    this.m_flags & b2World.e_clearForces && this.ClearForces();
                    this.m_flags &= ~b2World.e_locked;
                    profile_world_step.stop();
                },
                ClearForces: function() {
                    for (var body = this.m_bodyList; body; body = body.GetNext()) {
                        body.m_force.x = body.m_force.y = 0;
                        body.m_torque = 0;
                    }
                },
                DrawDebugData: function() {
                    if (null == this.g_debugDraw) {
                        return;
                    }
                    this.g_debugDraw.ClearDraw();
                    var flags = this.g_debugDraw.GetFlags();
                    if (flags & b2Draw.e_shapeBit) {
                        for (var b = this.m_bodyList; b; b = b.GetNext()) {
                            var xf = b.GetTransform();
                            for (var f = b.GetFixtureList(); f; f = f.GetNext()) {
                                false == b.IsActive() ? this.DrawShape(f, xf, new b2Color(.5, .5, .3)) : b.GetType() == b2Body.b2_staticBody ? this.DrawShape(f, xf, new b2Color(.5, .9, .5)) : b.GetType() == b2Body.b2_kinematicBody ? this.DrawShape(f, xf, new b2Color(.5, .5, .9)) : false == b.IsAwake() ? this.DrawShape(f, xf, new b2Color(.6, .6, .6)) : this.DrawShape(f, xf, new b2Color(.9, .7, .7));
                            }
                        }
                    }
                    if (flags & b2Draw.e_jointBit) {
                        for (var j = this.m_jointList; j; j = j.GetNext()) {
                            this.DrawJoint(j);
                        }
                    }
                    if (flags & b2Draw.e_pairBit) {
                        var color = new b2Color(.3, .9, .9);
                        for (var c = this.m_contactManager.m_contactList; c; c = c.GetNext()) {
                            var fixtureA = c.GetFixtureA();
                            var fixtureB = c.GetFixtureB();
                            var cA = fixtureA.GetAABB(c.GetChildIndexA()).GetCenter();
                            var cB = fixtureB.GetAABB(c.GetChildIndexB()).GetCenter();
                            this.g_debugDraw.DrawSegment(cA, cB, color);
                        }
                    }
                    if (flags & b2Draw.e_aabbBit) {
                        var color = new b2Color(.9, .3, .9);
                        var color2 = new b2Color(.3, .3, .9);
                        var bp = this.m_contactManager.m_broadPhase;
                        for (var b = this.m_bodyList; b; b = b.GetNext()) {
                            if (false == b.IsActive()) {
                                continue;
                            }
                            for (var f = b.GetFixtureList(); f; f = f.GetNext()) {
                                for (var i = 0; i < f.m_proxyCount; ++i) {
                                    var proxy = f.m_proxies[i];
                                    var aabb = bp.GetFatAABB(proxy.proxyId);
                                    var vs = [];
                                    vs[0] = new b2Vec2(aabb.lowerBound.x, aabb.lowerBound.y);
                                    vs[1] = new b2Vec2(aabb.upperBound.x, aabb.lowerBound.y);
                                    vs[2] = new b2Vec2(aabb.upperBound.x, aabb.upperBound.y);
                                    vs[3] = new b2Vec2(aabb.lowerBound.x, aabb.upperBound.y);
                                    this.g_debugDraw.DrawPolygon(vs, 4, color);
                                    var realAABB = new b2AABB();
                                    f.GetShape().ComputeAABB(realAABB, b.GetTransform(), 0);
                                    var vs = [];
                                    vs[0] = new b2Vec2(realAABB.lowerBound.x, realAABB.lowerBound.y);
                                    vs[1] = new b2Vec2(realAABB.upperBound.x, realAABB.lowerBound.y);
                                    vs[2] = new b2Vec2(realAABB.upperBound.x, realAABB.upperBound.y);
                                    vs[3] = new b2Vec2(realAABB.lowerBound.x, realAABB.upperBound.y);
                                    this.g_debugDraw.DrawPolygon(vs, 4, color2);
                                }
                            }
                        }
                    }
                    if (flags & b2Draw.e_centerOfMassBit) {
                        for (var b = this.m_bodyList; b; b = b.GetNext()) {
                            var xf = b.GetTransform().Clone();
                            xf.p = b.GetWorldCenter();
                            this.g_debugDraw.DrawTransform(xf);
                        }
                    }
                },
                QueryAABB: function(callback, aabb) {
                    var wrapper = new b2WorldQueryWrapper();
                    wrapper.broadPhase = this.m_contactManager.m_broadPhase;
                    wrapper.callback = callback;
                    this.m_contactManager.m_broadPhase.Query(wrapper, aabb);
                },
                RayCast: function(callback, point1, point2) {
                    var wrapper = new b2WorldRayCastWrapper();
                    wrapper.broadPhase = this.m_contactManager.m_broadPhase;
                    wrapper.callback = callback;
                    var input = new b2RayCastInput();
                    input.maxFraction = 1;
                    input.p1 = point1;
                    input.p2 = point2;
                    this.m_contactManager.m_broadPhase.RayCast(wrapper, input);
                },
                GetBodyList: function() {
                    return this.m_bodyList;
                },
                GetJointList: function() {
                    return this.m_jointList;
                },
                GetContactList: function() {
                    return this.m_contactManager.m_contactList;
                },
                SetAllowSleeping: function(flag) {
                    if (flag == this.m_allowSleep) {
                        return;
                    }
                    this.m_allowSleep = flag;
                    if (false == this.m_allowSleep) {
                        for (var b = this.m_bodyList; b; b = b.m_next) {
                            b.SetAwake(true);
                        }
                    }
                },
                GetAllowSleeping: function() {
                    return this.m_allowSleep;
                },
                SetWarmStarting: function(flag) {
                    this.m_warmStarting = flag;
                },
                GetWarmStarting: function() {
                    return this.m_warmStarting;
                },
                SetContinuousPhysics: function(flag) {
                    this.m_continuousPhysics = flag;
                },
                GetContinuousPhysics: function() {
                    return this.m_continuousPhysics;
                },
                SetSubStepping: function(flag) {
                    this.m_subStepping = flag;
                },
                GetSubStepping: function() {
                    return this.m_subStepping;
                },
                GetProxyCount: function() {
                    return this.m_contactManager.m_broadPhase.GetProxyCount();
                },
                GetBodyCount: function() {
                    return this.m_bodyCount;
                },
                GetJointCount: function() {
                    return this.m_jointCount;
                },
                GetContactCount: function() {
                    return this.m_contactManager.m_contactCount;
                },
                GetTreeHeight: function() {
                    return this.m_contactManager.m_broadPhase.GetTreeHeight();
                },
                GetTreeBalance: function() {
                    return this.m_contactManager.m_broadPhase.GetTreeBalance();
                },
                GetTreeQuality: function() {
                    return this.m_contactManager.m_broadPhase.GetTreeQuality();
                },
                SetGravity: function(gravity) {
                    this.m_gravity = gravity;
                },
                GetGravity: function() {
                    return this.m_gravity;
                },
                IsLocked: function() {
                    return (this.m_flags & b2World.e_locked) == b2World.e_locked;
                },
                SetAutoClearForces: function(flag) {
                    flag ? this.m_flags |= b2World.e_clearForces : this.m_flags &= ~b2World.e_clearForces;
                },
                GetAutoClearForces: function() {
                    return (this.m_flags & b2World.e_clearForces) == b2World.e_clearForces;
                },
                ShiftOrigin: function(newOrigin) {
                    b2Assert(0 == (this.m_flags & b2World.e_locked));
                    if ((this.m_flags & b2World.e_locked) == b2World.e_locked) {
                        return;
                    }
                    for (var b = this.m_bodyList; b; b = b.m_next) {
                        b.m_xf.p.Subtract(newOrigin);
                        b.m_sweep.c0.Subtract(newOrigin);
                        b.m_sweep.c.Subtract(newOrigin);
                    }
                    for (var j = this.m_jointList; j; j = j.m_next) {
                        j.ShiftOrigin(newOrigin);
                    }
                    this.m_contactManager.m_broadPhase.ShiftOrigin(newOrigin);
                },
                GetContactManager: function() {
                    return this.m_contactManager;
                },
                Solve: function(step) {
                    this.p_island.Initialize(this.m_bodyCount, this.m_contactManager.m_contactCount, this.m_jointCount, this.m_contactManager.m_contactListener);
                    for (var b = this.m_bodyList; b; b = b.m_next) {
                        b.m_flags &= ~b2Body.e_islandFlag;
                    }
                    for (var c = this.m_contactManager.m_contactList; c; c = c.m_next) {
                        c.m_flags &= ~b2Contact.e_islandFlag;
                    }
                    for (var j = this.m_jointList; j; j = j.m_next) {
                        j.m_islandFlag = false;
                    }
                    var stackSize = this.m_bodyCount;
                    var stack = new Array(stackSize);
                    for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
                        if (seed.m_flags & b2Body.e_islandFlag) {
                            continue;
                        }
                        if (false == seed.IsAwake() || false == seed.IsActive()) {
                            continue;
                        }
                        if (seed.GetType() == b2Body.b2_staticBody) {
                            continue;
                        }
                        this.p_island.Clear();
                        var stackCount = 0;
                        stack[stackCount++] = seed;
                        seed.m_flags |= b2Body.e_islandFlag;
                        while (stackCount > 0) {
                            var b = stack[--stackCount];
                            b2Assert(true == b.IsActive());
                            this.p_island.AddBody(b);
                            b.SetAwake(true);
                            if (b.GetType() == b2Body.b2_staticBody) {
                                continue;
                            }
                            for (var ce = b.m_contactList; ce; ce = ce.next) {
                                var contact = ce.contact;
                                if (contact.m_flags & b2Contact.e_islandFlag) {
                                    continue;
                                }
                                if (false == contact.IsEnabled() || false == contact.IsTouching()) {
                                    continue;
                                }
                                var sensorA = contact.m_fixtureA.m_isSensor;
                                var sensorB = contact.m_fixtureB.m_isSensor;
                                if (sensorA || sensorB) {
                                    continue;
                                }
                                this.p_island.AddContact(contact);
                                contact.m_flags |= b2Contact.e_islandFlag;
                                var other = ce.other;
                                if (other.m_flags & b2Body.e_islandFlag) {
                                    continue;
                                }
                                b2Assert(stackCount < stackSize);
                                stack[stackCount++] = other;
                                other.m_flags |= b2Body.e_islandFlag;
                            }
                            for (var je = b.m_jointList; je; je = je.next) {
                                if (true == je.joint.m_islandFlag) {
                                    continue;
                                }
                                var other = je.other;
                                if (false == other.IsActive()) {
                                    continue;
                                }
                                this.p_island.AddJoint(je.joint);
                                je.joint.m_islandFlag = true;
                                if (other.m_flags & b2Body.e_islandFlag) {
                                    continue;
                                }
                                b2Assert(stackCount < stackSize);
                                stack[stackCount++] = other;
                                other.m_flags |= b2Body.e_islandFlag;
                            }
                        }
                        this.p_island.Solve(step, this.m_gravity, this.m_allowSleep);
                        for (var i = 0; i < this.p_island.m_bodyCount; ++i) {
                            var b = this.p_island.m_bodies[i];
                            b.GetType() == b2Body.b2_staticBody && (b.m_flags &= ~b2Body.e_islandFlag);
                        }
                    }
                    profile_world_broadphase.start();
                    for (var b = this.m_bodyList; b; b = b.GetNext()) {
                        if (0 == (b.m_flags & b2Body.e_islandFlag)) {
                            continue;
                        }
                        if (b.GetType() == b2Body.b2_staticBody) {
                            continue;
                        }
                        b.SynchronizeFixtures();
                    }
                    this.m_contactManager.FindNewContacts();
                    profile_world_broadphase.stop();
                },
                SolveTOI: function(step) {
                    this.p_island.Initialize(2 * b2_maxTOIContacts, b2_maxTOIContacts, 0, this.m_contactManager.m_contactListener);
                    if (this.m_stepComplete) {
                        for (var b = this.m_bodyList; b; b = b.m_next) {
                            b.m_flags &= ~b2Body.e_islandFlag;
                            b.m_sweep.alpha0 = 0;
                        }
                        for (var c = this.m_contactManager.m_contactList; c; c = c.m_next) {
                            c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag);
                            c.m_toiCount = 0;
                            c.m_toi = 1;
                        }
                    }
                    for (;;) {
                        var minContact = null;
                        var minAlpha = 1;
                        for (var c = this.m_contactManager.m_contactList; c; c = c.m_next) {
                            if (false == c.IsEnabled()) {
                                continue;
                            }
                            if (c.m_toiCount > b2_maxSubSteps) {
                                continue;
                            }
                            var alpha = 1;
                            if (c.m_flags & b2Contact.e_toiFlag) {
                                alpha = c.m_toi;
                            } else {
                                var fA = c.GetFixtureA();
                                var fB = c.GetFixtureB();
                                if (fA.IsSensor() || fB.IsSensor()) {
                                    continue;
                                }
                                var bA = fA.GetBody();
                                var bB = fB.GetBody();
                                var typeA = bA.m_type;
                                var typeB = bB.m_type;
                                b2Assert(typeA == b2Body.b2_dynamicBody || typeB == b2Body.b2_dynamicBody);
                                var activeA = bA.IsAwake() && typeA != b2Body.b2_staticBody;
                                var activeB = bB.IsAwake() && typeB != b2Body.b2_staticBody;
                                if (false == activeA && false == activeB) {
                                    continue;
                                }
                                var collideA = bA.IsBullet() || typeA != b2Body.b2_dynamicBody;
                                var collideB = bB.IsBullet() || typeB != b2Body.b2_dynamicBody;
                                if (false == collideA && false == collideB) {
                                    continue;
                                }
                                var alpha0 = bA.m_sweep.alpha0;
                                if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {
                                    alpha0 = bB.m_sweep.alpha0;
                                    bA.m_sweep.Advance(alpha0);
                                } else {
                                    if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {
                                        alpha0 = bA.m_sweep.alpha0;
                                        bB.m_sweep.Advance(alpha0);
                                    }
                                }
                                b2Assert(alpha0 < 1);
                                var indexA = c.GetChildIndexA();
                                var indexB = c.GetChildIndexB();
                                var input = new b2TOIInput();
                                input.proxyA.Set(fA.GetShape(), indexA);
                                input.proxyB.Set(fB.GetShape(), indexB);
                                input.sweepA.Assign(bA.m_sweep);
                                input.sweepB.Assign(bB.m_sweep);
                                input.tMax = 1;
                                var output = new b2TOIOutput();
                                b2TimeOfImpact(output, input);
                                var beta = output.t;
                                alpha = output.state == b2TOIOutput.e_touching ? b2Min(alpha0 + (1 - alpha0) * beta, 1) : 1;
                                c.m_toi = alpha;
                                c.m_flags |= b2Contact.e_toiFlag;
                            }
                            if (alpha < minAlpha) {
                                minContact = c;
                                minAlpha = alpha;
                            }
                        }
                        if (null == minContact || 1 - 10 * b2_epsilon < minAlpha) {
                            this.m_stepComplete = true;
                            break;
                        }
                        var fA = minContact.GetFixtureA();
                        var fB = minContact.GetFixtureB();
                        var bA = fA.GetBody();
                        var bB = fB.GetBody();
                        b2World.m_local_sweep_backupA.Assign(bA.m_sweep);
                        b2World.m_local_sweep_backupB.Assign(bB.m_sweep);
                        bA.Advance(minAlpha);
                        bB.Advance(minAlpha);
                        minContact.Update(this.m_contactManager.m_contactListener);
                        minContact.m_flags &= ~b2Contact.e_toiFlag;
                        ++minContact.m_toiCount;
                        if (false == minContact.IsEnabled() || false == minContact.IsTouching()) {
                            minContact.SetEnabled(false);
                            bA.m_sweep.Assign(b2World.m_local_sweep_backupA);
                            bB.m_sweep.Assign(b2World.m_local_sweep_backupB);
                            bA.SynchronizeTransform();
                            bB.SynchronizeTransform();
                            continue;
                        }
                        bA.SetAwake(true);
                        bB.SetAwake(true);
                        this.p_island.Clear();
                        this.p_island.AddBody(bA);
                        this.p_island.AddBody(bB);
                        this.p_island.AddContact(minContact);
                        bA.m_flags |= b2Body.e_islandFlag;
                        bB.m_flags |= b2Body.e_islandFlag;
                        minContact.m_flags |= b2Contact.e_islandFlag;
                        var bodies = [ bA, bB ];
                        for (var i = 0; i < 2; ++i) {
                            var body = bodies[i];
                            if (body.m_type == b2Body.b2_dynamicBody) {
                                for (var ce = body.m_contactList; ce; ce = ce.next) {
                                    if (this.p_island.m_bodyCount == this.p_island.m_bodyCapacity) {
                                        break;
                                    }
                                    if (this.p_island.m_contactCount == this.p_island.m_contactCapacity) {
                                        break;
                                    }
                                    var contact = ce.contact;
                                    if (contact.m_flags & b2Contact.e_islandFlag) {
                                        continue;
                                    }
                                    var other = ce.other;
                                    if (other.m_type == b2Body.b2_dynamicBody && false == body.IsBullet() && false == other.IsBullet()) {
                                        continue;
                                    }
                                    var sensorA = contact.m_fixtureA.m_isSensor;
                                    var sensorB = contact.m_fixtureB.m_isSensor;
                                    if (sensorA || sensorB) {
                                        continue;
                                    }
                                    b2World.m_local_sweep_backupC.Assign(other.m_sweep);
                                    0 == (other.m_flags & b2Body.e_islandFlag) && other.Advance(minAlpha);
                                    contact.Update(this.m_contactManager.m_contactListener);
                                    if (false == contact.IsEnabled()) {
                                        other.m_sweep.Assign(b2World.m_local_sweep_backupC);
                                        other.SynchronizeTransform();
                                        continue;
                                    }
                                    if (false == contact.IsTouching()) {
                                        other.m_sweep.Assign(b2World.m_local_sweep_backupC);
                                        other.SynchronizeTransform();
                                        continue;
                                    }
                                    contact.m_flags |= b2Contact.e_islandFlag;
                                    this.p_island.AddContact(contact);
                                    if (other.m_flags & b2Body.e_islandFlag) {
                                        continue;
                                    }
                                    other.m_flags |= b2Body.e_islandFlag;
                                    other.m_type != b2Body.b2_staticBody && other.SetAwake(true);
                                    this.p_island.AddBody(other);
                                }
                            }
                        }
                        var subStep = new b2TimeStep();
                        subStep.dt = (1 - minAlpha) * step.dt;
                        subStep.inv_dt = 1 / subStep.dt;
                        subStep.dtRatio = 1;
                        subStep.positionIterations = 20;
                        subStep.velocityIterations = step.velocityIterations;
                        subStep.warmStarting = false;
                        this.p_island.SolveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);
                        for (var i = 0; i < this.p_island.m_bodyCount; ++i) {
                            var body = this.p_island.m_bodies[i];
                            body.m_flags &= ~b2Body.e_islandFlag;
                            if (body.m_type != b2Body.b2_dynamicBody) {
                                continue;
                            }
                            body.SynchronizeFixtures();
                            for (var ce = body.m_contactList; ce; ce = ce.next) {
                                ce.contact.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag);
                            }
                        }
                        this.m_contactManager.FindNewContacts();
                        if (this.m_subStepping) {
                            this.m_stepComplete = false;
                            break;
                        }
                    }
                },
                DrawJoint: function(joint) {
                    var bodyA = joint.GetBodyA();
                    var bodyB = joint.GetBodyB();
                    var xf1 = bodyA.GetTransform();
                    var xf2 = bodyB.GetTransform();
                    var x1 = xf1.p;
                    var x2 = xf2.p;
                    var p1 = joint.GetAnchorA();
                    var p2 = joint.GetAnchorB();
                    var color = new b2Color(.5, .8, .8);
                    switch (joint.GetType()) {
                      case b2Joint.e_distanceJoint:
                        this.g_debugDraw.DrawSegment(p1, p2, color);
                        break;

                      case b2Joint.e_pulleyJoint:
                        var pulley = joint;
                        var s1 = pulley.GetGroundAnchorA();
                        var s2 = pulley.GetGroundAnchorB();
                        this.g_debugDraw.DrawSegment(s1, p1, color);
                        this.g_debugDraw.DrawSegment(s2, p2, color);
                        this.g_debugDraw.DrawSegment(s1, s2, color);
                        break;

                      case b2Joint.e_mouseJoint:
                        break;

                      case b2Joint.e_motorJoint:
                        this.g_debugDraw.DrawPoint(joint.GetLinearOffset(), 5, color);

                      default:
                        this.g_debugDraw.DrawSegment(x1, p1, color);
                        this.g_debugDraw.DrawSegment(p1, p2, color);
                        this.g_debugDraw.DrawSegment(x2, p2, color);
                    }
                },
                DrawShape: function(fixture, xf, color) {
                    switch (fixture.GetType()) {
                      case b2Shape.e_circle:
                        var circle = fixture.GetShape();
                        var center = b2Mul_t_v2(xf, circle.m_p);
                        var radius = circle.m_radius;
                        var axis = b2Mul_r_v2(xf.q, new b2Vec2(1, 0));
                        this.g_debugDraw.DrawSolidCircle(center, radius, axis, color);
                        break;

                      case b2Shape.e_edge:
                        var edge = fixture.GetShape();
                        var v1 = b2Mul_t_v2(xf, edge.m_vertex1);
                        var v2 = b2Mul_t_v2(xf, edge.m_vertex2);
                        this.g_debugDraw.DrawSegment(v1, v2, color);
                        break;

                      case b2Shape.e_chain:
                        var chain = fixture.GetShape();
                        var count = chain.m_count;
                        var vertices = chain.m_vertices;
                        var v1 = b2Mul_t_v2(xf, vertices[0]);
                        for (var i = 1; i < count; ++i) {
                            var v2 = b2Mul_t_v2(xf, vertices[i]);
                            this.g_debugDraw.DrawSegment(v1, v2, color);
                            v1 = v2;
                        }
                        break;

                      case b2Shape.e_polygon:
                        var poly = fixture.GetShape();
                        var vertexCount = poly.m_count;
                        b2Assert(vertexCount <= b2_maxPolygonVertices);
                        var vertices = new Array(b2_maxPolygonVertices);
                        for (var i = 0; i < vertexCount; ++i) {
                            vertices[i] = b2Mul_t_v2(xf, poly.m_vertices[i]);
                        }
                        this.g_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
                    }
                }
            };
            b2World.e_newFixture = 1;
            b2World.e_locked = 2;
            b2World.e_clearForces = 4;
            function b2MixFriction(friction1, friction2) {
                return b2Sqrt(friction1 * friction2);
            }
            function b2MixRestitution(restitution1, restitution2) {
                return restitution1 > restitution2 ? restitution1 : restitution2;
            }
            function b2ContactRegister() {
                this.fcn = null;
                this.primary = false;
            }
            function b2ContactEdge() {
                this.other = null;
                this.contact = null;
                this.prev = null;
                this.next = null;
            }
            b2ContactEdge.prototype = {
                Clear: function() {
                    this.other = this.prev = this.next = null;
                }
            };
            function b2Contact() {
                this.m_nodeA = new b2ContactEdge();
                this.m_nodeB = new b2ContactEdge();
                this.m_manifold = new b2Manifold();
            }
            b2Contact.m_local_tempManifold = new b2Manifold();
            b2Contact.prototype = {
                Create: function(fA, indexA, fB, indexB) {
                    this.m_toi = 0;
                    this.m_flags = b2Contact.e_enabledFlag;
                    this.m_fixtureA = fA || null;
                    this.m_fixtureB = fB || null;
                    this.m_indexA = indexA || 0;
                    this.m_indexB = indexB || 0;
                    this.m_manifold.pointCount = 0;
                    this.m_prev = null;
                    this.m_next = null;
                    this.m_nodeA.contact = null;
                    this.m_nodeA.prev = null;
                    this.m_nodeA.next = null;
                    this.m_nodeA.other = null;
                    this.m_nodeB.contact = null;
                    this.m_nodeB.prev = null;
                    this.m_nodeB.next = null;
                    this.m_nodeB.other = null;
                    this.m_toiCount = 0;
                    if (fA) {
                        this.m_friction = b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
                        this.m_restitution = b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
                    } else {
                        this.m_friction = 0;
                        this.m_restitution = 0;
                    }
                    this.m_tangentSpeed = 0;
                },
                GetManifold: function() {
                    return this.m_manifold;
                },
                GetWorldManifold: function(worldManifold) {
                    var bodyA = this.m_fixtureA.GetBody();
                    var bodyB = this.m_fixtureB.GetBody();
                    var shapeA = this.m_fixtureA.GetShape();
                    var shapeB = this.m_fixtureB.GetShape();
                    worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
                },
                IsTouching: function() {
                    return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
                },
                SetEnabled: function(flag) {
                    flag ? this.m_flags |= b2Contact.e_enabledFlag : this.m_flags &= ~b2Contact.e_enabledFlag;
                },
                IsEnabled: function() {
                    return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
                },
                GetNext: function() {
                    return this.m_next;
                },
                GetFixtureA: function() {
                    return this.m_fixtureA;
                },
                GetChildIndexA: function() {
                    return this.m_indexA;
                },
                GetFixtureB: function() {
                    return this.m_fixtureB;
                },
                GetChildIndexB: function() {
                    return this.m_indexB;
                },
                SetFriction: function(friction) {
                    this.m_friction = friction;
                },
                GetFriction: function() {
                    return this.m_friction;
                },
                ResetFriction: function() {
                    this.m_friction = b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
                },
                SetRestitution: function(restitution) {
                    this.m_restitution = restitution;
                },
                GetRestitution: function() {
                    return this.m_restitution;
                },
                ResetRestitution: function() {
                    this.m_restitution = b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
                },
                SetTangentSpeed: function(speed) {
                    this.m_tangentSpeed = speed;
                },
                GetTangentSpeed: function() {
                    return this.m_tangentSpeed;
                },
                Evaluate: function(manifold, xfA, xfB) {},
                FlagForFiltering: function() {
                    this.m_flags |= b2Contact.e_filterFlag;
                },
                m_oldManifold: null,
                Update: function(listener) {
                    b2Contact.m_local_tempManifold.Assign(this.m_manifold);
                    this.m_flags |= b2Contact.e_enabledFlag;
                    var touching = false;
                    var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
                    var sensorA = this.m_fixtureA.IsSensor();
                    var sensorB = this.m_fixtureB.IsSensor();
                    var sensor = sensorA || sensorB;
                    var bodyA = this.m_fixtureA.GetBody();
                    var bodyB = this.m_fixtureB.GetBody();
                    var xfA = bodyA.GetTransform();
                    var xfB = bodyB.GetTransform();
                    if (sensor) {
                        var shapeA = this.m_fixtureA.GetShape();
                        var shapeB = this.m_fixtureB.GetShape();
                        touching = b2TestShapeOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);
                        this.m_manifold.pointCount = 0;
                    } else {
                        this.Evaluate(this.m_manifold, xfA, xfB);
                        touching = this.m_manifold.pointCount > 0;
                        for (var i = 0; i < this.m_manifold.pointCount; ++i) {
                            var mp2 = this.m_manifold.points[i];
                            mp2.normalImpulse = 0;
                            mp2.tangentImpulse = 0;
                            var id2 = mp2.id;
                            for (var j = 0; j < b2Contact.m_local_tempManifold.pointCount; ++j) {
                                var mp1 = b2Contact.m_local_tempManifold.points[j];
                                if (mp1.id.Get() == id2.Get()) {
                                    mp2.normalImpulse = mp1.normalImpulse;
                                    mp2.tangentImpulse = mp1.tangentImpulse;
                                    break;
                                }
                            }
                        }
                        if (touching != wasTouching) {
                            bodyA.SetAwake(true);
                            bodyB.SetAwake(true);
                        }
                    }
                    touching ? this.m_flags |= b2Contact.e_touchingFlag : this.m_flags &= ~b2Contact.e_touchingFlag;
                    false == wasTouching && true == touching && listener && listener.BeginContact(this);
                    true == wasTouching && false == touching && listener && listener.EndContact(this);
                    false == sensor && touching && listener && listener.PreSolve(this, b2Contact.m_local_tempManifold);
                }
            };
            b2Contact.e_islandFlag = 1;
            b2Contact.e_touchingFlag = 2;
            b2Contact.e_enabledFlag = 4;
            b2Contact.e_filterFlag = 8;
            b2Contact.e_bulletHitFlag = 16;
            b2Contact.e_toiFlag = 32;
            function b2CircleContact() {
                this.parent.call(this);
            }
            b2CircleContact.prototype = {
                Evaluate: function(manifold, xfA, xfB) {
                    b2CollideCircles(manifold, this.m_fixtureA.GetShape(), xfA, this.m_fixtureB.GetShape(), xfB);
                },
                Create: function(fixtureA, unused1, fixtureB, unused2) {
                    this.parent.prototype.Create.call(this, fixtureA, 0, fixtureB, 0);
                    b2Assert(this.m_fixtureA.GetType() == b2Shape.e_circle);
                    b2Assert(this.m_fixtureB.GetType() == b2Shape.e_circle);
                }
            };
            b2CircleContact._extend(b2Contact);
            var _local_temp_edgeShape = new b2EdgeShape();
            function b2ChainAndCircleContact() {
                this.parent.call(this);
            }
            b2ChainAndCircleContact.prototype = {
                Evaluate: function(manifold, xfA, xfB) {
                    var chain = this.m_fixtureA.GetShape();
                    chain.GetChildEdge(_local_temp_edgeShape, this.m_indexA);
                    b2CollideEdgeAndCircle(manifold, _local_temp_edgeShape, xfA, this.m_fixtureB.GetShape(), xfB);
                },
                Create: function(fixtureA, indexA, fixtureB, indexB) {
                    this.parent.prototype.Create.call(this, fixtureA, indexA, fixtureB, indexB);
                    b2Assert(this.m_fixtureA.GetType() == b2Shape.e_chain);
                    b2Assert(this.m_fixtureB.GetType() == b2Shape.e_circle);
                }
            };
            b2ChainAndCircleContact._extend(b2Contact);
            function b2ChainAndPolygonContact() {
                this.parent.call(this);
            }
            b2ChainAndPolygonContact.prototype = {
                Evaluate: function(manifold, xfA, xfB) {
                    var chain = this.m_fixtureA.GetShape();
                    chain.GetChildEdge(_local_temp_edgeShape, this.m_indexA);
                    b2CollideEdgeAndPolygon(manifold, _local_temp_edgeShape, xfA, this.m_fixtureB.GetShape(), xfB);
                },
                Create: function(fixtureA, indexA, fixtureB, indexB) {
                    this.parent.prototype.Create.call(this, fixtureA, indexA, fixtureB, indexB);
                    b2Assert(this.m_fixtureA.GetType() == b2Shape.e_chain);
                    b2Assert(this.m_fixtureB.GetType() == b2Shape.e_polygon);
                }
            };
            b2ChainAndPolygonContact.Create = function(fixtureA, indexA, fixtureB, indexB) {
                return new b2ChainAndPolygonContact(fixtureA, indexA, fixtureB, indexB);
            };
            b2ChainAndPolygonContact._extend(b2Contact);
            function b2EdgeAndCircleContact() {
                this.parent.call(this);
            }
            b2EdgeAndCircleContact.prototype = {
                Evaluate: function(manifold, xfA, xfB) {
                    b2CollideEdgeAndCircle(manifold, this.m_fixtureA.GetShape(), xfA, this.m_fixtureB.GetShape(), xfB);
                },
                Create: function(fixtureA, indexA, fixtureB, indexB) {
                    this.parent.prototype.Create.call(this, fixtureA, 0, fixtureB, 0);
                    b2Assert(this.m_fixtureA.GetType() == b2Shape.e_edge);
                    b2Assert(this.m_fixtureB.GetType() == b2Shape.e_circle);
                }
            };
            b2EdgeAndCircleContact.Create = function(fixtureA, indexA, fixtureB, indexB) {
                return new b2EdgeAndCircleContact(fixtureA, fixtureB);
            };
            b2EdgeAndCircleContact._extend(b2Contact);
            function b2EdgeAndPolygonContact() {
                this.parent.call(this);
            }
            b2EdgeAndPolygonContact.prototype = {
                Evaluate: function(manifold, xfA, xfB) {
                    b2CollideEdgeAndPolygon(manifold, this.m_fixtureA.GetShape(), xfA, this.m_fixtureB.GetShape(), xfB);
                },
                Create: function(fixtureA, indexA, fixtureB, indexB) {
                    this.parent.prototype.Create.call(this, fixtureA, 0, fixtureB, 0);
                    b2Assert(this.m_fixtureA.GetType() == b2Shape.e_edge);
                    b2Assert(this.m_fixtureB.GetType() == b2Shape.e_polygon);
                }
            };
            b2EdgeAndPolygonContact.Create = function(fixtureA, indexA, fixtureB, indexB) {
                return new b2EdgeAndPolygonContact(fixtureA, fixtureB);
            };
            b2EdgeAndPolygonContact._extend(b2Contact);
            function b2PolygonAndCircleContact() {
                this.parent.call(this);
            }
            b2PolygonAndCircleContact.prototype = {
                Evaluate: function(manifold, xfA, xfB) {
                    b2CollidePolygonAndCircle(manifold, this.m_fixtureA.GetShape(), xfA, this.m_fixtureB.GetShape(), xfB);
                },
                Create: function(fixtureA, indexA, fixtureB, indexB) {
                    this.parent.prototype.Create.call(this, fixtureA, 0, fixtureB, 0);
                    b2Assert(this.m_fixtureA.GetType() == b2Shape.e_polygon);
                    b2Assert(this.m_fixtureB.GetType() == b2Shape.e_circle);
                }
            };
            b2PolygonAndCircleContact.Create = function(fixtureA, indexA, fixtureB, indexB) {
                return new b2PolygonAndCircleContact(fixtureA, fixtureB);
            };
            b2PolygonAndCircleContact._extend(b2Contact);
            function b2PolygonContact() {
                this.parent.call(this);
            }
            b2PolygonContact.prototype = {
                Evaluate: function(manifold, xfA, xfB) {
                    b2CollidePolygons(manifold, this.m_fixtureA.GetShape(), xfA, this.m_fixtureB.GetShape(), xfB);
                },
                Create: function(fixtureA, indexA, fixtureB, indexB) {
                    this.parent.prototype.Create.call(this, fixtureA, 0, fixtureB, 0);
                    b2Assert(this.m_fixtureA.GetType() == b2Shape.e_polygon);
                    b2Assert(this.m_fixtureB.GetType() == b2Shape.e_polygon);
                }
            };
            b2PolygonContact.Create = function(fixtureA, indexA, fixtureB, indexB) {
                return new b2PolygonContact(fixtureA, fixtureB);
            };
            b2PolygonContact._extend(b2Contact);
            b2Contact.AddType = function(fcn, type1, type2) {
                b2Assert(0 <= type1 && type1 < b2Shape.e_typeCount);
                b2Assert(0 <= type2 && type2 < b2Shape.e_typeCount);
                b2Contact.s_registers[type1] || (b2Contact.s_registers[type1] = []);
                b2Contact.s_registers[type1][type2] = new b2ContactRegister();
                b2Contact.s_registers[type1][type2].fcn = fcn;
                b2Contact.s_registers[type1][type2].primary = true;
                if (type1 != type2) {
                    b2Contact.s_registers[type2] || (b2Contact.s_registers[type2] = []);
                    b2Contact.s_registers[type2][type1] = new b2ContactRegister();
                    b2Contact.s_registers[type2][type1].fcn = fcn;
                    b2Contact.s_registers[type2][type1].primary = false;
                }
                fcn.garbage = [];
                fcn.alloc = 2;
            };
            b2Contact.InitializeRegisters = function() {
                b2Contact.AddType(b2CircleContact, b2Shape.e_circle, b2Shape.e_circle);
                b2Contact.AddType(b2PolygonAndCircleContact, b2Shape.e_polygon, b2Shape.e_circle);
                b2Contact.AddType(b2PolygonContact, b2Shape.e_polygon, b2Shape.e_polygon);
                b2Contact.AddType(b2EdgeAndCircleContact, b2Shape.e_edge, b2Shape.e_circle);
                b2Contact.AddType(b2EdgeAndPolygonContact, b2Shape.e_edge, b2Shape.e_polygon);
                b2Contact.AddType(b2ChainAndCircleContact, b2Shape.e_chain, b2Shape.e_circle);
                b2Contact.AddType(b2ChainAndPolygonContact, b2Shape.e_chain, b2Shape.e_polygon);
            };
            b2Contact.RetrieveGarbage = function(fcn) {
                var contact;
                if (contact = fcn.garbage.pop()) {
                    return contact;
                }
                for (var i = 0; i < fcn.alloc - 1; ++i) {
                    fcn.garbage.push(new fcn());
                }
                fcn.alloc += 32;
                return new fcn();
            };
            b2Contact.Create = function(fixtureA, indexA, fixtureB, indexB) {
                if (false == b2Contact.s_initialized) {
                    b2Contact.InitializeRegisters();
                    b2Contact.s_initialized = true;
                }
                var type1 = fixtureA.GetType();
                var type2 = fixtureB.GetType();
                b2Assert(0 <= type1 && type1 < b2Shape.e_typeCount);
                b2Assert(0 <= type2 && type2 < b2Shape.e_typeCount);
                var fcn = b2Contact.s_registers[type1] && b2Contact.s_registers[type1][type2] ? b2Contact.s_registers[type1][type2].fcn : null;
                if (fcn) {
                    var contact = b2Contact.RetrieveGarbage(fcn);
                    b2Contact.s_registers[type1][type2].primary ? contact.Create(fixtureA, indexA, fixtureB, indexB) : contact.Create(fixtureB, indexB, fixtureA, indexA);
                    return contact;
                }
                return null;
            };
            b2Contact.Destroy = function(contact) {
                b2Assert(true == b2Contact.s_initialized);
                var fixtureA = contact.m_fixtureA;
                var fixtureB = contact.m_fixtureB;
                if (contact.m_manifold.pointCount > 0 && false == fixtureA.IsSensor() && false == fixtureB.IsSensor()) {
                    fixtureA.GetBody().SetAwake(true);
                    fixtureB.GetBody().SetAwake(true);
                }
                var typeA = fixtureA.GetType();
                var typeB = fixtureB.GetType();
                b2Assert(0 <= typeA && typeB < b2Shape.e_typeCount);
                b2Assert(0 <= typeA && typeB < b2Shape.e_typeCount);
                contact.m_nodeA.Clear();
                contact.m_nodeB.Clear();
                b2Contact.s_registers[typeA][typeB].fcn.garbage.push(contact);
            };
            b2Contact.s_registers = [];
            b2Contact.s_initialized = false;
            var b2_defaultFilter = new b2ContactFilter();
            var b2_defaultListener = new b2ContactListener();
            function b2ContactManager() {
                this.m_broadPhase = new b2BroadPhase();
                this.m_contactList = null;
                this.m_contactCount = 0;
                this.m_contactFilter = b2_defaultFilter;
                this.m_contactListener = b2_defaultListener;
            }
            b2ContactManager.prototype = {
                AddPair: function(proxyUserDataA, proxyUserDataB) {
                    var proxyA = proxyUserDataA;
                    var proxyB = proxyUserDataB;
                    var fixtureA = proxyA.fixture;
                    var fixtureB = proxyB.fixture;
                    var indexA = proxyA.childIndex;
                    var indexB = proxyB.childIndex;
                    var bodyA = fixtureA.GetBody();
                    var bodyB = fixtureB.GetBody();
                    if (bodyA == bodyB) {
                        return;
                    }
                    var edge = bodyB.GetContactList();
                    while (edge) {
                        if (edge.other == bodyA) {
                            var fA = edge.contact.GetFixtureA();
                            var fB = edge.contact.GetFixtureB();
                            var iA = edge.contact.GetChildIndexA();
                            var iB = edge.contact.GetChildIndexB();
                            if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {
                                return;
                            }
                            if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {
                                return;
                            }
                        }
                        edge = edge.next;
                    }
                    if (false == bodyB.ShouldCollide(bodyA)) {
                        return;
                    }
                    if (this.m_contactFilter && false == this.m_contactFilter.ShouldCollide(fixtureA, fixtureB)) {
                        return;
                    }
                    var c = b2Contact.Create(fixtureA, indexA, fixtureB, indexB);
                    if (null == c) {
                        return;
                    }
                    fixtureA = c.GetFixtureA();
                    fixtureB = c.GetFixtureB();
                    indexA = c.GetChildIndexA();
                    indexB = c.GetChildIndexB();
                    bodyA = fixtureA.GetBody();
                    bodyB = fixtureB.GetBody();
                    c.m_prev = null;
                    c.m_next = this.m_contactList;
                    null != this.m_contactList && (this.m_contactList.m_prev = c);
                    this.m_contactList = c;
                    c.m_nodeA.contact = c;
                    c.m_nodeA.other = bodyB;
                    c.m_nodeA.prev = null;
                    c.m_nodeA.next = bodyA.m_contactList;
                    null != bodyA.m_contactList && (bodyA.m_contactList.prev = c.m_nodeA);
                    bodyA.m_contactList = c.m_nodeA;
                    c.m_nodeB.contact = c;
                    c.m_nodeB.other = bodyA;
                    c.m_nodeB.prev = null;
                    c.m_nodeB.next = bodyB.m_contactList;
                    null != bodyB.m_contactList && (bodyB.m_contactList.prev = c.m_nodeB);
                    bodyB.m_contactList = c.m_nodeB;
                    if (false == fixtureA.IsSensor() && false == fixtureB.IsSensor()) {
                        bodyA.SetAwake(true);
                        bodyB.SetAwake(true);
                    }
                    ++this.m_contactCount;
                },
                FindNewContacts: function() {
                    this.m_broadPhase.UpdatePairs(this);
                },
                Destroy: function(c) {
                    var fixtureA = c.GetFixtureA();
                    var fixtureB = c.GetFixtureB();
                    var bodyA = fixtureA.GetBody();
                    var bodyB = fixtureB.GetBody();
                    this.m_contactListener && c.IsTouching() && this.m_contactListener.EndContact(c);
                    c.m_prev && (c.m_prev.m_next = c.m_next);
                    c.m_next && (c.m_next.m_prev = c.m_prev);
                    c == this.m_contactList && (this.m_contactList = c.m_next);
                    c.m_nodeA.prev && (c.m_nodeA.prev.next = c.m_nodeA.next);
                    c.m_nodeA.next && (c.m_nodeA.next.prev = c.m_nodeA.prev);
                    c.m_nodeA == bodyA.m_contactList && (bodyA.m_contactList = c.m_nodeA.next);
                    c.m_nodeB.prev && (c.m_nodeB.prev.next = c.m_nodeB.next);
                    c.m_nodeB.next && (c.m_nodeB.next.prev = c.m_nodeB.prev);
                    c.m_nodeB == bodyB.m_contactList && (bodyB.m_contactList = c.m_nodeB.next);
                    b2Contact.Destroy(c);
                    --this.m_contactCount;
                },
                Collide: function() {
                    var c = this.m_contactList;
                    while (c) {
                        var fixtureA = c.GetFixtureA();
                        var fixtureB = c.GetFixtureB();
                        var indexA = c.GetChildIndexA();
                        var indexB = c.GetChildIndexB();
                        var bodyA = fixtureA.GetBody();
                        var bodyB = fixtureB.GetBody();
                        if (c.m_flags & b2Contact.e_filterFlag) {
                            if (false == bodyB.ShouldCollide(bodyA)) {
                                var cNuke = c;
                                c = cNuke.GetNext();
                                this.Destroy(cNuke);
                                continue;
                            }
                            if (this.m_contactFilter && false == this.m_contactFilter.ShouldCollide(fixtureA, fixtureB)) {
                                var cNuke = c;
                                c = cNuke.GetNext();
                                this.Destroy(cNuke);
                                continue;
                            }
                            c.m_flags &= ~b2Contact.e_filterFlag;
                        }
                        var activeA = bodyA.IsAwake() && bodyA.m_type != b2Body.b2_staticBody;
                        var activeB = bodyB.IsAwake() && bodyB.m_type != b2Body.b2_staticBody;
                        if (false == activeA && false == activeB) {
                            c = c.GetNext();
                            continue;
                        }
                        var proxyIdA = fixtureA.m_proxies[indexA].proxyId;
                        var proxyIdB = fixtureB.m_proxies[indexB].proxyId;
                        var overlap = this.m_broadPhase.TestOverlap(proxyIdA, proxyIdB);
                        if (false == overlap) {
                            var cNuke = c;
                            c = cNuke.GetNext();
                            this.Destroy(cNuke);
                            continue;
                        }
                        c.Update(this.m_contactListener);
                        c = c.GetNext();
                    }
                }
            };
            function b2VelocityConstraintPoint() {
                this.rA = new b2Vec2();
                this.rB = new b2Vec2();
                this.normalImpulse = 0;
                this.tangentImpulse = 0;
                this.normalMass = 0;
                this.tangentMass = 0;
                this.velocityBias = 0;
            }
            function b2ContactPositionConstraint() {
                this.localPoints = new Array(b2_maxManifoldPoints);
                this.localNormal = new b2Vec2();
                this.localPoint = new b2Vec2();
                this.indexA = 0;
                this.indexB = 0;
                this.invMassA = 0, this.invMassB = 0;
                this.localCenterA = new b2Vec2(), this.localCenterB = new b2Vec2();
                this.invIA = 0, this.invIB = 0;
                this.type = 0;
                this.radiusA = 0, this.radiusB = 0;
                this.pointCount = 0;
            }
            function b2ContactVelocityConstraint() {
                this.points = new Array(b2_maxManifoldPoints);
                for (var i = 0; i < this.points.length; ++i) {
                    this.points[i] = new b2VelocityConstraintPoint();
                }
                this.normal = new b2Vec2();
                this.normalMass = new b2Mat22();
                this.K = new b2Mat22();
                this.indexA = 0;
                this.indexB = 0;
                this.invMassA = 0, this.invMassB = 0;
                this.invIA = 0, this.invIB = 0;
                this.friction = 0;
                this.restitution = 0;
                this.tangentSpeed = 0;
                this.pointCount = 0;
                this.contactIndex = 0;
            }
            function b2PositionSolverManifold() {
                this.normal = new b2Vec2();
                this.point = new b2Vec2();
                this.separation = 0;
            }
            b2PositionSolverManifold.prototype = {
                Initialize: function(pc, xfA, xfB, index) {
                    b2Assert(pc.pointCount > 0);
                    switch (pc.type) {
                      case b2Manifold.e_circles:
                        var pointAx = xfA.q.c * pc.localPoint.x - xfA.q.s * pc.localPoint.y + xfA.p.x;
                        var pointAy = xfA.q.s * pc.localPoint.x + xfA.q.c * pc.localPoint.y + xfA.p.y;
                        var pointBx = xfB.q.c * pc.localPoints[0].x - xfB.q.s * pc.localPoints[0].y + xfB.p.x;
                        var pointBy = xfB.q.s * pc.localPoints[0].x + xfB.q.c * pc.localPoints[0].y + xfB.p.y;
                        this.point.x = .5 * (pointAx + pointBx);
                        this.point.y = .5 * (pointAy + pointBy);
                        this.normal.x = pointBx - pointAx;
                        this.normal.y = pointBy - pointAy;
                        var tempnx = this.normal.x;
                        var tempny = this.normal.y;
                        this.normal.Normalize();
                        this.separation = tempnx * this.normal.x + tempny * this.normal.y - pc.radiusA - pc.radiusB;
                        break;

                      case b2Manifold.e_faceA:
                        this.normal.x = xfA.q.c * pc.localNormal.x - xfA.q.s * pc.localNormal.y;
                        this.normal.y = xfA.q.s * pc.localNormal.x + xfA.q.c * pc.localNormal.y;
                        var planePointx = xfA.q.c * pc.localPoint.x - xfA.q.s * pc.localPoint.y + xfA.p.x;
                        var planePointy = xfA.q.s * pc.localPoint.x + xfA.q.c * pc.localPoint.y + xfA.p.y;
                        var clipPointx = xfB.q.c * pc.localPoints[index].x - xfB.q.s * pc.localPoints[index].y + xfB.p.x;
                        var clipPointy = xfB.q.s * pc.localPoints[index].x + xfB.q.c * pc.localPoints[index].y + xfB.p.y;
                        this.separation = (clipPointx - planePointx) * this.normal.x + (clipPointy - planePointy) * this.normal.y - pc.radiusA - pc.radiusB;
                        this.point.x = clipPointx;
                        this.point.y = clipPointy;
                        break;

                      case b2Manifold.e_faceB:
                        this.normal.x = xfB.q.c * pc.localNormal.x - xfB.q.s * pc.localNormal.y;
                        this.normal.y = xfB.q.s * pc.localNormal.x + xfB.q.c * pc.localNormal.y;
                        var planePointx = xfB.q.c * pc.localPoint.x - xfB.q.s * pc.localPoint.y + xfB.p.x;
                        var planePointy = xfB.q.s * pc.localPoint.x + xfB.q.c * pc.localPoint.y + xfB.p.y;
                        var clipPointx = xfA.q.c * pc.localPoints[index].x - xfA.q.s * pc.localPoints[index].y + xfA.p.x;
                        var clipPointy = xfA.q.s * pc.localPoints[index].x + xfA.q.c * pc.localPoints[index].y + xfA.p.y;
                        this.separation = (clipPointx - planePointx) * this.normal.x + (clipPointy - planePointy) * this.normal.y - pc.radiusA - pc.radiusB;
                        this.point.x = clipPointx;
                        this.point.y = clipPointy;
                        this.normal.x = -this.normal.x;
                        this.normal.y = -this.normal.y;
                    }
                }
            };
            function b2ContactSolverDef() {
                this.step = new b2TimeStep();
                this.contacts = null;
                this.count = 0;
                this.positions = null;
                this.velocities = null;
            }
            function b2ContactSolver() {
                this.m_positionConstraints = [];
                this.m_velocityConstraints = [];
            }
            b2ContactSolver.cs_xfA = new b2Transform();
            b2ContactSolver.cs_xfB = new b2Transform();
            b2ContactSolver.temp_solver_manifold = new b2PositionSolverManifold();
            b2ContactSolver.prototype = {
                Init: function(def) {
                    this.m_step = def.step;
                    this.m_count = def.count;
                    this.m_positionConstraints.length = this.m_count;
                    this.m_velocityConstraints.length = this.m_count;
                    this.m_positions = def.positions;
                    this.m_velocities = def.velocities;
                    this.m_contacts = def.contacts;
                    for (var i = 0; i < this.m_count; ++i) {
                        var contact = this.m_contacts[i];
                        var fixtureA = contact.m_fixtureA;
                        var fixtureB = contact.m_fixtureB;
                        var shapeA = fixtureA.GetShape();
                        var shapeB = fixtureB.GetShape();
                        var radiusA = shapeA.m_radius;
                        var radiusB = shapeB.m_radius;
                        var bodyA = fixtureA.GetBody();
                        var bodyB = fixtureB.GetBody();
                        var manifold = contact.GetManifold();
                        var pointCount = manifold.pointCount;
                        b2Assert(pointCount > 0);
                        var vc = this.m_velocityConstraints[i] || new b2ContactVelocityConstraint();
                        vc.friction = contact.m_friction;
                        vc.restitution = contact.m_restitution;
                        vc.tangentSpeed = contact.m_tangentSpeed;
                        vc.indexA = bodyA.m_islandIndex;
                        vc.indexB = bodyB.m_islandIndex;
                        vc.invMassA = bodyA.m_invMass;
                        vc.invMassB = bodyB.m_invMass;
                        vc.invIA = bodyA.m_invI;
                        vc.invIB = bodyB.m_invI;
                        vc.contactIndex = i;
                        vc.pointCount = pointCount;
                        vc.K.SetZero();
                        vc.normalMass.SetZero();
                        this.m_velocityConstraints[i] = vc;
                        var pc = this.m_positionConstraints[i] || new b2ContactPositionConstraint();
                        pc.indexA = bodyA.m_islandIndex;
                        pc.indexB = bodyB.m_islandIndex;
                        pc.invMassA = bodyA.m_invMass;
                        pc.invMassB = bodyB.m_invMass;
                        pc.localCenterA.x = bodyA.m_sweep.localCenter.x;
                        pc.localCenterA.y = bodyA.m_sweep.localCenter.y;
                        pc.localCenterB.x = bodyB.m_sweep.localCenter.x;
                        pc.localCenterB.y = bodyB.m_sweep.localCenter.y;
                        pc.invIA = bodyA.m_invI;
                        pc.invIB = bodyB.m_invI;
                        pc.localNormal.x = manifold.localNormal.x;
                        pc.localNormal.y = manifold.localNormal.y;
                        pc.localPoint.x = manifold.localPoint.x;
                        pc.localPoint.y = manifold.localPoint.y;
                        pc.pointCount = pointCount;
                        pc.radiusA = radiusA;
                        pc.radiusB = radiusB;
                        pc.type = manifold.type;
                        this.m_positionConstraints[i] = pc;
                        for (var j = 0; j < pointCount; ++j) {
                            var cp = manifold.points[j];
                            var vcp = vc.points[j];
                            if (this.m_step.warmStarting) {
                                vcp.normalImpulse = this.m_step.dtRatio * cp.normalImpulse;
                                vcp.tangentImpulse = this.m_step.dtRatio * cp.tangentImpulse;
                            } else {
                                vcp.normalImpulse = 0;
                                vcp.tangentImpulse = 0;
                            }
                            vcp.rA.SetZero();
                            vcp.rB.SetZero();
                            vcp.normalMass = 0;
                            vcp.tangentMass = 0;
                            vcp.velocityBias = 0;
                            pc.localPoints[j] = cp.localPoint;
                        }
                    }
                },
                InitializeVelocityConstraints: function() {
                    for (var i = 0; i < this.m_count; ++i) {
                        var vc = this.m_velocityConstraints[i];
                        var pc = this.m_positionConstraints[i];
                        var radiusA = pc.radiusA;
                        var radiusB = pc.radiusB;
                        var manifold = this.m_contacts[vc.contactIndex].GetManifold();
                        var indexA = vc.indexA;
                        var indexB = vc.indexB;
                        var mA = vc.invMassA;
                        var mB = vc.invMassB;
                        var iA = vc.invIA;
                        var iB = vc.invIB;
                        var localCenterA = pc.localCenterA;
                        var localCenterB = pc.localCenterB;
                        var cA = this.m_positions[indexA].c;
                        var aA = this.m_positions[indexA].a;
                        var vA = this.m_velocities[indexA].v;
                        var wA = this.m_velocities[indexA].w;
                        var cB = this.m_positions[indexB].c;
                        var aB = this.m_positions[indexB].a;
                        var vB = this.m_velocities[indexB].v;
                        var wB = this.m_velocities[indexB].w;
                        b2Assert(manifold.pointCount > 0);
                        b2ContactSolver.cs_xfA.q.Set(aA);
                        b2ContactSolver.cs_xfB.q.Set(aB);
                        b2ContactSolver.cs_xfA.p.x = cA.x - (b2ContactSolver.cs_xfA.q.c * localCenterA.x - b2ContactSolver.cs_xfA.q.s * localCenterA.y);
                        b2ContactSolver.cs_xfA.p.y = cA.y - (b2ContactSolver.cs_xfA.q.s * localCenterA.x + b2ContactSolver.cs_xfA.q.c * localCenterA.y);
                        b2ContactSolver.cs_xfB.p.x = cB.x - (b2ContactSolver.cs_xfB.q.c * localCenterB.x - b2ContactSolver.cs_xfB.q.s * localCenterB.y);
                        b2ContactSolver.cs_xfB.p.y = cB.y - (b2ContactSolver.cs_xfB.q.s * localCenterB.x + b2ContactSolver.cs_xfB.q.c * localCenterB.y);
                        var worldManifold = new b2WorldManifold();
                        worldManifold.Initialize(manifold, b2ContactSolver.cs_xfA, radiusA, b2ContactSolver.cs_xfB, radiusB);
                        vc.normal.x = worldManifold.normal.x;
                        vc.normal.y = worldManifold.normal.y;
                        var pointCount = vc.pointCount;
                        for (var j = 0; j < pointCount; ++j) {
                            var vcp = vc.points[j];
                            vcp.rA.x = worldManifold.points[j].x - cA.x;
                            vcp.rA.y = worldManifold.points[j].y - cA.y;
                            vcp.rB.x = worldManifold.points[j].x - cB.x;
                            vcp.rB.y = worldManifold.points[j].y - cB.y;
                            var rnA = vcp.rA.x * vc.normal.y - vcp.rA.y * vc.normal.x;
                            var rnB = vcp.rB.x * vc.normal.y - vcp.rB.y * vc.normal.x;
                            var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                            vcp.normalMass = kNormal > 0 ? 1 / kNormal : 0;
                            var tangentx = 1 * vc.normal.y;
                            var tangenty = -1 * vc.normal.x;
                            var rtA = vcp.rA.x * tangenty - vcp.rA.y * tangentx;
                            var rtB = vcp.rB.x * tangenty - vcp.rB.y * tangentx;
                            var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;
                            vcp.tangentMass = kTangent > 0 ? 1 / kTangent : 0;
                            vcp.velocityBias = 0;
                            var vRel = vc.normal.x * (vB.x + -wB * vcp.rB.y - vA.x - -wA * vcp.rA.y) + vc.normal.y * (vB.y + wB * vcp.rB.x - vA.y - wA * vcp.rA.x);
                            vRel < -b2_velocityThreshold && (vcp.velocityBias = -vc.restitution * vRel);
                        }
                        if (2 == vc.pointCount) {
                            var vcp1 = vc.points[0];
                            var vcp2 = vc.points[1];
                            var rn1A = vcp1.rA.x * vc.normal.y - vcp1.rA.y * vc.normal.x;
                            var rn1B = vcp1.rB.x * vc.normal.y - vcp1.rB.y * vc.normal.x;
                            var rn2A = vcp2.rA.x * vc.normal.y - vcp2.rA.y * vc.normal.x;
                            var rn2B = vcp2.rB.x * vc.normal.y - vcp2.rB.y * vc.normal.x;
                            var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
                            var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
                            var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;
                            var k_maxConditionNumber = 1e3;
                            if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                                vc.K.ex.x = k11;
                                vc.K.ex.y = k12;
                                vc.K.ey.x = k12;
                                vc.K.ey.y = k22;
                                vc.normalMass.Assign(vc.K.GetInverse());
                            } else {
                                vc.pointCount = 1;
                            }
                        }
                    }
                },
                WarmStart: function() {
                    for (var i = 0; i < this.m_count; ++i) {
                        var vc = this.m_velocityConstraints[i];
                        var indexA = vc.indexA;
                        var indexB = vc.indexB;
                        var mA = vc.invMassA;
                        var iA = vc.invIA;
                        var mB = vc.invMassB;
                        var iB = vc.invIB;
                        var pointCount = vc.pointCount;
                        var vA = this.m_velocities[indexA].v;
                        var wA = this.m_velocities[indexA].w;
                        var vB = this.m_velocities[indexB].v;
                        var wB = this.m_velocities[indexB].w;
                        var normal = vc.normal;
                        var tangentx = 1 * normal.y;
                        var tangenty = -1 * normal.x;
                        for (var j = 0; j < pointCount; ++j) {
                            var vcp = vc.points[j];
                            var Px = vcp.normalImpulse * normal.x + vcp.tangentImpulse * tangentx;
                            var Py = vcp.normalImpulse * normal.y + vcp.tangentImpulse * tangenty;
                            wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
                            vA.x -= mA * Px;
                            vA.y -= mA * Py;
                            wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
                            vB.x += mB * Px;
                            vB.y += mB * Py;
                        }
                        this.m_velocities[indexA].w = wA;
                        this.m_velocities[indexB].w = wB;
                    }
                },
                SolveVelocityConstraints: function() {
                    for (var i = 0; i < this.m_count; ++i) {
                        var vc = this.m_velocityConstraints[i];
                        var indexA = vc.indexA;
                        var indexB = vc.indexB;
                        var mA = vc.invMassA;
                        var iA = vc.invIA;
                        var mB = vc.invMassB;
                        var iB = vc.invIB;
                        var pointCount = vc.pointCount;
                        var vA = this.m_velocities[indexA].v;
                        var wA = this.m_velocities[indexA].w;
                        var vB = this.m_velocities[indexB].v;
                        var wB = this.m_velocities[indexB].w;
                        var normal = vc.normal;
                        var tangentx = 1 * normal.y;
                        var tangenty = -1 * normal.x;
                        var friction = vc.friction;
                        b2Assert(1 == pointCount || 2 == pointCount);
                        for (var j = 0; j < pointCount; ++j) {
                            var vcp = vc.points[j];
                            var dvx = vB.x + -wB * vcp.rB.y - vA.x - -wA * vcp.rA.y;
                            var dvy = vB.y + wB * vcp.rB.x - vA.y - wA * vcp.rA.x;
                            var vt = dvx * tangentx + dvy * tangenty - vc.tangentSpeed;
                            var lambda = vcp.tangentMass * -vt;
                            var maxFriction = friction * vcp.normalImpulse;
                            var newImpulse = b2Clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);
                            lambda = newImpulse - vcp.tangentImpulse;
                            vcp.tangentImpulse = newImpulse;
                            var Px = lambda * tangentx;
                            var Py = lambda * tangenty;
                            vA.x -= mA * Px;
                            vA.y -= mA * Py;
                            wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
                            vB.x += mB * Px;
                            vB.y += mB * Py;
                            wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
                        }
                        if (1 == vc.pointCount) {
                            vcp = vc.points[0];
                            dvx = vB.x + -wB * vcp.rB.y - vA.x - -wA * vcp.rA.y;
                            dvy = vB.y + wB * vcp.rB.x - vA.y - wA * vcp.rA.x;
                            var vn = dvx * normal.x + dvy * normal.y;
                            var lambda = -vcp.normalMass * (vn - vcp.velocityBias);
                            var newImpulse = b2Max(vcp.normalImpulse + lambda, 0);
                            lambda = newImpulse - vcp.normalImpulse;
                            vcp.normalImpulse = newImpulse;
                            Px = lambda * normal.x;
                            Py = lambda * normal.y;
                            vA.x -= mA * Px;
                            vA.y -= mA * Py;
                            wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
                            vB.x += mB * Px;
                            vB.y += mB * Py;
                            wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
                        } else {
                            var cp1 = vc.points[0];
                            var cp2 = vc.points[1];
                            var ax = cp1.normalImpulse;
                            var ay = cp2.normalImpulse;
                            b2Assert(ax >= 0 && ay >= 0);
                            var dv1x = vB.x + -wB * cp1.rB.y - vA.x - -wA * cp1.rA.y;
                            var dv1y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
                            var dv2x = vB.x + -wB * cp2.rB.y - vA.x - -wA * cp2.rA.y;
                            var dv2y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
                            var vn1 = dv1x * normal.x + dv1y * normal.y;
                            var vn2 = dv2x * normal.x + dv2y * normal.y;
                            var bx = vn1 - cp1.velocityBias;
                            var by = vn2 - cp2.velocityBias;
                            bx -= vc.K.ex.x * ax + vc.K.ey.x * ay;
                            by -= vc.K.ex.y * ax + vc.K.ey.y * ay;
                            for (;;) {
                                var xx = -(vc.normalMass.ex.x * bx + vc.normalMass.ey.x * by);
                                var xy = -(vc.normalMass.ex.y * bx + vc.normalMass.ey.y * by);
                                if (xx >= 0 && xy >= 0) {
                                    var dx = xx - ax;
                                    var dy = xy - ay;
                                    var P1x = dx * normal.x;
                                    var P1y = dx * normal.y;
                                    var P2x = dy * normal.x;
                                    var P2y = dy * normal.y;
                                    vA.x -= mA * (P1x + P2x);
                                    vA.y -= mA * (P1y + P2y);
                                    wA -= iA * (cp1.rA.x * P1y - cp1.rA.y * P1x + (cp2.rA.x * P2y - cp2.rA.y * P2x));
                                    vB.x += mB * (P1x + P2x);
                                    vB.y += mB * (P1y + P2y);
                                    wB += iB * (cp1.rB.x * P1y - cp1.rB.y * P1x + (cp2.rB.x * P2y - cp2.rB.y * P2x));
                                    cp1.normalImpulse = xx;
                                    cp2.normalImpulse = xy;
                                    break;
                                }
                                xx = -cp1.normalMass * bx;
                                xy = 0;
                                vn1 = 0;
                                vn2 = vc.K.ex.y * xx + by;
                                if (xx >= 0 && vn2 >= 0) {
                                    dx = xx - ax;
                                    dy = xy - ay;
                                    P1x = dx * normal.x;
                                    P1y = dx * normal.y;
                                    P2x = dy * normal.x;
                                    P2y = dy * normal.y;
                                    vA.x -= mA * (P1x + P2x);
                                    vA.y -= mA * (P1y + P2y);
                                    wA -= iA * (cp1.rA.x * P1y - cp1.rA.y * P1x + (cp2.rA.x * P2y - cp2.rA.y * P2x));
                                    vB.x += mB * (P1x + P2x);
                                    vB.y += mB * (P1y + P2y);
                                    wB += iB * (cp1.rB.x * P1y - cp1.rB.y * P1x + (cp2.rB.x * P2y - cp2.rB.y * P2x));
                                    cp1.normalImpulse = xx;
                                    cp2.normalImpulse = xy;
                                    break;
                                }
                                xx = 0;
                                xy = -cp2.normalMass * by;
                                vn1 = vc.K.ey.x * xy + bx;
                                vn2 = 0;
                                if (xy >= 0 && vn1 >= 0) {
                                    dx = xx - ax;
                                    dy = xy - ay;
                                    P1x = dx * normal.x;
                                    P1y = dx * normal.y;
                                    P2x = dy * normal.x;
                                    P2y = dy * normal.y;
                                    vA.x -= mA * (P1x + P2x);
                                    vA.y -= mA * (P1y + P2y);
                                    wA -= iA * (cp1.rA.x * P1y - cp1.rA.y * P1x + (cp2.rA.x * P2y - cp2.rA.y * P2x));
                                    vB.x += mB * (P1x + P2x);
                                    vB.y += mB * (P1y + P2y);
                                    wB += iB * (cp1.rB.x * P1y - cp1.rB.y * P1x + (cp2.rB.x * P2y - cp2.rB.y * P2x));
                                    cp1.normalImpulse = xx;
                                    cp2.normalImpulse = xy;
                                    break;
                                }
                                xx = 0;
                                xy = 0;
                                vn1 = bx;
                                vn2 = by;
                                if (vn1 >= 0 && vn2 >= 0) {
                                    dx = xx - ax;
                                    dy = xy - ay;
                                    P1x = dx * normal.x;
                                    P1y = dx * normal.y;
                                    P2x = dy * normal.x;
                                    P2y = dy * normal.y;
                                    vA.x -= mA * (P1x + P2x);
                                    vA.y -= mA * (P1y + P2y);
                                    wA -= iA * (cp1.rA.x * P1y - cp1.rA.y * P1x + (cp2.rA.x * P2y - cp2.rA.y * P2x));
                                    vB.x += mB * (P1x + P2x);
                                    vB.y += mB * (P1y + P2y);
                                    wB += iB * (cp1.rB.x * P1y - cp1.rB.y * P1x + (cp2.rB.x * P2y - cp2.rB.y * P2x));
                                    cp1.normalImpulse = xx;
                                    cp2.normalImpulse = xy;
                                    break;
                                }
                                break;
                            }
                        }
                        this.m_velocities[indexA].w = wA;
                        this.m_velocities[indexB].w = wB;
                    }
                },
                StoreImpulses: function() {
                    for (var i = 0; i < this.m_count; ++i) {
                        var vc = this.m_velocityConstraints[i];
                        var manifold = this.m_contacts[vc.contactIndex].GetManifold();
                        for (var j = 0; j < vc.pointCount; ++j) {
                            manifold.points[j].normalImpulse = vc.points[j].normalImpulse;
                            manifold.points[j].tangentImpulse = vc.points[j].tangentImpulse;
                        }
                    }
                },
                SolvePositionConstraints: function() {
                    var minSeparation = 0;
                    for (var i = 0; i < this.m_count; ++i) {
                        var pc = this.m_positionConstraints[i];
                        var indexA = pc.indexA;
                        var indexB = pc.indexB;
                        var localCenterA = pc.localCenterA;
                        var mA = pc.invMassA;
                        var iA = pc.invIA;
                        var localCenterB = pc.localCenterB;
                        var mB = pc.invMassB;
                        var iB = pc.invIB;
                        var pointCount = pc.pointCount;
                        var cA = this.m_positions[indexA].c;
                        var aA = this.m_positions[indexA].a;
                        var cB = this.m_positions[indexB].c;
                        var aB = this.m_positions[indexB].a;
                        for (var j = 0; j < pointCount; ++j) {
                            b2ContactSolver.cs_xfA.q.Set(aA);
                            b2ContactSolver.cs_xfB.q.Set(aB);
                            b2ContactSolver.cs_xfA.p.x = cA.x - (b2ContactSolver.cs_xfA.q.c * localCenterA.x - b2ContactSolver.cs_xfA.q.s * localCenterA.y);
                            b2ContactSolver.cs_xfA.p.y = cA.y - (b2ContactSolver.cs_xfA.q.s * localCenterA.x + b2ContactSolver.cs_xfA.q.c * localCenterA.y);
                            b2ContactSolver.cs_xfB.p.x = cB.x - (b2ContactSolver.cs_xfB.q.c * localCenterB.x - b2ContactSolver.cs_xfB.q.s * localCenterB.y);
                            b2ContactSolver.cs_xfB.p.y = cB.y - (b2ContactSolver.cs_xfB.q.s * localCenterB.x + b2ContactSolver.cs_xfB.q.c * localCenterB.y);
                            b2ContactSolver.temp_solver_manifold.Initialize(pc, b2ContactSolver.cs_xfA, b2ContactSolver.cs_xfB, j);
                            var normal = b2ContactSolver.temp_solver_manifold.normal;
                            var point = b2ContactSolver.temp_solver_manifold.point;
                            var separation = b2ContactSolver.temp_solver_manifold.separation;
                            var rAx = point.x - cA.x;
                            var rAy = point.y - cA.y;
                            var rBx = point.x - cB.x;
                            var rBy = point.y - cB.y;
                            minSeparation = b2Min(minSeparation, separation);
                            var C = b2Clamp(b2_baumgarte * (separation + b2_linearSlop), -b2_maxLinearCorrection, 0);
                            var rnA = rAx * normal.y - rAy * normal.x;
                            var rnB = rBx * normal.y - rBy * normal.x;
                            var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                            var impulse = K > 0 ? -C / K : 0;
                            var Px = impulse * normal.x;
                            var Py = impulse * normal.y;
                            cA.x -= mA * Px;
                            cA.y -= mA * Py;
                            aA -= iA * (rAx * Py - rAy * Px);
                            cB.x += mB * Px;
                            cB.y += mB * Py;
                            aB += iB * (rBx * Py - rBy * Px);
                        }
                        this.m_positions[indexA].a = aA;
                        this.m_positions[indexB].a = aB;
                    }
                    return minSeparation >= -3 * b2_linearSlop;
                },
                SolveTOIPositionConstraints: function(toiIndexA, toiIndexB) {
                    var minSeparation = 0;
                    for (var i = 0; i < this.m_count; ++i) {
                        var pc = this.m_positionConstraints[i];
                        var indexA = pc.indexA;
                        var indexB = pc.indexB;
                        var localCenterA = pc.localCenterA;
                        var localCenterB = pc.localCenterB;
                        var pointCount = pc.pointCount;
                        var mA = 0;
                        var iA = 0;
                        if (indexA == toiIndexA || indexA == toiIndexB) {
                            mA = pc.invMassA;
                            iA = pc.invIA;
                        }
                        var mB = 0;
                        var iB = 0;
                        if (indexB == toiIndexA || indexB == toiIndexB) {
                            mB = pc.invMassB;
                            iB = pc.invIB;
                        }
                        var cA = this.m_positions[indexA].c;
                        var aA = this.m_positions[indexA].a;
                        var cB = this.m_positions[indexB].c;
                        var aB = this.m_positions[indexB].a;
                        for (var j = 0; j < pointCount; ++j) {
                            b2ContactSolver.cs_xfA.q.Set(aA);
                            b2ContactSolver.cs_xfB.q.Set(aB);
                            b2ContactSolver.cs_xfA.p.Assign(b2Vec2.Subtract(cA, b2Mul_r_v2(b2ContactSolver.cs_xfA.q, localCenterA)));
                            b2ContactSolver.cs_xfB.p.Assign(b2Vec2.Subtract(cB, b2Mul_r_v2(b2ContactSolver.cs_xfB.q, localCenterB)));
                            b2ContactSolver.temp_solver_manifold.Initialize(pc, b2ContactSolver.cs_xfA, b2ContactSolver.cs_xfB, j);
                            var normal = b2ContactSolver.temp_solver_manifold.normal;
                            var point = b2ContactSolver.temp_solver_manifold.point;
                            var separation = b2ContactSolver.temp_solver_manifold.separation;
                            var rA = b2Vec2.Subtract(point, cA);
                            var rB = b2Vec2.Subtract(point, cB);
                            minSeparation = b2Min(minSeparation, separation);
                            var C = b2Clamp(b2_toiBaugarte * (separation + b2_linearSlop), -b2_maxLinearCorrection, 0);
                            var rnA = b2Cross_v2_v2(rA, normal);
                            var rnB = b2Cross_v2_v2(rB, normal);
                            var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                            var impulse = K > 0 ? -C / K : 0;
                            var P = b2Vec2.Multiply(impulse, normal);
                            cA.Subtract(b2Vec2.Multiply(mA, P));
                            aA -= iA * b2Cross_v2_v2(rA, P);
                            cB.Add(b2Vec2.Multiply(mB, P));
                            aB += iB * b2Cross_v2_v2(rB, P);
                        }
                        this.m_positions[indexA].a = aA;
                        this.m_positions[indexB].a = aB;
                    }
                    return minSeparation >= -1.5 * b2_linearSlop;
                }
            };
            function b2Island() {
                this.m_bodies = [];
                this.m_contacts = [];
                this.m_joints = [];
                this.m_velocities = [];
                this.m_positions = [];
            }
            var profile_solve_init = b2Profiler.create("solve initialization", "solve");
            var profile_solve_init_warmStarting = b2Profiler.create("warm starting", "solve initialization");
            var profile_solve_velocity = b2Profiler.create("solve velocities", "solve");
            var profile_solve_position = b2Profiler.create("solve positions", "solve");
            b2Island._solverData = new b2SolverData();
            b2Island._solverDef = new b2ContactSolverDef();
            b2Island._solver = new b2ContactSolver();
            b2Island.prototype = {
                Clear: function() {
                    this.m_bodyCount = 0;
                    this.m_contactCount = 0;
                    this.m_jointCount = 0;
                },
                Initialize: function(bodyCapacity, contactCapacity, jointCapacity, listener) {
                    this.m_listener = listener;
                    this.m_bodyCapacity = bodyCapacity;
                    this.m_contactCapacity = contactCapacity;
                    this.m_jointCapacity = jointCapacity;
                    this.m_bodyCount = 0;
                    this.m_contactCount = 0;
                    this.m_jointCount = 0;
                    this.m_bodies.length = bodyCapacity;
                    this.m_contacts.length = contactCapacity;
                    this.m_joints.length = jointCapacity;
                    this.m_velocities.length = bodyCapacity;
                    this.m_positions.length = bodyCapacity;
                },
                Solve: function(step, gravity, allowSleep) {
                    profile_solve_init.start();
                    var h = step.dt;
                    for (var i = 0; i < this.m_bodyCount; ++i) {
                        var b = this.m_bodies[i];
                        this.m_positions[i].c.Assign(b.m_sweep.c);
                        var a = b.m_sweep.a;
                        this.m_velocities[i].v.Assign(b.m_linearVelocity);
                        var w = b.m_angularVelocity;
                        b.m_sweep.c0.Assign(b.m_sweep.c);
                        b.m_sweep.a0 = b.m_sweep.a;
                        if (b.m_type == b2Body.b2_dynamicBody) {
                            this.m_velocities[i].v.x += h * (b.m_gravityScale * gravity.x + b.m_invMass * b.m_force.x);
                            this.m_velocities[i].v.y += h * (b.m_gravityScale * gravity.y + b.m_invMass * b.m_force.y);
                            w += h * b.m_invI * b.m_torque;
                            this.m_velocities[i].v.x *= 1 / (1 + h * b.m_linearDamping);
                            this.m_velocities[i].v.y *= 1 / (1 + h * b.m_linearDamping);
                            w *= 1 / (1 + h * b.m_angularDamping);
                        }
                        this.m_positions[i].a = a;
                        this.m_velocities[i].w = w;
                    }
                    b2Island._solverData.step = step;
                    b2Island._solverData.positions = this.m_positions;
                    b2Island._solverData.velocities = this.m_velocities;
                    b2Island._solverDef.step = step;
                    b2Island._solverDef.contacts = this.m_contacts;
                    b2Island._solverDef.count = this.m_contactCount;
                    b2Island._solverDef.positions = this.m_positions;
                    b2Island._solverDef.velocities = this.m_velocities;
                    b2Island._solverDef.allocator = this.m_allocator;
                    b2Island._solver.Init(b2Island._solverDef);
                    b2Island._solver.InitializeVelocityConstraints();
                    if (step.warmStarting) {
                        profile_solve_init_warmStarting.start();
                        b2Island._solver.WarmStart();
                        profile_solve_init_warmStarting.stop();
                    }
                    for (var i = 0; i < this.m_jointCount; ++i) {
                        this.m_joints[i].InitVelocityConstraints(b2Island._solverData);
                    }
                    profile_solve_init.stop();
                    profile_solve_velocity.start();
                    for (var i = 0; i < step.velocityIterations; ++i) {
                        for (var j = 0; j < this.m_jointCount; ++j) {
                            this.m_joints[j].SolveVelocityConstraints(b2Island._solverData);
                        }
                        b2Island._solver.SolveVelocityConstraints();
                    }
                    b2Island._solver.StoreImpulses();
                    profile_solve_velocity.stop();
                    profile_solve_position.start();
                    for (var i = 0; i < this.m_bodyCount; ++i) {
                        var c = this.m_positions[i].c;
                        var a = this.m_positions[i].a;
                        var v = this.m_velocities[i].v;
                        var w = this.m_velocities[i].w;
                        var translationx = h * v.x;
                        var translationy = h * v.y;
                        var translationl = translationx * translationx + translationy * translationy;
                        if (translationl > b2_maxTranslationSquared) {
                            var ratio = b2_maxTranslation / b2Sqrt(translationl);
                            v.x *= ratio;
                            v.y *= ratio;
                        }
                        var rotation = h * w;
                        if (rotation * rotation > b2_maxRotationSquared) {
                            var ratio = b2_maxRotation / b2Abs(rotation);
                            w *= ratio;
                        }
                        c.x += h * v.x;
                        c.y += h * v.y;
                        a += h * w;
                        this.m_positions[i].a = a;
                        this.m_velocities[i].w = w;
                    }
                    var positionSolved = false;
                    for (var i = 0; i < step.positionIterations; ++i) {
                        var contactsOkay = b2Island._solver.SolvePositionConstraints();
                        var jointsOkay = true;
                        for (var j = 0; j < this.m_jointCount; ++j) {
                            var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Island._solverData);
                            jointsOkay = jointsOkay && jointOkay;
                        }
                        if (contactsOkay && jointsOkay) {
                            positionSolved = true;
                            break;
                        }
                    }
                    for (var i = 0; i < this.m_bodyCount; ++i) {
                        var body = this.m_bodies[i];
                        body.m_sweep.c.Assign(this.m_positions[i].c);
                        body.m_sweep.a = this.m_positions[i].a;
                        body.m_linearVelocity.Assign(this.m_velocities[i].v);
                        body.m_angularVelocity = this.m_velocities[i].w;
                        body.SynchronizeTransform();
                    }
                    profile_solve_position.stop();
                    this.Report(b2Island._solver.m_velocityConstraints);
                    if (allowSleep) {
                        var minSleepTime = b2_maxFloat;
                        var linTolSqr = b2_linearSleepTolerance * b2_linearSleepTolerance;
                        var angTolSqr = b2_angularSleepTolerance * b2_angularSleepTolerance;
                        for (var i = 0; i < this.m_bodyCount; ++i) {
                            var b = this.m_bodies[i];
                            if (b.GetType() == b2Body.b2_staticBody) {
                                continue;
                            }
                            if (0 == (b.m_flags & b2Body.e_autoSleepFlag) || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Dot_v2_v2(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
                                b.m_sleepTime = 0;
                                minSleepTime = 0;
                            } else {
                                b.m_sleepTime += h;
                                minSleepTime = b2Min(minSleepTime, b.m_sleepTime);
                            }
                        }
                        if (minSleepTime >= b2_timeToSleep && positionSolved) {
                            for (var i = 0; i < this.m_bodyCount; ++i) {
                                var b = this.m_bodies[i];
                                b.SetAwake(false);
                            }
                        }
                    }
                },
                SolveTOI: function(subStep, toiIndexA, toiIndexB) {
                    b2Assert(toiIndexA < this.m_bodyCount);
                    b2Assert(toiIndexB < this.m_bodyCount);
                    for (var i = 0; i < this.m_bodyCount; ++i) {
                        var b = this.m_bodies[i];
                        this.m_positions[i].c.Assign(b.m_sweep.c);
                        this.m_positions[i].a = b.m_sweep.a;
                        this.m_velocities[i].v.Assign(b.m_linearVelocity);
                        this.m_velocities[i].w = b.m_angularVelocity;
                    }
                    b2Island._solverDef.contacts = this.m_contacts;
                    b2Island._solverDef.count = this.m_contactCount;
                    b2Island._solverDef.step = subStep;
                    b2Island._solverDef.positions = this.m_positions;
                    b2Island._solverDef.velocities = this.m_velocities;
                    b2Island._solver.Init(b2Island._solverDef);
                    for (var i = 0; i < subStep.positionIterations; ++i) {
                        var contactsOkay = b2Island._solver.SolveTOIPositionConstraints(toiIndexA, toiIndexB);
                        if (contactsOkay) {
                            break;
                        }
                    }
                    this.m_bodies[toiIndexA].m_sweep.c0.Assign(this.m_positions[toiIndexA].c);
                    this.m_bodies[toiIndexA].m_sweep.a0 = this.m_positions[toiIndexA].a;
                    this.m_bodies[toiIndexB].m_sweep.c0.Assign(this.m_positions[toiIndexB].c);
                    this.m_bodies[toiIndexB].m_sweep.a0 = this.m_positions[toiIndexB].a;
                    b2Island._solver.InitializeVelocityConstraints();
                    for (var i = 0; i < subStep.velocityIterations; ++i) {
                        b2Island._solver.SolveVelocityConstraints();
                    }
                    var h = subStep.dt;
                    for (var i = 0; i < this.m_bodyCount; ++i) {
                        var c = this.m_positions[i].c;
                        var a = this.m_positions[i].a;
                        var v = this.m_velocities[i].v;
                        var w = this.m_velocities[i].w;
                        var translation = b2Vec2.Multiply(h, v);
                        if (b2Dot_v2_v2(translation, translation) > b2_maxTranslationSquared) {
                            var ratio = b2_maxTranslation / translation.Length();
                            v.Multiply(ratio);
                        }
                        var rotation = h * w;
                        if (rotation * rotation > b2_maxRotationSquared) {
                            var ratio = b2_maxRotation / b2Abs(rotation);
                            w *= ratio;
                        }
                        c.Add(b2Vec2.Multiply(h, v));
                        a += h * w;
                        this.m_positions[i].a = a;
                        this.m_velocities[i].w = w;
                        var body = this.m_bodies[i];
                        body.m_sweep.c.Assign(c);
                        body.m_sweep.a = a;
                        body.m_linearVelocity.Assign(v);
                        body.m_angularVelocity = w;
                        body.SynchronizeTransform();
                    }
                    this.Report(b2Island._solver.m_velocityConstraints);
                },
                AddBody: function(body) {
                    b2Assert(this.m_bodyCount < this.m_bodyCapacity);
                    body.m_islandIndex = this.m_bodyCount;
                    this.m_bodies[this.m_bodyCount] = body;
                    if (!this.m_positions[this.m_bodyCount]) {
                        this.m_positions[this.m_bodyCount] = new b2Position();
                        this.m_velocities[this.m_bodyCount] = new b2Velocity();
                    }
                    ++this.m_bodyCount;
                },
                AddContact: function(contact) {
                    b2Assert(this.m_contactCount < this.m_contactCapacity);
                    this.m_contacts[this.m_contactCount++] = contact;
                },
                AddJoint: function(joint) {
                    b2Assert(this.m_jointCount < this.m_jointCapacity);
                    this.m_joints[this.m_jointCount++] = joint;
                },
                Report: function(constraints) {
                    if (null == this.m_listener) {
                        return;
                    }
                    for (var i = 0; i < this.m_contactCount; ++i) {
                        var c = this.m_contacts[i];
                        var vc = constraints[i];
                        var impulse = new b2ContactImpulse();
                        impulse.count = vc.pointCount;
                        for (var j = 0; j < vc.pointCount; ++j) {
                            impulse.normalImpulses[j] = vc.points[j].normalImpulse;
                            impulse.tangentImpulses[j] = vc.points[j].tangentImpulse;
                        }
                        this.m_listener.PostSolve(c, impulse);
                    }
                }
            };
            function b2Jacobian() {
                this.linear = new b2Vec2();
                this.angularA = 0;
                this.angularB = 0;
            }
            function b2JointEdge() {
                this.other = null;
                this.joint = null;
                this.prev = null;
                this.next = null;
            }
            function b2JointDef() {
                this.type = b2Joint.e_unknownJoint;
                this.userData = null;
                this.bodyA = null;
                this.bodyB = null;
                this.collideConnected = false;
            }
            b2JointDef.prototype = {
                _deserialize: function(data, bodies, joints) {
                    this.bodyA = bodies[data["bodyA"]];
                    this.bodyB = bodies[data["bodyB"]];
                    this.collideConnected = data["collideConnected"];
                }
            };
            function b2Joint(def) {
                b2Assert(def.bodyA != def.bodyB);
                this.m_type = def.type;
                this.m_prev = null;
                this.m_next = null;
                this.m_bodyA = def.bodyA;
                this.m_bodyB = def.bodyB;
                this.m_index = 0;
                this.m_collideConnected = def.collideConnected;
                this.m_islandFlag = false;
                this.m_userData = def.userData;
                this.m_edgeA = new b2JointEdge();
                this.m_edgeA.joint = null;
                this.m_edgeA.other = null;
                this.m_edgeA.prev = null;
                this.m_edgeA.next = null;
                this.m_edgeB = new b2JointEdge();
                this.m_edgeB.joint = null;
                this.m_edgeB.other = null;
                this.m_edgeB.prev = null;
                this.m_edgeB.next = null;
            }
            b2Joint.prototype = {
                GetType: function() {
                    return this.m_type;
                },
                GetBodyA: function() {
                    return this.m_bodyA;
                },
                GetBodyB: function() {
                    return this.m_bodyB;
                },
                GetAnchorA: function() {},
                GetAnchorB: function() {},
                GetReactionForce: function(inv_dt) {},
                GetReactionTorque: function(inv_dt) {},
                GetNext: function() {
                    return this.m_next;
                },
                GetUserData: function() {
                    return this.m_userData;
                },
                SetUserData: function(data) {
                    this.m_userData = data;
                },
                IsActive: function() {
                    return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
                },
                GetCollideConnected: function() {
                    return this.m_collideConnected;
                },
                ShiftOrigin: function(newOrigin) {},
                InitVelocityConstraints: function(data) {},
                SolveVelocityConstraints: function(data) {},
                SolvePositionConstraints: function(data) {},
                _serialize: function(out) {
                    var obj = out || {};
                    obj["bodyA"] = null;
                    obj["bodyB"] = null;
                    obj["type"] = this.m_type;
                    obj["collideConnected"] = this.m_collideConnected;
                    return obj;
                }
            };
            b2Joint.e_inactiveLimit = 0;
            b2Joint.e_atLowerLimit = 1;
            b2Joint.e_atUpperLimit = 2;
            b2Joint.e_equalLimits = 3;
            b2Joint.e_unknownJoint = 0;
            b2Joint.e_revoluteJoint = 1;
            b2Joint.e_prismaticJoint = 2;
            b2Joint.e_distanceJoint = 3;
            b2Joint.e_pulleyJoint = 4;
            b2Joint.e_mouseJoint = 5;
            b2Joint.e_gearJoint = 6;
            b2Joint.e_wheelJoint = 7;
            b2Joint.e_weldJoint = 8;
            b2Joint.e_frictionJoint = 9;
            b2Joint.e_ropeJoint = 10;
            b2Joint.e_motorJoint = 11;
            b2Joint.Create = function(def) {
                var joint = null;
                switch (def.type) {
                  case b2Joint.e_distanceJoint:
                    joint = new b2DistanceJoint(def);
                    break;

                  case b2Joint.e_mouseJoint:
                    joint = new b2MouseJoint(def);
                    break;

                  case b2Joint.e_prismaticJoint:
                    joint = new b2PrismaticJoint(def);
                    break;

                  case b2Joint.e_revoluteJoint:
                    joint = new b2RevoluteJoint(def);
                    break;

                  case b2Joint.e_pulleyJoint:
                    joint = new b2PulleyJoint(def);
                    break;

                  case b2Joint.e_gearJoint:
                    joint = new b2GearJoint(def);
                    break;

                  case b2Joint.e_wheelJoint:
                    joint = new b2WheelJoint(def);
                    break;

                  case b2Joint.e_weldJoint:
                    joint = new b2WeldJoint(def);
                    break;

                  case b2Joint.e_frictionJoint:
                    joint = new b2FrictionJoint(def);
                    break;

                  case b2Joint.e_ropeJoint:
                    joint = new b2RopeJoint(def);
                    break;

                  case b2Joint.e_motorJoint:
                    joint = new b2MotorJoint(def);
                    break;

                  default:
                    b2Assert(false);
                }
                return joint;
            };
            b2Joint.Destroy = function(joint) {};
            function b2RevoluteJointDef() {
                this.parent.call(this);
                this.type = b2Joint.e_revoluteJoint;
                this.localAnchorA = new b2Vec2();
                this.localAnchorB = new b2Vec2();
                this.referenceAngle = 0;
                this.lowerAngle = 0;
                this.upperAngle = 0;
                this.maxMotorTorque = 0;
                this.motorSpeed = 0;
                this.enableLimit = false;
                this.enableMotor = false;
                Object.seal(this);
            }
            b2RevoluteJointDef.prototype = {
                Initialize: function(bA, bB, anchor) {
                    this.bodyA = bA;
                    this.bodyB = bB;
                    this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
                    this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
                    this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
                },
                _deserialize: function(data, bodies, joints) {
                    this.parent.prototype._deserialize.call(this, data, bodies, joints);
                    this.localAnchorA._deserialize(data["localAnchorA"]);
                    this.localAnchorB._deserialize(data["localAnchorB"]);
                    this.referenceAngle = data["referenceAngle"];
                    this.lowerAngle = data["lowerAngle"];
                    this.upperAngle = data["upperAngle"];
                    this.maxMotorTorque = data["maxMotorTorque"];
                    this.motorSpeed = data["motorSpeed"];
                    this.enableLimit = data["enableLimit"];
                    this.enableMotor = data["enableMotor"];
                }
            };
            b2RevoluteJointDef._extend(b2JointDef);
            function b2RevoluteJoint(def) {
                this.parent.call(this, def);
                this.m_localAnchorA = def.localAnchorA.Clone();
                this.m_localAnchorB = def.localAnchorB.Clone();
                this.m_referenceAngle = def.referenceAngle;
                this.m_impulse = new b2Vec3();
                this.m_motorImpulse = 0;
                this.m_lowerAngle = def.lowerAngle;
                this.m_upperAngle = def.upperAngle;
                this.m_maxMotorTorque = def.maxMotorTorque;
                this.m_motorSpeed = def.motorSpeed;
                this.m_enableLimit = def.enableLimit;
                this.m_enableMotor = def.enableMotor;
                this.m_limitState = b2Joint.e_inactiveLimit;
                this.m_indexA = 0;
                this.m_indexB = 0;
                this.m_rA = new b2Vec2();
                this.m_rB = new b2Vec2();
                this.m_localCenterA = new b2Vec2();
                this.m_localCenterB = new b2Vec2();
                this.m_invMassA = 0;
                this.m_invMassB = 0;
                this.m_invIA = 0;
                this.m_invIB = 0;
                this.m_mass = new b2Mat33();
                this.m_motorMass = 0;
            }
            b2RevoluteJoint.prototype = {
                GetAnchorA: function() {
                    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
                },
                GetAnchorB: function() {
                    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
                },
                GetLocalAnchorA: function() {
                    return this.m_localAnchorA;
                },
                GetLocalAnchorB: function() {
                    return this.m_localAnchorB;
                },
                GetReferenceAngle: function() {
                    return this.m_referenceAngle;
                },
                GetJointAngle: function() {
                    var bA = this.m_bodyA;
                    var bB = this.m_bodyB;
                    return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
                },
                GetJointSpeed: function() {
                    var bA = this.m_bodyA;
                    var bB = this.m_bodyB;
                    return bB.m_angularVelocity - bA.m_angularVelocity;
                },
                IsLimitEnabled: function() {
                    return this.m_enableLimit;
                },
                EnableLimit: function(flag) {
                    if (flag != this.m_enableLimit) {
                        this.m_bodyA.SetAwake(true);
                        this.m_bodyB.SetAwake(true);
                        this.m_enableLimit = flag;
                        this.m_impulse.z = 0;
                    }
                },
                GetLowerLimit: function() {
                    return this.m_lowerAngle;
                },
                GetUpperLimit: function() {
                    return this.m_upperAngle;
                },
                SetLimits: function(lower, upper) {
                    b2Assert(lower <= upper);
                    if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {
                        this.m_bodyA.SetAwake(true);
                        this.m_bodyB.SetAwake(true);
                        this.m_impulse.z = 0;
                        this.m_lowerAngle = lower;
                        this.m_upperAngle = upper;
                    }
                },
                IsMotorEnabled: function() {
                    return this.m_enableMotor;
                },
                EnableMotor: function(flag) {
                    this.m_bodyA.SetAwake(true);
                    this.m_bodyB.SetAwake(true);
                    this.m_enableMotor = flag;
                },
                SetMotorSpeed: function(speed) {
                    this.m_bodyA.SetAwake(true);
                    this.m_bodyB.SetAwake(true);
                    this.m_motorSpeed = speed;
                },
                GetMotorSpeed: function() {
                    return this.m_motorSpeed;
                },
                SetMaxMotorTorque: function(torque) {
                    this.m_bodyA.SetAwake(true);
                    this.m_bodyB.SetAwake(true);
                    this.m_maxMotorTorque = torque;
                },
                GetMaxMotorTorque: function() {
                    return this.m_maxMotorTorque;
                },
                GetReactionForce: function(inv_dt) {
                    var P = new b2Vec2(this.m_impulse.x, this.m_impulse.y);
                    return b2Vec2.Multiply(inv_dt, P);
                },
                GetReactionTorque: function(inv_dt) {
                    return inv_dt * this.m_impulse.z;
                },
                GetMotorTorque: function(inv_dt) {
                    return inv_dt * this.m_motorImpulse;
                },
                InitVelocityConstraints: function(data) {
                    this.m_indexA = this.m_bodyA.m_islandIndex;
                    this.m_indexB = this.m_bodyB.m_islandIndex;
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var aA = data.positions[this.m_indexA].a;
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var aB = data.positions[this.m_indexB].a;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    this.m_rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
                    this.m_rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    var fixedRotation = iA + iB == 0;
                    this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
                    this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
                    this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
                    this.m_mass.ex.y = this.m_mass.ey.x;
                    this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
                    this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
                    this.m_mass.ex.z = this.m_mass.ez.x;
                    this.m_mass.ey.z = this.m_mass.ez.y;
                    this.m_mass.ez.z = iA + iB;
                    this.m_motorMass = iA + iB;
                    this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass);
                    (false == this.m_enableMotor || fixedRotation) && (this.m_motorImpulse = 0);
                    if (this.m_enableLimit && false == fixedRotation) {
                        var jointAngle = aB - aA - this.m_referenceAngle;
                        if (b2Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * b2_angularSlop) {
                            this.m_limitState = b2Joint.e_equalLimits;
                        } else {
                            if (jointAngle <= this.m_lowerAngle) {
                                this.m_limitState != b2Joint.e_atLowerLimit && (this.m_impulse.z = 0);
                                this.m_limitState = b2Joint.e_atLowerLimit;
                            } else {
                                if (jointAngle >= this.m_upperAngle) {
                                    this.m_limitState != b2Joint.e_atUpperLimit && (this.m_impulse.z = 0);
                                    this.m_limitState = b2Joint.e_atUpperLimit;
                                } else {
                                    this.m_limitState = b2Joint.e_inactiveLimit;
                                    this.m_impulse.z = 0;
                                }
                            }
                        }
                    } else {
                        this.m_limitState = b2Joint.e_inactiveLimit;
                    }
                    if (data.step.warmStarting) {
                        this.m_impulse.Multiply(data.step.dtRatio);
                        this.m_motorImpulse *= data.step.dtRatio;
                        var P = new b2Vec2(this.m_impulse.x, this.m_impulse.y);
                        vA.Subtract(b2Vec2.Multiply(mA, P));
                        wA -= iA * (b2Cross_v2_v2(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);
                        vB.Add(b2Vec2.Multiply(mB, P));
                        wB += iB * (b2Cross_v2_v2(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);
                    } else {
                        this.m_impulse.SetZero();
                        this.m_motorImpulse = 0;
                    }
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolveVelocityConstraints: function(data) {
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    var fixedRotation = iA + iB == 0;
                    if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits && false == fixedRotation) {
                        var Cdot = wB - wA - this.m_motorSpeed;
                        var impulse = -this.m_motorMass * Cdot;
                        var oldImpulse = this.m_motorImpulse;
                        var maxImpulse = data.step.dt * this.m_maxMotorTorque;
                        this.m_motorImpulse = b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
                        impulse = this.m_motorImpulse - oldImpulse;
                        wA -= iA * impulse;
                        wB += iB * impulse;
                    }
                    if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit && false == fixedRotation) {
                        var Cdot1 = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB)), vA), b2Cross_f_v2(wA, this.m_rA));
                        var Cdot2 = wB - wA;
                        var Cdot = new b2Vec3(Cdot1.x, Cdot1.y, Cdot2);
                        var impulse = this.m_mass.Solve33(Cdot).Negate();
                        if (this.m_limitState == b2Joint.e_equalLimits) {
                            this.m_impulse.Add(impulse);
                        } else {
                            if (this.m_limitState == b2Joint.e_atLowerLimit) {
                                var newImpulse = this.m_impulse.z + impulse.z;
                                if (newImpulse < 0) {
                                    var rhs = b2Vec2.Add(Cdot1.Negate(), b2Vec2.Multiply(this.m_impulse.z, new b2Vec2(this.m_mass.ez.x, this.m_mass.ez.y)));
                                    var reduced = this.m_mass.Solve22(rhs);
                                    impulse.x = reduced.x;
                                    impulse.y = reduced.y;
                                    impulse.z = -this.m_impulse.z;
                                    this.m_impulse.x += reduced.x;
                                    this.m_impulse.y += reduced.y;
                                    this.m_impulse.z = 0;
                                } else {
                                    this.m_impulse.Add(impulse);
                                }
                            } else {
                                if (this.m_limitState == b2Joint.e_atUpperLimit) {
                                    var newImpulse = this.m_impulse.z + impulse.z;
                                    if (newImpulse > 0) {
                                        var rhs = b2Vec2.Add(Cdot1.Negate(), b2Vec2.Multiply(this.m_impulse.z, new b2Vec2(this.m_mass.ez.x, this.m_mass.ez.y)));
                                        var reduced = this.m_mass.Solve22(rhs);
                                        impulse.x = reduced.x;
                                        impulse.y = reduced.y;
                                        impulse.z = -this.m_impulse.z;
                                        this.m_impulse.x += reduced.x;
                                        this.m_impulse.y += reduced.y;
                                        this.m_impulse.z = 0;
                                    } else {
                                        this.m_impulse.Add(impulse);
                                    }
                                }
                            }
                        }
                        var P = new b2Vec2(impulse.x, impulse.y);
                        vA.Subtract(b2Vec2.Multiply(mA, P));
                        wA -= iA * (b2Cross_v2_v2(this.m_rA, P) + impulse.z);
                        vB.Add(b2Vec2.Multiply(mB, P));
                        wB += iB * (b2Cross_v2_v2(this.m_rB, P) + impulse.z);
                    } else {
                        var Cdot = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB)), vA), b2Cross_f_v2(wA, this.m_rA));
                        var impulse = this.m_mass.Solve22(Cdot.Negate());
                        this.m_impulse.x += impulse.x;
                        this.m_impulse.y += impulse.y;
                        vA.Subtract(b2Vec2.Multiply(mA, impulse));
                        wA -= iA * b2Cross_v2_v2(this.m_rA, impulse);
                        vB.Add(b2Vec2.Multiply(mB, impulse));
                        wB += iB * b2Cross_v2_v2(this.m_rB, impulse);
                    }
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolvePositionConstraints: function(data) {
                    var cA = data.positions[this.m_indexA].c.Clone();
                    var aA = data.positions[this.m_indexA].a;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    var angularError = 0;
                    var positionError = 0;
                    var fixedRotation = this.m_invIA + this.m_invIB == 0;
                    if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit && false == fixedRotation) {
                        var angle = aB - aA - this.m_referenceAngle;
                        var limitImpulse = 0;
                        if (this.m_limitState == b2Joint.e_equalLimits) {
                            var C = b2Clamp(angle - this.m_lowerAngle, -b2_maxAngularCorrection, b2_maxAngularCorrection);
                            limitImpulse = -this.m_motorMass * C;
                            angularError = b2Abs(C);
                        } else {
                            if (this.m_limitState == b2Joint.e_atLowerLimit) {
                                var C = angle - this.m_lowerAngle;
                                angularError = -C;
                                C = b2Clamp(C + b2_angularSlop, -b2_maxAngularCorrection, 0);
                                limitImpulse = -this.m_motorMass * C;
                            } else {
                                if (this.m_limitState == b2Joint.e_atUpperLimit) {
                                    var C = angle - this.m_upperAngle;
                                    angularError = C;
                                    C = b2Clamp(C - b2_angularSlop, 0, b2_maxAngularCorrection);
                                    limitImpulse = -this.m_motorMass * C;
                                }
                            }
                        }
                        aA -= this.m_invIA * limitImpulse;
                        aB += this.m_invIB * limitImpulse;
                    }
                    qA.Set(aA);
                    qB.Set(aB);
                    var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
                    var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
                    var C = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, rB), cA), rA);
                    positionError = C.Length();
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    var K = new b2Mat22();
                    K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
                    K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
                    K.ey.x = K.ex.y;
                    K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;
                    var impulse = K.Solve(C).Negate();
                    cA.Subtract(b2Vec2.Multiply(mA, impulse));
                    aA -= iA * b2Cross_v2_v2(rA, impulse);
                    cB.Add(b2Vec2.Multiply(mB, impulse));
                    aB += iB * b2Cross_v2_v2(rB, impulse);
                    data.positions[this.m_indexA].c.Assign(cA);
                    data.positions[this.m_indexA].a = aA;
                    data.positions[this.m_indexB].c.Assign(cB);
                    data.positions[this.m_indexB].a = aB;
                    return positionError <= b2_linearSlop && angularError <= b2_angularSlop;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    this.parent.prototype._serialize.call(this, obj);
                    obj["localAnchorA"] = this.m_localAnchorA._serialize();
                    obj["localAnchorB"] = this.m_localAnchorB._serialize();
                    obj["referenceAngle"] = this.m_referenceAngle;
                    obj["lowerAngle"] = this.m_lowerAngle;
                    obj["upperAngle"] = this.m_upperAngle;
                    obj["maxMotorTorque"] = this.m_maxMotorTorque;
                    obj["motorSpeed"] = this.m_motorSpeed;
                    obj["enableLimit"] = this.m_enableLimit;
                    obj["enableMotor"] = this.m_enableMotor;
                    return obj;
                }
            };
            b2RevoluteJoint._extend(b2Joint);
            function b2MouseJointDef() {
                this.parent.call(this);
                this.type = b2Joint.e_mouseJoint;
                this.target = new b2Vec2(0, 0);
                this.maxForce = 0;
                this.frequencyHz = 5;
                this.dampingRatio = .7;
                Object.seal(this);
            }
            b2MouseJointDef._extend(b2JointDef);
            function b2MouseJoint(def) {
                this.parent.call(this, def);
                b2Assert(def.target.IsValid());
                b2Assert(b2IsValid(def.maxForce) && def.maxForce >= 0);
                b2Assert(b2IsValid(def.frequencyHz) && def.frequencyHz >= 0);
                b2Assert(b2IsValid(def.dampingRatio) && def.dampingRatio >= 0);
                this.m_targetA = def.target.Clone();
                this.m_localAnchorB = b2MulT_t_v2(this.m_bodyB.GetTransform(), this.m_targetA);
                this.m_maxForce = def.maxForce;
                this.m_impulse = new b2Vec2();
                this.m_frequencyHz = def.frequencyHz;
                this.m_dampingRatio = def.dampingRatio;
                this.m_beta = 0;
                this.m_gamma = 0;
                this.m_indexA = 0;
                this.m_indexB = 0;
                this.m_rB = new b2Vec2();
                this.m_localCenterB = new b2Vec2();
                this.m_invMassB = 0;
                this.m_invIB = 0;
                this.m_mass = new b2Mat22();
                this.m_C = new b2Vec2();
            }
            b2MouseJoint.prototype = {
                GetAnchorA: function() {
                    return this.m_targetA;
                },
                GetAnchorB: function() {
                    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
                },
                GetReactionForce: function(inv_dt) {
                    return b2Vec2.Multiply(inv_dt, this.m_impulse);
                },
                GetReactionTorque: function(inv_dt) {
                    return 0 * inv_dt;
                },
                SetTarget: function(target) {
                    false == this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(true);
                    this.m_targetA.Assign(target);
                },
                GetTarget: function() {
                    return this.m_targetA;
                },
                SetMaxForce: function(force) {
                    this.m_maxForce = force;
                },
                GetMaxForce: function() {
                    return this.m_maxForce;
                },
                SetFrequency: function(hz) {
                    this.m_frequencyHz = hz;
                },
                GetFrequency: function() {
                    return this.m_frequencyHz;
                },
                SetDampingRatio: function(ratio) {
                    this.m_dampingRatio = ratio;
                },
                GetDampingRatio: function() {
                    return this.m_dampingRatio;
                },
                ShiftOrigin: function(newOrigin) {
                    this.m_targetA.Subtract(newOrigin);
                },
                InitVelocityConstraints: function(data) {
                    this.m_indexB = this.m_bodyB.m_islandIndex;
                    this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var qB = new b2Rot(aB);
                    var mass = this.m_bodyB.GetMass();
                    var omega = 2 * b2_pi * this.m_frequencyHz;
                    var d = 2 * mass * this.m_dampingRatio * omega;
                    var k = mass * (omega * omega);
                    var h = data.step.dt;
                    b2Assert(d + h * k > b2_epsilon);
                    this.m_gamma = h * (d + h * k);
                    0 != this.m_gamma && (this.m_gamma = 1 / this.m_gamma);
                    this.m_beta = h * k * this.m_gamma;
                    this.m_rB.Assign(b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB)));
                    var K = new b2Mat22();
                    K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;
                    K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
                    K.ey.x = K.ex.y;
                    K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;
                    this.m_mass.Assign(K.GetInverse());
                    this.m_C.Assign(b2Vec2.Subtract(b2Vec2.Add(cB, this.m_rB), this.m_targetA));
                    this.m_C.Multiply(this.m_beta);
                    wB *= .98;
                    if (data.step.warmStarting) {
                        this.m_impulse.Multiply(data.step.dtRatio);
                        vB.Add(b2Vec2.Multiply(this.m_invMassB, this.m_impulse));
                        wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, this.m_impulse);
                    } else {
                        this.m_impulse.SetZero();
                    }
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolveVelocityConstraints: function(data) {
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var Cdot = b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB));
                    var impulse = b2Mul_m22_v2(this.m_mass, b2Vec2.Add(b2Vec2.Add(Cdot, this.m_C), b2Vec2.Multiply(this.m_gamma, this.m_impulse)).Negate());
                    var oldImpulse = this.m_impulse.Clone();
                    this.m_impulse.Add(impulse);
                    var maxImpulse = data.step.dt * this.m_maxForce;
                    this.m_impulse.LengthSquared() > maxImpulse * maxImpulse && this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
                    impulse.Assign(b2Vec2.Subtract(this.m_impulse, oldImpulse));
                    vB.Add(b2Vec2.Multiply(this.m_invMassB, impulse));
                    wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, impulse);
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolvePositionConstraints: function(data) {
                    return true;
                }
            };
            b2MouseJoint._extend(b2Joint);
            function b2DistanceJointDef() {
                this.parent.call(this);
                this.type = b2Joint.e_distanceJoint;
                this.localAnchorA = new b2Vec2(0, 0);
                this.localAnchorB = new b2Vec2(0, 0);
                this.length = 1;
                this.frequencyHz = 0;
                this.dampingRatio = 0;
                Object.seal(this);
            }
            b2DistanceJointDef.prototype = {
                Initialize: function(b1, b2, anchor1, anchor2) {
                    this.bodyA = b1;
                    this.bodyB = b2;
                    this.localAnchorA = this.bodyA.GetLocalPoint(anchor1);
                    this.localAnchorB = this.bodyB.GetLocalPoint(anchor2);
                    var d = b2Vec2.Subtract(anchor2, anchor1);
                    this.length = d.Length();
                },
                _deserialize: function(data, bodies, joints) {
                    this.parent.prototype._deserialize.call(this, data, bodies, joints);
                    this.localAnchorA._deserialize(data["localAnchorA"]);
                    this.localAnchorB._deserialize(data["localAnchorB"]);
                    this.length = data["length"];
                    this.frequencyHz = data["frequencyHz"];
                    this.dampingRatio = data["dampingRatio"];
                }
            };
            b2DistanceJointDef._extend(b2JointDef);
            function b2DistanceJoint(def) {
                this.parent.call(this, def);
                this.m_localAnchorA = def.localAnchorA.Clone();
                this.m_localAnchorB = def.localAnchorB.Clone();
                this.m_length = def.length;
                this.m_frequencyHz = def.frequencyHz;
                this.m_dampingRatio = def.dampingRatio;
                this.m_impulse = 0;
                this.m_gamma = 0;
                this.m_bias = 0;
                this.m_indexA = 0;
                this.m_indexB = 0;
                this.m_u = new b2Vec2();
                this.m_rA = new b2Vec2();
                this.m_rB = new b2Vec2();
                this.m_localCenterA = new b2Vec2();
                this.m_localCenterB = new b2Vec2();
                this.m_invMassA = 0;
                this.m_invMassB = 0;
                this.m_invIA = 0;
                this.m_invIB = 0;
                this.m_mass = 0;
            }
            b2DistanceJoint.prototype = {
                GetAnchorA: function() {
                    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
                },
                GetAnchorB: function() {
                    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
                },
                GetReactionForce: function(inv_dt) {
                    var F = b2Vec2.Multiply(inv_dt * this.m_impulse, this.m_u);
                    return F;
                },
                GetReactionTorque: function(inv_dt) {
                    return 0;
                },
                GetLocalAnchorA: function() {
                    return this.m_localAnchorA;
                },
                GetLocalAnchorB: function() {
                    return this.m_localAnchorB;
                },
                SetLength: function(length) {
                    this.m_length = length;
                },
                GetLength: function() {
                    return this.m_length;
                },
                SetFrequency: function(hz) {
                    this.m_frequencyHz = hz;
                },
                GetFrequency: function() {
                    return this.m_frequencyHz;
                },
                SetDampingRatio: function(ratio) {
                    this.m_dampingRatio = ratio;
                },
                GetDampingRatio: function() {
                    return this.m_dampingRatio;
                },
                InitVelocityConstraints: function(data) {
                    this.m_indexA = this.m_bodyA.m_islandIndex;
                    this.m_indexB = this.m_bodyB.m_islandIndex;
                    this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
                    this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = data.positions[this.m_indexA].c.Clone();
                    var aA = data.positions[this.m_indexA].a;
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    this.m_rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
                    this.m_rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
                    this.m_u = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, this.m_rB), cA), this.m_rA);
                    var length = this.m_u.Length();
                    length > b2_linearSlop ? this.m_u.Multiply(1 / length) : this.m_u.Set(0, 0);
                    var crAu = b2Cross_v2_v2(this.m_rA, this.m_u);
                    var crBu = b2Cross_v2_v2(this.m_rB, this.m_u);
                    var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;
                    this.m_mass = 0 != invMass ? 1 / invMass : 0;
                    if (this.m_frequencyHz > 0) {
                        var C = length - this.m_length;
                        var omega = 2 * b2_pi * this.m_frequencyHz;
                        var d = 2 * this.m_mass * this.m_dampingRatio * omega;
                        var k = this.m_mass * omega * omega;
                        var h = data.step.dt;
                        this.m_gamma = h * (d + h * k);
                        this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;
                        this.m_bias = C * h * k * this.m_gamma;
                        invMass += this.m_gamma;
                        this.m_mass = 0 != invMass ? 1 / invMass : 0;
                    } else {
                        this.m_gamma = 0;
                        this.m_bias = 0;
                    }
                    if (data.step.warmStarting) {
                        this.m_impulse *= data.step.dtRatio;
                        var P = b2Vec2.Multiply(this.m_impulse, this.m_u);
                        vA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
                        wA -= this.m_invIA * b2Cross_v2_v2(this.m_rA, P);
                        vB.Add(b2Vec2.Multiply(this.m_invMassB, P));
                        wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, P);
                    } else {
                        this.m_impulse = 0;
                    }
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolveVelocityConstraints: function(data) {
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var vpA = b2Vec2.Add(vA, b2Cross_f_v2(wA, this.m_rA));
                    var vpB = b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB));
                    var Cdot = b2Dot_v2_v2(this.m_u, b2Vec2.Subtract(vpB, vpA));
                    var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
                    this.m_impulse += impulse;
                    var P = b2Vec2.Multiply(impulse, this.m_u);
                    vA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
                    wA -= this.m_invIA * b2Cross_v2_v2(this.m_rA, P);
                    vB.Add(b2Vec2.Multiply(this.m_invMassB, P));
                    wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, P);
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolvePositionConstraints: function(data) {
                    if (this.m_frequencyHz > 0) {
                        return true;
                    }
                    var cA = data.positions[this.m_indexA].c.Clone();
                    var aA = data.positions[this.m_indexA].a;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
                    var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
                    var u = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, rB), cA), rA);
                    var length = u.Normalize();
                    var C = length - this.m_length;
                    C = b2Clamp(C, -b2_maxLinearCorrection, b2_maxLinearCorrection);
                    var impulse = -this.m_mass * C;
                    var P = b2Vec2.Multiply(impulse, u);
                    cA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
                    aA -= this.m_invIA * b2Cross_v2_v2(rA, P);
                    cB.Add(b2Vec2.Multiply(this.m_invMassB, P));
                    aB += this.m_invIB * b2Cross_v2_v2(rB, P);
                    data.positions[this.m_indexA].c.Assign(cA);
                    data.positions[this.m_indexA].a = aA;
                    data.positions[this.m_indexB].c.Assign(cB);
                    data.positions[this.m_indexB].a = aB;
                    return b2Abs(C) < b2_linearSlop;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    this.parent.prototype._serialize.call(this, obj);
                    obj["localAnchorA"] = this.m_localAnchorA._serialize();
                    obj["localAnchorB"] = this.m_localAnchorB._serialize();
                    obj["length"] = this.m_length;
                    obj["frequencyHz"] = this.m_frequencyHz;
                    obj["dampingRatio"] = this.m_dampingRatio;
                    return obj;
                }
            };
            b2DistanceJoint._extend(b2Joint);
            function b2PrismaticJointDef() {
                this.parent.call(this);
                this.type = b2Joint.e_prismaticJoint;
                this.localAnchorA = new b2Vec2();
                this.localAnchorB = new b2Vec2();
                this.localAxisA = new b2Vec2(1, 0);
                this.referenceAngle = 0;
                this.enableLimit = false;
                this.lowerTranslation = 0;
                this.upperTranslation = 0;
                this.enableMotor = false;
                this.maxMotorForce = 0;
                this.motorSpeed = 0;
                Object.seal(this);
            }
            b2PrismaticJointDef.prototype = {
                Initialize: function(bA, bB, anchor, axis) {
                    this.bodyA = bA;
                    this.bodyB = bB;
                    this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
                    this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
                    this.localAxisA = this.bodyA.GetLocalVector(axis);
                    this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
                },
                _deserialize: function(data, bodies, joints) {
                    this.parent.prototype._deserialize.call(this, data, bodies, joints);
                    this.localAnchorA._deserialize(data["localAnchorA"]);
                    this.localAnchorB._deserialize(data["localAnchorB"]);
                    this.localAxisA._deserialize(data["localAxisA"]);
                    this.referenceAngle = data["referenceAngle"];
                    this.enableLimit = data["enableLimit"];
                    this.lowerTranslation = data["lowerTranslation"];
                    this.upperTranslation = data["upperTranslation"];
                    this.enableMotor = data["enableMotor"];
                    this.maxMotorForce = data["maxMotorForce"];
                    this.motorSpeed = data["motorSpeed"];
                }
            };
            b2PrismaticJointDef._extend(b2JointDef);
            function b2PrismaticJoint(def) {
                this.parent.call(this, def);
                this.m_localAnchorA = def.localAnchorA.Clone();
                this.m_localAnchorB = def.localAnchorB.Clone();
                this.m_localXAxisA = def.localAxisA.Clone();
                this.m_localXAxisA.Normalize();
                this.m_localYAxisA = b2Cross_f_v2(1, this.m_localXAxisA);
                this.m_referenceAngle = def.referenceAngle;
                this.m_impulse = new b2Vec3();
                this.m_motorMass = 0;
                this.m_motorImpulse = 0;
                this.m_lowerTranslation = def.lowerTranslation;
                this.m_upperTranslation = def.upperTranslation;
                this.m_maxMotorForce = def.maxMotorForce;
                this.m_motorSpeed = def.motorSpeed;
                this.m_enableLimit = def.enableLimit;
                this.m_enableMotor = def.enableMotor;
                this.m_limitState = b2Joint.e_inactiveLimit;
                this.m_axis = new b2Vec2();
                this.m_perp = new b2Vec2();
                this.m_indexA = 0;
                this.m_indexB = 0;
                this.m_localCenterA = new b2Vec2();
                this.m_localCenterB = new b2Vec2();
                this.m_invMassA = 0;
                this.m_invMassB = 0;
                this.m_invIA = 0;
                this.m_invIB = 0;
                this.m_s1 = 0, this.m_s2 = 0;
                this.m_a1 = 0, this.m_a2 = 0;
                this.m_K = new b2Mat33();
                this.m_motorMass = 0;
            }
            b2PrismaticJoint.prototype = {
                GetAnchorA: function() {
                    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
                },
                GetAnchorB: function() {
                    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
                },
                GetReactionForce: function(inv_dt) {
                    return b2Vec2.Multiply(inv_dt, b2Vec2.Add(b2Vec2.Multiply(this.m_impulse.x, this.m_perp), b2Vec2.Multiply(this.m_motorImpulse + this.m_impulse.z, this.m_axis)));
                },
                GetReactionTorque: function(inv_dt) {
                    return inv_dt * this.m_impulse.y;
                },
                GetLocalAnchorA: function() {
                    return this.m_localAnchorA;
                },
                GetLocalAnchorB: function() {
                    return this.m_localAnchorB;
                },
                GetLocalAxisA: function() {
                    return this.m_localXAxisA;
                },
                GetReferenceAngle: function() {
                    return this.m_referenceAngle;
                },
                GetJointTranslation: function() {
                    var pA = this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
                    var pB = this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
                    var d = b2Vec2.Subtract(pB, pA);
                    var axis = this.m_bodyA.GetWorldVector(this.m_localXAxisA);
                    var translation = b2Dot_v2_v2(d, axis);
                    return translation;
                },
                GetJointSpeed: function() {
                    var bA = this.m_bodyA;
                    var bB = this.m_bodyB;
                    var rA = b2Mul_r_v2(bA.m_xf.q, b2Vec2.Subtract(this.m_localAnchorA, bA.m_sweep.localCenter));
                    var rB = b2Mul_r_v2(bB.m_xf.q, b2Vec2.Subtract(this.m_localAnchorB, bB.m_sweep.localCenter));
                    var p1 = b2Vec2.Add(bA.m_sweep.c, rA);
                    var p2 = b2Vec2.Add(bB.m_sweep.c, rB);
                    var d = b2Vec2.Subtract(p2, p1);
                    var axis = b2Mul_r_v2(bA.m_xf.q, this.m_localXAxisA);
                    var vA = bA.m_linearVelocity;
                    var vB = bB.m_linearVelocity;
                    var wA = bA.m_angularVelocity;
                    var wB = bB.m_angularVelocity;
                    var speed = b2Dot_v2_v2(d, b2Cross_f_v2(wA, axis)) + b2Dot_v2_v2(axis, b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(vB, b2Cross_f_v2(wB, rB)), vA), b2Cross_f_v2(wA, rA)));
                    return speed;
                },
                IsLimitEnabled: function() {
                    return this.m_enableLimit;
                },
                EnableLimit: function(flag) {
                    if (flag != this.m_enableLimit) {
                        this.m_bodyA.SetAwake(true);
                        this.m_bodyB.SetAwake(true);
                        this.m_enableLimit = flag;
                        this.m_impulse.z = 0;
                    }
                },
                GetLowerLimit: function() {
                    return this.m_lowerTranslation;
                },
                GetUpperLimit: function() {
                    return this.m_upperTranslation;
                },
                SetLimits: function(lower, upper) {
                    b2Assert(lower <= upper);
                    if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {
                        this.m_bodyA.SetAwake(true);
                        this.m_bodyB.SetAwake(true);
                        this.m_lowerTranslation = lower;
                        this.m_upperTranslation = upper;
                        this.m_impulse.z = 0;
                    }
                },
                IsMotorEnabled: function() {
                    return this.m_enableMotor;
                },
                EnableMotor: function(flag) {
                    this.m_bodyA.SetAwake(true);
                    this.m_bodyB.SetAwake(true);
                    this.m_enableMotor = flag;
                },
                SetMotorSpeed: function(speed) {
                    this.m_bodyA.SetAwake(true);
                    this.m_bodyB.SetAwake(true);
                    this.m_motorSpeed = speed;
                },
                GetMotorSpeed: function() {
                    return this.m_motorSpeed;
                },
                SetMaxMotorForce: function(force) {
                    this.m_bodyA.SetAwake(true);
                    this.m_bodyB.SetAwake(true);
                    this.m_maxMotorForce = force;
                },
                GetMaxMotorForce: function() {
                    return this.m_maxMotorForce;
                },
                GetMotorForce: function(inv_dt) {
                    return inv_dt * this.m_motorImpulse;
                },
                InitVelocityConstraints: function(data) {
                    this.m_indexA = this.m_bodyA.m_islandIndex;
                    this.m_indexB = this.m_bodyB.m_islandIndex;
                    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
                    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = data.positions[this.m_indexA].c.Clone();
                    var aA = data.positions[this.m_indexA].a;
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
                    var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
                    var d = b2Vec2.Add(b2Vec2.Subtract(cB, cA), b2Vec2.Subtract(rB, rA));
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    this.m_axis = b2Mul_r_v2(qA, this.m_localXAxisA);
                    this.m_a1 = b2Cross_v2_v2(b2Vec2.Add(d, rA), this.m_axis);
                    this.m_a2 = b2Cross_v2_v2(rB, this.m_axis);
                    this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
                    this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass);
                    this.m_perp = b2Mul_r_v2(qA, this.m_localYAxisA);
                    this.m_s1 = b2Cross_v2_v2(b2Vec2.Add(d, rA), this.m_perp);
                    this.m_s2 = b2Cross_v2_v2(rB, this.m_perp);
                    var k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;
                    var k12 = iA * this.m_s1 + iB * this.m_s2;
                    var k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;
                    var k22 = iA + iB;
                    0 == k22 && (k22 = 1);
                    var k23 = iA * this.m_a1 + iB * this.m_a2;
                    var k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
                    this.m_K.ex.Set(k11, k12, k13);
                    this.m_K.ey.Set(k12, k22, k23);
                    this.m_K.ez.Set(k13, k23, k33);
                    if (this.m_enableLimit) {
                        var jointTranslation = b2Dot_v2_v2(this.m_axis, d);
                        if (b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2_linearSlop) {
                            this.m_limitState = b2Joint.e_equalLimits;
                        } else {
                            if (jointTranslation <= this.m_lowerTranslation) {
                                if (this.m_limitState != b2Joint.e_atLowerLimit) {
                                    this.m_limitState = b2Joint.e_atLowerLimit;
                                    this.m_impulse.z = 0;
                                }
                            } else {
                                if (jointTranslation >= this.m_upperTranslation) {
                                    if (this.m_limitState != b2Joint.e_atUpperLimit) {
                                        this.m_limitState = b2Joint.e_atUpperLimit;
                                        this.m_impulse.z = 0;
                                    }
                                } else {
                                    this.m_limitState = b2Joint.e_inactiveLimit;
                                    this.m_impulse.z = 0;
                                }
                            }
                        }
                    } else {
                        this.m_limitState = b2Joint.e_inactiveLimit;
                        this.m_impulse.z = 0;
                    }
                    false == this.m_enableMotor && (this.m_motorImpulse = 0);
                    if (data.step.warmStarting) {
                        this.m_impulse.Multiply(data.step.dtRatio);
                        this.m_motorImpulse *= data.step.dtRatio;
                        var P = b2Vec2.Add(b2Vec2.Multiply(this.m_impulse.x, this.m_perp), b2Vec2.Multiply(this.m_motorImpulse + this.m_impulse.z, this.m_axis));
                        var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
                        var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
                        vA.Subtract(b2Vec2.Multiply(mA, P));
                        wA -= iA * LA;
                        vB.Add(b2Vec2.Multiply(mB, P));
                        wB += iB * LB;
                    } else {
                        this.m_impulse.SetZero();
                        this.m_motorImpulse = 0;
                    }
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolveVelocityConstraints: function(data) {
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
                        var Cdot = b2Dot_v2_v2(this.m_axis, b2Vec2.Subtract(vB, vA)) + this.m_a2 * wB - this.m_a1 * wA;
                        var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
                        var oldImpulse = this.m_motorImpulse;
                        var maxImpulse = data.step.dt * this.m_maxMotorForce;
                        this.m_motorImpulse = b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
                        impulse = this.m_motorImpulse - oldImpulse;
                        var P = b2Vec2.Multiply(impulse, this.m_axis);
                        var LA = impulse * this.m_a1;
                        var LB = impulse * this.m_a2;
                        vA.Subtract(b2Vec2.Multiply(mA, P));
                        wA -= iA * LA;
                        vB.Add(b2Vec2.Multiply(mB, P));
                        wB += iB * LB;
                    }
                    var Cdot1 = new b2Vec2();
                    Cdot1.x = b2Dot_v2_v2(this.m_perp, b2Vec2.Subtract(vB, vA)) + this.m_s2 * wB - this.m_s1 * wA;
                    Cdot1.y = wB - wA;
                    if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
                        var Cdot2;
                        Cdot2 = b2Dot_v2_v2(this.m_axis, b2Vec2.Subtract(vB, vA)) + this.m_a2 * wB - this.m_a1 * wA;
                        var Cdot = new b2Vec3(Cdot1.x, Cdot1.y, Cdot2);
                        var f1 = this.m_impulse.Clone();
                        var df = this.m_K.Solve33(Cdot.Negate());
                        this.m_impulse.Add(df);
                        this.m_limitState == b2Joint.e_atLowerLimit ? this.m_impulse.z = b2Max(this.m_impulse.z, 0) : this.m_limitState == b2Joint.e_atUpperLimit && (this.m_impulse.z = b2Min(this.m_impulse.z, 0));
                        var b = b2Vec2.Subtract(Cdot1.Negate(), b2Vec2.Multiply(this.m_impulse.z - f1.z, new b2Vec2(this.m_K.ez.x, this.m_K.ez.y)));
                        var f2r = b2Vec2.Add(this.m_K.Solve22(b), new b2Vec2(f1.x, f1.y));
                        this.m_impulse.x = f2r.x;
                        this.m_impulse.y = f2r.y;
                        df = b2Vec3.Subtract(this.m_impulse, f1);
                        var P = b2Vec2.Add(b2Vec2.Multiply(df.x, this.m_perp), b2Vec2.Multiply(df.z, this.m_axis));
                        var LA = df.x * this.m_s1 + df.y + df.z * this.m_a1;
                        var LB = df.x * this.m_s2 + df.y + df.z * this.m_a2;
                        vA.Subtract(b2Vec2.Multiply(mA, P));
                        wA -= iA * LA;
                        vB.Add(b2Vec2.Multiply(mB, P));
                        wB += iB * LB;
                    } else {
                        var df = this.m_K.Solve22(Cdot1.Negate());
                        this.m_impulse.x += df.x;
                        this.m_impulse.y += df.y;
                        var P = b2Vec2.Multiply(df.x, this.m_perp);
                        var LA = df.x * this.m_s1 + df.y;
                        var LB = df.x * this.m_s2 + df.y;
                        vA.Subtract(b2Vec2.Multiply(mA, P));
                        wA -= iA * LA;
                        vB.Add(b2Vec2.Multiply(mB, P));
                        wB += iB * LB;
                    }
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolvePositionConstraints: function(data) {
                    var cA = data.positions[this.m_indexA].c.Clone();
                    var aA = data.positions[this.m_indexA].a;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
                    var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
                    var d = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, rB), cA), rA);
                    var axis = b2Mul_r_v2(qA, this.m_localXAxisA);
                    var a1 = b2Cross_v2_v2(b2Vec2.Add(d, rA), axis);
                    var a2 = b2Cross_v2_v2(rB, axis);
                    var perp = b2Mul_r_v2(qA, this.m_localYAxisA);
                    var s1 = b2Cross_v2_v2(b2Vec2.Add(d, rA), perp);
                    var s2 = b2Cross_v2_v2(rB, perp);
                    var impulse = new b2Vec3();
                    var C1 = new b2Vec2();
                    C1.x = b2Dot_v2_v2(perp, d);
                    C1.y = aB - aA - this.m_referenceAngle;
                    var linearError = b2Abs(C1.x);
                    var angularError = b2Abs(C1.y);
                    var active = false;
                    var C2 = 0;
                    if (this.m_enableLimit) {
                        var translation = b2Dot_v2_v2(axis, d);
                        if (b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2_linearSlop) {
                            C2 = b2Clamp(translation, -b2_maxLinearCorrection, b2_maxLinearCorrection);
                            linearError = b2Max(linearError, b2Abs(translation));
                            active = true;
                        } else {
                            if (translation <= this.m_lowerTranslation) {
                                C2 = b2Clamp(translation - this.m_lowerTranslation + b2_linearSlop, -b2_maxLinearCorrection, 0);
                                linearError = b2Max(linearError, this.m_lowerTranslation - translation);
                                active = true;
                            } else {
                                if (translation >= this.m_upperTranslation) {
                                    C2 = b2Clamp(translation - this.m_upperTranslation - b2_linearSlop, 0, b2_maxLinearCorrection);
                                    linearError = b2Max(linearError, translation - this.m_upperTranslation);
                                    active = true;
                                }
                            }
                        }
                    }
                    if (active) {
                        var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
                        var k12 = iA * s1 + iB * s2;
                        var k13 = iA * s1 * a1 + iB * s2 * a2;
                        var k22 = iA + iB;
                        0 == k22 && (k22 = 1);
                        var k23 = iA * a1 + iB * a2;
                        var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;
                        var K = new b2Mat33();
                        K.ex.Set(k11, k12, k13);
                        K.ey.Set(k12, k22, k23);
                        K.ez.Set(k13, k23, k33);
                        var C = new b2Vec3();
                        C.x = C1.x;
                        C.y = C1.y;
                        C.z = C2;
                        impulse = K.Solve33(C.Negate());
                    } else {
                        var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
                        var k12 = iA * s1 + iB * s2;
                        var k22 = iA + iB;
                        0 == k22 && (k22 = 1);
                        var K = new b2Mat22();
                        K.ex.Set(k11, k12);
                        K.ey.Set(k12, k22);
                        var impulse1 = K.Solve(C1.Negate());
                        impulse.x = impulse1.x;
                        impulse.y = impulse1.y;
                        impulse.z = 0;
                    }
                    var P = b2Vec2.Add(b2Vec2.Multiply(impulse.x, perp), b2Vec2.Multiply(impulse.z, axis));
                    var LA = impulse.x * s1 + impulse.y + impulse.z * a1;
                    var LB = impulse.x * s2 + impulse.y + impulse.z * a2;
                    cA.Subtract(b2Vec2.Multiply(mA, P));
                    aA -= iA * LA;
                    cB.Add(b2Vec2.Multiply(mB, P));
                    aB += iB * LB;
                    data.positions[this.m_indexA].c.Assign(cA);
                    data.positions[this.m_indexA].a = aA;
                    data.positions[this.m_indexB].c.Assign(cB);
                    data.positions[this.m_indexB].a = aB;
                    return linearError <= b2_linearSlop && angularError <= b2_angularSlop;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    this.parent.prototype._serialize.call(this, obj);
                    obj["localAnchorA"] = this.m_localAnchorA._serialize();
                    obj["localAnchorB"] = this.m_localAnchorB._serialize();
                    obj["localAxisA"] = this.m_localXAxisA._serialize();
                    obj["referenceAngle"] = this.m_referenceAngle;
                    obj["enableLimit"] = this.m_enableLimit;
                    obj["lowerTranslation"] = this.m_lowerTranslation;
                    obj["upperTranslation"] = this.m_upperTranslation;
                    obj["enableMotor"] = this.m_enableMotor;
                    obj["maxMotorForce"] = this.m_maxMotorForce;
                    obj["motorSpeed"] = this.m_motorSpeed;
                    return obj;
                }
            };
            b2PrismaticJoint._extend(b2Joint);
            function b2FrictionJointDef() {
                this.parent.call(this);
                this.type = b2Joint.e_frictionJoint;
                this.localAnchorA = new b2Vec2();
                this.localAnchorB = new b2Vec2();
                this.maxForce = 0;
                this.maxTorque = 0;
                Object.seal(this);
            }
            b2FrictionJointDef.prototype = {
                Initialize: function(bA, bB, anchor) {
                    this.bodyA = bA;
                    this.bodyB = bB;
                    this.localAnchorA.Assign(this.bodyA.GetLocalPoint(anchor));
                    this.localAnchorB.Assign(this.bodyB.GetLocalPoint(anchor));
                },
                _deserialize: function(data, bodies, joints) {
                    this.parent.prototype._deserialize.call(this, data, bodies, joints);
                    this.localAnchorA._deserialize(data["localAnchorA"]);
                    this.localAnchorB._deserialize(data["localAnchorB"]);
                    this.maxForce = data["maxForce"];
                    this.maxTorque = data["maxTorque"];
                }
            };
            b2FrictionJointDef._extend(b2JointDef);
            function b2FrictionJoint(def) {
                this.parent.call(this, def);
                this.m_localAnchorA = def.localAnchorA.Clone();
                this.m_localAnchorB = def.localAnchorB.Clone();
                this.m_linearImpulse = new b2Vec2();
                this.m_angularImpulse = 0;
                this.m_maxForce = def.maxForce;
                this.m_maxTorque = def.maxTorque;
                this.m_indexA = 0;
                this.m_indexB = 0;
                this.m_rA = new b2Vec2();
                this.m_rB = new b2Vec2();
                this.m_localCenterA = new b2Vec2();
                this.m_localCenterB = new b2Vec2();
                this.m_invMassA = 0;
                this.m_invMassB = 0;
                this.m_invIA = 0;
                this.m_invIB = 0;
                this.m_linearMass = new b2Mat22();
                this.m_angularMass = 0;
            }
            b2FrictionJoint.prototype = {
                GetAnchorA: function() {
                    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
                },
                GetAnchorB: function() {
                    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
                },
                GetReactionForce: function(inv_dt) {
                    return b2Vec2.Multiply(inv_dt, this.m_linearImpulse);
                },
                GetReactionTorque: function(inv_dt) {
                    return inv_dt * this.m_angularImpulse;
                },
                GetLocalAnchorA: function() {
                    return this.m_localAnchorA;
                },
                GetLocalAnchorB: function() {
                    return this.m_localAnchorB;
                },
                SetMaxForce: function(force) {
                    b2Assert(b2IsValid(force) && force >= 0);
                    this.m_maxForce = force;
                },
                GetMaxForce: function() {
                    return this.m_maxForce;
                },
                SetMaxTorque: function(torque) {
                    b2Assert(b2IsValid(torque) && torque >= 0);
                    this.m_maxTorque = torque;
                },
                GetMaxTorque: function() {
                    return this.m_maxTorque;
                },
                InitVelocityConstraints: function(data) {
                    this.m_indexA = this.m_bodyA.m_islandIndex;
                    this.m_indexB = this.m_bodyB.m_islandIndex;
                    this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
                    this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var aA = data.positions[this.m_indexA].a;
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var aB = data.positions[this.m_indexB].a;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    this.m_rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
                    this.m_rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    var K = new b2Mat22();
                    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;
                    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
                    K.ey.x = K.ex.y;
                    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;
                    this.m_linearMass = K.GetInverse();
                    this.m_angularMass = iA + iB;
                    this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass);
                    if (data.step.warmStarting) {
                        this.m_linearImpulse.Multiply(data.step.dtRatio);
                        this.m_angularImpulse *= data.step.dtRatio;
                        var P = new b2Vec2(this.m_linearImpulse.x, this.m_linearImpulse.y);
                        vA.Subtract(b2Vec2.Multiply(mA, P));
                        wA -= iA * (b2Cross_v2_v2(this.m_rA, P) + this.m_angularImpulse);
                        vB.Add(b2Vec2.Multiply(mB, P));
                        wB += iB * (b2Cross_v2_v2(this.m_rB, P) + this.m_angularImpulse);
                    } else {
                        this.m_linearImpulse.SetZero();
                        this.m_angularImpulse = 0;
                    }
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolveVelocityConstraints: function(data) {
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    var h = data.step.dt;
                    var Cdot = wB - wA;
                    var impulse = -this.m_angularMass * Cdot;
                    var oldImpulse = this.m_angularImpulse;
                    var maxImpulse = h * this.m_maxTorque;
                    this.m_angularImpulse = b2Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
                    impulse = this.m_angularImpulse - oldImpulse;
                    wA -= iA * impulse;
                    wB += iB * impulse;
                    var Cdot = b2Vec2.Add(vB, b2Vec2.Subtract(b2Cross_f_v2(wB, this.m_rB), b2Vec2.Subtract(vA, b2Cross_f_v2(wA, this.m_rA))));
                    var impulse = b2Mul_m22_v2(this.m_linearMass, Cdot).Negate();
                    var oldImpulse = this.m_linearImpulse.Clone();
                    this.m_linearImpulse.Add(impulse);
                    var maxImpulse = h * this.m_maxForce;
                    if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
                        this.m_linearImpulse.Normalize();
                        this.m_linearImpulse.Multiply(maxImpulse);
                    }
                    impulse = b2Vec2.Subtract(this.m_linearImpulse, oldImpulse);
                    vA.Subtract(b2Vec2.Multiply(mA, impulse));
                    wA -= iA * b2Cross_v2_v2(this.m_rA, impulse);
                    vB.Add(b2Vec2.Multiply(mB, impulse));
                    wB += iB * b2Cross_v2_v2(this.m_rB, impulse);
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolvePositionConstraints: function(data) {
                    return true;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    this.parent.prototype._serialize.call(this, obj);
                    obj["localAnchorA"] = this.m_localAnchorA._serialize();
                    obj["localAnchorB"] = this.m_localAnchorB._serialize();
                    obj["maxForce"] = this.m_maxForce;
                    obj["maxTorque"] = this.m_maxTorque;
                    return obj;
                }
            };
            b2FrictionJoint._extend(b2Joint);
            function b2WeldJointDef() {
                this.parent.call(this);
                this.type = b2Joint.e_weldJoint;
                this.localAnchorA = new b2Vec2(0, 0);
                this.localAnchorB = new b2Vec2(0, 0);
                this.referenceAngle = 0;
                this.frequencyHz = 0;
                this.dampingRatio = 0;
                Object.seal(this);
            }
            b2WeldJointDef.prototype = {
                Initialize: function(bA, bB, anchor) {
                    this.bodyA = bA;
                    this.bodyB = bB;
                    this.localAnchorA.Assign(this.bodyA.GetLocalPoint(anchor));
                    this.localAnchorB.Assign(this.bodyB.GetLocalPoint(anchor));
                    this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
                },
                _deserialize: function(data, bodies, joints) {
                    this.parent.prototype._deserialize.call(this, data, bodies, joints);
                    this.localAnchorA._deserialize(data["localAnchorA"]);
                    this.localAnchorB._deserialize(data["localAnchorB"]);
                    this.referenceAngle = data["referenceAngle"];
                    this.frequencyHz = data["frequencyHz"];
                    this.dampingRatio = data["dampingRatio"];
                }
            };
            b2WeldJointDef._extend(b2JointDef);
            function b2WeldJoint(def) {
                this.parent.call(this, def);
                this.m_bias = 0;
                this.m_gamma = 0;
                this.m_indexA = 0;
                this.m_indexB = 0;
                this.m_rA = new b2Vec2();
                this.m_rB = new b2Vec2();
                this.m_localCenterA = new b2Vec2();
                this.m_localCenterB = new b2Vec2();
                this.m_invMassA = 0;
                this.m_invMassB = 0;
                this.m_invIA = 0;
                this.m_invIB = 0;
                this.m_mass = new b2Mat33();
                this.m_localAnchorA = def.localAnchorA.Clone();
                this.m_localAnchorB = def.localAnchorB.Clone();
                this.m_referenceAngle = def.referenceAngle;
                this.m_frequencyHz = def.frequencyHz;
                this.m_dampingRatio = def.dampingRatio;
                this.m_impulse = new b2Vec3();
            }
            b2WeldJoint.prototype = {
                GetAnchorA: function() {
                    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
                },
                GetAnchorB: function() {
                    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
                },
                GetReactionForce: function(inv_dt) {
                    var P = new b2Vec2(this.m_impulse.x, this.m_impulse.y);
                    return b2Vec2.Multiply(inv_dt, P);
                },
                GetReactionTorque: function(inv_dt) {
                    return inv_dt * this.m_impulse.z;
                },
                GetLocalAnchorA: function() {
                    return this.m_localAnchorA;
                },
                GetLocalAnchorB: function() {
                    return this.m_localAnchorB;
                },
                GetReferenceAngle: function() {
                    return this.m_referenceAngle;
                },
                SetFrequency: function(hz) {
                    this.m_frequencyHz = hz;
                },
                GetFrequency: function() {
                    return this.m_frequencyHz;
                },
                SetDampingRatio: function(ratio) {
                    this.m_dampingRatio = ratio;
                },
                GetDampingRatio: function() {
                    return this.m_dampingRatio;
                },
                InitVelocityConstraints: function(data) {
                    this.m_indexA = this.m_bodyA.m_islandIndex;
                    this.m_indexB = this.m_bodyB.m_islandIndex;
                    this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
                    this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var aA = data.positions[this.m_indexA].a;
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var aB = data.positions[this.m_indexB].a;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    this.m_rA.Assign(b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA)));
                    this.m_rB.Assign(b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB)));
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    var K = new b2Mat33();
                    K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
                    K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
                    K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
                    K.ex.y = K.ey.x;
                    K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
                    K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
                    K.ex.z = K.ez.x;
                    K.ey.z = K.ez.y;
                    K.ez.z = iA + iB;
                    if (this.m_frequencyHz > 0) {
                        K.GetInverse22(this.m_mass);
                        var invM = iA + iB;
                        var m = invM > 0 ? 1 / invM : 0;
                        var C = aB - aA - this.m_referenceAngle;
                        var omega = 2 * b2_pi * this.m_frequencyHz;
                        var d = 2 * m * this.m_dampingRatio * omega;
                        var k = m * omega * omega;
                        var h = data.step.dt;
                        this.m_gamma = h * (d + h * k);
                        this.m_gamma = 0 != this.m_gamma ? 1 / this.m_gamma : 0;
                        this.m_bias = C * h * k * this.m_gamma;
                        invM += this.m_gamma;
                        this.m_mass.ez.z = 0 != invM ? 1 / invM : 0;
                    } else {
                        if (0 == K.ez.z) {
                            K.GetInverse22(this.m_mass);
                            this.m_gamma = 0;
                            this.m_bias = 0;
                        } else {
                            K.GetSymInverse33(this.m_mass);
                            this.m_gamma = 0;
                            this.m_bias = 0;
                        }
                    }
                    if (data.step.warmStarting) {
                        this.m_impulse.Multiply(data.step.dtRatio);
                        var P = new b2Vec2(this.m_impulse.x, this.m_impulse.y);
                        vA.Subtract(b2Vec2.Multiply(mA, P));
                        wA -= iA * (b2Cross_v2_v2(this.m_rA, P) + this.m_impulse.z);
                        vB.Add(b2Vec2.Multiply(mB, P));
                        wB += iB * (b2Cross_v2_v2(this.m_rB, P) + this.m_impulse.z);
                    } else {
                        this.m_impulse.SetZero();
                    }
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolveVelocityConstraints: function(data) {
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    if (this.m_frequencyHz > 0) {
                        var Cdot2 = wB - wA;
                        var impulse2 = -this.m_mass.ez.z * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z);
                        this.m_impulse.z += impulse2;
                        wA -= iA * impulse2;
                        wB += iB * impulse2;
                        var Cdot1 = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB)), vA), b2Cross_f_v2(wA, this.m_rA));
                        var impulse1 = b2Mul22_m33_v2(this.m_mass, Cdot1).Negate();
                        this.m_impulse.x += impulse1.x;
                        this.m_impulse.y += impulse1.y;
                        var P = impulse1.Clone();
                        vA.Subtract(b2Vec2.Multiply(mA, P));
                        wA -= iA * b2Cross_v2_v2(this.m_rA, P);
                        vB.Add(b2Vec2.Multiply(mB, P));
                        wB += iB * b2Cross_v2_v2(this.m_rB, P);
                    } else {
                        var Cdot1 = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB)), vA), b2Cross_f_v2(wA, this.m_rA));
                        var Cdot2 = wB - wA;
                        var Cdot = new b2Vec3(Cdot1.x, Cdot1.y, Cdot2);
                        var impulse = b2Mul_m33_v3(this.m_mass, Cdot).Negate();
                        this.m_impulse.Add(impulse);
                        var P = new b2Vec2(impulse.x, impulse.y);
                        vA.Subtract(b2Vec2.Multiply(mA, P));
                        wA -= iA * (b2Cross_v2_v2(this.m_rA, P) + impulse.z);
                        vB.Add(b2Vec2.Multiply(mB, P));
                        wB += iB * (b2Cross_v2_v2(this.m_rB, P) + impulse.z);
                    }
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolvePositionConstraints: function(data) {
                    var cA = data.positions[this.m_indexA].c.Clone();
                    var aA = data.positions[this.m_indexA].a;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
                    var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
                    var positionError, angularError;
                    var K = new b2Mat33();
                    K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;
                    K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;
                    K.ez.x = -rA.y * iA - rB.y * iB;
                    K.ex.y = K.ey.x;
                    K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;
                    K.ez.y = rA.x * iA + rB.x * iB;
                    K.ex.z = K.ez.x;
                    K.ey.z = K.ez.y;
                    K.ez.z = iA + iB;
                    if (this.m_frequencyHz > 0) {
                        var C1 = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, rB), cA), rA);
                        positionError = C1.Length();
                        angularError = 0;
                        var P = K.Solve22(C1).Negate();
                        cA.Subtract(b2Vec2.Multiply(mA, P));
                        aA -= iA * b2Cross_v2_v2(rA, P);
                        cB.Add(b2Vec2.Multiply(mB, P));
                        aB += iB * b2Cross_v2_v2(rB, P);
                    } else {
                        var C1 = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, rB), cA), rA);
                        var C2 = aB - aA - this.m_referenceAngle;
                        positionError = C1.Length();
                        angularError = b2Abs(C2);
                        var C = new b2Vec3(C1.x, C1.y, C2);
                        var impulse;
                        if (K.ez.z > 0) {
                            impulse = K.Solve33(C).Invert();
                        } else {
                            var impulse2 = K.Solve22(C1).Invert();
                            impulse = new b2Vec3(impulse2.x, impulse2.y, 0);
                        }
                        var P = new b2Vec2(impulse.x, impulse.y);
                        cA.Subtract(b2Vec2.Multiply(mA, P));
                        aA -= iA * (b2Cross_v2_v2(rA, P) + impulse.z);
                        cB.Add(b2Vec2.Multiply(mB, P));
                        aB += iB * (b2Cross_v2_v2(rB, P) + impulse.z);
                    }
                    data.positions[this.m_indexA].c.Assign(cA);
                    data.positions[this.m_indexA].a = aA;
                    data.positions[this.m_indexB].c.Assign(cB);
                    data.positions[this.m_indexB].a = aB;
                    return positionError <= b2_linearSlop && angularError <= b2_angularSlop;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    this.parent.prototype._serialize.call(this, obj);
                    obj["localAnchorA"] = this.m_localAnchorA._serialize();
                    obj["localAnchorB"] = this.m_localAnchorB._serialize();
                    obj["referenceAngle"] = this.m_referenceAngle;
                    obj["frequencyHz"] = this.m_frequencyHz;
                    obj["dampingRatio"] = this.m_dampingRatio;
                    return obj;
                }
            };
            b2WeldJoint._extend(b2Joint);
            function b2WheelJointDef() {
                this.parent.call(this);
                this.type = b2Joint.e_wheelJoint;
                this.localAnchorA = new b2Vec2();
                this.localAnchorB = new b2Vec2();
                this.localAxisA = new b2Vec2(1, 0);
                this.enableMotor = false;
                this.maxMotorTorque = 0;
                this.motorSpeed = 0;
                this.frequencyHz = 2;
                this.dampingRatio = .7;
                Object.seal(this);
            }
            b2WheelJointDef.prototype = {
                Initialize: function(bA, bB, anchor, axis) {
                    this.bodyA = bA;
                    this.bodyB = bB;
                    this.localAnchorA.Assign(this.bodyA.GetLocalPoint(anchor));
                    this.localAnchorB.Assign(this.bodyB.GetLocalPoint(anchor));
                    this.localAxisA.Assign(this.bodyA.GetLocalVector(axis));
                },
                _deserialize: function(data, bodies, joints) {
                    this.parent.prototype._deserialize.call(this, data, bodies, joints);
                    this.localAnchorA._deserialize(data["localAnchorA"]);
                    this.localAnchorB._deserialize(data["localAnchorB"]);
                    this.localAxisA._deserialize(data["localAxisA"]);
                    this.enableMotor = data["enableMotor"];
                    this.maxMotorTorque = data["maxMotorTorque"];
                    this.motorSpeed = data["motorSpeed"];
                    this.frequencyHz = data["frequencyHz"];
                    this.dampingRatio = data["dampingRatio"];
                }
            };
            b2WheelJointDef._extend(b2JointDef);
            function b2WheelJoint(def) {
                this.parent.call(this, def);
                this.m_indexA = 0;
                this.m_indexB = 0;
                this.m_localCenterA = new b2Vec2();
                this.m_localCenterB = new b2Vec2();
                this.m_invMassA = 0;
                this.m_invMassB = 0;
                this.m_invIA = 0;
                this.m_invIB = 0;
                this.m_localAnchorA = def.localAnchorA.Clone();
                this.m_localAnchorB = def.localAnchorB.Clone();
                this.m_localXAxisA = def.localAxisA.Clone();
                this.m_localYAxisA = b2Cross_f_v2(1, this.m_localXAxisA);
                this.m_mass = 0;
                this.m_impulse = 0;
                this.m_motorMass = 0;
                this.m_motorImpulse = 0;
                this.m_springMass = 0;
                this.m_springImpulse = 0;
                this.m_maxMotorTorque = def.maxMotorTorque;
                this.m_motorSpeed = def.motorSpeed;
                this.m_enableMotor = def.enableMotor;
                this.m_frequencyHz = def.frequencyHz;
                this.m_dampingRatio = def.dampingRatio;
                this.m_bias = 0;
                this.m_gamma = 0;
                this.m_ax = new b2Vec2();
                this.m_ay = new b2Vec2();
                this.m_sAx = this.m_sBx = 0;
                this.m_sAy = this.m_sBy = 0;
            }
            b2WheelJoint.prototype = {
                GetAnchorA: function() {
                    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
                },
                GetAnchorB: function() {
                    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
                },
                GetReactionForce: function(inv_dt) {
                    return b2Vec2.Multiply(inv_dt, b2Vec2.Add(b2Vec2.Multiply(this.m_impulse, this.m_ay), b2Vec2.Multiply(this.m_springImpulse, this.m_ax)));
                },
                GetReactionTorque: function(inv_dt) {
                    return inv_dt * this.m_motorImpulse;
                },
                GetLocalAnchorA: function() {
                    return this.m_localAnchorA;
                },
                GetLocalAnchorB: function() {
                    return this.m_localAnchorB;
                },
                GetLocalAxisA: function() {
                    return this.m_localXAxisA;
                },
                GetJointTranslation: function() {
                    var bA = this.m_bodyA;
                    var bB = this.m_bodyB;
                    var pA = bA.GetWorldPoint(this.m_localAnchorA);
                    var pB = bB.GetWorldPoint(this.m_localAnchorB);
                    var d = b2Vec2.Subtract(pB, pA);
                    var axis = bA.GetWorldVector(this.m_localXAxisA);
                    var translation = b2Dot_v2_v2(d, axis);
                    return translation;
                },
                GetJointSpeed: function() {
                    var wA = this.m_bodyA.m_angularVelocity;
                    var wB = this.m_bodyB.m_angularVelocity;
                    return wB - wA;
                },
                IsMotorEnabled: function() {
                    return this.m_enableMotor;
                },
                EnableMotor: function(flag) {
                    this.m_bodyA.SetAwake(true);
                    this.m_bodyB.SetAwake(true);
                    this.m_enableMotor = flag;
                },
                SetMotorSpeed: function(speed) {
                    this.m_bodyA.SetAwake(true);
                    this.m_bodyB.SetAwake(true);
                    this.m_motorSpeed = speed;
                },
                GetMotorSpeed: function() {
                    return this.m_motorSpeed;
                },
                SetMaxMotorTorque: function(torque) {
                    this.m_bodyA.SetAwake(true);
                    this.m_bodyB.SetAwake(true);
                    this.m_maxMotorTorque = torque;
                },
                GetMaxMotorTorque: function() {
                    return this.m_maxMotorTorque;
                },
                GetMotorTorque: function(inv_dt) {
                    return inv_dt * this.m_motorImpulse;
                },
                SetSpringFrequencyHz: function(hz) {
                    this.m_frequencyHz = hz;
                },
                GetSpringFrequencyHz: function() {
                    return this.m_frequencyHz;
                },
                SetSpringDampingRatio: function(ratio) {
                    this.m_dampingRatio = ratio;
                },
                GetSpringDampingRatio: function() {
                    return this.m_dampingRatio;
                },
                InitVelocityConstraints: function(data) {
                    this.m_indexA = this.m_bodyA.m_islandIndex;
                    this.m_indexB = this.m_bodyB.m_islandIndex;
                    this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
                    this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    var cA = data.positions[this.m_indexA].c.Clone();
                    var aA = data.positions[this.m_indexA].a;
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
                    var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
                    var d = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, rB), cA), rA);
                    this.m_ay.Assign(b2Mul_r_v2(qA, this.m_localYAxisA));
                    this.m_sAy = b2Cross_v2_v2(b2Vec2.Add(d, rA), this.m_ay);
                    this.m_sBy = b2Cross_v2_v2(rB, this.m_ay);
                    this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy * this.m_sBy;
                    this.m_mass > 0 && (this.m_mass = 1 / this.m_mass);
                    this.m_springMass = 0;
                    this.m_bias = 0;
                    this.m_gamma = 0;
                    if (this.m_frequencyHz > 0) {
                        this.m_ax.Assign(b2Mul_r_v2(qA, this.m_localXAxisA));
                        this.m_sAx = b2Cross_v2_v2(b2Vec2.Add(d, rA), this.m_ax);
                        this.m_sBx = b2Cross_v2_v2(rB, this.m_ax);
                        var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx * this.m_sBx;
                        if (invMass > 0) {
                            this.m_springMass = 1 / invMass;
                            var C = b2Dot_v2_v2(d, this.m_ax);
                            var omega = 2 * b2_pi * this.m_frequencyHz;
                            var d = 2 * this.m_springMass * this.m_dampingRatio * omega;
                            var k = this.m_springMass * omega * omega;
                            var h = data.step.dt;
                            this.m_gamma = h * (d + h * k);
                            this.m_gamma > 0 && (this.m_gamma = 1 / this.m_gamma);
                            this.m_bias = C * h * k * this.m_gamma;
                            this.m_springMass = invMass + this.m_gamma;
                            this.m_springMass > 0 && (this.m_springMass = 1 / this.m_springMass);
                        }
                    } else {
                        this.m_springImpulse = 0;
                    }
                    if (this.m_enableMotor) {
                        this.m_motorMass = iA + iB;
                        this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass);
                    } else {
                        this.m_motorMass = 0;
                        this.m_motorImpulse = 0;
                    }
                    if (data.step.warmStarting) {
                        this.m_impulse *= data.step.dtRatio;
                        this.m_springImpulse *= data.step.dtRatio;
                        this.m_motorImpulse *= data.step.dtRatio;
                        var P = b2Vec2.Add(b2Vec2.Multiply(this.m_impulse, this.m_ay), b2Vec2.Multiply(this.m_springImpulse, this.m_ax));
                        var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;
                        var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;
                        vA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
                        wA -= this.m_invIA * LA;
                        vB.Add(b2Vec2.Multiply(this.m_invMassB, P));
                        wB += this.m_invIB * LB;
                    } else {
                        this.m_impulse = 0;
                        this.m_springImpulse = 0;
                        this.m_motorImpulse = 0;
                    }
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolveVelocityConstraints: function(data) {
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var Cdot = b2Dot_v2_v2(this.m_ax, b2Vec2.Subtract(vB, vA)) + this.m_sBx * wB - this.m_sAx * wA;
                    var impulse = -this.m_springMass * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse);
                    this.m_springImpulse += impulse;
                    var P = b2Vec2.Multiply(impulse, this.m_ax);
                    var LA = impulse * this.m_sAx;
                    var LB = impulse * this.m_sBx;
                    vA.Subtract(b2Vec2.Multiply(mA, P));
                    wA -= iA * LA;
                    vB.Add(b2Vec2.Multiply(mB, P));
                    wB += iB * LB;
                    var Cdot = wB - wA - this.m_motorSpeed;
                    var impulse = -this.m_motorMass * Cdot;
                    var oldImpulse = this.m_motorImpulse;
                    var maxImpulse = data.step.dt * this.m_maxMotorTorque;
                    this.m_motorImpulse = b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
                    impulse = this.m_motorImpulse - oldImpulse;
                    wA -= iA * impulse;
                    wB += iB * impulse;
                    var Cdot = b2Dot_v2_v2(this.m_ay, b2Vec2.Subtract(vB, vA)) + this.m_sBy * wB - this.m_sAy * wA;
                    var impulse = -this.m_mass * Cdot;
                    this.m_impulse += impulse;
                    var P = b2Vec2.Multiply(impulse, this.m_ay);
                    var LA = impulse * this.m_sAy;
                    var LB = impulse * this.m_sBy;
                    vA.Subtract(b2Vec2.Multiply(mA, P));
                    wA -= iA * LA;
                    vB.Add(b2Vec2.Multiply(mB, P));
                    wB += iB * LB;
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolvePositionConstraints: function(data) {
                    var cA = data.positions[this.m_indexA].c.Clone();
                    var aA = data.positions[this.m_indexA].a;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
                    var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
                    var d = b2Vec2.Add(b2Vec2.Subtract(cB, cA), b2Vec2.Subtract(rB, rA));
                    var ay = b2Mul_r_v2(qA, this.m_localYAxisA);
                    var sAy = b2Cross_v2_v2(b2Vec2.Add(d, rA), ay);
                    var sBy = b2Cross_v2_v2(rB, ay);
                    var C = b2Dot_v2_v2(d, ay);
                    var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;
                    var impulse;
                    impulse = 0 != k ? -C / k : 0;
                    var P = b2Vec2.Multiply(impulse, ay);
                    var LA = impulse * sAy;
                    var LB = impulse * sBy;
                    cA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
                    aA -= this.m_invIA * LA;
                    cB.Add(b2Vec2.Multiply(this.m_invMassB, P));
                    aB += this.m_invIB * LB;
                    data.positions[this.m_indexA].c.Assign(cA);
                    data.positions[this.m_indexA].a = aA;
                    data.positions[this.m_indexB].c.Assign(cB);
                    data.positions[this.m_indexB].a = aB;
                    return b2Abs(C) <= b2_linearSlop;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    this.parent.prototype._serialize.call(this, obj);
                    obj["localAnchorA"] = this.m_localAnchorA._serialize();
                    obj["localAnchorB"] = this.m_localAnchorB._serialize();
                    obj["localAxisA"] = this.m_localAxisA._serialize();
                    obj["enableMotor"] = this.m_enableMotor;
                    obj["maxMotorTorque"] = this.m_maxMotorTorque;
                    obj["motorSpeed"] = this.m_motorSpeed;
                    obj["frequencyHz"] = this.m_frequencyHz;
                    obj["dampingRatio"] = this.m_dampingRatio;
                    return obj;
                }
            };
            b2WheelJoint._extend(b2Joint);
            function b2GearJointDef() {
                this.parent.call(this);
                this.type = b2Joint.e_gearJoint;
                this.joint1 = null;
                this.joint2 = null;
                this.ratio = 1;
                Object.seal(this);
            }
            b2GearJointDef.prototype = {
                _deserialize: function(data, bodies, joints) {
                    this.parent.prototype._deserialize.call(this, data, bodies, joints);
                    this.joint1 = data["joint1"];
                    this.joint2 = data["joint2"];
                    this.ratio = data["ratio"];
                }
            };
            b2GearJointDef._extend(b2JointDef);
            function b2GearJoint(def) {
                this.parent.call(this, def);
                this.m_joint1 = def.joint1;
                this.m_joint2 = def.joint2;
                this.m_typeA = this.m_joint1.GetType();
                this.m_typeB = this.m_joint2.GetType();
                b2Assert(this.m_typeA == b2Joint.e_revoluteJoint || this.m_typeA == b2Joint.e_prismaticJoint);
                b2Assert(this.m_typeB == b2Joint.e_revoluteJoint || this.m_typeB == b2Joint.e_prismaticJoint);
                var coordinateA, coordinateB;
                this.m_bodyC = this.m_joint1.GetBodyA();
                this.m_bodyA = this.m_joint1.GetBodyB();
                var xfA = this.m_bodyA.m_xf;
                var aA = this.m_bodyA.m_sweep.a;
                var xfC = this.m_bodyC.m_xf;
                var aC = this.m_bodyC.m_sweep.a;
                this.m_localAnchorA = new b2Vec2();
                this.m_localAnchorB = new b2Vec2();
                this.m_localAnchorC = new b2Vec2();
                this.m_localAnchorD = new b2Vec2();
                this.m_localAxisC = new b2Vec2();
                this.m_localAxisD = new b2Vec2();
                if (this.m_typeA == b2Joint.e_revoluteJoint) {
                    var revolute = def.joint1;
                    this.m_localAnchorC.Assign(revolute.m_localAnchorA);
                    this.m_localAnchorA.Assign(revolute.m_localAnchorB);
                    this.m_referenceAngleA = revolute.m_referenceAngle;
                    this.m_localAxisC.SetZero();
                    coordinateA = aA - aC - this.m_referenceAngleA;
                } else {
                    var prismatic = def.joint1;
                    this.m_localAnchorC.Assign(prismatic.m_localAnchorA);
                    this.m_localAnchorA.Assign(prismatic.m_localAnchorB);
                    this.m_referenceAngleA = prismatic.m_referenceAngle;
                    this.m_localAxisC.Assign(prismatic.m_localXAxisA);
                    var pC = this.m_localAnchorC;
                    var pA = b2MulT_r_v2(xfC.q, b2Vec2.Add(b2Mul_r_v2(xfA.q, this.m_localAnchorA), b2Vec2.Subtract(xfA.p, xfC.p)));
                    coordinateA = b2Dot_v2_v2(b2Vec2.Subtract(pA, pC), this.m_localAxisC);
                }
                this.m_bodyD = this.m_joint2.GetBodyA();
                this.m_bodyB = this.m_joint2.GetBodyB();
                var xfB = this.m_bodyB.m_xf;
                var aB = this.m_bodyB.m_sweep.a;
                var xfD = this.m_bodyD.m_xf;
                var aD = this.m_bodyD.m_sweep.a;
                if (this.m_typeB == b2Joint.e_revoluteJoint) {
                    var revolute = def.joint2;
                    this.m_localAnchorD.Assign(revolute.m_localAnchorA);
                    this.m_localAnchorB.Assign(revolute.m_localAnchorB);
                    this.m_referenceAngleB = revolute.m_referenceAngle;
                    this.m_localAxisD.SetZero();
                    coordinateB = aB - aD - this.m_referenceAngleB;
                } else {
                    var prismatic = def.joint2;
                    this.m_localAnchorD.Assign(prismatic.m_localAnchorA);
                    this.m_localAnchorB.Assign(prismatic.m_localAnchorB);
                    this.m_referenceAngleB = prismatic.m_referenceAngle;
                    this.m_localAxisD.Assign(prismatic.m_localXAxisA);
                    var pD = this.m_localAnchorD;
                    var pB = b2MulT_r_v2(xfD.q, b2Vec2.Add(b2Mul_r_v2(xfB.q, this.m_localAnchorB), b2Vec2.Subtract(xfB.p, xfD.p)));
                    coordinateB = b2Dot_v2_v2(b2Vec2.Subtract(pB, pD), this.m_localAxisD);
                }
                this.m_ratio = def.ratio;
                this.m_constant = coordinateA + this.m_ratio * coordinateB;
                this.m_impulse = 0;
                this.m_indexA = this.m_indexB = this.m_indexC = this.m_indexD = 0;
                this.m_lcA = new b2Vec2();
                this.m_lcB = new b2Vec2();
                this.m_lcC = new b2Vec2();
                this.m_lcD = new b2Vec2();
                this.m_mA = this.m_mB = this.m_mC = this.m_mD = 0;
                this.m_iA = this.m_iB = this.m_iC = this.m_iD = 0;
                this.m_JvAC = new b2Vec2(), this.m_JvBD = new b2Vec2();
                this.m_JwA = this.m_JwB = this.m_JwC = this.m_JwD = 0;
                this.m_mass = 0;
            }
            b2GearJoint.prototype = {
                GetAnchorA: function() {
                    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
                },
                GetAnchorB: function() {
                    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
                },
                GetReactionForce: function(inv_dt) {
                    var P = b2Vec2.Multiply(this.m_impulse, this.m_JvAC);
                    return b2Vec2.Multiply(inv_dt, P);
                },
                GetReactionTorque: function(inv_dt) {
                    var L = this.m_impulse * this.m_JwA;
                    return inv_dt * L;
                },
                GetJoint1: function() {
                    return this.m_joint1;
                },
                GetJoint2: function() {
                    return this.m_joint2;
                },
                SetRatio: function(ratio) {
                    b2Assert(b2IsValid(ratio));
                    this.m_ratio = ratio;
                },
                GetRatio: function() {
                    return this.m_ratio;
                },
                InitVelocityConstraints: function(data) {
                    this.m_indexA = this.m_bodyA.m_islandIndex;
                    this.m_indexB = this.m_bodyB.m_islandIndex;
                    this.m_indexC = this.m_bodyC.m_islandIndex;
                    this.m_indexD = this.m_bodyD.m_islandIndex;
                    this.m_lcA.Assign(this.m_bodyA.m_sweep.localCenter);
                    this.m_lcB.Assign(this.m_bodyB.m_sweep.localCenter);
                    this.m_lcC.Assign(this.m_bodyC.m_sweep.localCenter);
                    this.m_lcD.Assign(this.m_bodyD.m_sweep.localCenter);
                    this.m_mA = this.m_bodyA.m_invMass;
                    this.m_mB = this.m_bodyB.m_invMass;
                    this.m_mC = this.m_bodyC.m_invMass;
                    this.m_mD = this.m_bodyD.m_invMass;
                    this.m_iA = this.m_bodyA.m_invI;
                    this.m_iB = this.m_bodyB.m_invI;
                    this.m_iC = this.m_bodyC.m_invI;
                    this.m_iD = this.m_bodyD.m_invI;
                    var aA = data.positions[this.m_indexA].a;
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var aB = data.positions[this.m_indexB].a;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var aC = data.positions[this.m_indexC].a;
                    var vC = data.velocities[this.m_indexC].v.Clone();
                    var wC = data.velocities[this.m_indexC].w;
                    var aD = data.positions[this.m_indexD].a;
                    var vD = data.velocities[this.m_indexD].v.Clone();
                    var wD = data.velocities[this.m_indexD].w;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB), qC = new b2Rot(aC), qD = new b2Rot(aD);
                    this.m_mass = 0;
                    if (this.m_typeA == b2Joint.e_revoluteJoint) {
                        this.m_JvAC.SetZero();
                        this.m_JwA = 1;
                        this.m_JwC = 1;
                        this.m_mass += this.m_iA + this.m_iC;
                    } else {
                        var u = b2Mul_r_v2(qC, this.m_localAxisC);
                        var rC = b2Mul_r_v2(qC, b2Vec2.Subtract(this.m_localAnchorC, this.m_lcC));
                        var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_lcA));
                        this.m_JvAC.Assign(u);
                        this.m_JwC = b2Cross_v2_v2(rC, u);
                        this.m_JwA = b2Cross_v2_v2(rA, u);
                        this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;
                    }
                    if (this.m_typeB == b2Joint.e_revoluteJoint) {
                        this.m_JvBD.SetZero();
                        this.m_JwB = this.m_ratio;
                        this.m_JwD = this.m_ratio;
                        this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
                    } else {
                        var u = b2Mul_r_v2(qD, this.m_localAxisD);
                        var rD = b2Mul_r_v2(qD, b2Vec2.Subtract(this.m_localAnchorD, this.m_lcD));
                        var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_lcB));
                        this.m_JvBD.Assign(b2Vec2.Multiply(this.m_ratio, u));
                        this.m_JwD = this.m_ratio * b2Cross_v2_v2(rD, u);
                        this.m_JwB = this.m_ratio * b2Cross_v2_v2(rB, u);
                        this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;
                    }
                    this.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0;
                    if (data.step.warmStarting) {
                        vA.Add(b2Vec2.Multiply(this.m_mA * this.m_impulse, this.m_JvAC));
                        wA += this.m_iA * this.m_impulse * this.m_JwA;
                        vB.Add(b2Vec2.Multiply(this.m_mB * this.m_impulse, this.m_JvBD));
                        wB += this.m_iB * this.m_impulse * this.m_JwB;
                        vC.Subtract(b2Vec2.Multiply(this.m_mC * this.m_impulse, this.m_JvAC));
                        wC -= this.m_iC * this.m_impulse * this.m_JwC;
                        vD.Subtract(b2Vec2.Multiply(this.m_mD * this.m_impulse, this.m_JvBD));
                        wD -= this.m_iD * this.m_impulse * this.m_JwD;
                    } else {
                        this.m_impulse = 0;
                    }
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                    data.velocities[this.m_indexC].v.Assign(vC);
                    data.velocities[this.m_indexC].w = wC;
                    data.velocities[this.m_indexD].v.Assign(vD);
                    data.velocities[this.m_indexD].w = wD;
                },
                SolveVelocityConstraints: function(data) {
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var vC = data.velocities[this.m_indexC].v.Clone();
                    var wC = data.velocities[this.m_indexC].w;
                    var vD = data.velocities[this.m_indexD].v.Clone();
                    var wD = data.velocities[this.m_indexD].w;
                    var Cdot = b2Dot_v2_v2(this.m_JvAC, b2Vec2.Subtract(vA, vC)) + b2Dot_v2_v2(this.m_JvBD, b2Vec2.Subtract(vB, vD));
                    Cdot += this.m_JwA * wA - this.m_JwC * wC + (this.m_JwB * wB - this.m_JwD * wD);
                    var impulse = -this.m_mass * Cdot;
                    this.m_impulse += impulse;
                    vA.Add(b2Vec2.Multiply(this.m_mA * impulse, this.m_JvAC));
                    wA += this.m_iA * impulse * this.m_JwA;
                    vB.Add(b2Vec2.Multiply(this.m_mB * impulse, this.m_JvBD));
                    wB += this.m_iB * impulse * this.m_JwB;
                    vC.Subtract(b2Vec2.Multiply(this.m_mC * impulse, this.m_JvAC));
                    wC -= this.m_iC * impulse * this.m_JwC;
                    vD.Subtract(b2Vec2.Multiply(this.m_mD * impulse, this.m_JvBD));
                    wD -= this.m_iD * impulse * this.m_JwD;
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                    data.velocities[this.m_indexC].v.Assign(vC);
                    data.velocities[this.m_indexC].w = wC;
                    data.velocities[this.m_indexD].v.Assign(vD);
                    data.velocities[this.m_indexD].w = wD;
                },
                SolvePositionConstraints: function(data) {
                    var cA = data.positions[this.m_indexA].c.Clone();
                    var aA = data.positions[this.m_indexA].a;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var cC = data.positions[this.m_indexC].c.Clone();
                    var aC = data.positions[this.m_indexC].a;
                    var cD = data.positions[this.m_indexD].c.Clone();
                    var aD = data.positions[this.m_indexD].a;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB), qC = new b2Rot(aC), qD = new b2Rot(aD);
                    var linearError = 0;
                    var coordinateA, coordinateB;
                    var JvAC = new b2Vec2(), JvBD = new b2Vec2();
                    var JwA, JwB, JwC, JwD;
                    var mass = 0;
                    if (this.m_typeA == b2Joint.e_revoluteJoint) {
                        JvAC.SetZero();
                        JwA = 1;
                        JwC = 1;
                        mass += this.m_iA + this.m_iC;
                        coordinateA = aA - aC - this.m_referenceAngleA;
                    } else {
                        var u = b2Mul_r_v2(qC, this.m_localAxisC);
                        var rC = b2Mul_r_v2(qC, b2Vec2.Subtract(this.m_localAnchorC, this.m_lcC));
                        var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_lcA));
                        JvAC.Assign(u);
                        JwC = b2Cross_v2_v2(rC, u);
                        JwA = b2Cross_v2_v2(rA, u);
                        mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;
                        var pC = b2Vec2.Subtract(this.m_localAnchorC, this.m_lcC);
                        var pA = b2MulT_r_v2(qC, b2Vec2.Add(rA, b2Vec2.Subtract(cA, cC)));
                        coordinateA = b2Dot_v2_v2(b2Vec2.Subtract(pA, pC), this.m_localAxisC);
                    }
                    if (this.m_typeB == b2Joint.e_revoluteJoint) {
                        JvBD.SetZero();
                        JwB = this.m_ratio;
                        JwD = this.m_ratio;
                        mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
                        coordinateB = aB - aD - this.m_referenceAngleB;
                    } else {
                        var u = b2Mul_r_v2(qD, this.m_localAxisD);
                        var rD = b2Mul_r_v2(qD, b2Vec2.Subtract(this.m_localAnchorD, this.m_lcD));
                        var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_lcB));
                        JvBD.Assign(b2Vec2.Multiply(this.m_ratio, u));
                        JwD = this.m_ratio * b2Cross_v2_v2(rD, u);
                        JwB = this.m_ratio * b2Cross_v2_v2(rB, u);
                        mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * JwD * JwD + this.m_iB * JwB * JwB;
                        var pD = b2Vec2.Subtract(this.m_localAnchorD, this.m_lcD);
                        var pB = b2MulT_r_v2(qD, b2Vec2.Add(rB, b2Vec2.Subtract(cB, cD)));
                        coordinateB = b2Dot_v2_v2(b2Vec2.Subtract(pB, pD), this.m_localAxisD);
                    }
                    var C = coordinateA + this.m_ratio * coordinateB - this.m_constant;
                    var impulse = 0;
                    mass > 0 && (impulse = -C / mass);
                    cA.Add(b2Vec2.Multiply(this.m_mA, b2Vec2.Multiply(impulse, JvAC)));
                    aA += this.m_iA * impulse * JwA;
                    cB.Add(b2Vec2.Multiply(this.m_mB, b2Vec2.Multiply(impulse, JvBD)));
                    aB += this.m_iB * impulse * JwB;
                    cC.Subtract(b2Vec2.Multiply(this.m_mC, b2Vec2.Multiply(impulse, JvAC)));
                    aC -= this.m_iC * impulse * JwC;
                    cD.Subtract(b2Vec2.Multiply(this.m_mD, b2Vec2.Multiply(impulse, JvBD)));
                    aD -= this.m_iD * impulse * JwD;
                    data.positions[this.m_indexA].c.Assign(cA);
                    data.positions[this.m_indexA].a = aA;
                    data.positions[this.m_indexB].c.Assign(cB);
                    data.positions[this.m_indexB].a = aB;
                    data.positions[this.m_indexC].c.Assign(cC);
                    data.positions[this.m_indexC].a = aC;
                    data.positions[this.m_indexD].c.Assign(cD);
                    data.positions[this.m_indexD].a = aD;
                    return linearError < b2_linearSlop;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    this.parent.prototype._serialize.call(this, obj);
                    obj["joint1"] = this.m_joint1.__temp_joint_id;
                    obj["joint2"] = this.m_joint2.__temp_joint_id;
                    obj["ratio"] = this.m_ratio;
                    return obj;
                }
            };
            b2GearJoint._extend(b2Joint);
            function b2MotorJointDef() {
                this.parent.call(this);
                this.type = b2Joint.e_motorJoint;
                this.linearOffset = new b2Vec2();
                this.angularOffset = 0;
                this.maxForce = 1;
                this.maxTorque = 1;
                this.correctionFactor = .3;
                Object.seal(this);
            }
            b2MotorJointDef.prototype = {
                Initialize: function(bA, bB) {
                    this.bodyA = bA;
                    this.bodyB = bB;
                    var xB = this.bodyB.GetPosition();
                    this.linearOffset.Assign(this.bodyA.GetLocalPoint(xB));
                    var angleA = this.bodyA.GetAngle();
                    var angleB = this.bodyB.GetAngle();
                    this.angularOffset = angleB - angleA;
                },
                _deserialize: function(data, bodies, joints) {
                    this.parent.prototype._deserialize.call(this, data, bodies, joints);
                    this.linearOffset._deserialize(data["linearOffset"]);
                    this.angularOffset = data["angularOffset"];
                    this.maxForce = data["maxForce"];
                    this.maxTorque = data["maxTorque"];
                    this.correctionFactor = data["correctionFactor"];
                }
            };
            b2MotorJointDef._extend(b2JointDef);
            function b2MotorJoint(def) {
                this.parent.call(this, def);
                this.m_linearOffset = def.linearOffset.Clone();
                this.m_angularOffset = def.angularOffset;
                this.m_linearImpulse = new b2Vec2();
                this.m_angularImpulse = 0;
                this.m_maxForce = def.maxForce;
                this.m_maxTorque = def.maxTorque;
                this.m_correctionFactor = def.correctionFactor;
                this.m_indexA = 0;
                this.m_indexB = 0;
                this.m_rA = new b2Vec2();
                this.m_rB = new b2Vec2();
                this.m_localCenterA = new b2Vec2();
                this.m_localCenterB = new b2Vec2();
                this.m_linearError = new b2Vec2();
                this.m_angularError = 0;
                this.m_invMassA = 0;
                this.m_invMassB = 0;
                this.m_invIA = 0;
                this.m_invIB = 0;
                this.m_linearMass = new b2Mat22();
                this.m_angularMass = 0;
            }
            b2MotorJoint.prototype = {
                GetAnchorA: function() {
                    return this.m_bodyA.GetPosition();
                },
                GetAnchorB: function() {
                    return this.m_bodyB.GetPosition();
                },
                GetReactionForce: function(inv_dt) {
                    return b2Vec2.Multiply(inv_dt, this.m_linearImpulse);
                },
                GetReactionTorque: function(inv_dt) {
                    return inv_dt * this.m_angularImpulse;
                },
                SetLinearOffset: function(linearOffset) {
                    if (linearOffset.x != this.m_linearOffset.x || linearOffset.y != this.m_linearOffset.y) {
                        this.m_bodyA.SetAwake(true);
                        this.m_bodyB.SetAwake(true);
                        this.m_linearOffset.Assign(linearOffset);
                    }
                },
                GetLinearOffset: function() {
                    return this.m_linearOffset;
                },
                SetAngularOffset: function(angularOffset) {
                    if (angularOffset != this.m_angularOffset) {
                        this.m_bodyA.SetAwake(true);
                        this.m_bodyB.SetAwake(true);
                        this.m_angularOffset = angularOffset;
                    }
                },
                GetAngularOffset: function() {
                    return this.m_angularOffset;
                },
                SetMaxForce: function(force) {
                    b2Assert(b2IsValid(force) && force >= 0);
                    this.m_maxForce = force;
                },
                GetMaxForce: function() {
                    return this.m_maxForce;
                },
                SetMaxTorque: function(torque) {
                    b2Assert(b2IsValid(torque) && torque >= 0);
                    this.m_maxTorque = torque;
                },
                GetMaxTorque: function() {
                    return this.m_maxTorque;
                },
                SetCorrectionFactor: function(factor) {
                    b2Assert(b2IsValid(factor) && 0 <= factor && factor <= 1);
                    this.m_correctionFactor = factor;
                },
                GetCorrectionFactor: function() {
                    return this.m_correctionFactor;
                },
                InitVelocityConstraints: function(data) {
                    this.m_indexA = this.m_bodyA.m_islandIndex;
                    this.m_indexB = this.m_bodyB.m_islandIndex;
                    this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
                    this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = data.positions[this.m_indexA].c.Clone();
                    var aA = data.positions[this.m_indexA].a;
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    this.m_rA.Assign(b2Mul_r_v2(qA, this.m_localCenterA.Negate()));
                    this.m_rB.Assign(b2Mul_r_v2(qB, this.m_localCenterB.Negate()));
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    var K = new b2Mat22();
                    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;
                    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
                    K.ey.x = K.ex.y;
                    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;
                    this.m_linearMass.Assign(K.GetInverse());
                    this.m_angularMass = iA + iB;
                    this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass);
                    this.m_linearError.x = cB.x + this.m_rB.x - cA.x - this.m_rA.x - (qA.c * this.m_linearOffset.x - qA.s * this.m_linearOffset.y);
                    this.m_linearError.y = cB.y + this.m_rB.y - cA.y - this.m_rA.y - (qA.s * this.m_linearOffset.x + qA.c * this.m_linearOffset.y);
                    this.m_angularError = aB - aA - this.m_angularOffset;
                    if (data.step.warmStarting) {
                        this.m_linearImpulse.Multiply(data.step.dtRatio);
                        this.m_angularImpulse *= data.step.dtRatio;
                        var P = new b2Vec2(this.m_linearImpulse.x, this.m_linearImpulse.y);
                        vA.Subtract(b2Vec2.Multiply(mA, P));
                        wA -= iA * (b2Cross_v2_v2(this.m_rA, P) + this.m_angularImpulse);
                        vB.Add(b2Vec2.Multiply(mB, P));
                        wB += iB * (b2Cross_v2_v2(this.m_rB, P) + this.m_angularImpulse);
                    } else {
                        this.m_linearImpulse.SetZero();
                        this.m_angularImpulse = 0;
                    }
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolveVelocityConstraints: function(data) {
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var mA = this.m_invMassA, mB = this.m_invMassB;
                    var iA = this.m_invIA, iB = this.m_invIB;
                    var h = data.step.dt;
                    var inv_h = data.step.inv_dt;
                    var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;
                    var impulse = -this.m_angularMass * Cdot;
                    var oldImpulse = this.m_angularImpulse;
                    var maxImpulse = h * this.m_maxTorque;
                    this.m_angularImpulse = b2Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
                    impulse = this.m_angularImpulse - oldImpulse;
                    wA -= iA * impulse;
                    wB += iB * impulse;
                    var Cdot = new b2Vec2(vB.x + -wB * this.m_rB.x - vA.x - -wA * this.m_rA.x + inv_h * this.m_correctionFactor * this.m_linearError.x, vB.y + wB * this.m_rB.y - vA.y - wA * this.m_rA.y + inv_h * this.m_correctionFactor * this.m_linearError.y);
                    var impulse = b2Mul_m22_v2(this.m_linearMass, Cdot).Negate();
                    var oldImpulse = this.m_linearImpulse.Clone();
                    this.m_linearImpulse.Add(impulse);
                    var maxImpulse = h * this.m_maxForce;
                    if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
                        this.m_linearImpulse.Normalize();
                        this.m_linearImpulse.Multiply(maxImpulse);
                    }
                    impulse.Assign(b2Vec2.Subtract(this.m_linearImpulse, oldImpulse));
                    vA.Subtract(b2Vec2.Multiply(mA, impulse));
                    wA -= iA * b2Cross_v2_v2(this.m_rA, impulse);
                    vB.Add(b2Vec2.Multiply(mB, impulse));
                    wB += iB * b2Cross_v2_v2(this.m_rB, impulse);
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolvePositionConstraints: function(data) {
                    return true;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    this.parent.prototype._serialize.call(this, obj);
                    obj["linearOffset"] = this.m_linearOffset._serialize();
                    obj["angularOffset"] = this.m_angularOffset;
                    obj["maxForce"] = this.m_maxForce;
                    obj["maxTorque"] = this.m_maxTorque;
                    obj["correctionFactor"] = this.m_correctionFactor;
                    return obj;
                }
            };
            b2MotorJoint._extend(b2Joint);
            var b2_minPulleyLength = 2;
            function b2PulleyJointDef() {
                this.parent.call(this);
                this.type = b2Joint.e_pulleyJoint;
                this.groundAnchorA = new b2Vec2(-1, 1);
                this.groundAnchorB = new b2Vec2(1, 1);
                this.localAnchorA = new b2Vec2(-1, 0);
                this.localAnchorB = new b2Vec2(1, 0);
                this.lengthA = 0;
                this.lengthB = 0;
                this.ratio = 1;
                this.collideConnected = true;
                Object.seal(this);
            }
            b2PulleyJointDef.prototype = {
                Initialize: function(bA, bB, groundA, groundB, anchorA, anchorB, r) {
                    this.bodyA = bA;
                    this.bodyB = bB;
                    this.groundAnchorA.Assign(groundA);
                    this.groundAnchorB.Assign(groundB);
                    this.localAnchorA.Assign(this.bodyA.GetLocalPoint(anchorA));
                    this.localAnchorB.Assign(this.bodyB.GetLocalPoint(anchorB));
                    var dA = b2Vec2.Subtract(anchorA, groundA);
                    this.lengthA = dA.Length();
                    var dB = b2Vec2.Subtract(anchorB, groundB);
                    this.lengthB = dB.Length();
                    this.ratio = r;
                    b2Assert(this.ratio > b2_epsilon);
                },
                _deserialize: function(data, bodies, joints) {
                    this.parent.prototype._deserialize.call(this, data, bodies, joints);
                    this.groundAnchorA._deserialize(data["groundAnchorA"]);
                    this.groundAnchorB._deserialize(data["groundAnchorB"]);
                    this.localAnchorA._deserialize(data["localAnchorA"]);
                    this.localAnchorB._deserialize(data["localAnchorB"]);
                    this.lengthA = data["lengthA"];
                    this.lengthB = data["lengthB"];
                    this.ratio = data["ratio"];
                }
            };
            b2PulleyJointDef._extend(b2JointDef);
            function b2PulleyJoint(def) {
                this.parent.call(this, def);
                this.m_indexA = 0;
                this.m_indexB = 0;
                this.m_uA = new b2Vec2();
                this.m_uB = new b2Vec2();
                this.m_rA = new b2Vec2();
                this.m_rB = new b2Vec2();
                this.m_localCenterA = new b2Vec2();
                this.m_localCenterB = new b2Vec2();
                this.m_invMassA = 0;
                this.m_invMassB = 0;
                this.m_invIA = 0;
                this.m_invIB = 0;
                this.m_mass = 0;
                this.m_groundAnchorA = def.groundAnchorA.Clone();
                this.m_groundAnchorB = def.groundAnchorB.Clone();
                this.m_localAnchorA = def.localAnchorA.Clone();
                this.m_localAnchorB = def.localAnchorB.Clone();
                this.m_lengthA = def.lengthA;
                this.m_lengthB = def.lengthB;
                b2Assert(0 != def.ratio);
                this.m_ratio = def.ratio;
                this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
                this.m_impulse = 0;
            }
            b2PulleyJoint.prototype = {
                GetAnchorA: function() {
                    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
                },
                GetAnchorB: function() {
                    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
                },
                GetReactionForce: function(inv_dt) {
                    var P = b2Vec2.Multiply(this.m_impulse, this.m_uB);
                    return b2Vec2.Multiply(inv_dt, P);
                },
                GetReactionTorque: function(inv_dt) {
                    return 0;
                },
                GetGroundAnchorA: function() {
                    return this.m_groundAnchorA;
                },
                GetGroundAnchorB: function() {
                    return this.m_groundAnchorB;
                },
                GetLengthA: function() {
                    return this.m_lengthA;
                },
                GetLengthB: function() {
                    return this.m_lengthB;
                },
                GetRatio: function() {
                    return this.m_ratio;
                },
                GetCurrentLengthA: function() {
                    var p = this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
                    var s = this.m_groundAnchorA;
                    var d = b2Vec2.Subtract(p, s);
                    return d.Length();
                },
                GetCurrentLengthB: function() {
                    var p = this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
                    var s = this.m_groundAnchorB;
                    var d = b2Vec2.Subtract(p, s);
                    return d.Length();
                },
                ShiftOrigin: function(newOrigin) {
                    this.m_groundAnchorA.Subtract(newOrigin);
                    this.m_groundAnchorB.Subtract(newOrigin);
                },
                InitVelocityConstraints: function(data) {
                    this.m_indexA = this.m_bodyA.m_islandIndex;
                    this.m_indexB = this.m_bodyB.m_islandIndex;
                    this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
                    this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = data.positions[this.m_indexA].c.Clone();
                    var aA = data.positions[this.m_indexA].a;
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    this.m_rA.Assign(b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA)));
                    this.m_rB.Assign(b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB)));
                    this.m_uA.Assign(b2Vec2.Add(cA, b2Vec2.Subtract(this.m_rA, this.m_groundAnchorA)));
                    this.m_uB.Assign(b2Vec2.Add(cB, b2Vec2.Subtract(this.m_rB, this.m_groundAnchorB)));
                    var lengthA = this.m_uA.Length();
                    var lengthB = this.m_uB.Length();
                    lengthA > 10 * b2_linearSlop ? this.m_uA.Multiply(1 / lengthA) : this.m_uA.SetZero();
                    lengthB > 10 * b2_linearSlop ? this.m_uB.Multiply(1 / lengthB) : this.m_uB.SetZero();
                    var ruA = b2Cross_v2_v2(this.m_rA, this.m_uA);
                    var ruB = b2Cross_v2_v2(this.m_rB, this.m_uB);
                    var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
                    var mB = this.m_invMassB + this.m_invIB * ruB * ruB;
                    this.m_mass = mA + this.m_ratio * this.m_ratio * mB;
                    this.m_mass > 0 && (this.m_mass = 1 / this.m_mass);
                    if (data.step.warmStarting) {
                        this.m_impulse *= data.step.dtRatio;
                        var PA = b2Vec2.Multiply(-this.m_impulse, this.m_uA);
                        var PB = b2Vec2.Multiply(-this.m_ratio * this.m_impulse, this.m_uB);
                        vA.Add(b2Vec2.Multiply(this.m_invMassA, PA));
                        wA += this.m_invIA * b2Cross_v2_v2(this.m_rA, PA);
                        vB.Add(b2Vec2.Multiply(this.m_invMassB, PB));
                        wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, PB);
                    } else {
                        this.m_impulse = 0;
                    }
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolveVelocityConstraints: function(data) {
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var vpA = b2Vec2.Add(vA, b2Cross_f_v2(wA, this.m_rA));
                    var vpB = b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB));
                    var Cdot = -b2Dot_v2_v2(this.m_uA, vpA) - this.m_ratio * b2Dot_v2_v2(this.m_uB, vpB);
                    var impulse = -this.m_mass * Cdot;
                    this.m_impulse += impulse;
                    var PA = b2Vec2.Multiply(-impulse, this.m_uA);
                    var PB = b2Vec2.Multiply(-this.m_ratio, b2Vec2.Multiply(impulse, this.m_uB));
                    vA.Add(b2Vec2.Multiply(this.m_invMassA, PA));
                    wA += this.m_invIA * b2Cross_v2_v2(this.m_rA, PA);
                    vB.Add(b2Vec2.Multiply(this.m_invMassB, PB));
                    wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, PB);
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolvePositionConstraints: function(data) {
                    var cA = data.positions[this.m_indexA].c.Clone();
                    var aA = data.positions[this.m_indexA].a;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
                    var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
                    var uA = b2Vec2.Add(cA, b2Vec2.Subtract(rA, this.m_groundAnchorA));
                    var uB = b2Vec2.Add(cB, b2Vec2.Subtract(rB, this.m_groundAnchorB));
                    var lengthA = uA.Length();
                    var lengthB = uB.Length();
                    lengthA > 10 * b2_linearSlop ? uA.Multiply(1 / lengthA) : uA.SetZero();
                    lengthB > 10 * b2_linearSlop ? uB.Multiply(1 / lengthB) : uB.SetZero();
                    var ruA = b2Cross_v2_v2(rA, uA);
                    var ruB = b2Cross_v2_v2(rB, uB);
                    var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
                    var mB = this.m_invMassB + this.m_invIB * ruB * ruB;
                    var mass = mA + this.m_ratio * this.m_ratio * mB;
                    mass > 0 && (mass = 1 / mass);
                    var C = this.m_constant - lengthA - this.m_ratio * lengthB;
                    var linearError = b2Abs(C);
                    var impulse = -mass * C;
                    var PA = b2Vec2.Multiply(-impulse, uA);
                    var PB = b2Vec2.Multiply(-this.m_ratio, b2Vec2.Multiply(impulse, uB));
                    cA.Add(b2Vec2.Multiply(this.m_invMassA, PA));
                    aA += this.m_invIA * b2Cross_v2_v2(rA, PA);
                    cB.Add(b2Vec2.Multiply(this.m_invMassB, PB));
                    aB += this.m_invIB * b2Cross_v2_v2(rB, PB);
                    data.positions[this.m_indexA].c.Assign(cA);
                    data.positions[this.m_indexA].a = aA;
                    data.positions[this.m_indexB].c.Assign(cB);
                    data.positions[this.m_indexB].a = aB;
                    return linearError < b2_linearSlop;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    this.parent.prototype._serialize.call(this, obj);
                    obj["groundAnchorA"] = this.m_groundAnchorA._serialize();
                    obj["groundAnchorB"] = this.m_groundAnchorB._serialize();
                    obj["localAnchorA"] = this.m_localAnchorA._serialize();
                    obj["localAnchorB"] = this.m_localAnchorB._serialize();
                    obj["lengthA"] = this.m_lengthA;
                    obj["lengthB"] = this.m_lengthB;
                    obj["ratio"] = this.m_ratio;
                    return obj;
                }
            };
            b2PulleyJoint._extend(b2Joint);
            function b2RopeJointDef() {
                this.parent.call(this);
                this.type = b2Joint.e_ropeJoint;
                this.localAnchorA = new b2Vec2(-1, 0);
                this.localAnchorB = new b2Vec2(1, 0);
                this.maxLength = 0;
                Object.seal(this);
            }
            b2RopeJointDef.prototype = {
                _deserialize: function(data, bodies, joints) {
                    this.parent.prototype._deserialize.call(this, data, bodies, joints);
                    this.localAnchorA._deserialize(data["localAnchorA"]);
                    this.localAnchorB._deserialize(data["localAnchorB"]);
                    this.maxLength = data["maxLength"];
                }
            };
            b2RopeJointDef._extend(b2JointDef);
            function b2RopeJoint(def) {
                this.parent.call(this, def);
                this.m_localAnchorA = def.localAnchorA.Clone();
                this.m_localAnchorB = def.localAnchorB.Clone();
                this.m_maxLength = def.maxLength;
                this.m_mass = 0;
                this.m_impulse = 0;
                this.m_state = b2Joint.e_inactiveLimit;
                this.m_length = 0;
                this.m_indexA = 0;
                this.m_indexB = 0;
                this.m_u = new b2Vec2();
                this.m_rA = new b2Vec2();
                this.m_rB = new b2Vec2();
                this.m_localCenterA = new b2Vec2();
                this.m_localCenterB = new b2Vec2();
                this.m_invMassA = 0;
                this.m_invMassB = 0;
                this.m_invIA = 0;
                this.m_invIB = 0;
            }
            b2RopeJoint.prototype = {
                GetAnchorA: function() {
                    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
                },
                GetAnchorB: function() {
                    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
                },
                GetReactionForce: function(inv_dt) {
                    var F = b2Vec2.Multiply(inv_dt * this.m_impulse, this.m_u);
                    return F;
                },
                GetReactionTorque: function(inv_dt) {
                    return 0;
                },
                GetLocalAnchorA: function() {
                    return this.m_localAnchorA;
                },
                GetLocalAnchorB: function() {
                    return this.m_localAnchorB;
                },
                SetMaxLength: function(length) {
                    this.m_maxLength = length;
                },
                GetMaxLength: function() {
                    return this.m_maxLength;
                },
                GetLimitState: function() {
                    return this.m_state;
                },
                InitVelocityConstraints: function(data) {
                    this.m_indexA = this.m_bodyA.m_islandIndex;
                    this.m_indexB = this.m_bodyB.m_islandIndex;
                    this.m_localCenterA.Assign(this.m_bodyA.m_sweep.localCenter);
                    this.m_localCenterB.Assign(this.m_bodyB.m_sweep.localCenter);
                    this.m_invMassA = this.m_bodyA.m_invMass;
                    this.m_invMassB = this.m_bodyB.m_invMass;
                    this.m_invIA = this.m_bodyA.m_invI;
                    this.m_invIB = this.m_bodyB.m_invI;
                    var cA = data.positions[this.m_indexA].c.Clone();
                    var aA = data.positions[this.m_indexA].a;
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    this.m_rA.Assign(b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA)));
                    this.m_rB.Assign(b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB)));
                    this.m_u.Assign(b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, this.m_rB), cA), this.m_rA));
                    this.m_length = this.m_u.Length();
                    var C = this.m_length - this.m_maxLength;
                    C > 0 ? this.m_state = b2Joint.e_atUpperLimit : this.m_state = b2Joint.e_inactiveLimit;
                    if (!(this.m_length > b2_linearSlop)) {
                        this.m_u.SetZero();
                        this.m_mass = 0;
                        this.m_impulse = 0;
                        return;
                    }
                    this.m_u.Multiply(1 / this.m_length);
                    var crA = b2Cross_v2_v2(this.m_rA, this.m_u);
                    var crB = b2Cross_v2_v2(this.m_rB, this.m_u);
                    var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB + this.m_invIB * crB * crB;
                    this.m_mass = 0 != invMass ? 1 / invMass : 0;
                    if (data.step.warmStarting) {
                        this.m_impulse *= data.step.dtRatio;
                        var P = b2Vec2.Multiply(this.m_impulse, this.m_u);
                        vA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
                        wA -= this.m_invIA * b2Cross_v2_v2(this.m_rA, P);
                        vB.Add(b2Vec2.Multiply(this.m_invMassB, P));
                        wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, P);
                    } else {
                        this.m_impulse = 0;
                    }
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolveVelocityConstraints: function(data) {
                    var vA = data.velocities[this.m_indexA].v.Clone();
                    var wA = data.velocities[this.m_indexA].w;
                    var vB = data.velocities[this.m_indexB].v.Clone();
                    var wB = data.velocities[this.m_indexB].w;
                    var vpA = b2Vec2.Add(vA, b2Cross_f_v2(wA, this.m_rA));
                    var vpB = b2Vec2.Add(vB, b2Cross_f_v2(wB, this.m_rB));
                    var C = this.m_length - this.m_maxLength;
                    var Cdot = b2Dot_v2_v2(this.m_u, b2Vec2.Subtract(vpB, vpA));
                    C < 0 && (Cdot += data.step.inv_dt * C);
                    var impulse = -this.m_mass * Cdot;
                    var oldImpulse = this.m_impulse;
                    this.m_impulse = b2Min(0, this.m_impulse + impulse);
                    impulse = this.m_impulse - oldImpulse;
                    var P = b2Vec2.Multiply(impulse, this.m_u);
                    vA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
                    wA -= this.m_invIA * b2Cross_v2_v2(this.m_rA, P);
                    vB.Add(b2Vec2.Multiply(this.m_invMassB, P));
                    wB += this.m_invIB * b2Cross_v2_v2(this.m_rB, P);
                    data.velocities[this.m_indexA].v.Assign(vA);
                    data.velocities[this.m_indexA].w = wA;
                    data.velocities[this.m_indexB].v.Assign(vB);
                    data.velocities[this.m_indexB].w = wB;
                },
                SolvePositionConstraints: function(data) {
                    var cA = data.positions[this.m_indexA].c.Clone();
                    var aA = data.positions[this.m_indexA].a;
                    var cB = data.positions[this.m_indexB].c.Clone();
                    var aB = data.positions[this.m_indexB].a;
                    var qA = new b2Rot(aA), qB = new b2Rot(aB);
                    var rA = b2Mul_r_v2(qA, b2Vec2.Subtract(this.m_localAnchorA, this.m_localCenterA));
                    var rB = b2Mul_r_v2(qB, b2Vec2.Subtract(this.m_localAnchorB, this.m_localCenterB));
                    var u = b2Vec2.Subtract(b2Vec2.Subtract(b2Vec2.Add(cB, rB), cA), rA);
                    var length = u.Normalize();
                    var C = length - this.m_maxLength;
                    C = b2Clamp(C, 0, b2_maxLinearCorrection);
                    var impulse = -this.m_mass * C;
                    var P = b2Vec2.Multiply(impulse, u);
                    cA.Subtract(b2Vec2.Multiply(this.m_invMassA, P));
                    aA -= this.m_invIA * b2Cross_v2_v2(rA, P);
                    cB.Add(b2Vec2.Multiply(this.m_invMassB, P));
                    aB += this.m_invIB * b2Cross_v2_v2(rB, P);
                    data.positions[this.m_indexA].c.Assign(cA);
                    data.positions[this.m_indexA].a = aA;
                    data.positions[this.m_indexB].c.Assign(cB);
                    data.positions[this.m_indexB].a = aB;
                    return length - this.m_maxLength < b2_linearSlop;
                },
                _serialize: function(out) {
                    var obj = out || {};
                    this.parent.prototype._serialize.call(this, obj);
                    obj["localAnchorA"] = this.m_localAnchorA._serialize();
                    obj["localAnchorB"] = this.m_localAnchorB._serialize();
                    obj["maxLength"] = this.m_maxLength;
                    return obj;
                }
            };
            b2RopeJoint._extend(b2Joint);
            var expf = Math.exp;
            function b2RopeDef() {
                this.vertices = null;
                this.count = 0;
                this.masses = null;
                this.gravity = new b2Vec2();
                this.damping = .1;
                this.k2 = .9;
                this.k3 = .1;
            }
            function b2Rope() {
                this.m_count = 0;
                this.m_ps = null;
                this.m_p0s = null;
                this.m_vs = null;
                this.m_ims = null;
                this.m_Ls = null;
                this.m_as = null;
                this.m_damping = 0;
                this.m_gravity = new b2Vec2();
                this.m_k2 = 1;
                this.m_k3 = .1;
            }
            b2Rope.prototype = {
                Initialize: function(def) {
                    b2Assert(def.count >= 3);
                    this.m_count = def.count;
                    this.m_ps = new Array(this.m_count);
                    this.m_p0s = new Array(this.m_count);
                    this.m_vs = new Array(this.m_count);
                    this.m_ims = new Array(this.m_count);
                    for (var i = 0; i < this.m_count; ++i) {
                        this.m_ps[i] = def.vertices[i].Clone();
                        this.m_p0s[i] = def.vertices[i].Clone();
                        this.m_vs[i] = new b2Vec2();
                        var m = def.masses[i];
                        m > 0 ? this.m_ims[i] = 1 / m : this.m_ims[i] = 0;
                    }
                    var count2 = this.m_count - 1;
                    var count3 = this.m_count - 2;
                    this.m_Ls = new Array(count2);
                    this.m_as = new Array(count3);
                    for (var i = 0; i < count2; ++i) {
                        var p1 = this.m_ps[i];
                        var p2 = this.m_ps[i + 1];
                        this.m_Ls[i] = b2Distance(p1, p2);
                    }
                    for (var i = 0; i < count3; ++i) {
                        var p1 = this.m_ps[i];
                        var p2 = this.m_ps[i + 1];
                        var p3 = this.m_ps[i + 2];
                        var d1 = b2Vec2.Subtract(p2, p1);
                        var d2 = b2Vec2.Subtract(p3, p2);
                        var a = b2Cross_v2_v2(d1, d2);
                        var b = b2Dot_v2_v2(d1, d2);
                        this.m_as[i] = b2Atan2(a, b);
                    }
                    this.m_gravity = def.gravity.Clone();
                    this.m_damping = def.damping;
                    this.m_k2 = def.k2;
                    this.m_k3 = def.k3;
                },
                Step: function(h, iterations) {
                    if (0 == h) {
                        return;
                    }
                    var d = expf(-h * this.m_damping);
                    for (var i = 0; i < this.m_count; ++i) {
                        this.m_p0s[i].Assign(this.m_ps[i]);
                        this.m_ims[i] > 0 && this.m_vs[i].Add(b2Vec2.Multiply(h, this.m_gravity));
                        this.m_vs[i].Multiply(d);
                        this.m_ps[i].Add(b2Vec2.Multiply(h, this.m_vs[i]));
                    }
                    for (var i = 0; i < iterations; ++i) {
                        this.SolveC2();
                        this.SolveC3();
                        this.SolveC2();
                    }
                    var inv_h = 1 / h;
                    for (var i = 0; i < this.m_count; ++i) {
                        this.m_vs[i] = b2Vec2.Multiply(inv_h, b2Vec2.Subtract(this.m_ps[i], this.m_p0s[i]));
                    }
                },
                GetVertexCount: function() {
                    return this.m_count;
                },
                GetVertices: function() {
                    return this.m_ps;
                },
                Draw: function(draw) {
                    var c = new b2Color(.4, .5, .7);
                    for (var i = 0; i < this.m_count - 1; ++i) {
                        draw.DrawSegment(this.m_ps[i], this.m_ps[i + 1], c);
                    }
                },
                SetAngle: function(angle) {
                    var count3 = this.m_count - 2;
                    for (var i = 0; i < count3; ++i) {
                        this.m_as[i] = angle;
                    }
                },
                SolveC2: function() {
                    var count2 = this.m_count - 1;
                    for (var i = 0; i < count2; ++i) {
                        var p1 = this.m_ps[i];
                        var p2 = this.m_ps[i + 1];
                        var d = b2Vec2.Subtract(p2, p1);
                        var L = d.Normalize();
                        var im1 = this.m_ims[i];
                        var im2 = this.m_ims[i + 1];
                        if (im1 + im2 == 0) {
                            continue;
                        }
                        var s1 = im1 / (im1 + im2);
                        var s2 = im2 / (im1 + im2);
                        p1.Subtract(b2Vec2.Multiply(this.m_k2 * s1 * (this.m_Ls[i] - L), d));
                        p2.Add(b2Vec2.Multiply(this.m_k2 * s2 * (this.m_Ls[i] - L), d));
                    }
                },
                SolveC3: function() {
                    var count3 = this.m_count - 2;
                    for (var i = 0; i < count3; ++i) {
                        var p1 = this.m_ps[i];
                        var p2 = this.m_ps[i + 1];
                        var p3 = this.m_ps[i + 2];
                        var m1 = this.m_ims[i];
                        var m2 = this.m_ims[i + 1];
                        var m3 = this.m_ims[i + 2];
                        var d1 = b2Vec2.Subtract(p2, p1);
                        var d2 = b2Vec2.Subtract(p3, p2);
                        var L1sqr = d1.LengthSquared();
                        var L2sqr = d2.LengthSquared();
                        if (L1sqr * L2sqr == 0) {
                            continue;
                        }
                        var a = b2Cross_v2_v2(d1, d2);
                        var b = b2Dot_v2_v2(d1, d2);
                        var angle = b2Atan2(a, b);
                        var Jd1 = b2Vec2.Multiply(-1 / L1sqr, d1.Skew());
                        var Jd2 = b2Vec2.Multiply(1 / L2sqr, d2.Skew());
                        var J1 = b2Vec2.Negate(Jd1);
                        var J2 = b2Vec2.Subtract(Jd1, Jd2);
                        var J3 = Jd2;
                        var mass = m1 * b2Dot_v2_v2(J1, J1) + m2 * b2Dot_v2_v2(J2, J2) + m3 * b2Dot_v2_v2(J3, J3);
                        if (0 == mass) {
                            continue;
                        }
                        mass = 1 / mass;
                        var C = angle - this.m_as[i];
                        while (C > b2_pi) {
                            angle -= 2 * b2_pi;
                            C = angle - this.m_as[i];
                        }
                        while (C < -b2_pi) {
                            angle += 2 * b2_pi;
                            C = angle - this.m_as[i];
                        }
                        var impulse = -this.m_k3 * mass * C;
                        p1.Add(b2Vec2.Multiply(m1 * impulse, J1));
                        p2.Add(b2Vec2.Multiply(m2 * impulse, J2));
                        p3.Add(b2Vec2.Multiply(m3 * impulse, J3));
                    }
                }
            };
            var b2JsonSerializer = {
                serialize: function(world) {
                    var shapes = [];
                    var i;
                    var serialized;
                    var b;
                    var f;
                    var shape;
                    for (b = world.GetBodyList(); b; b = b.GetNext()) {
                        for (f = b.GetFixtureList(); f; f = f.GetNext()) {
                            shape = f.GetShape();
                            f.__temp_shape_id = shapes.length;
                            shapes.push(shape._serialize());
                        }
                    }
                    var fixtures = [];
                    for (b = world.GetBodyList(); b; b = b.GetNext()) {
                        b.__temp_fixture_ids = [];
                        for (f = b.GetFixtureList(); f; f = f.GetNext()) {
                            serialized = f._serialize();
                            serialized["shape"] = f.__temp_shape_id;
                            delete f.__temp_shape_id;
                            b.__temp_fixture_ids.push(fixtures.length);
                            fixtures.push(serialized);
                        }
                    }
                    var bodies = [];
                    for (b = world.GetBodyList(); b; b = b.GetNext()) {
                        serialized = b._serialize();
                        serialized.fixtures = [];
                        for (i = 0; i < b.__temp_fixture_ids.length; ++i) {
                            serialized.fixtures.push(b.__temp_fixture_ids[i]);
                        }
                        delete b.__temp_fixture_ids;
                        b.__temp_body_id = bodies.length;
                        bodies.push(serialized);
                    }
                    var joints = [];
                    var j;
                    for (j = world.GetJointList(), i = 0; j; j = j.GetNext(), ++i) {
                        j.__temp_joint_id = i;
                    }
                    for (j = world.GetJointList(); j; j = j.GetNext()) {
                        if (j.GetType() === b2Joint.e_mouseJoint) {
                            continue;
                        }
                        serialized = j._serialize();
                        serialized["bodyA"] = j.GetBodyA().__temp_body_id;
                        serialized["bodyB"] = j.GetBodyB().__temp_body_id;
                        joints.push(serialized);
                    }
                    for (j = world.GetJointList(); j; j = j.GetNext()) {
                        delete j.__temp_joint_id;
                    }
                    for (b = world.GetBodyList(); b; b = b.GetNext()) {
                        delete b.__temp_body_id;
                    }
                    return {
                        shapes: shapes,
                        fixtures: fixtures,
                        bodies: bodies,
                        joints: joints
                    };
                },
                deserialize: function(serialized, world, clear) {
                    var deserialized = JSON.parse(serialized);
                    if (clear) {
                        for (var b = world.GetBodyList(); b; ) {
                            var next = b.GetNext();
                            world.DestroyBody(b);
                            b = next;
                        }
                        for (var j = world.GetJointList(); j; ) {
                            var next = j.GetNext();
                            world.DestroyJoint(j);
                            j = next;
                        }
                    }
                    var shapes = [];
                    for (var i = 0; i < deserialized.shapes.length; ++i) {
                        var shapeData = deserialized.shapes[i];
                        var shape;
                        switch (shapeData.m_type) {
                          case b2Shape.e_circle:
                            shape = new b2CircleShape();
                            break;

                          case b2Shape.e_edge:
                            shape = new b2EdgeShape();
                            break;

                          case b2Shape.e_chain:
                            shape = new b2ChainShape();
                            break;

                          case b2Shape.e_polygon:
                            shape = new b2PolygonShape();
                        }
                        shape._deserialize(shapeData);
                        shapes.push(shape);
                    }
                    var fixtures = [];
                    for (i = 0; i < deserialized.fixtures.length; ++i) {
                        var fixtureData = deserialized.fixtures[i];
                        var fixture = new b2FixtureDef();
                        fixture._deserialize(fixtureData);
                        fixture.shape = shapes[fixtureData["shape"]];
                        fixtures.push(fixture);
                    }
                    var bodies = [];
                    for (i = 0; i < deserialized.bodies.length; ++i) {
                        var bodyData = deserialized.bodies[i];
                        var def = new b2BodyDef();
                        def._deserialize(bodyData);
                        var body = world.CreateBody(def);
                        for (var x = 0; x < bodyData.fixtures.length; ++x) {
                            body.CreateFixture(fixtures[bodyData.fixtures[x]]);
                        }
                        bodies.push(body);
                    }
                    var joints = [];
                    var gears = [];
                    for (i = 0; i < deserialized.joints.length; ++i) {
                        var jointData = deserialized.joints[i];
                        var jointDef;
                        switch (jointData.type) {
                          case b2Joint.e_revoluteJoint:
                            jointDef = new b2RevoluteJointDef();
                            break;

                          case b2Joint.e_prismaticJoint:
                            jointDef = new b2PrismaticJointDef();
                            break;

                          case b2Joint.e_distanceJoint:
                            jointDef = new b2DistanceJointDef();
                            break;

                          case b2Joint.e_pulleyJoint:
                            jointDef = new b2PulleyJointDef();
                            break;

                          case b2Joint.e_gearJoint:
                            jointDef = new b2GearJointDef();
                            break;

                          case b2Joint.e_wheelJoint:
                            jointDef = new b2WheelJointDef();
                            break;

                          case b2Joint.e_weldJoint:
                            jointDef = new b2WeldJointDef();
                            break;

                          case b2Joint.e_frictionJoint:
                            jointDef = new b2FrictionJointDef();
                            break;

                          case b2Joint.e_ropeJoint:
                            jointDef = new b2RopeJointDef();
                            break;

                          case b2Joint.e_motorJoint:
                            jointDef = new b2MotorJointDef();
                            break;

                          default:
                            throw new Error("unknown joint");
                        }
                        jointDef._deserialize(jointData, bodies);
                        if (jointData.type === b2Joint.e_gearJoint) {
                            gears.push([ jointDef, joints.length ]);
                            joints.push(null);
                        } else {
                            var joint = world.CreateJoint(jointDef);
                            joints.push(joint);
                        }
                    }
                    for (i = 0; i < gears.length; ++i) {
                        gears[i][0].joint1 = joints[gears[i][0].joint1];
                        gears[i][0].joint2 = joints[gears[i][0].joint2];
                        joint = world.CreateJoint(gears[i][0]);
                        joints[gears[i][1]] = joint;
                    }
                }
            };
            var b2RUBELoader = (function() {
                function parseVector(obj) {
                    return new b2Vec2(obj ? obj.x || 0 : 0, obj ? obj.y || 0 : 0);
                }
                function parseVectorArray(obj) {
                    var vals = new Array(obj.x.length);
                    for (var i = 0; i < vals.length; ++i) {
                        vals[i] = new b2Vec2(obj.x[i], obj.y[i]);
                    }
                    return vals;
                }
                function parseProperty(obj, instance) {
                    var name = obj.name;
                    var val;
                    if ("undefined" !== typeof obj["int"]) {
                        val = obj["int"];
                    } else {
                        if ("undefined" !== typeof obj["float"]) {
                            val = obj["float"];
                        } else {
                            if ("undefined" !== typeof obj["string"]) {
                                val = obj["string"];
                            } else {
                                if ("undefined" !== typeof obj["bool"]) {
                                    val = obj["bool"];
                                } else {
                                    if ("undefined" === typeof obj.vec2) {
                                        throw new Error("unknown property type");
                                    }
                                    val = parseVector(obj.vec2);
                                }
                            }
                        }
                    }
                    if (instance.hasOwnProperty(name)) {
                        throw new Error("custom property possibly overwriting an existing one");
                    }
                    instance[name] = val;
                }
                function parseFixture(obj, body) {
                    var def = new b2FixtureDef();
                    def.density = obj.density || 0;
                    def.filter.categoryBits = "undefined" === typeof obj["filter-categoryBits"] ? 1 : obj["filter-categoryBits"];
                    def.filter.maskBits = "undefined" === typeof obj["filter-maskBits"] ? 65535 : obj["filter-maskBits"];
                    def.filter.groupIndex = "undefined" === typeof obj["filter-groupIndex"] ? 0 : obj["filter-groupIndex"];
                    def.friction = obj.friction || 0;
                    def.restitution = obj.restitution || 0;
                    def.isSensor = obj.sensor || 0;
                    var shape;
                    if ("undefined" !== typeof obj.circle) {
                        shape = new b2CircleShape();
                        shape.m_p = parseVector(obj.circle.center);
                        shape.m_radius = obj.circle.radius || 0;
                    } else {
                        if ("undefined" !== typeof obj.polygon) {
                            var vertices = parseVectorArray(obj.polygon.vertices);
                            shape = new b2PolygonShape();
                            shape.Set(vertices, vertices.length);
                        } else {
                            if ("undefined" === typeof obj.chain) {
                                throw new Error("unknown shape type");
                            }
                            var vertices = parseVectorArray(obj.chain.vertices);
                            shape = new b2ChainShape();
                            shape.m_count = vertices.length;
                            shape.m_vertices = vertices;
                            (shape.m_hasNextVertex = obj.chain.hasNextVertex) && (shape.m_nextVertex = parseVector(obj.chain.nextVertex));
                            (shape.m_hasPrevVertex = obj.chain.hasPrevVertex) && (shape.m_prevVertex = parseVector(obj.chain.prevVertex));
                        }
                    }
                    def.shape = shape;
                    var fixture = body.CreateFixture(def);
                    fixture.name = obj.name;
                    if (obj.customProperties) {
                        for (var i = 0; i < obj.customProperties.length; ++i) {
                            parseProperty(obj, fixture);
                        }
                    }
                }
                function parseBody(obj, world) {
                    var def = new b2BodyDef();
                    def.type = obj.type || b2Body.b2_staticBody;
                    def.angle = obj.angle || 0;
                    def.angularDamping = obj.angularDamping || 0;
                    def.angularVelocity = obj.angularVelocity || 0;
                    def.awake = obj.awake || false;
                    def.bullet = obj.bullet || false;
                    def.fixedRotation = obj.fixedRotation || false;
                    def.linearDamping = obj.linearDamping || false;
                    def.linearVelocity = parseVector(obj.linearVelocity);
                    def.gravityScale = "undefined" !== typeof obj.gravityScale ? obj.gravityScale : 1;
                    var md = new b2MassData();
                    md.mass = obj["massData-mass"] || 0;
                    md.center = parseVector(obj["massData-center"]);
                    md.I = obj["massData-I"] || 0;
                    def.position = parseVector(obj.position);
                    var body = world.CreateBody(def);
                    body.name = obj.name;
                    body.SetMassData(md);
                    if (obj.fixture) {
                        for (var i = 0; i < obj.fixture.length; ++i) {
                            parseFixture(obj.fixture[i], body);
                        }
                    }
                    if (obj.customProperties) {
                        for (i = 0; i < obj.customProperties.length; ++i) {
                            parseProperty(obj, body);
                        }
                    }
                    return body;
                }
                var jointsList = {
                    revolute: b2RevoluteJointDef,
                    distance: b2DistanceJointDef,
                    prismatic: b2PrismaticJointDef,
                    wheel: b2WheelJointDef,
                    rope: b2RopeJointDef,
                    motor: b2MotorJointDef,
                    weld: b2WeldJointDef,
                    friction: b2FrictionJointDef
                };
                function parseJoint(obj, world, bodies) {
                    if (!jointsList[obj.type]) {
                        throw new Error("unknown joint type");
                    }
                    var jd = new jointsList[obj.type]();
                    switch (jd.type) {
                      case b2Joint.e_revoluteJoint:
                        jd.localAnchorA = parseVector(obj.anchorA);
                        jd.localAnchorB = parseVector(obj.anchorB);
                        jd.enableLimit = obj.enableLimit || false;
                        jd.enableMotor = obj.enableMotor || false;
                        jd.lowerAngle = obj.lowerLimit || 0;
                        jd.maxMotorTorque = obj.maxMotorTorque || 0;
                        jd.motorSpeed = obj.motorSpeed || 0;
                        jd.referenceAngle = obj.refAngle || 0;
                        jd.upperAngle = obj.upperLimit || 0;
                        break;

                      case b2Joint.e_distanceJoint:
                        jd.localAnchorA = parseVector(obj.anchorA);
                        jd.localAnchorB = parseVector(obj.anchorB);
                        jd.dampingRatio = obj.dampingRatio || 0;
                        jd.frequencyHz = obj.frequency || 0;
                        jd.length = obj.length || 0;
                        break;

                      case b2Joint.e_prismaticJoint:
                        jd.localAnchorA = parseVector(obj.anchorA);
                        jd.localAnchorB = parseVector(obj.anchorB);
                        jd.enableLimit = obj.enableLimit || false;
                        jd.enableMotor = obj.enableMotor || false;
                        jd.localAxisA = parseVector(obj.localAxisA);
                        jd.lowerTranslation = obj.lowerLimit || 0;
                        jd.maxMotorForce = obj.maxMotorForce || 0;
                        jd.motorSpeed = obj.motorSpeed || 0;
                        jd.referenceAngle = obj.refAngle || 0;
                        jd.upperTranslation = obj.upperLimit || 0;
                        break;

                      case b2Joint.e_wheelJoint:
                        jd.localAnchorA = parseVector(obj.anchorA);
                        jd.localAnchorB = parseVector(obj.anchorB);
                        jd.enableMotor = obj.enableMotor || false;
                        jd.localAxisA = parseVector(obj.localAxisA);
                        jd.maxMotorTorque = obj.maxMotorTorque || 0;
                        jd.motorSpeed = obj.motorSpeed || 0;
                        jd.dampingRatio = obj.springDampingRatio || 0;
                        jd.frequencyHz = obj.springFrequency || 0;
                        break;

                      case b2Joint.e_ropeJoint:
                        jd.localAnchorA = parseVector(obj.anchorA);
                        jd.localAnchorB = parseVector(obj.anchorB);
                        jd.maxLength = obj.maxLength || 0;
                        break;

                      case b2Joint.e_motorJoint:
                        jd.linearOffset = parseVector(obj.anchorA);
                        jd.angularOffset = obj.refAngle || 0;
                        jd.maxForce = obj.maxForce || 0;
                        jd.maxTorque = obj.maxTorque || 0;
                        jd.correctionFactor = obj.correctionFactor || 0;
                        break;

                      case b2Joint.e_weldJoint:
                        jd.localAnchorA = parseVector(obj.anchorA);
                        jd.localAnchorB = parseVector(obj.anchorB);
                        jd.referenceAngle = obj.refAngle || 0;
                        jd.dampingRatio = obj.dampingRatio || 0;
                        jd.frequencyHz = obj.frequencyHz || 0;
                        break;

                      case b2Joint.e_frictionJoint:
                        jd.localAnchorA = parseVector(obj.anchorA);
                        jd.localAnchorB = parseVector(obj.anchorB);
                        jd.maxForce = obj.maxForce || 0;
                        jd.maxTorque = obj.maxTorque || 0;
                        break;

                      default:
                        throw new Error("wat?");
                    }
                    jd.bodyA = bodies[obj.bodyA || 0];
                    jd.bodyB = bodies[obj.bodyB || 0];
                    jd.collideConnected = obj.collideConnected || false;
                    var joint = world.CreateJoint(jd);
                    joint.name = obj.name;
                    if (obj.customProperties) {
                        for (var i = 0; i < obj.customProperties.length; ++i) {
                            parseProperty(obj, joint);
                        }
                    }
                    return joint;
                }
                function b2RubeParameters() {
                    this.world = null;
                    this.positionIterations = 0;
                    this.velocityIterations = 0;
                    this.stepsPerSecond = 0;
                    this.fixtures = {};
                    this.bodies = {};
                    this.joints = {};
                    Object.seal(this);
                }
                function parseWorld(obj, world) {
                    var params = new b2RubeParameters();
                    params.world = world = world || new b2World(new b2Vec2(0, 0));
                    params.positionIterations = obj.positionIterations || 0;
                    params.velocityIterations = obj.velocityIterations || 0;
                    params.stepsPerSecond = obj.stepsPerSecond || 0;
                    obj.gravity && world.SetGravity(parseVector(obj.gravity));
                    world.SetAllowSleeping(obj.allowSleep || false);
                    world.SetAutoClearForces(obj.autoClearForces || false);
                    world.SetWarmStarting(obj.warmStarting || false);
                    world.SetContinuousPhysics(obj.continuousPhysics || false);
                    world.SetSubStepping(obj.subStepping || false);
                    var bodies = [];
                    var bl = obj.body;
                    if (bl) {
                        for (var i = 0; i < bl.length; ++i) {
                            var body = parseBody(bl[i], world);
                            bodies.push(body);
                            for (var f = body.GetFixtureList(); f; f = f.GetNext()) {
                                params.fixtures[f.name] || (params.fixtures[f.name] = []);
                                params.fixtures[f.name].push(f);
                            }
                            params.bodies[body.name] || (params.bodies[body.name] = []);
                            params.bodies[body.name].push(body);
                        }
                    }
                    var joints = [];
                    var jl = obj.joint;
                    if (jl) {
                        for (i = 0; i < jl.length; ++i) {
                            var joint = parseJoint(jl[i], world, bodies);
                            joints.push(joint);
                            params.joints[joint.name] || (params.joints[joint.name] = []);
                            params.joints[joint.name].push(joint);
                        }
                    }
                    return params;
                }
                return {
                    parseWorld: parseWorld
                };
            })();
            var mappings = [ {
                trimmed: "version",
                name: "b2_version",
                def: b2_version
            }, {
                trimmed: "Vec2",
                name: "b2Vec2",
                def: b2Vec2
            }, {
                trimmed: "Vec3",
                name: "b2Vec3",
                def: b2Vec3
            }, {
                trimmed: "Mat22",
                name: "b2Mat22",
                def: b2Mat22
            }, {
                trimmed: "Mat33",
                name: "b2Mat33",
                def: b2Mat33
            }, {
                trimmed: "Rot",
                name: "b2Rot",
                def: b2Rot
            }, {
                trimmed: "Transform",
                name: "b2Transform",
                def: b2Transform
            }, {
                trimmed: "Sweep",
                name: "b2Sweep",
                def: b2Sweep
            }, {
                trimmed: "Dot_v2_v2",
                name: "b2Dot_v2_v2",
                def: b2Dot_v2_v2
            }, {
                trimmed: "Cross_v2_v2",
                name: "b2Cross_v2_v2",
                def: b2Cross_v2_v2
            }, {
                trimmed: "Cross_v2_f",
                name: "b2Cross_v2_f",
                def: b2Cross_v2_f
            }, {
                trimmed: "Cross_f_v2",
                name: "b2Cross_f_v2",
                def: b2Cross_f_v2
            }, {
                trimmed: "Mul_m22_v2",
                name: "b2Mul_m22_v2",
                def: b2Mul_m22_v2
            }, {
                trimmed: "MulT_m22_v2",
                name: "b2MulT_m22_v2",
                def: b2MulT_m22_v2
            }, {
                trimmed: "Distance",
                name: "b2Distance",
                def: b2Distance
            }, {
                trimmed: "DistanceSquared",
                name: "b2DistanceSquared",
                def: b2DistanceSquared
            }, {
                trimmed: "Dot_v3_v3",
                name: "b2Dot_v3_v3",
                def: b2Dot_v3_v3
            }, {
                trimmed: "Cross_v3_v3",
                name: "b2Cross_v3_v3",
                def: b2Cross_v3_v3
            }, {
                trimmed: "Mul_m22_m22",
                name: "b2Mul_m22_m22",
                def: b2Mul_m22_m22
            }, {
                trimmed: "MulT_m22_m22",
                name: "b2MulT_m22_m22",
                def: b2MulT_m22_m22
            }, {
                trimmed: "Mul_m33_v3",
                name: "b2Mul_m33_v3",
                def: b2Mul_m33_v3
            }, {
                trimmed: "Mul22_m33_v2",
                name: "b2Mul22_m33_v2",
                def: b2Mul22_m33_v2
            }, {
                trimmed: "Mul_r_r",
                name: "b2Mul_r_r",
                def: b2Mul_r_r
            }, {
                trimmed: "MulT_r_r",
                name: "b2MulT_r_r",
                def: b2MulT_r_r
            }, {
                trimmed: "Mul_r_v2",
                name: "b2Mul_r_v2",
                def: b2Mul_r_v2
            }, {
                trimmed: "MulT_r_v2",
                name: "b2MulT_r_v2",
                def: b2MulT_r_v2
            }, {
                trimmed: "Mul_t_v2",
                name: "b2Mul_t_v2",
                def: b2Mul_t_v2
            }, {
                trimmed: "Min_v2",
                name: "b2Min_v2",
                def: b2Min_v2
            }, {
                trimmed: "Max_v2",
                name: "b2Max_v2",
                def: b2Max_v2
            }, {
                trimmed: "Clamp",
                name: "b2Clamp",
                def: b2Clamp
            }, {
                trimmed: "MulT_t_v2",
                name: "b2MulT_t_v2",
                def: b2MulT_t_v2
            }, {
                trimmed: "Mul_t_t",
                name: "b2Mul_t_t",
                def: b2Mul_t_t
            }, {
                trimmed: "MulT_t_t",
                name: "b2MulT_t_t",
                def: b2MulT_t_t
            }, {
                trimmed: "Clamp_v2",
                name: "b2Clamp_v2",
                def: b2Clamp_v2
            }, {
                trimmed: "NextPowerOfTwo",
                name: "b2NextPowerOfTwo",
                def: b2NextPowerOfTwo
            }, {
                trimmed: "Abs_v2",
                name: "b2Abs_v2",
                def: b2Abs_v2
            }, {
                trimmed: "Abs_m22",
                name: "b2Abs_m22",
                def: b2Abs_m22
            }, {
                trimmed: "IsPowerOfTwo",
                name: "b2IsPowerOfTwo",
                def: b2IsPowerOfTwo
            }, {
                trimmed: "RandomFloat",
                name: "b2RandomFloat",
                def: b2RandomFloat
            }, {
                trimmed: "Timer",
                name: "b2Timer",
                def: b2Timer
            }, {
                trimmed: "Color",
                name: "b2Color",
                def: b2Color
            }, {
                trimmed: "Draw",
                name: "b2Draw",
                def: b2Draw
            }, {
                trimmed: "ContactID",
                name: "b2ContactID",
                def: b2ContactID
            }, {
                trimmed: "ManifoldPoint",
                name: "b2ManifoldPoint",
                def: b2ManifoldPoint
            }, {
                trimmed: "Manifold",
                name: "b2Manifold",
                def: b2Manifold
            }, {
                trimmed: "WorldManifold",
                name: "b2WorldManifold",
                def: b2WorldManifold
            }, {
                trimmed: "GetPointStates",
                name: "b2GetPointStates",
                def: b2GetPointStates
            }, {
                trimmed: "ClipVertex",
                name: "b2ClipVertex",
                def: b2ClipVertex
            }, {
                trimmed: "RayCastInput",
                name: "b2RayCastInput",
                def: b2RayCastInput
            }, {
                trimmed: "RayCastOutput",
                name: "b2RayCastOutput",
                def: b2RayCastOutput
            }, {
                trimmed: "AABB",
                name: "b2AABB",
                def: b2AABB
            }, {
                trimmed: "CollideCircles",
                name: "b2CollideCircles",
                def: b2CollideCircles
            }, {
                trimmed: "CollidePolygonAndCircle",
                name: "b2CollidePolygonAndCircle",
                def: b2CollidePolygonAndCircle
            }, {
                trimmed: "FindMaxSeparation",
                name: "b2FindMaxSeparation",
                def: b2FindMaxSeparation
            }, {
                trimmed: "FindIncidentEdge",
                name: "b2FindIncidentEdge",
                def: b2FindIncidentEdge
            }, {
                trimmed: "CollidePolygons",
                name: "b2CollidePolygons",
                def: b2CollidePolygons
            }, {
                trimmed: "CollideEdgeAndCircle",
                name: "b2CollideEdgeAndCircle",
                def: b2CollideEdgeAndCircle
            }, {
                trimmed: "EPAxis",
                name: "b2EPAxis",
                def: b2EPAxis
            }, {
                trimmed: "TempPolygon",
                name: "b2TempPolygon",
                def: b2TempPolygon
            }, {
                trimmed: "ReferenceFace",
                name: "b2ReferenceFace",
                def: b2ReferenceFace
            }, {
                trimmed: "EPCollider",
                name: "b2EPCollider",
                def: b2EPCollider
            }, {
                trimmed: "CollideEdgeAndPolygon",
                name: "b2CollideEdgeAndPolygon",
                def: b2CollideEdgeAndPolygon
            }, {
                trimmed: "ClipSegmentToLine",
                name: "b2ClipSegmentToLine",
                def: b2ClipSegmentToLine
            }, {
                trimmed: "TestShapeOverlap",
                name: "b2TestShapeOverlap",
                def: b2TestShapeOverlap
            }, {
                trimmed: "TestOverlap",
                name: "b2TestOverlap",
                def: b2TestOverlap
            }, {
                trimmed: "Shape",
                name: "b2Shape",
                def: b2Shape
            }, {
                trimmed: "CircleShape",
                name: "b2CircleShape",
                def: b2CircleShape
            }, {
                trimmed: "EdgeShape",
                name: "b2EdgeShape",
                def: b2EdgeShape
            }, {
                trimmed: "ChainShape",
                name: "b2ChainShape",
                def: b2ChainShape
            }, {
                trimmed: "PolygonShape",
                name: "b2PolygonShape",
                def: b2PolygonShape
            }, {
                trimmed: "Pair",
                name: "b2Pair",
                def: b2Pair
            }, {
                trimmed: "PairLessThan",
                name: "b2PairLessThan",
                def: b2PairLessThan
            }, {
                trimmed: "BroadPhase",
                name: "b2BroadPhase",
                def: b2BroadPhase
            }, {
                trimmed: "DistanceProxy",
                name: "b2DistanceProxy",
                def: b2DistanceProxy
            }, {
                trimmed: "SimplexCache",
                name: "b2SimplexCache",
                def: b2SimplexCache
            }, {
                trimmed: "DistanceInput",
                name: "b2DistanceInput",
                def: b2DistanceInput
            }, {
                trimmed: "DistanceOutput",
                name: "b2DistanceOutput",
                def: b2DistanceOutput
            }, {
                trimmed: "SimplexVertex",
                name: "b2SimplexVertex",
                def: b2SimplexVertex
            }, {
                trimmed: "Simplex",
                name: "b2Simplex",
                def: b2Simplex
            }, {
                trimmed: "DistanceFunc",
                name: "b2DistanceFunc",
                def: b2DistanceFunc
            }, {
                trimmed: "TreeNode",
                name: "b2TreeNode",
                def: b2TreeNode
            }, {
                trimmed: "DynamicTree",
                name: "b2DynamicTree",
                def: b2DynamicTree
            }, {
                trimmed: "TOIInput",
                name: "b2TOIInput",
                def: b2TOIInput
            }, {
                trimmed: "TOIOutput",
                name: "b2TOIOutput",
                def: b2TOIOutput
            }, {
                trimmed: "SeparationFunction",
                name: "b2SeparationFunction",
                def: b2SeparationFunction
            }, {
                trimmed: "TimeOfImpact",
                name: "b2TimeOfImpact",
                def: b2TimeOfImpact
            }, {
                trimmed: "BodyDef",
                name: "b2BodyDef",
                def: b2BodyDef
            }, {
                trimmed: "Body",
                name: "b2Body",
                def: b2Body
            }, {
                trimmed: "Filter",
                name: "b2Filter",
                def: b2Filter
            }, {
                trimmed: "FixtureDef",
                name: "b2FixtureDef",
                def: b2FixtureDef
            }, {
                trimmed: "Fixture",
                name: "b2Fixture",
                def: b2Fixture
            }, {
                trimmed: "DestructionListener",
                name: "b2DestructionListener",
                def: b2DestructionListener
            }, {
                trimmed: "ContactFilter",
                name: "b2ContactFilter",
                def: b2ContactFilter
            }, {
                trimmed: "ContactImpulse",
                name: "b2ContactImpulse",
                def: b2ContactImpulse
            }, {
                trimmed: "ContactListener",
                name: "b2ContactListener",
                def: b2ContactListener
            }, {
                trimmed: "QueryCallback",
                name: "b2QueryCallback",
                def: b2QueryCallback
            }, {
                trimmed: "RayCastCallback",
                name: "b2RayCastCallback",
                def: b2RayCastCallback
            }, {
                trimmed: "TimeStep",
                name: "b2TimeStep",
                def: b2TimeStep
            }, {
                trimmed: "Position",
                name: "b2Position",
                def: b2Position
            }, {
                trimmed: "Velocity",
                name: "b2Velocity",
                def: b2Velocity
            }, {
                trimmed: "SolverData",
                name: "b2SolverData",
                def: b2SolverData
            }, {
                trimmed: "World",
                name: "b2World",
                def: b2World
            }, {
                trimmed: "MixFriction",
                name: "b2MixFriction",
                def: b2MixFriction
            }, {
                trimmed: "MixRestitution",
                name: "b2MixRestitution",
                def: b2MixRestitution
            }, {
                trimmed: "ContactRegister",
                name: "b2ContactRegister",
                def: b2ContactRegister
            }, {
                trimmed: "ContactEdge",
                name: "b2ContactEdge",
                def: b2ContactEdge
            }, {
                trimmed: "Contact",
                name: "b2Contact",
                def: b2Contact
            }, {
                trimmed: "CircleContact",
                name: "b2CircleContact",
                def: b2CircleContact
            }, {
                trimmed: "PolygonContact",
                name: "b2PolygonContact",
                def: b2PolygonContact
            }, {
                trimmed: "ChainAndCircleContact",
                name: "b2ChainAndCircleContact",
                def: b2ChainAndCircleContact
            }, {
                trimmed: "ChainAndPolygonContact",
                name: "b2ChainAndPolygonContact",
                def: b2ChainAndPolygonContact
            }, {
                trimmed: "EdgeAndCircleContact",
                name: "b2EdgeAndCircleContact",
                def: b2EdgeAndCircleContact
            }, {
                trimmed: "EdgeAndPolygonContact",
                name: "b2EdgeAndPolygonContact",
                def: b2EdgeAndPolygonContact
            }, {
                trimmed: "PolygonAndCircleContact",
                name: "b2PolygonAndCircleContact",
                def: b2PolygonAndCircleContact
            }, {
                trimmed: "defaultFilter",
                name: "b2_defaultFilter",
                def: b2_defaultFilter
            }, {
                trimmed: "defaultListener",
                name: "b2_defaultListener",
                def: b2_defaultListener
            }, {
                trimmed: "ContactManager",
                name: "b2ContactManager",
                def: b2ContactManager
            }, {
                trimmed: "VelocityConstraintPoint",
                name: "b2VelocityConstraintPoint",
                def: b2VelocityConstraintPoint
            }, {
                trimmed: "ContactPositionConstraint",
                name: "b2ContactPositionConstraint",
                def: b2ContactPositionConstraint
            }, {
                trimmed: "ContactVelocityConstraint",
                name: "b2ContactVelocityConstraint",
                def: b2ContactVelocityConstraint
            }, {
                trimmed: "PositionSolverManifold",
                name: "b2PositionSolverManifold",
                def: b2PositionSolverManifold
            }, {
                trimmed: "ContactSolverDef",
                name: "b2ContactSolverDef",
                def: b2ContactSolverDef
            }, {
                trimmed: "ContactSolver",
                name: "b2ContactSolver",
                def: b2ContactSolver
            }, {
                trimmed: "Island",
                name: "b2Island",
                def: b2Island
            }, {
                trimmed: "Jacobian",
                name: "b2Jacobian",
                def: b2Jacobian
            }, {
                trimmed: "JointEdge",
                name: "b2JointEdge",
                def: b2JointEdge
            }, {
                trimmed: "JointDef",
                name: "b2JointDef",
                def: b2JointDef
            }, {
                trimmed: "Joint",
                name: "b2Joint",
                def: b2Joint
            }, {
                trimmed: "RevoluteJointDef",
                name: "b2RevoluteJointDef",
                def: b2RevoluteJointDef
            }, {
                trimmed: "RevoluteJoint",
                name: "b2RevoluteJoint",
                def: b2RevoluteJoint
            }, {
                trimmed: "MouseJointDef",
                name: "b2MouseJointDef",
                def: b2MouseJointDef
            }, {
                trimmed: "MouseJoint",
                name: "b2MouseJoint",
                def: b2MouseJoint
            }, {
                trimmed: "DistanceJointDef",
                name: "b2DistanceJointDef",
                def: b2DistanceJointDef
            }, {
                trimmed: "DistanceJoint",
                name: "b2DistanceJoint",
                def: b2DistanceJoint
            }, {
                trimmed: "PrismaticJointDef",
                name: "b2PrismaticJointDef",
                def: b2PrismaticJointDef
            }, {
                trimmed: "PrismaticJoint",
                name: "b2PrismaticJoint",
                def: b2PrismaticJoint
            }, {
                trimmed: "FrictionJointDef",
                name: "b2FrictionJointDef",
                def: b2FrictionJointDef
            }, {
                trimmed: "FrictionJoint",
                name: "b2FrictionJoint",
                def: b2FrictionJoint
            }, {
                trimmed: "WeldJointDef",
                name: "b2WeldJointDef",
                def: b2WeldJointDef
            }, {
                trimmed: "WeldJoint",
                name: "b2WeldJoint",
                def: b2WeldJoint
            }, {
                trimmed: "WheelJointDef",
                name: "b2WheelJointDef",
                def: b2WheelJointDef
            }, {
                trimmed: "WheelJoint",
                name: "b2WheelJoint",
                def: b2WheelJoint
            }, {
                trimmed: "GearJointDef",
                name: "b2GearJointDef",
                def: b2GearJointDef
            }, {
                trimmed: "GearJoint",
                name: "b2GearJoint",
                def: b2GearJoint
            }, {
                trimmed: "MotorJointDef",
                name: "b2MotorJointDef",
                def: b2MotorJointDef
            }, {
                trimmed: "MotorJoint",
                name: "b2MotorJoint",
                def: b2MotorJoint
            }, {
                trimmed: "PulleyJointDef",
                name: "b2PulleyJointDef",
                def: b2PulleyJointDef
            }, {
                trimmed: "PulleyJoint",
                name: "b2PulleyJoint",
                def: b2PulleyJoint
            }, {
                trimmed: "RopeJointDef",
                name: "b2RopeJointDef",
                def: b2RopeJointDef
            }, {
                trimmed: "RopeJoint",
                name: "b2RopeJoint",
                def: b2RopeJoint
            }, {
                trimmed: "RopeDef",
                name: "b2RopeDef",
                def: b2RopeDef
            }, {
                trimmed: "Rope",
                name: "b2Rope",
                def: b2Rope
            }, {
                trimmed: "maxManifoldPoints",
                name: "b2_maxManifoldPoints",
                def: b2_maxManifoldPoints
            }, {
                trimmed: "maxPolygonVertices",
                name: "b2_maxPolygonVertices",
                def: b2_maxPolygonVertices
            }, {
                trimmed: "aabbExtension",
                name: "b2_aabbExtension",
                def: b2_aabbExtension
            }, {
                trimmed: "aabbMultiplier",
                name: "b2_aabbMultiplier",
                def: b2_aabbMultiplier
            }, {
                trimmed: "linearSlop",
                name: "b2_linearSlop",
                def: b2_linearSlop
            }, {
                trimmed: "angularSlop",
                name: "b2_angularSlop",
                def: b2_angularSlop
            }, {
                trimmed: "polygonRadius",
                name: "b2_polygonRadius",
                def: b2_polygonRadius
            }, {
                trimmed: "maxSubSteps",
                name: "b2_maxSubSteps",
                def: b2_maxSubSteps
            }, {
                trimmed: "maxTOIContacts",
                name: "b2_maxTOIContacts",
                def: b2_maxTOIContacts
            }, {
                trimmed: "velocityThreshold",
                name: "b2_velocityThreshold",
                def: b2_velocityThreshold
            }, {
                trimmed: "maxLinearCorrection",
                name: "b2_maxLinearCorrection",
                def: b2_maxLinearCorrection
            }, {
                trimmed: "maxAngularCorrection",
                name: "b2_maxAngularCorrection",
                def: b2_maxAngularCorrection
            }, {
                trimmed: "maxTranslation",
                name: "b2_maxTranslation",
                def: b2_maxTranslation
            }, {
                trimmed: "maxTranslationSquared",
                name: "b2_maxTranslationSquared",
                def: b2_maxTranslationSquared
            }, {
                trimmed: "maxRotation",
                name: "b2_maxRotation",
                def: b2_maxRotation
            }, {
                trimmed: "maxRotationSquared",
                name: "b2_maxRotationSquared",
                def: b2_maxRotationSquared
            }, {
                trimmed: "baumgarte",
                name: "b2_baumgarte",
                def: b2_baumgarte
            }, {
                trimmed: "toiBaugarte",
                name: "b2_toiBaugarte",
                def: b2_toiBaugarte
            }, {
                trimmed: "timeToSleep",
                name: "b2_timeToSleep",
                def: b2_timeToSleep
            }, {
                trimmed: "linearSleepTolerance",
                name: "b2_linearSleepTolerance",
                def: b2_linearSleepTolerance
            }, {
                trimmed: "angularSleepTolerance",
                name: "b2_angularSleepTolerance",
                def: b2_angularSleepTolerance
            }, {
                trimmed: "epsilon",
                name: "b2_epsilon",
                def: b2_epsilon
            }, {
                trimmed: "JsonSerializer",
                name: "b2JsonSerializer",
                def: b2JsonSerializer
            }, {
                trimmed: "RUBELoader",
                name: "b2RUBELoader",
                def: b2RUBELoader
            }, {
                trimmed: "Profiler",
                name: "b2Profiler",
                def: b2Profiler
            } ];
            if ("undefined" !== typeof b2_compatibility && "undefined" !== typeof window) {
                for (var i = 0; i < mappings.length; ++i) {
                    window[mappings[i].name] = mappings[i].def;
                }
            } else {
                var b2 = {};
                for (var i = 0; i < mappings.length; ++i) {
                    b2[mappings[i].trimmed] = mappings[i].def;
                }
                "undefined" !== typeof module ? module.exports = b2 : window["b2"] = b2;
            }
        })();
    }), {} ],
    311: [ (function(require, module, exports) {
        Object.create = Object.create || function(o) {
            function F() {}
            F.prototype = o;
            return new F();
        };
        var assert = function(value, message) {
            if (!value) {
                throw new Error("Assertion failed: " + message);
            }
        };
        var assertSoft = function(value, message) {
            if (!value && console && console.warn) {
                console.warn("ASSERTION FAILED: " + message);
                console.trace && console.trace();
            }
        };
        var mymin = function(a, b) {
            return a < b ? a : b;
        };
        var mymax = function(a, b) {
            return a > b ? a : b;
        };
        var min, max;
        if ("object" === typeof window && window.navigator.userAgent.indexOf("Firefox") > -1) {
            min = Math.min;
            max = Math.max;
        } else {
            min = mymin;
            max = mymax;
        }
        var hashPair = function(a, b) {
            return a < b ? a + " " + b : b + " " + a;
        };
        var deleteObjFromList = function(arr, obj) {
            for (var i = 0; i < arr.length; i++) {
                if (arr[i] === obj) {
                    arr[i] = arr[arr.length - 1];
                    arr.length--;
                    return;
                }
            }
        };
        var closestPointOnSegment = function(p, a, b) {
            var delta = vsub(a, b);
            var t = clamp01(vdot(delta, vsub(p, b)) / vlengthsq(delta));
            return vadd(b, vmult(delta, t));
        };
        var closestPointOnSegment2 = function(px, py, ax, ay, bx, by) {
            var deltax = ax - bx;
            var deltay = ay - by;
            var t = clamp01(vdot2(deltax, deltay, px - bx, py - by) / vlengthsq2(deltax, deltay));
            return new Vect(bx + deltax * t, by + deltay * t);
        };
        cp.momentForCircle = function(m, r1, r2, offset) {
            return m * (.5 * (r1 * r1 + r2 * r2) + vlengthsq(offset));
        };
        cp.areaForCircle = function(r1, r2) {
            return Math.PI * Math.abs(r1 * r1 - r2 * r2);
        };
        cp.momentForSegment = function(m, a, b) {
            var offset = vmult(vadd(a, b), .5);
            return m * (vdistsq(b, a) / 12 + vlengthsq(offset));
        };
        cp.areaForSegment = function(a, b, r) {
            return r * (Math.PI * r + 2 * vdist(a, b));
        };
        cp.momentForPoly = function(m, verts, offset) {
            var sum1 = 0;
            var sum2 = 0;
            var len = verts.length;
            for (var i = 0; i < len; i += 2) {
                var v1x = verts[i] + offset.x;
                var v1y = verts[i + 1] + offset.y;
                var v2x = verts[(i + 2) % len] + offset.x;
                var v2y = verts[(i + 3) % len] + offset.y;
                var a = vcross2(v2x, v2y, v1x, v1y);
                var b = vdot2(v1x, v1y, v1x, v1y) + vdot2(v1x, v1y, v2x, v2y) + vdot2(v2x, v2y, v2x, v2y);
                sum1 += a * b;
                sum2 += a;
            }
            return m * sum1 / (6 * sum2);
        };
        cp.areaForPoly = function(verts) {
            var area = 0;
            for (var i = 0, len = verts.length; i < len; i += 2) {
                area += vcross(new Vect(verts[i], verts[i + 1]), new Vect(verts[(i + 2) % len], verts[(i + 3) % len]));
            }
            return -area / 2;
        };
        cp.centroidForPoly = function(verts) {
            var sum = 0;
            var vsum = new Vect(0, 0);
            for (var i = 0, len = verts.length; i < len; i += 2) {
                var v1 = new Vect(verts[i], verts[i + 1]);
                var v2 = new Vect(verts[(i + 2) % len], verts[(i + 3) % len]);
                var cross = vcross(v1, v2);
                sum += cross;
                vsum = vadd(vsum, vmult(vadd(v1, v2), cross));
            }
            return vmult(vsum, 1 / (3 * sum));
        };
        cp.recenterPoly = function(verts) {
            var centroid = cp.centroidForPoly(verts);
            for (var i = 0; i < verts.length; i += 2) {
                verts[i] -= centroid.x;
                verts[i + 1] -= centroid.y;
            }
        };
        cp.momentForBox = function(m, width, height) {
            return m * (width * width + height * height) / 12;
        };
        cp.momentForBox2 = function(m, box) {
            var width = box.r - box.l;
            var height = box.t - box.b;
            var offset = vmult([ box.l + box.r, box.b + box.t ], .5);
            return cp.momentForBox(m, width, height) + m * vlengthsq(offset);
        };
        var loopIndexes = cp.loopIndexes = function(verts) {
            var start = 0, end = 0;
            var minx, miny, maxx, maxy;
            minx = maxx = verts[0];
            miny = maxy = verts[1];
            var count = verts.length >> 1;
            for (var i = 1; i < count; i++) {
                var x = verts[2 * i];
                var y = verts[2 * i + 1];
                if (x < minx || x == minx && y < miny) {
                    minx = x;
                    miny = y;
                    start = i;
                } else {
                    if (x > maxx || x == maxx && y > maxy) {
                        maxx = x;
                        maxy = y;
                        end = i;
                    }
                }
            }
            return [ start, end ];
        };
        var SWAP = function(arr, idx1, idx2) {
            var tmp = arr[2 * idx1];
            arr[2 * idx1] = arr[2 * idx2];
            arr[2 * idx2] = tmp;
            tmp = arr[2 * idx1 + 1];
            arr[2 * idx1 + 1] = arr[2 * idx2 + 1];
            arr[2 * idx2 + 1] = tmp;
        };
        var QHullPartition = function(verts, offs, count, a, b, tol) {
            if (0 === count) {
                return 0;
            }
            var max = 0;
            var pivot = offs;
            var delta = vsub(b, a);
            var valueTol = tol * vlength(delta);
            var head = offs;
            for (var tail = offs + count - 1; head <= tail; ) {
                var v = new Vect(verts[2 * head], verts[2 * head + 1]);
                var value = vcross(delta, vsub(v, a));
                if (value > valueTol) {
                    if (value > max) {
                        max = value;
                        pivot = head;
                    }
                    head++;
                } else {
                    SWAP(verts, head, tail);
                    tail--;
                }
            }
            pivot != offs && SWAP(verts, offs, pivot);
            return head - offs;
        };
        var QHullReduce = function(tol, verts, offs, count, a, pivot, b, resultPos) {
            if (count < 0) {
                return 0;
            }
            if (0 == count) {
                verts[2 * resultPos] = pivot.x;
                verts[2 * resultPos + 1] = pivot.y;
                return 1;
            }
            var left_count = QHullPartition(verts, offs, count, a, pivot, tol);
            var left = new Vect(verts[2 * offs], verts[2 * offs + 1]);
            var index = QHullReduce(tol, verts, offs + 1, left_count - 1, a, left, pivot, resultPos);
            var pivotPos = resultPos + index++;
            verts[2 * pivotPos] = pivot.x;
            verts[2 * pivotPos + 1] = pivot.y;
            var right_count = QHullPartition(verts, offs + left_count, count - left_count, pivot, b, tol);
            var right = new Vect(verts[2 * (offs + left_count)], verts[2 * (offs + left_count) + 1]);
            return index + QHullReduce(tol, verts, offs + left_count + 1, right_count - 1, pivot, right, b, resultPos + index);
        };
        cp.convexHull = function(verts, result, tolerance) {
            if (result) {
                for (var i = 0; i < verts.length; i++) {
                    result[i] = verts[i];
                }
            } else {
                result = verts;
            }
            var indexes = loopIndexes(verts);
            var start = indexes[0], end = indexes[1];
            if (start == end) {
                result.length = 2;
                return result;
            }
            SWAP(result, 0, start);
            SWAP(result, 1, 0 == end ? start : end);
            var a = new Vect(result[0], result[1]);
            var b = new Vect(result[2], result[3]);
            var count = verts.length >> 1;
            var resultCount = QHullReduce(tolerance, result, 2, count - 2, a, b, a, 1) + 1;
            result.length = 2 * resultCount;
            assertSoft(polyValidate(result), "Internal error: cpConvexHull() and cpPolyValidate() did not agree.Please report this error with as much info as you can.");
            return result;
        };
        var clamp = function(f, minv, maxv) {
            return min(max(f, minv), maxv);
        };
        var clamp01 = function(f) {
            return max(0, min(f, 1));
        };
        var lerp = function(f1, f2, t) {
            return f1 * (1 - t) + f2 * t;
        };
        var lerpconst = function(f1, f2, d) {
            return f1 + clamp(f2 - f1, -d, d);
        };
        var Vect = cp.Vect = function(x, y) {
            this.x = x;
            this.y = y;
        };
        cp.v = function(x, y) {
            return new Vect(x, y);
        };
        var vzero = cp.vzero = new Vect(0, 0);
        var vdot = cp.v.dot = function(v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        };
        var vdot2 = function(x1, y1, x2, y2) {
            return x1 * x2 + y1 * y2;
        };
        var vlength = cp.v.len = function(v) {
            return Math.sqrt(vdot(v, v));
        };
        var vlength2 = cp.v.len2 = function(x, y) {
            return Math.sqrt(x * x + y * y);
        };
        var veql = cp.v.eql = function(v1, v2) {
            return v1.x === v2.x && v1.y === v2.y;
        };
        var vadd = cp.v.add = function(v1, v2) {
            return new Vect(v1.x + v2.x, v1.y + v2.y);
        };
        Vect.prototype.add = function(v2) {
            this.x += v2.x;
            this.y += v2.y;
            return this;
        };
        var vsub = cp.v.sub = function(v1, v2) {
            return new Vect(v1.x - v2.x, v1.y - v2.y);
        };
        Vect.prototype.sub = function(v2) {
            this.x -= v2.x;
            this.y -= v2.y;
            return this;
        };
        var vneg = cp.v.neg = function(v) {
            return new Vect(-v.x, -v.y);
        };
        Vect.prototype.neg = function() {
            this.x = -this.x;
            this.y = -this.y;
            return this;
        };
        var vmult = cp.v.mult = function(v, s) {
            return new Vect(v.x * s, v.y * s);
        };
        Vect.prototype.mult = function(s) {
            this.x *= s;
            this.y *= s;
            return this;
        };
        var vcross = cp.v.cross = function(v1, v2) {
            return v1.x * v2.y - v1.y * v2.x;
        };
        var vcross2 = function(x1, y1, x2, y2) {
            return x1 * y2 - y1 * x2;
        };
        var vperp = cp.v.perp = function(v) {
            return new Vect(-v.y, v.x);
        };
        var vpvrperp = cp.v.pvrperp = function(v) {
            return new Vect(v.y, -v.x);
        };
        var vproject = cp.v.project = function(v1, v2) {
            return vmult(v2, vdot(v1, v2) / vlengthsq(v2));
        };
        Vect.prototype.project = function(v2) {
            this.mult(vdot(this, v2) / vlengthsq(v2));
            return this;
        };
        var vrotate = cp.v.rotate = function(v1, v2) {
            return new Vect(v1.x * v2.x - v1.y * v2.y, v1.x * v2.y + v1.y * v2.x);
        };
        Vect.prototype.rotate = function(v2) {
            this.x = this.x * v2.x - this.y * v2.y;
            this.y = this.x * v2.y + this.y * v2.x;
            return this;
        };
        var vunrotate = cp.v.unrotate = function(v1, v2) {
            return new Vect(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y);
        };
        var vlengthsq = cp.v.lengthsq = function(v) {
            return vdot(v, v);
        };
        var vlengthsq2 = cp.v.lengthsq2 = function(x, y) {
            return x * x + y * y;
        };
        var vlerp = cp.v.lerp = function(v1, v2, t) {
            return vadd(vmult(v1, 1 - t), vmult(v2, t));
        };
        var vnormalize = cp.v.normalize = function(v) {
            return vmult(v, 1 / vlength(v));
        };
        var vnormalize_safe = cp.v.normalize_safe = function(v) {
            return 0 === v.x && 0 === v.y ? vzero : vnormalize(v);
        };
        var vclamp = cp.v.clamp = function(v, len) {
            return vdot(v, v) > len * len ? vmult(vnormalize(v), len) : v;
        };
        var vlerpconst = cp.v.lerpconst = function(v1, v2, d) {
            return vadd(v1, vclamp(vsub(v2, v1), d));
        };
        var vdist = cp.v.dist = function(v1, v2) {
            return vlength(vsub(v1, v2));
        };
        var vdistsq = cp.v.distsq = function(v1, v2) {
            return vlengthsq(vsub(v1, v2));
        };
        var vnear = cp.v.near = function(v1, v2, dist) {
            return vdistsq(v1, v2) < dist * dist;
        };
        var vslerp = cp.v.slerp = function(v1, v2, t) {
            var omega = Math.acos(vdot(v1, v2));
            if (omega) {
                var denom = 1 / Math.sin(omega);
                return vadd(vmult(v1, Math.sin((1 - t) * omega) * denom), vmult(v2, Math.sin(t * omega) * denom));
            }
            return v1;
        };
        var vslerpconst = cp.v.slerpconst = function(v1, v2, a) {
            var angle = Math.acos(vdot(v1, v2));
            return vslerp(v1, v2, min(a, angle) / angle);
        };
        var vforangle = cp.v.forangle = function(a) {
            return new Vect(Math.cos(a), Math.sin(a));
        };
        var vtoangle = cp.v.toangle = function(v) {
            return Math.atan2(v.y, v.x);
        };
        var vstr = cp.v.str = function(v) {
            return "(" + v.x.toFixed(3) + ", " + v.y.toFixed(3) + ")";
        };
        var numBB = 0;
        var BB = cp.BB = function(l, b, r, t) {
            this.l = l;
            this.b = b;
            this.r = r;
            this.t = t;
            numBB++;
        };
        cp.bb = function(l, b, r, t) {
            return new BB(l, b, r, t);
        };
        var bbNewForCircle = function(p, r) {
            return new BB(p.x - r, p.y - r, p.x + r, p.y + r);
        };
        var bbIntersects = function(a, b) {
            return a.l <= b.r && b.l <= a.r && a.b <= b.t && b.b <= a.t;
        };
        var bbIntersects2 = function(bb, l, b, r, t) {
            return bb.l <= r && l <= bb.r && bb.b <= t && b <= bb.t;
        };
        var bbContainsBB = function(bb, other) {
            return bb.l <= other.l && bb.r >= other.r && bb.b <= other.b && bb.t >= other.t;
        };
        var bbContainsVect = function(bb, v) {
            return bb.l <= v.x && bb.r >= v.x && bb.b <= v.y && bb.t >= v.y;
        };
        var bbContainsVect2 = function(l, b, r, t, v) {
            return l <= v.x && r >= v.x && b <= v.y && t >= v.y;
        };
        var bbMerge = function(a, b) {
            return new BB(min(a.l, b.l), min(a.b, b.b), max(a.r, b.r), max(a.t, b.t));
        };
        var bbExpand = function(bb, v) {
            return new BB(min(bb.l, v.x), min(bb.b, v.y), max(bb.r, v.x), max(bb.t, v.y));
        };
        var bbArea = function(bb) {
            return (bb.r - bb.l) * (bb.t - bb.b);
        };
        var bbMergedArea = function(a, b) {
            return (max(a.r, b.r) - min(a.l, b.l)) * (max(a.t, b.t) - min(a.b, b.b));
        };
        var bbMergedArea2 = function(bb, l, b, r, t) {
            return (max(bb.r, r) - min(bb.l, l)) * (max(bb.t, t) - min(bb.b, b));
        };
        var bbIntersectsSegment = function(bb, a, b) {
            return bbSegmentQuery(bb, a, b) != 1 / 0;
        };
        var bbClampVect = function(bb, v) {
            var x = min(max(bb.l, v.x), bb.r);
            var y = min(max(bb.b, v.y), bb.t);
            return new Vect(x, y);
        };
        var bbWrapVect = function(bb, v) {
            var ix = Math.abs(bb.r - bb.l);
            var modx = (v.x - bb.l) % ix;
            var x = modx > 0 ? modx : modx + ix;
            var iy = Math.abs(bb.t - bb.b);
            var mody = (v.y - bb.b) % iy;
            var y = mody > 0 ? mody : mody + iy;
            return new Vect(x + bb.l, y + bb.b);
        };
        var shapeIDCounter = 0;
        var CP_NO_GROUP = cp.NO_GROUP = 0;
        var CP_ALL_LAYERS = cp.ALL_LAYERS = -1;
        cp.resetShapeIdCounter = function() {
            shapeIDCounter = 0;
        };
        var Shape = cp.Shape = function(body) {
            this.body = body;
            this.bb_l = this.bb_b = this.bb_r = this.bb_t = 0;
            this.hashid = shapeIDCounter++;
            this.sensor = false;
            this.e = 0;
            this.u = 0;
            this.surface_v = vzero;
            this.collision_type = 0;
            this.group = 0;
            this.layers = CP_ALL_LAYERS;
            this.space = null;
            this.collisionCode = this.collisionCode;
        };
        Shape.prototype.setElasticity = function(e) {
            this.e = e;
        };
        Shape.prototype.setFriction = function(u) {
            this.body.activate();
            this.u = u;
        };
        Shape.prototype.setLayers = function(layers) {
            this.body.activate();
            this.layers = layers;
        };
        Shape.prototype.setSensor = function(sensor) {
            this.body.activate();
            this.sensor = sensor;
        };
        Shape.prototype.setCollisionType = function(collision_type) {
            this.body.activate();
            this.collision_type = collision_type;
        };
        Shape.prototype.getBody = function() {
            return this.body;
        };
        Shape.prototype.active = function() {
            return this.body && this.body.shapeList.indexOf(this) !== -1;
        };
        Shape.prototype.setBody = function(body) {
            assert(!this.active(), "You cannot change the body on an active shape. You must remove the shape from the space before changing the body.");
            this.body = body;
        };
        Shape.prototype.cacheBB = function() {
            return this.update(this.body.p, this.body.rot);
        };
        Shape.prototype.update = function(pos, rot) {
            assert(!isNaN(rot.x), "Rotation is NaN");
            assert(!isNaN(pos.x), "Position is NaN");
            this.cacheData(pos, rot);
        };
        Shape.prototype.pointQuery = function(p) {
            var info = this.nearestPointQuery(p);
            if (info.d < 0) {
                return info;
            }
        };
        Shape.prototype.getBB = function() {
            return new BB(this.bb_l, this.bb_b, this.bb_r, this.bb_t);
        };
        var PointQueryExtendedInfo = function(shape) {
            this.shape = shape;
            this.d = 1 / 0;
            this.n = vzero;
        };
        var NearestPointQueryInfo = function(shape, p, d) {
            this.shape = shape;
            this.p = p;
            this.d = d;
        };
        var SegmentQueryInfo = function(shape, t, n) {
            this.shape = shape;
            this.t = t;
            this.n = n;
        };
        SegmentQueryInfo.prototype.hitPoint = function(start, end) {
            return vlerp(start, end, this.t);
        };
        SegmentQueryInfo.prototype.hitDist = function(start, end) {
            return vdist(start, end) * this.t;
        };
        var CircleShape = cp.CircleShape = function(body, radius, offset) {
            this.c = this.tc = offset;
            this.r = radius;
            this.type = "circle";
            Shape.call(this, body);
        };
        CircleShape.prototype = Object.create(Shape.prototype);
        CircleShape.prototype.cacheData = function(p, rot) {
            var c = this.tc = vrotate(this.c, rot).add(p);
            var r = this.r;
            this.bb_l = c.x - r;
            this.bb_b = c.y - r;
            this.bb_r = c.x + r;
            this.bb_t = c.y + r;
        };
        CircleShape.prototype.nearestPointQuery = function(p) {
            var deltax = p.x - this.tc.x;
            var deltay = p.y - this.tc.y;
            var d = vlength2(deltax, deltay);
            var r = this.r;
            var nearestp = new Vect(this.tc.x + deltax * r / d, this.tc.y + deltay * r / d);
            return new NearestPointQueryInfo(this, nearestp, d - r);
        };
        var circleSegmentQuery = function(shape, center, r, a, b, info) {
            a = vsub(a, center);
            b = vsub(b, center);
            var qa = vdot(a, a) - 2 * vdot(a, b) + vdot(b, b);
            var qb = -2 * vdot(a, a) + 2 * vdot(a, b);
            var qc = vdot(a, a) - r * r;
            var det = qb * qb - 4 * qa * qc;
            if (det >= 0) {
                var t = (-qb - Math.sqrt(det)) / (2 * qa);
                if (0 <= t && t <= 1) {
                    return new SegmentQueryInfo(shape, t, vnormalize(vlerp(a, b, t)));
                }
            }
        };
        CircleShape.prototype.segmentQuery = function(a, b) {
            return circleSegmentQuery(this, this.tc, this.r, a, b);
        };
        var SegmentShape = cp.SegmentShape = function(body, a, b, r) {
            this.a = a;
            this.b = b;
            this.n = vperp(vnormalize(vsub(b, a)));
            this.ta = this.tb = this.tn = null;
            this.r = r;
            this.a_tangent = vzero;
            this.b_tangent = vzero;
            this.type = "segment";
            Shape.call(this, body);
        };
        SegmentShape.prototype = Object.create(Shape.prototype);
        SegmentShape.prototype.cacheData = function(p, rot) {
            this.ta = vadd(p, vrotate(this.a, rot));
            this.tb = vadd(p, vrotate(this.b, rot));
            this.tn = vrotate(this.n, rot);
            var l, r, b, t;
            if (this.ta.x < this.tb.x) {
                l = this.ta.x;
                r = this.tb.x;
            } else {
                l = this.tb.x;
                r = this.ta.x;
            }
            if (this.ta.y < this.tb.y) {
                b = this.ta.y;
                t = this.tb.y;
            } else {
                b = this.tb.y;
                t = this.ta.y;
            }
            var rad = this.r;
            this.bb_l = l - rad;
            this.bb_b = b - rad;
            this.bb_r = r + rad;
            this.bb_t = t + rad;
        };
        SegmentShape.prototype.nearestPointQuery = function(p) {
            var closest = closestPointOnSegment(p, this.ta, this.tb);
            var deltax = p.x - closest.x;
            var deltay = p.y - closest.y;
            var d = vlength2(deltax, deltay);
            var r = this.r;
            var nearestp = d ? vadd(closest, vmult(new Vect(deltax, deltay), r / d)) : closest;
            return new NearestPointQueryInfo(this, nearestp, d - r);
        };
        SegmentShape.prototype.segmentQuery = function(a, b) {
            var n = this.tn;
            var d = vdot(vsub(this.ta, a), n);
            var r = this.r;
            var flipped_n = d > 0 ? vneg(n) : n;
            var n_offset = vsub(vmult(flipped_n, r), a);
            var seg_a = vadd(this.ta, n_offset);
            var seg_b = vadd(this.tb, n_offset);
            var delta = vsub(b, a);
            if (vcross(delta, seg_a) * vcross(delta, seg_b) <= 0) {
                var d_offset = d + (d > 0 ? -r : r);
                var ad = -d_offset;
                var bd = vdot(delta, n) - d_offset;
                if (ad * bd < 0) {
                    return new SegmentQueryInfo(this, ad / (ad - bd), flipped_n);
                }
            } else {
                if (0 !== r) {
                    var info1 = circleSegmentQuery(this, this.ta, this.r, a, b);
                    var info2 = circleSegmentQuery(this, this.tb, this.r, a, b);
                    return info1 ? info2 && info2.t < info1.t ? info2 : info1 : info2;
                }
            }
        };
        SegmentShape.prototype.setNeighbors = function(prev, next) {
            this.a_tangent = vsub(prev, this.a);
            this.b_tangent = vsub(next, this.b);
        };
        SegmentShape.prototype.setEndpoints = function(a, b) {
            this.a = a;
            this.b = b;
            this.n = vperp(vnormalize(vsub(b, a)));
        };
        var polyValidate = function(verts) {
            var len = verts.length;
            for (var i = 0; i < len; i += 2) {
                var ax = verts[i];
                var ay = verts[i + 1];
                var bx = verts[(i + 2) % len];
                var by = verts[(i + 3) % len];
                var cx = verts[(i + 4) % len];
                var cy = verts[(i + 5) % len];
                if (vcross2(bx - ax, by - ay, cx - bx, cy - by) > 0) {
                    return false;
                }
            }
            return true;
        };
        var PolyShape = cp.PolyShape = function(body, verts, offset) {
            this.setVerts(verts, offset);
            this.type = "poly";
            Shape.call(this, body);
        };
        PolyShape.prototype = Object.create(Shape.prototype);
        var SplittingPlane = function(n, d) {
            this.n = n;
            this.d = d;
        };
        SplittingPlane.prototype.compare = function(v) {
            return vdot(this.n, v) - this.d;
        };
        PolyShape.prototype.setVerts = function(verts, offset) {
            assert(verts.length >= 4, "Polygons require some verts");
            assert("number" === typeof verts[0], "Polygon verticies should be specified in a flattened list (eg [x1,y1,x2,y2,x3,y3,...])");
            assert(polyValidate(verts), "Polygon is concave or has a reversed winding. Consider using cpConvexHull()");
            var len = verts.length;
            var numVerts = len >> 1;
            this.verts = new Array(len);
            this.tVerts = new Array(len);
            this.planes = new Array(numVerts);
            this.tPlanes = new Array(numVerts);
            for (var i = 0; i < len; i += 2) {
                var ax = verts[i] + offset.x;
                var ay = verts[i + 1] + offset.y;
                var bx = verts[(i + 2) % len] + offset.x;
                var by = verts[(i + 3) % len] + offset.y;
                var n = vnormalize(vperp(new Vect(bx - ax, by - ay)));
                this.verts[i] = ax;
                this.verts[i + 1] = ay;
                this.planes[i >> 1] = new SplittingPlane(n, vdot2(n.x, n.y, ax, ay));
                this.tPlanes[i >> 1] = new SplittingPlane(new Vect(0, 0), 0);
            }
        };
        var BoxShape = cp.BoxShape = function(body, width, height) {
            var hw = width / 2;
            var hh = height / 2;
            return BoxShape2(body, new BB(-hw, -hh, hw, hh));
        };
        var BoxShape2 = cp.BoxShape2 = function(body, box) {
            var verts = [ box.l, box.b, box.l, box.t, box.r, box.t, box.r, box.b ];
            return new PolyShape(body, verts, vzero);
        };
        PolyShape.prototype.transformVerts = function(p, rot) {
            var src = this.verts;
            var dst = this.tVerts;
            var l = 1 / 0, r = -(1 / 0);
            var b = 1 / 0, t = -(1 / 0);
            for (var i = 0; i < src.length; i += 2) {
                var x = src[i];
                var y = src[i + 1];
                var vx = p.x + x * rot.x - y * rot.y;
                var vy = p.y + x * rot.y + y * rot.x;
                dst[i] = vx;
                dst[i + 1] = vy;
                l = min(l, vx);
                r = max(r, vx);
                b = min(b, vy);
                t = max(t, vy);
            }
            this.bb_l = l;
            this.bb_b = b;
            this.bb_r = r;
            this.bb_t = t;
        };
        PolyShape.prototype.transformAxes = function(p, rot) {
            var src = this.planes;
            var dst = this.tPlanes;
            for (var i = 0; i < src.length; i++) {
                var n = vrotate(src[i].n, rot);
                dst[i].n = n;
                dst[i].d = vdot(p, n) + src[i].d;
            }
        };
        PolyShape.prototype.cacheData = function(p, rot) {
            this.transformAxes(p, rot);
            this.transformVerts(p, rot);
        };
        PolyShape.prototype.nearestPointQuery = function(p) {
            var planes = this.tPlanes;
            var verts = this.tVerts;
            var v0x = verts[verts.length - 2];
            var v0y = verts[verts.length - 1];
            var minDist = 1 / 0;
            var closestPoint = vzero;
            var outside = false;
            for (var i = 0; i < planes.length; i++) {
                planes[i].compare(p) > 0 && (outside = true);
                var v1x = verts[2 * i];
                var v1y = verts[2 * i + 1];
                var closest = closestPointOnSegment2(p.x, p.y, v0x, v0y, v1x, v1y);
                var dist = vdist(p, closest);
                if (dist < minDist) {
                    minDist = dist;
                    closestPoint = closest;
                }
                v0x = v1x;
                v0y = v1y;
            }
            return new NearestPointQueryInfo(this, closestPoint, outside ? minDist : -minDist);
        };
        PolyShape.prototype.segmentQuery = function(a, b) {
            var axes = this.tPlanes;
            var verts = this.tVerts;
            var numVerts = axes.length;
            var len = 2 * numVerts;
            for (var i = 0; i < numVerts; i++) {
                var n = axes[i].n;
                var an = vdot(a, n);
                if (axes[i].d > an) {
                    continue;
                }
                var bn = vdot(b, n);
                var t = (axes[i].d - an) / (bn - an);
                if (t < 0 || 1 < t) {
                    continue;
                }
                var point = vlerp(a, b, t);
                var dt = -vcross(n, point);
                var dtMin = -vcross2(n.x, n.y, verts[2 * i], verts[2 * i + 1]);
                var dtMax = -vcross2(n.x, n.y, verts[(2 * i + 2) % len], verts[(2 * i + 3) % len]);
                if (dtMin <= dt && dt <= dtMax) {
                    return new SegmentQueryInfo(this, t, n);
                }
            }
        };
        PolyShape.prototype.valueOnAxis = function(n, d) {
            var verts = this.tVerts;
            var m = vdot2(n.x, n.y, verts[0], verts[1]);
            for (var i = 2; i < verts.length; i += 2) {
                m = min(m, vdot2(n.x, n.y, verts[i], verts[i + 1]));
            }
            return m - d;
        };
        PolyShape.prototype.containsVert = function(vx, vy) {
            var planes = this.tPlanes;
            for (var i = 0; i < planes.length; i++) {
                var n = planes[i].n;
                var dist = vdot2(n.x, n.y, vx, vy) - planes[i].d;
                if (dist > 0) {
                    return false;
                }
            }
            return true;
        };
        PolyShape.prototype.containsVertPartial = function(vx, vy, n) {
            var planes = this.tPlanes;
            for (var i = 0; i < planes.length; i++) {
                var n2 = planes[i].n;
                if (vdot(n2, n) < 0) {
                    continue;
                }
                var dist = vdot2(n2.x, n2.y, vx, vy) - planes[i].d;
                if (dist > 0) {
                    return false;
                }
            }
            return true;
        };
        PolyShape.prototype.getNumVerts = function() {
            return this.verts.length / 2;
        };
        PolyShape.prototype.getVert = function(i) {
            return new Vect(this.verts[2 * i], this.verts[2 * i + 1]);
        };
        var Body = cp.Body = function(m, i) {
            this.p = new Vect(0, 0);
            this.vx = this.vy = 0;
            this.f = new Vect(0, 0);
            this.w = 0;
            this.t = 0;
            this.v_limit = 1 / 0;
            this.w_limit = 1 / 0;
            this.v_biasx = this.v_biasy = 0;
            this.w_bias = 0;
            this.space = null;
            this.shapeList = [];
            this.arbiterList = null;
            this.constraintList = null;
            this.nodeRoot = null;
            this.nodeNext = null;
            this.nodeIdleTime = 0;
            this.setMass(m);
            this.setMoment(i);
            this.rot = new Vect(0, 0);
            this.setAngle(0);
        };
        var createStaticBody = function() {
            var body = new Body(1 / 0, 1 / 0);
            body.nodeIdleTime = 1 / 0;
            return body;
        };
        cp.StaticBody = createStaticBody;
        if ("undefined" !== typeof DEBUG && DEBUG) {
            var v_assert_nan = function(v, message) {
                assert(v.x == v.x && v.y == v.y, message);
            };
            var v_assert_infinite = function(v, message) {
                assert(Math.abs(v.x) !== 1 / 0 && Math.abs(v.y) !== 1 / 0, message);
            };
            var v_assert_sane = function(v, message) {
                v_assert_nan(v, message);
                v_assert_infinite(v, message);
            };
            Body.prototype.sanityCheck = function() {
                assert(this.m === this.m && this.m_inv === this.m_inv, "Body's mass is invalid.");
                assert(this.i === this.i && this.i_inv === this.i_inv, "Body's moment is invalid.");
                v_assert_sane(this.p, "Body's position is invalid.");
                v_assert_sane(this.f, "Body's force is invalid.");
                assert(this.vx === this.vx && Math.abs(this.vx) !== 1 / 0, "Body's velocity is invalid.");
                assert(this.vy === this.vy && Math.abs(this.vy) !== 1 / 0, "Body's velocity is invalid.");
                assert(this.a === this.a && Math.abs(this.a) !== 1 / 0, "Body's angle is invalid.");
                assert(this.w === this.w && Math.abs(this.w) !== 1 / 0, "Body's angular velocity is invalid.");
                assert(this.t === this.t && Math.abs(this.t) !== 1 / 0, "Body's torque is invalid.");
                v_assert_sane(this.rot, "Body's rotation vector is invalid.");
                assert(this.v_limit === this.v_limit, "Body's velocity limit is invalid.");
                assert(this.w_limit === this.w_limit, "Body's angular velocity limit is invalid.");
            };
        } else {
            Body.prototype.sanityCheck = function() {};
        }
        Body.prototype.getPos = function() {
            return this.p;
        };
        Body.prototype.getVel = function() {
            return new Vect(this.vx, this.vy);
        };
        Body.prototype.getAngVel = function() {
            return this.w;
        };
        Body.prototype.isSleeping = function() {
            return null !== this.nodeRoot;
        };
        Body.prototype.isStatic = function() {
            return this.nodeIdleTime === 1 / 0;
        };
        Body.prototype.isRogue = function() {
            return null === this.space;
        };
        Body.prototype.setMass = function(mass) {
            assert(mass > 0, "Mass must be positive and non-zero.");
            this.activate();
            this.m = mass;
            this.m_inv = 1 / mass;
        };
        Body.prototype.setMoment = function(moment) {
            assert(moment > 0, "Moment of Inertia must be positive and non-zero.");
            this.activate();
            this.i = moment;
            this.i_inv = 1 / moment;
        };
        Body.prototype.addShape = function(shape) {
            this.shapeList.push(shape);
        };
        Body.prototype.removeShape = function(shape) {
            deleteObjFromList(this.shapeList, shape);
        };
        var filterConstraints = function(node, body, filter) {
            if (node === filter) {
                return node.next(body);
            }
            node.a === body ? node.next_a = filterConstraints(node.next_a, body, filter) : node.next_b = filterConstraints(node.next_b, body, filter);
            return node;
        };
        Body.prototype.removeConstraint = function(constraint) {
            this.constraintList = filterConstraints(this.constraintList, this, constraint);
        };
        Body.prototype.setPos = function(pos) {
            this.activate();
            this.sanityCheck();
            pos === vzero && (pos = cp.v(0, 0));
            this.p = pos;
        };
        Body.prototype.setVel = function(velocity) {
            this.activate();
            this.vx = velocity.x;
            this.vy = velocity.y;
        };
        Body.prototype.setAngVel = function(w) {
            this.activate();
            this.w = w;
        };
        Body.prototype.setAngleInternal = function(angle) {
            assert(!isNaN(angle), "Internal Error: Attempting to set body's angle to NaN");
            this.a = angle;
            this.rot.x = Math.cos(angle);
            this.rot.y = Math.sin(angle);
        };
        Body.prototype.setAngle = function(angle) {
            this.activate();
            this.sanityCheck();
            this.setAngleInternal(angle);
        };
        Body.prototype.velocity_func = function(gravity, damping, dt) {
            var vx = this.vx * damping + (gravity.x + this.f.x * this.m_inv) * dt;
            var vy = this.vy * damping + (gravity.y + this.f.y * this.m_inv) * dt;
            var v_limit = this.v_limit;
            var lensq = vx * vx + vy * vy;
            var scale = lensq > v_limit * v_limit ? v_limit / Math.sqrt(lensq) : 1;
            this.vx = vx * scale;
            this.vy = vy * scale;
            var w_limit = this.w_limit;
            this.w = clamp(this.w * damping + this.t * this.i_inv * dt, -w_limit, w_limit);
            this.sanityCheck();
        };
        Body.prototype.position_func = function(dt) {
            this.p.x += (this.vx + this.v_biasx) * dt;
            this.p.y += (this.vy + this.v_biasy) * dt;
            this.setAngleInternal(this.a + (this.w + this.w_bias) * dt);
            this.v_biasx = this.v_biasy = 0;
            this.w_bias = 0;
            this.sanityCheck();
        };
        Body.prototype.resetForces = function() {
            this.activate();
            this.f = new Vect(0, 0);
            this.t = 0;
        };
        Body.prototype.applyForce = function(force, r) {
            this.activate();
            this.f = vadd(this.f, force);
            this.t += vcross(r, force);
        };
        Body.prototype.applyImpulse = function(j, r) {
            this.activate();
            apply_impulse(this, j.x, j.y, r);
        };
        Body.prototype.getVelAtPoint = function(r) {
            return vadd(new Vect(this.vx, this.vy), vmult(vperp(r), this.w));
        };
        Body.prototype.getVelAtWorldPoint = function(point) {
            return this.getVelAtPoint(vsub(point, this.p));
        };
        Body.prototype.getVelAtLocalPoint = function(point) {
            return this.getVelAtPoint(vrotate(point, this.rot));
        };
        Body.prototype.eachShape = function(func) {
            for (var i = 0, len = this.shapeList.length; i < len; i++) {
                func(this.shapeList[i]);
            }
        };
        Body.prototype.eachConstraint = function(func) {
            var constraint = this.constraintList;
            while (constraint) {
                var next = constraint.next(this);
                func(constraint);
                constraint = next;
            }
        };
        Body.prototype.eachArbiter = function(func) {
            var arb = this.arbiterList;
            while (arb) {
                var next = arb.next(this);
                arb.swappedColl = this === arb.body_b;
                func(arb);
                arb = next;
            }
        };
        Body.prototype.local2World = function(v) {
            return vadd(this.p, vrotate(v, this.rot));
        };
        Body.prototype.world2Local = function(v) {
            return vunrotate(vsub(v, this.p), this.rot);
        };
        Body.prototype.kineticEnergy = function() {
            var vsq = this.vx * this.vx + this.vy * this.vy;
            var wsq = this.w * this.w;
            return (vsq ? vsq * this.m : 0) + (wsq ? wsq * this.i : 0);
        };
        var SpatialIndex = cp.SpatialIndex = function(staticIndex) {
            this.staticIndex = staticIndex;
            if (staticIndex) {
                if (staticIndex.dynamicIndex) {
                    throw new Error("This static index is already associated with a dynamic index.");
                }
                staticIndex.dynamicIndex = this;
            }
        };
        SpatialIndex.prototype.collideStatic = function(staticIndex, func) {
            if (staticIndex.count > 0) {
                var query = staticIndex.query;
                this.each((function(obj) {
                    query(obj, new BB(obj.bb_l, obj.bb_b, obj.bb_r, obj.bb_t), func);
                }));
            }
        };
        var BBTree = cp.BBTree = function(staticIndex) {
            SpatialIndex.call(this, staticIndex);
            this.velocityFunc = null;
            this.leaves = {};
            this.count = 0;
            this.root = null;
            this.pooledNodes = null;
            this.pooledPairs = null;
            this.stamp = 0;
        };
        BBTree.prototype = Object.create(SpatialIndex.prototype);
        var numNodes = 0;
        var Node = function(tree, a, b) {
            this.obj = null;
            this.bb_l = min(a.bb_l, b.bb_l);
            this.bb_b = min(a.bb_b, b.bb_b);
            this.bb_r = max(a.bb_r, b.bb_r);
            this.bb_t = max(a.bb_t, b.bb_t);
            this.parent = null;
            this.setA(a);
            this.setB(b);
        };
        BBTree.prototype.makeNode = function(a, b) {
            var node = this.pooledNodes;
            if (node) {
                this.pooledNodes = node.parent;
                node.constructor(this, a, b);
                return node;
            }
            numNodes++;
            return new Node(this, a, b);
        };
        var numLeaves = 0;
        var Leaf = function(tree, obj) {
            this.obj = obj;
            tree.getBB(obj, this);
            this.parent = null;
            this.stamp = 1;
            this.pairs = null;
            numLeaves++;
        };
        BBTree.prototype.getBB = function(obj, dest) {
            var velocityFunc = this.velocityFunc;
            if (velocityFunc) {
                var coef = .1;
                var x = (obj.bb_r - obj.bb_l) * coef;
                var y = (obj.bb_t - obj.bb_b) * coef;
                var v = vmult(velocityFunc(obj), .1);
                dest.bb_l = obj.bb_l + min(-x, v.x);
                dest.bb_b = obj.bb_b + min(-y, v.y);
                dest.bb_r = obj.bb_r + max(x, v.x);
                dest.bb_t = obj.bb_t + max(y, v.y);
            } else {
                dest.bb_l = obj.bb_l;
                dest.bb_b = obj.bb_b;
                dest.bb_r = obj.bb_r;
                dest.bb_t = obj.bb_t;
            }
        };
        BBTree.prototype.getStamp = function() {
            var dynamic = this.dynamicIndex;
            return dynamic && dynamic.stamp ? dynamic.stamp : this.stamp;
        };
        BBTree.prototype.incrementStamp = function() {
            this.dynamicIndex && this.dynamicIndex.stamp ? this.dynamicIndex.stamp++ : this.stamp++;
        };
        var numPairs = 0;
        var Pair = function(leafA, nextA, leafB, nextB) {
            this.prevA = null;
            this.leafA = leafA;
            this.nextA = nextA;
            this.prevB = null;
            this.leafB = leafB;
            this.nextB = nextB;
        };
        BBTree.prototype.makePair = function(leafA, nextA, leafB, nextB) {
            var pair = this.pooledPairs;
            if (pair) {
                this.pooledPairs = pair.prevA;
                pair.prevA = null;
                pair.leafA = leafA;
                pair.nextA = nextA;
                pair.prevB = null;
                pair.leafB = leafB;
                pair.nextB = nextB;
                return pair;
            }
            numPairs++;
            return new Pair(leafA, nextA, leafB, nextB);
        };
        Pair.prototype.recycle = function(tree) {
            this.prevA = tree.pooledPairs;
            tree.pooledPairs = this;
        };
        var unlinkThread = function(prev, leaf, next) {
            next && (next.leafA === leaf ? next.prevA = prev : next.prevB = prev);
            prev ? prev.leafA === leaf ? prev.nextA = next : prev.nextB = next : leaf.pairs = next;
        };
        Leaf.prototype.clearPairs = function(tree) {
            var pair = this.pairs, next;
            this.pairs = null;
            while (pair) {
                if (pair.leafA === this) {
                    next = pair.nextA;
                    unlinkThread(pair.prevB, pair.leafB, pair.nextB);
                } else {
                    next = pair.nextB;
                    unlinkThread(pair.prevA, pair.leafA, pair.nextA);
                }
                pair.recycle(tree);
                pair = next;
            }
        };
        var pairInsert = function(a, b, tree) {
            var nextA = a.pairs, nextB = b.pairs;
            var pair = tree.makePair(a, nextA, b, nextB);
            a.pairs = b.pairs = pair;
            nextA && (nextA.leafA === a ? nextA.prevA = pair : nextA.prevB = pair);
            nextB && (nextB.leafA === b ? nextB.prevA = pair : nextB.prevB = pair);
        };
        Node.prototype.recycle = function(tree) {
            this.parent = tree.pooledNodes;
            tree.pooledNodes = this;
        };
        Leaf.prototype.recycle = function(tree) {};
        Node.prototype.setA = function(value) {
            this.A = value;
            value.parent = this;
        };
        Node.prototype.setB = function(value) {
            this.B = value;
            value.parent = this;
        };
        Leaf.prototype.isLeaf = true;
        Node.prototype.isLeaf = false;
        Node.prototype.otherChild = function(child) {
            return this.A == child ? this.B : this.A;
        };
        Node.prototype.replaceChild = function(child, value, tree) {
            assertSoft(child == this.A || child == this.B, "Node is not a child of parent.");
            if (this.A == child) {
                this.A.recycle(tree);
                this.setA(value);
            } else {
                this.B.recycle(tree);
                this.setB(value);
            }
            for (var node = this; node; node = node.parent) {
                var a = node.A;
                var b = node.B;
                node.bb_l = min(a.bb_l, b.bb_l);
                node.bb_b = min(a.bb_b, b.bb_b);
                node.bb_r = max(a.bb_r, b.bb_r);
                node.bb_t = max(a.bb_t, b.bb_t);
            }
        };
        Node.prototype.bbArea = Leaf.prototype.bbArea = function() {
            return (this.bb_r - this.bb_l) * (this.bb_t - this.bb_b);
        };
        var bbTreeMergedArea = function(a, b) {
            return (max(a.bb_r, b.bb_r) - min(a.bb_l, b.bb_l)) * (max(a.bb_t, b.bb_t) - min(a.bb_b, b.bb_b));
        };
        var bbProximity = function(a, b) {
            return Math.abs(a.bb_l + a.bb_r - b.bb_l - b.bb_r) + Math.abs(a.bb_b + a.bb_t - b.bb_b - b.bb_t);
        };
        var subtreeInsert = function(subtree, leaf, tree) {
            if (null == subtree) {
                return leaf;
            }
            if (subtree.isLeaf) {
                return tree.makeNode(leaf, subtree);
            }
            var cost_a = subtree.B.bbArea() + bbTreeMergedArea(subtree.A, leaf);
            var cost_b = subtree.A.bbArea() + bbTreeMergedArea(subtree.B, leaf);
            if (cost_a === cost_b) {
                cost_a = bbProximity(subtree.A, leaf);
                cost_b = bbProximity(subtree.B, leaf);
            }
            cost_b < cost_a ? subtree.setB(subtreeInsert(subtree.B, leaf, tree)) : subtree.setA(subtreeInsert(subtree.A, leaf, tree));
            subtree.bb_l = min(subtree.bb_l, leaf.bb_l);
            subtree.bb_b = min(subtree.bb_b, leaf.bb_b);
            subtree.bb_r = max(subtree.bb_r, leaf.bb_r);
            subtree.bb_t = max(subtree.bb_t, leaf.bb_t);
            return subtree;
        };
        Node.prototype.intersectsBB = Leaf.prototype.intersectsBB = function(bb) {
            return this.bb_l <= bb.r && bb.l <= this.bb_r && this.bb_b <= bb.t && bb.b <= this.bb_t;
        };
        var subtreeQuery = function(subtree, bb, func) {
            if (subtree.intersectsBB(bb)) {
                if (subtree.isLeaf) {
                    func(subtree.obj);
                } else {
                    subtreeQuery(subtree.A, bb, func);
                    subtreeQuery(subtree.B, bb, func);
                }
            }
        };
        var nodeSegmentQuery = function(node, a, b) {
            var idx = 1 / (b.x - a.x);
            var tx1 = node.bb_l == a.x ? -(1 / 0) : (node.bb_l - a.x) * idx;
            var tx2 = node.bb_r == a.x ? 1 / 0 : (node.bb_r - a.x) * idx;
            var txmin = min(tx1, tx2);
            var txmax = max(tx1, tx2);
            var idy = 1 / (b.y - a.y);
            var ty1 = node.bb_b == a.y ? -(1 / 0) : (node.bb_b - a.y) * idy;
            var ty2 = node.bb_t == a.y ? 1 / 0 : (node.bb_t - a.y) * idy;
            var tymin = min(ty1, ty2);
            var tymax = max(ty1, ty2);
            if (tymin <= txmax && txmin <= tymax) {
                var min_ = max(txmin, tymin);
                var max_ = min(txmax, tymax);
                if (0 <= max_ && min_ <= 1) {
                    return max(min_, 0);
                }
            }
            return 1 / 0;
        };
        var subtreeSegmentQuery = function(subtree, a, b, t_exit, func) {
            if (subtree.isLeaf) {
                return func(subtree.obj);
            }
            var t_a = nodeSegmentQuery(subtree.A, a, b);
            var t_b = nodeSegmentQuery(subtree.B, a, b);
            if (t_a < t_b) {
                t_a < t_exit && (t_exit = min(t_exit, subtreeSegmentQuery(subtree.A, a, b, t_exit, func)));
                t_b < t_exit && (t_exit = min(t_exit, subtreeSegmentQuery(subtree.B, a, b, t_exit, func)));
            } else {
                t_b < t_exit && (t_exit = min(t_exit, subtreeSegmentQuery(subtree.B, a, b, t_exit, func)));
                t_a < t_exit && (t_exit = min(t_exit, subtreeSegmentQuery(subtree.A, a, b, t_exit, func)));
            }
            return t_exit;
        };
        BBTree.prototype.subtreeRecycle = function(node) {
            if (node.isLeaf) {
                this.subtreeRecycle(node.A);
                this.subtreeRecycle(node.B);
                node.recycle(this);
            }
        };
        var subtreeRemove = function(subtree, leaf, tree) {
            if (leaf == subtree) {
                return null;
            }
            var parent = leaf.parent;
            if (parent == subtree) {
                var other = subtree.otherChild(leaf);
                other.parent = subtree.parent;
                subtree.recycle(tree);
                return other;
            }
            parent.parent.replaceChild(parent, parent.otherChild(leaf), tree);
            return subtree;
        };
        var bbTreeIntersectsNode = function(a, b) {
            return a.bb_l <= b.bb_r && b.bb_l <= a.bb_r && a.bb_b <= b.bb_t && b.bb_b <= a.bb_t;
        };
        Leaf.prototype.markLeafQuery = function(leaf, left, tree, func) {
            if (bbTreeIntersectsNode(leaf, this)) {
                if (left) {
                    pairInsert(leaf, this, tree);
                } else {
                    this.stamp < leaf.stamp && pairInsert(this, leaf, tree);
                    func && func(leaf.obj, this.obj);
                }
            }
        };
        Node.prototype.markLeafQuery = function(leaf, left, tree, func) {
            if (bbTreeIntersectsNode(leaf, this)) {
                this.A.markLeafQuery(leaf, left, tree, func);
                this.B.markLeafQuery(leaf, left, tree, func);
            }
        };
        Leaf.prototype.markSubtree = function(tree, staticRoot, func) {
            if (this.stamp == tree.getStamp()) {
                staticRoot && staticRoot.markLeafQuery(this, false, tree, func);
                for (var node = this; node.parent; node = node.parent) {
                    node == node.parent.A ? node.parent.B.markLeafQuery(this, true, tree, func) : node.parent.A.markLeafQuery(this, false, tree, func);
                }
            } else {
                var pair = this.pairs;
                while (pair) {
                    if (this === pair.leafB) {
                        func && func(pair.leafA.obj, this.obj);
                        pair = pair.nextB;
                    } else {
                        pair = pair.nextA;
                    }
                }
            }
        };
        Node.prototype.markSubtree = function(tree, staticRoot, func) {
            this.A.markSubtree(tree, staticRoot, func);
            this.B.markSubtree(tree, staticRoot, func);
        };
        Leaf.prototype.containsObj = function(obj) {
            return this.bb_l <= obj.bb_l && this.bb_r >= obj.bb_r && this.bb_b <= obj.bb_b && this.bb_t >= obj.bb_t;
        };
        Leaf.prototype.update = function(tree) {
            var root = tree.root;
            var obj = this.obj;
            if (!this.containsObj(obj)) {
                tree.getBB(this.obj, this);
                root = subtreeRemove(root, this, tree);
                tree.root = subtreeInsert(root, this, tree);
                this.clearPairs(tree);
                this.stamp = tree.getStamp();
                return true;
            }
            return false;
        };
        Leaf.prototype.addPairs = function(tree) {
            var dynamicIndex = tree.dynamicIndex;
            if (dynamicIndex) {
                var dynamicRoot = dynamicIndex.root;
                dynamicRoot && dynamicRoot.markLeafQuery(this, true, dynamicIndex, null);
            } else {
                var staticRoot = tree.staticIndex.root;
                this.markSubtree(tree, staticRoot, null);
            }
        };
        BBTree.prototype.insert = function(obj, hashid) {
            var leaf = new Leaf(this, obj);
            this.leaves[hashid] = leaf;
            this.root = subtreeInsert(this.root, leaf, this);
            this.count++;
            leaf.stamp = this.getStamp();
            leaf.addPairs(this);
            this.incrementStamp();
        };
        BBTree.prototype.remove = function(obj, hashid) {
            var leaf = this.leaves[hashid];
            delete this.leaves[hashid];
            this.root = subtreeRemove(this.root, leaf, this);
            this.count--;
            leaf.clearPairs(this);
            leaf.recycle(this);
        };
        BBTree.prototype.contains = function(obj, hashid) {
            return null != this.leaves[hashid];
        };
        var voidQueryFunc = function(obj1, obj2) {};
        BBTree.prototype.reindexQuery = function(func) {
            if (!this.root) {
                return;
            }
            var hashid, leaves = this.leaves;
            for (hashid in leaves) {
                leaves[hashid].update(this);
            }
            var staticIndex = this.staticIndex;
            var staticRoot = staticIndex && staticIndex.root;
            this.root.markSubtree(this, staticRoot, func);
            staticIndex && !staticRoot && this.collideStatic(this, staticIndex, func);
            this.incrementStamp();
        };
        BBTree.prototype.reindex = function() {
            this.reindexQuery(voidQueryFunc);
        };
        BBTree.prototype.reindexObject = function(obj, hashid) {
            var leaf = this.leaves[hashid];
            if (leaf) {
                leaf.update(this) && leaf.addPairs(this);
                this.incrementStamp();
            }
        };
        BBTree.prototype.pointQuery = function(point, func) {
            this.query(new BB(point.x, point.y, point.x, point.y), func);
        };
        BBTree.prototype.segmentQuery = function(a, b, t_exit, func) {
            this.root && subtreeSegmentQuery(this.root, a, b, t_exit, func);
        };
        BBTree.prototype.query = function(bb, func) {
            this.root && subtreeQuery(this.root, bb, func);
        };
        BBTree.prototype.count = function() {
            return this.count;
        };
        BBTree.prototype.each = function(func) {
            var hashid;
            for (hashid in this.leaves) {
                func(this.leaves[hashid].obj);
            }
        };
        var bbTreeMergedArea2 = function(node, l, b, r, t) {
            return (max(node.bb_r, r) - min(node.bb_l, l)) * (max(node.bb_t, t) - min(node.bb_b, b));
        };
        var partitionNodes = function(tree, nodes, offset, count) {
            if (1 == count) {
                return nodes[offset];
            }
            if (2 == count) {
                return tree.makeNode(nodes[offset], nodes[offset + 1]);
            }
            var node = nodes[offset];
            var bb_l = node.bb_l, bb_b = node.bb_b, bb_r = node.bb_r, bb_t = node.bb_t;
            var end = offset + count;
            for (var i = offset + 1; i < end; i++) {
                node = nodes[i];
                bb_l = min(bb_l, node.bb_l);
                bb_b = min(bb_b, node.bb_b);
                bb_r = max(bb_r, node.bb_r);
                bb_t = max(bb_t, node.bb_t);
            }
            var splitWidth = bb_r - bb_l > bb_t - bb_b;
            var bounds = new Array(2 * count);
            if (splitWidth) {
                for (var i = offset; i < end; i++) {
                    bounds[2 * i + 0] = nodes[i].bb_l;
                    bounds[2 * i + 1] = nodes[i].bb_r;
                }
            } else {
                for (var i = offset; i < end; i++) {
                    bounds[2 * i + 0] = nodes[i].bb_b;
                    bounds[2 * i + 1] = nodes[i].bb_t;
                }
            }
            bounds.sort((function(a, b) {
                return a - b;
            }));
            var split = .5 * (bounds[count - 1] + bounds[count]);
            var a_l = bb_l, a_b = bb_b, a_r = bb_r, a_t = bb_t;
            var b_l = bb_l, b_b = bb_b, b_r = bb_r, b_t = bb_t;
            splitWidth ? a_r = b_l = split : a_t = b_b = split;
            var right = end;
            for (var left = offset; left < right; ) {
                var node = nodes[left];
                if (bbTreeMergedArea2(node, b_l, b_b, b_r, b_t) < bbTreeMergedArea2(node, a_l, a_b, a_r, a_t)) {
                    right--;
                    nodes[left] = nodes[right];
                    nodes[right] = node;
                } else {
                    left++;
                }
            }
            if (right == count) {
                var node = null;
                for (var i = offset; i < end; i++) {
                    node = subtreeInsert(node, nodes[i], tree);
                }
                return node;
            }
            return NodeNew(tree, partitionNodes(tree, nodes, offset, right - offset), partitionNodes(tree, nodes, right, end - right));
        };
        BBTree.prototype.optimize = function() {
            var nodes = new Array(this.count);
            var i = 0;
            for (var hashid in this.leaves) {
                nodes[i++] = this.nodes[hashid];
            }
            tree.subtreeRecycle(root);
            this.root = partitionNodes(tree, nodes, nodes.length);
        };
        var nodeRender = function(node, depth) {
            if (!node.isLeaf && depth <= 10) {
                nodeRender(node.A, depth + 1);
                nodeRender(node.B, depth + 1);
            }
            var str = "";
            for (var i = 0; i < depth; i++) {
                str += " ";
            }
            console.log(str + node.bb_b + " " + node.bb_t);
        };
        BBTree.prototype.log = function() {
            this.root && nodeRender(this.root, 0);
        };
        var CollisionHandler = cp.CollisionHandler = function() {
            this.a = this.b = 0;
        };
        CollisionHandler.prototype.begin = function(arb, space) {
            return true;
        };
        CollisionHandler.prototype.preSolve = function(arb, space) {
            return true;
        };
        CollisionHandler.prototype.postSolve = function(arb, space) {};
        CollisionHandler.prototype.separate = function(arb, space) {};
        var CP_MAX_CONTACTS_PER_ARBITER = 4;
        var Arbiter = function(a, b) {
            this.e = 0;
            this.u = 0;
            this.surface_vr = vzero;
            this.a = a;
            this.body_a = a.body;
            this.b = b;
            this.body_b = b.body;
            this.thread_a_next = this.thread_a_prev = null;
            this.thread_b_next = this.thread_b_prev = null;
            this.contacts = null;
            this.stamp = 0;
            this.handler = null;
            this.swappedColl = false;
            this.state = "first coll";
        };
        Arbiter.prototype.getShapes = function() {
            return this.swappedColl ? [ this.b, this.a ] : [ this.a, this.b ];
        };
        Arbiter.prototype.totalImpulse = function() {
            var contacts = this.contacts;
            var sum = new Vect(0, 0);
            for (var i = 0, count = contacts.length; i < count; i++) {
                var con = contacts[i];
                sum.add(vmult(con.n, con.jnAcc));
            }
            return this.swappedColl ? sum : sum.neg();
        };
        Arbiter.prototype.totalImpulseWithFriction = function() {
            var contacts = this.contacts;
            var sum = new Vect(0, 0);
            for (var i = 0, count = contacts.length; i < count; i++) {
                var con = contacts[i];
                sum.add(new Vect(con.jnAcc, con.jtAcc).rotate(con.n));
            }
            return this.swappedColl ? sum : sum.neg();
        };
        Arbiter.prototype.totalKE = function() {
            var eCoef = (1 - this.e) / (1 + this.e);
            var sum = 0;
            var contacts = this.contacts;
            for (var i = 0, count = contacts.length; i < count; i++) {
                var con = contacts[i];
                var jnAcc = con.jnAcc;
                var jtAcc = con.jtAcc;
                sum += eCoef * jnAcc * jnAcc / con.nMass + jtAcc * jtAcc / con.tMass;
            }
            return sum;
        };
        Arbiter.prototype.ignore = function() {
            this.state = "ignore";
        };
        Arbiter.prototype.getA = function() {
            return this.swappedColl ? this.b : this.a;
        };
        Arbiter.prototype.getB = function() {
            return this.swappedColl ? this.a : this.b;
        };
        Arbiter.prototype.isFirstContact = function() {
            return "first coll" === this.state;
        };
        var ContactPoint = function(point, normal, dist) {
            this.point = point;
            this.normal = normal;
            this.dist = dist;
        };
        Arbiter.prototype.getContactPointSet = function() {
            var set = new Array(this.contacts.length);
            var i;
            for (i = 0; i < set.length; i++) {
                set[i] = new ContactPoint(this.contacts[i].p, this.contacts[i].n, this.contacts[i].dist);
            }
            return set;
        };
        Arbiter.prototype.getNormal = function(i) {
            var n = this.contacts[i].n;
            return this.swappedColl ? vneg(n) : n;
        };
        Arbiter.prototype.getPoint = function(i) {
            return this.contacts[i].p;
        };
        Arbiter.prototype.getDepth = function(i) {
            return this.contacts[i].dist;
        };
        var unthreadHelper = function(arb, body, prev, next) {
            prev ? prev.body_a === body ? prev.thread_a_next = next : prev.thread_b_next = next : body.arbiterList = next;
            next && (next.body_a === body ? next.thread_a_prev = prev : next.thread_b_prev = prev);
        };
        Arbiter.prototype.unthread = function() {
            unthreadHelper(this, this.body_a, this.thread_a_prev, this.thread_a_next);
            unthreadHelper(this, this.body_b, this.thread_b_prev, this.thread_b_next);
            this.thread_a_prev = this.thread_a_next = null;
            this.thread_b_prev = this.thread_b_next = null;
        };
        Arbiter.prototype.update = function(contacts, handler, a, b) {
            if (this.contacts) {
                for (var i = 0; i < this.contacts.length; i++) {
                    var old = this.contacts[i];
                    for (var j = 0; j < contacts.length; j++) {
                        var new_contact = contacts[j];
                        if (new_contact.hash === old.hash) {
                            new_contact.jnAcc = old.jnAcc;
                            new_contact.jtAcc = old.jtAcc;
                        }
                    }
                }
            }
            this.contacts = contacts;
            this.handler = handler;
            this.swappedColl = a.collision_type !== handler.a;
            this.e = a.e * b.e;
            this.u = a.u * b.u;
            this.surface_vr = vsub(a.surface_v, b.surface_v);
            this.a = a;
            this.body_a = a.body;
            this.b = b;
            this.body_b = b.body;
            "cached" == this.state && (this.state = "first coll");
        };
        Arbiter.prototype.preStep = function(dt, slop, bias) {
            var a = this.body_a;
            var b = this.body_b;
            for (var i = 0; i < this.contacts.length; i++) {
                var con = this.contacts[i];
                con.r1 = vsub(con.p, a.p);
                con.r2 = vsub(con.p, b.p);
                con.nMass = 1 / k_scalar(a, b, con.r1, con.r2, con.n);
                con.tMass = 1 / k_scalar(a, b, con.r1, con.r2, vperp(con.n));
                con.bias = -bias * min(0, con.dist + slop) / dt;
                con.jBias = 0;
                con.bounce = normal_relative_velocity(a, b, con.r1, con.r2, con.n) * this.e;
            }
        };
        Arbiter.prototype.applyCachedImpulse = function(dt_coef) {
            if (this.isFirstContact()) {
                return;
            }
            var a = this.body_a;
            var b = this.body_b;
            for (var i = 0; i < this.contacts.length; i++) {
                var con = this.contacts[i];
                var nx = con.n.x;
                var ny = con.n.y;
                var jx = nx * con.jnAcc - ny * con.jtAcc;
                var jy = nx * con.jtAcc + ny * con.jnAcc;
                apply_impulses(a, b, con.r1, con.r2, jx * dt_coef, jy * dt_coef);
            }
        };
        var numApplyImpulse = 0;
        var numApplyContact = 0;
        Arbiter.prototype.applyImpulse = function() {
            numApplyImpulse++;
            var a = this.body_a;
            var b = this.body_b;
            var surface_vr = this.surface_vr;
            var friction = this.u;
            for (var i = 0; i < this.contacts.length; i++) {
                numApplyContact++;
                var con = this.contacts[i];
                var nMass = con.nMass;
                var n = con.n;
                var r1 = con.r1;
                var r2 = con.r2;
                var vrx = b.vx - r2.y * b.w - (a.vx - r1.y * a.w);
                var vry = b.vy + r2.x * b.w - (a.vy + r1.x * a.w);
                var vbn = n.x * (b.v_biasx - r2.y * b.w_bias - a.v_biasx + r1.y * a.w_bias) + n.y * (r2.x * b.w_bias + b.v_biasy - r1.x * a.w_bias - a.v_biasy);
                var vrn = vdot2(vrx, vry, n.x, n.y);
                var vrt = vdot2(vrx + surface_vr.x, vry + surface_vr.y, -n.y, n.x);
                var jbn = (con.bias - vbn) * nMass;
                var jbnOld = con.jBias;
                con.jBias = max(jbnOld + jbn, 0);
                var jn = -(con.bounce + vrn) * nMass;
                var jnOld = con.jnAcc;
                con.jnAcc = max(jnOld + jn, 0);
                var jtMax = friction * con.jnAcc;
                var jt = -vrt * con.tMass;
                var jtOld = con.jtAcc;
                con.jtAcc = clamp(jtOld + jt, -jtMax, jtMax);
                var bias_x = n.x * (con.jBias - jbnOld);
                var bias_y = n.y * (con.jBias - jbnOld);
                apply_bias_impulse(a, -bias_x, -bias_y, r1);
                apply_bias_impulse(b, bias_x, bias_y, r2);
                var rot_x = con.jnAcc - jnOld;
                var rot_y = con.jtAcc - jtOld;
                apply_impulses(a, b, r1, r2, n.x * rot_x - n.y * rot_y, n.x * rot_y + n.y * rot_x);
            }
        };
        Arbiter.prototype.callSeparate = function(space) {
            var handler = space.lookupHandler(this.a.collision_type, this.b.collision_type);
            handler.separate(this, space);
        };
        Arbiter.prototype.next = function(body) {
            return this.body_a == body ? this.thread_a_next : this.thread_b_next;
        };
        var numContacts = 0;
        var Contact = function(p, n, dist, hash) {
            this.p = p;
            this.n = n;
            this.dist = dist;
            this.r1 = this.r2 = vzero;
            this.nMass = this.tMass = this.bounce = this.bias = 0;
            this.jnAcc = this.jtAcc = this.jBias = 0;
            this.hash = hash;
            numContacts++;
        };
        var NONE = [];
        var circle2circleQuery = function(p1, p2, r1, r2) {
            var mindist = r1 + r2;
            var delta = vsub(p2, p1);
            var distsq = vlengthsq(delta);
            if (distsq >= mindist * mindist) {
                return;
            }
            var dist = Math.sqrt(distsq);
            return new Contact(vadd(p1, vmult(delta, .5 + (r1 - .5 * mindist) / (dist ? dist : 1 / 0))), dist ? vmult(delta, 1 / dist) : new Vect(1, 0), dist - mindist, 0);
        };
        var circle2circle = function(circ1, circ2) {
            var contact = circle2circleQuery(circ1.tc, circ2.tc, circ1.r, circ2.r);
            return contact ? [ contact ] : NONE;
        };
        var circle2segment = function(circleShape, segmentShape) {
            var seg_a = segmentShape.ta;
            var seg_b = segmentShape.tb;
            var center = circleShape.tc;
            var seg_delta = vsub(seg_b, seg_a);
            var closest_t = clamp01(vdot(seg_delta, vsub(center, seg_a)) / vlengthsq(seg_delta));
            var closest = vadd(seg_a, vmult(seg_delta, closest_t));
            var contact = circle2circleQuery(center, closest, circleShape.r, segmentShape.r);
            if (contact) {
                var n = contact.n;
                return 0 === closest_t && vdot(n, segmentShape.a_tangent) < 0 || 1 === closest_t && vdot(n, segmentShape.b_tangent) < 0 ? NONE : [ contact ];
            }
            return NONE;
        };
        var last_MSA_min = 0;
        var findMSA = function(poly, planes) {
            var min_index = 0;
            var min = poly.valueOnAxis(planes[0].n, planes[0].d);
            if (min > 0) {
                return -1;
            }
            for (var i = 1; i < planes.length; i++) {
                var dist = poly.valueOnAxis(planes[i].n, planes[i].d);
                if (dist > 0) {
                    return -1;
                }
                if (dist > min) {
                    min = dist;
                    min_index = i;
                }
            }
            last_MSA_min = min;
            return min_index;
        };
        var findVertsFallback = function(poly1, poly2, n, dist) {
            var arr = [];
            var verts1 = poly1.tVerts;
            for (var i = 0; i < verts1.length; i += 2) {
                var vx = verts1[i];
                var vy = verts1[i + 1];
                poly2.containsVertPartial(vx, vy, vneg(n)) && arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly1.hashid, i)));
            }
            var verts2 = poly2.tVerts;
            for (var i = 0; i < verts2.length; i += 2) {
                var vx = verts2[i];
                var vy = verts2[i + 1];
                poly1.containsVertPartial(vx, vy, n) && arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly2.hashid, i)));
            }
            return arr;
        };
        var findVerts = function(poly1, poly2, n, dist) {
            var arr = [];
            var verts1 = poly1.tVerts;
            for (var i = 0; i < verts1.length; i += 2) {
                var vx = verts1[i];
                var vy = verts1[i + 1];
                poly2.containsVert(vx, vy) && arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly1.hashid, i >> 1)));
            }
            var verts2 = poly2.tVerts;
            for (var i = 0; i < verts2.length; i += 2) {
                var vx = verts2[i];
                var vy = verts2[i + 1];
                poly1.containsVert(vx, vy) && arr.push(new Contact(new Vect(vx, vy), n, dist, hashPair(poly2.hashid, i >> 1)));
            }
            return arr.length ? arr : findVertsFallback(poly1, poly2, n, dist);
        };
        var poly2poly = function(poly1, poly2) {
            var mini1 = findMSA(poly2, poly1.tPlanes);
            if (mini1 == -1) {
                return NONE;
            }
            var min1 = last_MSA_min;
            var mini2 = findMSA(poly1, poly2.tPlanes);
            if (mini2 == -1) {
                return NONE;
            }
            var min2 = last_MSA_min;
            return min1 > min2 ? findVerts(poly1, poly2, poly1.tPlanes[mini1].n, min1) : findVerts(poly1, poly2, vneg(poly2.tPlanes[mini2].n), min2);
        };
        var segValueOnAxis = function(seg, n, d) {
            var a = vdot(n, seg.ta) - seg.r;
            var b = vdot(n, seg.tb) - seg.r;
            return min(a, b) - d;
        };
        var findPointsBehindSeg = function(arr, seg, poly, pDist, coef) {
            var dta = vcross(seg.tn, seg.ta);
            var dtb = vcross(seg.tn, seg.tb);
            var n = vmult(seg.tn, coef);
            var verts = poly.tVerts;
            for (var i = 0; i < verts.length; i += 2) {
                var vx = verts[i];
                var vy = verts[i + 1];
                if (vdot2(vx, vy, n.x, n.y) < vdot(seg.tn, seg.ta) * coef + seg.r) {
                    var dt = vcross2(seg.tn.x, seg.tn.y, vx, vy);
                    dta >= dt && dt >= dtb && arr.push(new Contact(new Vect(vx, vy), n, pDist, hashPair(poly.hashid, i)));
                }
            }
        };
        var seg2poly = function(seg, poly) {
            var arr = [];
            var planes = poly.tPlanes;
            var numVerts = planes.length;
            var segD = vdot(seg.tn, seg.ta);
            var minNorm = poly.valueOnAxis(seg.tn, segD) - seg.r;
            var minNeg = poly.valueOnAxis(vneg(seg.tn), -segD) - seg.r;
            if (minNeg > 0 || minNorm > 0) {
                return NONE;
            }
            var mini = 0;
            var poly_min = segValueOnAxis(seg, planes[0].n, planes[0].d);
            if (poly_min > 0) {
                return NONE;
            }
            for (var i = 0; i < numVerts; i++) {
                var dist = segValueOnAxis(seg, planes[i].n, planes[i].d);
                if (dist > 0) {
                    return NONE;
                }
                if (dist > poly_min) {
                    poly_min = dist;
                    mini = i;
                }
            }
            var poly_n = vneg(planes[mini].n);
            var va = vadd(seg.ta, vmult(poly_n, seg.r));
            var vb = vadd(seg.tb, vmult(poly_n, seg.r));
            poly.containsVert(va.x, va.y) && arr.push(new Contact(va, poly_n, poly_min, hashPair(seg.hashid, 0)));
            poly.containsVert(vb.x, vb.y) && arr.push(new Contact(vb, poly_n, poly_min, hashPair(seg.hashid, 1)));
            (minNorm >= poly_min || minNeg >= poly_min) && (minNorm > minNeg ? findPointsBehindSeg(arr, seg, poly, minNorm, 1) : findPointsBehindSeg(arr, seg, poly, minNeg, -1));
            if (0 === arr.length) {
                var mini2 = 2 * mini;
                var verts = poly.tVerts;
                var poly_a = new Vect(verts[mini2], verts[mini2 + 1]);
                var con;
                if (con = circle2circleQuery(seg.ta, poly_a, seg.r, 0, arr)) {
                    return [ con ];
                }
                if (con = circle2circleQuery(seg.tb, poly_a, seg.r, 0, arr)) {
                    return [ con ];
                }
                var len = 2 * numVerts;
                var poly_b = new Vect(verts[(mini2 + 2) % len], verts[(mini2 + 3) % len]);
                if (con = circle2circleQuery(seg.ta, poly_b, seg.r, 0, arr)) {
                    return [ con ];
                }
                if (con = circle2circleQuery(seg.tb, poly_b, seg.r, 0, arr)) {
                    return [ con ];
                }
            }
            return arr;
        };
        var circle2poly = function(circ, poly) {
            var planes = poly.tPlanes;
            var mini = 0;
            var min = vdot(planes[0].n, circ.tc) - planes[0].d - circ.r;
            for (var i = 0; i < planes.length; i++) {
                var dist = vdot(planes[i].n, circ.tc) - planes[i].d - circ.r;
                if (dist > 0) {
                    return NONE;
                }
                if (dist > min) {
                    min = dist;
                    mini = i;
                }
            }
            var n = planes[mini].n;
            var verts = poly.tVerts;
            var len = verts.length;
            var mini2 = mini << 1;
            var ax = verts[mini2];
            var ay = verts[mini2 + 1];
            var bx = verts[(mini2 + 2) % len];
            var by = verts[(mini2 + 3) % len];
            var dta = vcross2(n.x, n.y, ax, ay);
            var dtb = vcross2(n.x, n.y, bx, by);
            var dt = vcross(n, circ.tc);
            if (dt < dtb) {
                var con = circle2circleQuery(circ.tc, new Vect(bx, by), circ.r, 0, con);
                return con ? [ con ] : NONE;
            }
            if (dt < dta) {
                return [ new Contact(vsub(circ.tc, vmult(n, circ.r + min / 2)), vneg(n), min, 0) ];
            }
            var con = circle2circleQuery(circ.tc, new Vect(ax, ay), circ.r, 0, con);
            return con ? [ con ] : NONE;
        };
        CircleShape.prototype.collisionCode = 0;
        SegmentShape.prototype.collisionCode = 1;
        PolyShape.prototype.collisionCode = 2;
        CircleShape.prototype.collisionTable = [ circle2circle, circle2segment, circle2poly ];
        SegmentShape.prototype.collisionTable = [ null, function(segA, segB) {
            return NONE;
        }, seg2poly ];
        PolyShape.prototype.collisionTable = [ null, null, poly2poly ];
        var collideShapes = cp.collideShapes = function(a, b) {
            assert(a.collisionCode <= b.collisionCode, "Collided shapes must be sorted by type");
            return a.collisionTable[b.collisionCode](a, b);
        };
        var defaultCollisionHandler = new CollisionHandler();
        var Space = cp.Space = function() {
            this.stamp = 0;
            this.curr_dt = 0;
            this.bodies = [];
            this.rousedBodies = [];
            this.sleepingComponents = [];
            this.staticShapes = new BBTree(null);
            this.activeShapes = new BBTree(this.staticShapes);
            this.arbiters = [];
            this.contactBuffersHead = null;
            this.cachedArbiters = {};
            this.constraints = [];
            this.locked = 0;
            this.collisionHandlers = {};
            this.defaultHandler = defaultCollisionHandler;
            this.postStepCallbacks = [];
            this.iterations = 10;
            this.gravity = vzero;
            this.damping = 1;
            this.idleSpeedThreshold = 0;
            this.sleepTimeThreshold = 1 / 0;
            this.collisionSlop = .1;
            this.collisionBias = Math.pow(.9, 60);
            this.collisionPersistence = 3;
            this.enableContactGraph = false;
            this.staticBody = new Body(1 / 0, 1 / 0);
            this.staticBody.nodeIdleTime = 1 / 0;
            this.collideShapes = this.makeCollideShapes();
        };
        Space.prototype.getCurrentTimeStep = function() {
            return this.curr_dt;
        };
        Space.prototype.setIterations = function(iter) {
            this.iterations = iter;
        };
        Space.prototype.isLocked = function() {
            return this.locked;
        };
        var assertSpaceUnlocked = function(space) {
            assert(!space.locked, "This addition/removal cannot be done safely during a call to cpSpaceStep()  or during a query. Put these calls into a post-step callback.");
        };
        Space.prototype.addCollisionHandler = function(a, b, begin, preSolve, postSolve, separate) {
            assertSpaceUnlocked(this);
            this.removeCollisionHandler(a, b);
            var handler = new CollisionHandler();
            handler.a = a;
            handler.b = b;
            begin && (handler.begin = begin);
            preSolve && (handler.preSolve = preSolve);
            postSolve && (handler.postSolve = postSolve);
            separate && (handler.separate = separate);
            this.collisionHandlers[hashPair(a, b)] = handler;
        };
        Space.prototype.removeCollisionHandler = function(a, b) {
            assertSpaceUnlocked(this);
            delete this.collisionHandlers[hashPair(a, b)];
        };
        Space.prototype.setDefaultCollisionHandler = function(begin, preSolve, postSolve, separate) {
            assertSpaceUnlocked(this);
            var handler = new CollisionHandler();
            begin && (handler.begin = begin);
            preSolve && (handler.preSolve = preSolve);
            postSolve && (handler.postSolve = postSolve);
            separate && (handler.separate = separate);
            this.defaultHandler = handler;
        };
        Space.prototype.lookupHandler = function(a, b) {
            return this.collisionHandlers[hashPair(a, b)] || this.defaultHandler;
        };
        Space.prototype.addShape = function(shape) {
            var body = shape.body;
            if (body.isStatic()) {
                return this.addStaticShape(shape);
            }
            assert(!shape.space, "This shape is already added to a space and cannot be added to another.");
            assertSpaceUnlocked(this);
            body.activate();
            body.addShape(shape);
            shape.update(body.p, body.rot);
            this.activeShapes.insert(shape, shape.hashid);
            shape.space = this;
            return shape;
        };
        Space.prototype.addStaticShape = function(shape) {
            assert(!shape.space, "This shape is already added to a space and cannot be added to another.");
            assertSpaceUnlocked(this);
            var body = shape.body;
            body.addShape(shape);
            shape.update(body.p, body.rot);
            this.staticShapes.insert(shape, shape.hashid);
            shape.space = this;
            return shape;
        };
        Space.prototype.addBody = function(body) {
            assert(!body.isStatic(), "Static bodies cannot be added to a space as they are not meant to be simulated.");
            assert(!body.space, "This body is already added to a space and cannot be added to another.");
            assertSpaceUnlocked(this);
            this.bodies.push(body);
            body.space = this;
            return body;
        };
        Space.prototype.addConstraint = function(constraint) {
            assert(!constraint.space, "This shape is already added to a space and cannot be added to another.");
            assertSpaceUnlocked(this);
            var a = constraint.a, b = constraint.b;
            a.activate();
            b.activate();
            this.constraints.push(constraint);
            constraint.next_a = a.constraintList;
            a.constraintList = constraint;
            constraint.next_b = b.constraintList;
            b.constraintList = constraint;
            constraint.space = this;
            return constraint;
        };
        Space.prototype.filterArbiters = function(body, filter) {
            for (var hash in this.cachedArbiters) {
                var arb = this.cachedArbiters[hash];
                if (body === arb.body_a && (filter === arb.a || null === filter) || body === arb.body_b && (filter === arb.b || null === filter)) {
                    filter && "cached" !== arb.state && arb.callSeparate(this);
                    arb.unthread();
                    deleteObjFromList(this.arbiters, arb);
                    delete this.cachedArbiters[hash];
                }
            }
        };
        Space.prototype.removeShape = function(shape) {
            var body = shape.body;
            if (body.isStatic()) {
                this.removeStaticShape(shape);
            } else {
                assert(this.containsShape(shape), "Cannot remove a shape that was not added to the space. (Removed twice maybe?)");
                assertSpaceUnlocked(this);
                body.activate();
                body.removeShape(shape);
                this.filterArbiters(body, shape);
                this.activeShapes.remove(shape, shape.hashid);
                shape.space = null;
            }
        };
        Space.prototype.removeStaticShape = function(shape) {
            assert(this.containsShape(shape), "Cannot remove a static or sleeping shape that was not added to the space. (Removed twice maybe?)");
            assertSpaceUnlocked(this);
            var body = shape.body;
            body.isStatic() && body.activateStatic(shape);
            body.removeShape(shape);
            this.filterArbiters(body, shape);
            this.staticShapes.remove(shape, shape.hashid);
            shape.space = null;
        };
        Space.prototype.removeBody = function(body) {
            assert(this.containsBody(body), "Cannot remove a body that was not added to the space. (Removed twice maybe?)");
            assertSpaceUnlocked(this);
            body.activate();
            deleteObjFromList(this.bodies, body);
            body.space = null;
        };
        Space.prototype.removeConstraint = function(constraint) {
            assert(this.containsConstraint(constraint), "Cannot remove a constraint that was not added to the space. (Removed twice maybe?)");
            assertSpaceUnlocked(this);
            constraint.a.activate();
            constraint.b.activate();
            deleteObjFromList(this.constraints, constraint);
            constraint.a.removeConstraint(constraint);
            constraint.b.removeConstraint(constraint);
            constraint.space = null;
        };
        Space.prototype.containsShape = function(shape) {
            return shape.space === this;
        };
        Space.prototype.containsBody = function(body) {
            return body.space == this;
        };
        Space.prototype.containsConstraint = function(constraint) {
            return constraint.space == this;
        };
        Space.prototype.uncacheArbiter = function(arb) {
            delete this.cachedArbiters[hashPair(arb.a.hashid, arb.b.hashid)];
            deleteObjFromList(this.arbiters, arb);
        };
        Space.prototype.eachBody = function(func) {
            this.lock();
            var bodies = this.bodies;
            for (var i = 0; i < bodies.length; i++) {
                func(bodies[i]);
            }
            var components = this.sleepingComponents;
            for (var i = 0; i < components.length; i++) {
                var root = components[i];
                var body = root;
                while (body) {
                    var next = body.nodeNext;
                    func(body);
                    body = next;
                }
            }
            this.unlock(true);
        };
        Space.prototype.eachShape = function(func) {
            this.lock();
            this.activeShapes.each(func);
            this.staticShapes.each(func);
            this.unlock(true);
        };
        Space.prototype.eachConstraint = function(func) {
            this.lock();
            var constraints = this.constraints;
            for (var i = 0; i < constraints.length; i++) {
                func(constraints[i]);
            }
            this.unlock(true);
        };
        Space.prototype.reindexStatic = function() {
            assert(!this.locked, "You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete.");
            this.staticShapes.each((function(shape) {
                var body = shape.body;
                shape.update(body.p, body.rot);
            }));
            this.staticShapes.reindex();
        };
        Space.prototype.reindexShape = function(shape) {
            assert(!this.locked, "You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete.");
            var body = shape.body;
            shape.update(body.p, body.rot);
            this.activeShapes.reindexObject(shape, shape.hashid);
            this.staticShapes.reindexObject(shape, shape.hashid);
        };
        Space.prototype.reindexShapesForBody = function(body) {
            for (var shape = body.shapeList; shape; shape = shape.next) {
                this.reindexShape(shape);
            }
        };
        Space.prototype.useSpatialHash = function(dim, count) {
            throw new Error("Spatial Hash not implemented.");
            var staticShapes;
            var activeShapes;
        };
        Space.prototype.activateBody = function(body) {
            assert(!body.isRogue(), "Internal error: Attempting to activate a rogue body.");
            if (this.locked) {
                this.rousedBodies.indexOf(body) === -1 && this.rousedBodies.push(body);
            } else {
                this.bodies.push(body);
                for (var i = 0; i < body.shapeList.length; i++) {
                    var shape = body.shapeList[i];
                    this.staticShapes.remove(shape, shape.hashid);
                    this.activeShapes.insert(shape, shape.hashid);
                }
                for (var arb = body.arbiterList; arb; arb = arb.next(body)) {
                    var bodyA = arb.body_a;
                    if (body === bodyA || bodyA.isStatic()) {
                        var a = arb.a, b = arb.b;
                        this.cachedArbiters[hashPair(a.hashid, b.hashid)] = arb;
                        arb.stamp = this.stamp;
                        arb.handler = this.lookupHandler(a.collision_type, b.collision_type);
                        this.arbiters.push(arb);
                    }
                }
                for (var constraint = body.constraintList; constraint; constraint = constraint.nodeNext) {
                    var bodyA = constraint.a;
                    (body === bodyA || bodyA.isStatic()) && this.constraints.push(constraint);
                }
            }
        };
        Space.prototype.deactivateBody = function(body) {
            assert(!body.isRogue(), "Internal error: Attempting to deactivate a rogue body.");
            deleteObjFromList(this.bodies, body);
            for (var i = 0; i < body.shapeList.length; i++) {
                var shape = body.shapeList[i];
                this.activeShapes.remove(shape, shape.hashid);
                this.staticShapes.insert(shape, shape.hashid);
            }
            for (var arb = body.arbiterList; arb; arb = arb.next(body)) {
                var bodyA = arb.body_a;
                (body === bodyA || bodyA.isStatic()) && this.uncacheArbiter(arb);
            }
            for (var constraint = body.constraintList; constraint; constraint = constraint.nodeNext) {
                var bodyA = constraint.a;
                (body === bodyA || bodyA.isStatic()) && deleteObjFromList(this.constraints, constraint);
            }
        };
        var componentRoot = function(body) {
            return body ? body.nodeRoot : null;
        };
        var componentActivate = function(root) {
            if (!root || !root.isSleeping(root)) {
                return;
            }
            assert(!root.isRogue(), "Internal Error: componentActivate() called on a rogue body.");
            var space = root.space;
            var body = root;
            while (body) {
                var next = body.nodeNext;
                body.nodeIdleTime = 0;
                body.nodeRoot = null;
                body.nodeNext = null;
                space.activateBody(body);
                body = next;
            }
            deleteObjFromList(space.sleepingComponents, root);
        };
        Body.prototype.activate = function() {
            if (!this.isRogue()) {
                this.nodeIdleTime = 0;
                componentActivate(componentRoot(this));
            }
        };
        Body.prototype.activateStatic = function(filter) {
            assert(this.isStatic(), "Body.activateStatic() called on a non-static body.");
            for (var arb = this.arbiterList; arb; arb = arb.next(this)) {
                filter && filter != arb.a && filter != arb.b || (arb.body_a == this ? arb.body_b : arb.body_a).activate();
            }
        };
        Body.prototype.pushArbiter = function(arb) {
            assertSoft(null === (arb.body_a === this ? arb.thread_a_next : arb.thread_b_next), "Internal Error: Dangling contact graph pointers detected. (A)");
            assertSoft(null === (arb.body_a === this ? arb.thread_a_prev : arb.thread_b_prev), "Internal Error: Dangling contact graph pointers detected. (B)");
            var next = this.arbiterList;
            assertSoft(null === next || null === (next.body_a === this ? next.thread_a_prev : next.thread_b_prev), "Internal Error: Dangling contact graph pointers detected. (C)");
            arb.body_a === this ? arb.thread_a_next = next : arb.thread_b_next = next;
            next && (next.body_a === this ? next.thread_a_prev = arb : next.thread_b_prev = arb);
            this.arbiterList = arb;
        };
        var componentAdd = function(root, body) {
            body.nodeRoot = root;
            if (body !== root) {
                body.nodeNext = root.nodeNext;
                root.nodeNext = body;
            }
        };
        var floodFillComponent = function(root, body) {
            if (!body.isRogue()) {
                var other_root = componentRoot(body);
                if (null == other_root) {
                    componentAdd(root, body);
                    for (var arb = body.arbiterList; arb; arb = arb.next(body)) {
                        floodFillComponent(root, body == arb.body_a ? arb.body_b : arb.body_a);
                    }
                    for (var constraint = body.constraintList; constraint; constraint = constraint.next(body)) {
                        floodFillComponent(root, body == constraint.a ? constraint.b : constraint.a);
                    }
                } else {
                    assertSoft(other_root === root, "Internal Error: Inconsistency detected in the contact graph.");
                }
            }
        };
        var componentActive = function(root, threshold) {
            for (var body = root; body; body = body.nodeNext) {
                if (body.nodeIdleTime < threshold) {
                    return true;
                }
            }
            return false;
        };
        Space.prototype.processComponents = function(dt) {
            var sleep = this.sleepTimeThreshold !== 1 / 0;
            var bodies = this.bodies;
            for (var i = 0; i < bodies.length; i++) {
                var body = bodies[i];
                assertSoft(null === body.nodeNext, "Internal Error: Dangling next pointer detected in contact graph.");
                assertSoft(null === body.nodeRoot, "Internal Error: Dangling root pointer detected in contact graph.");
            }
            if (sleep) {
                var dv = this.idleSpeedThreshold;
                var dvsq = dv ? dv * dv : vlengthsq(this.gravity) * dt * dt;
                for (var i = 0; i < bodies.length; i++) {
                    var body = bodies[i];
                    var keThreshold = dvsq ? body.m * dvsq : 0;
                    body.nodeIdleTime = body.kineticEnergy() > keThreshold ? 0 : body.nodeIdleTime + dt;
                }
            }
            var arbiters = this.arbiters;
            for (var i = 0, count = arbiters.length; i < count; i++) {
                var arb = arbiters[i];
                var a = arb.body_a, b = arb.body_b;
                if (sleep) {
                    (b.isRogue() && !b.isStatic() || a.isSleeping()) && a.activate();
                    (a.isRogue() && !a.isStatic() || b.isSleeping()) && b.activate();
                }
                a.pushArbiter(arb);
                b.pushArbiter(arb);
            }
            if (sleep) {
                var constraints = this.constraints;
                for (var i = 0; i < constraints.length; i++) {
                    var constraint = constraints[i];
                    var a = constraint.a, b = constraint.b;
                    b.isRogue() && !b.isStatic() && a.activate();
                    a.isRogue() && !a.isStatic() && b.activate();
                }
                for (var i = 0; i < bodies.length; ) {
                    var body = bodies[i];
                    if (null === componentRoot(body)) {
                        floodFillComponent(body, body);
                        if (!componentActive(body, this.sleepTimeThreshold)) {
                            this.sleepingComponents.push(body);
                            for (var other = body; other; other = other.nodeNext) {
                                this.deactivateBody(other);
                            }
                            continue;
                        }
                    }
                    i++;
                    body.nodeRoot = null;
                    body.nodeNext = null;
                }
            }
        };
        Body.prototype.sleep = function() {
            this.sleepWithGroup(null);
        };
        Body.prototype.sleepWithGroup = function(group) {
            assert(!this.isStatic() && !this.isRogue(), "Rogue and static bodies cannot be put to sleep.");
            var space = this.space;
            assert(space, "Cannot put a rogue body to sleep.");
            assert(!space.locked, "Bodies cannot be put to sleep during a query or a call to cpSpaceStep(). Put these calls into a post-step callback.");
            assert(null === group || group.isSleeping(), "Cannot use a non-sleeping body as a group identifier.");
            if (this.isSleeping()) {
                assert(componentRoot(this) === componentRoot(group), "The body is already sleeping and it's group cannot be reassigned.");
                return;
            }
            for (var i = 0; i < this.shapeList.length; i++) {
                this.shapeList[i].update(this.p, this.rot);
            }
            space.deactivateBody(this);
            if (group) {
                var root = componentRoot(group);
                this.nodeRoot = root;
                this.nodeNext = root.nodeNext;
                this.nodeIdleTime = 0;
                root.nodeNext = this;
            } else {
                this.nodeRoot = this;
                this.nodeNext = null;
                this.nodeIdleTime = 0;
                space.sleepingComponents.push(this);
            }
            deleteObjFromList(space.bodies, this);
        };
        Space.prototype.activateShapesTouchingShape = function(shape) {
            this.sleepTimeThreshold !== 1 / 0 && this.shapeQuery(shape, (function(shape, points) {
                shape.body.activate();
            }));
        };
        Space.prototype.pointQuery = function(point, layers, group, func) {
            var helper = function(shape) {
                !(shape.group && group === shape.group) && layers & shape.layers && shape.pointQuery(point) && func(shape);
            };
            var bb = new BB(point.x, point.y, point.x, point.y);
            this.lock();
            this.activeShapes.query(bb, helper);
            this.staticShapes.query(bb, helper);
            this.unlock(true);
        };
        Space.prototype.pointQueryFirst = function(point, layers, group) {
            var outShape = null;
            this.pointQuery(point, layers, group, (function(shape) {
                shape.sensor || (outShape = shape);
            }));
            return outShape;
        };
        Space.prototype.nearestPointQuery = function(point, maxDistance, layers, group, func) {
            var helper = function(shape) {
                if (!(shape.group && group === shape.group) && layers & shape.layers) {
                    var info = shape.nearestPointQuery(point);
                    info.d < maxDistance && func(shape, info.d, info.p);
                }
            };
            var bb = bbNewForCircle(point, maxDistance);
            this.lock();
            this.activeShapes.query(bb, helper);
            this.staticShapes.query(bb, helper);
            this.unlock(true);
        };
        Space.prototype.nearestPointQueryNearest = function(point, maxDistance, layers, group) {
            var out;
            var helper = function(shape) {
                if (!(shape.group && group === shape.group) && layers & shape.layers && !shape.sensor) {
                    var info = shape.nearestPointQuery(point);
                    info.d < maxDistance && (!out || info.d < out.d) && (out = info);
                }
            };
            var bb = bbNewForCircle(point, maxDistance);
            this.activeShapes.query(bb, helper);
            this.staticShapes.query(bb, helper);
            return out;
        };
        Space.prototype.segmentQuery = function(start, end, layers, group, func) {
            var helper = function(shape) {
                var info;
                !(shape.group && group === shape.group) && layers & shape.layers && (info = shape.segmentQuery(start, end)) && func(shape, info.t, info.n);
                return 1;
            };
            this.lock();
            this.staticShapes.segmentQuery(start, end, 1, helper);
            this.activeShapes.segmentQuery(start, end, 1, helper);
            this.unlock(true);
        };
        Space.prototype.segmentQueryFirst = function(start, end, layers, group) {
            var out = null;
            var helper = function(shape) {
                var info;
                !(shape.group && group === shape.group) && layers & shape.layers && !shape.sensor && (info = shape.segmentQuery(start, end)) && (null === out || info.t < out.t) && (out = info);
                return out ? out.t : 1;
            };
            this.staticShapes.segmentQuery(start, end, 1, helper);
            this.activeShapes.segmentQuery(start, end, out ? out.t : 1, helper);
            return out;
        };
        Space.prototype.bbQuery = function(bb, layers, group, func) {
            var helper = function(shape) {
                !(shape.group && group === shape.group) && layers & shape.layers && bbIntersects2(bb, shape.bb_l, shape.bb_b, shape.bb_r, shape.bb_t) && func(shape);
            };
            this.lock();
            this.activeShapes.query(bb, helper);
            this.staticShapes.query(bb, helper);
            this.unlock(true);
        };
        Space.prototype.shapeQuery = function(shape, func) {
            var body = shape.body;
            body && shape.update(body.p, body.rot);
            var bb = new BB(shape.bb_l, shape.bb_b, shape.bb_r, shape.bb_t);
            var anyCollision = false;
            var helper = function(b) {
                var a = shape;
                if (a.group && a.group === b.group || !(a.layers & b.layers) || a === b) {
                    return;
                }
                var contacts;
                if (a.collisionCode <= b.collisionCode) {
                    contacts = collideShapes(a, b);
                } else {
                    contacts = collideShapes(b, a);
                    for (var i = 0; i < contacts.length; i++) {
                        contacts[i].n = vneg(contacts[i].n);
                    }
                }
                if (contacts.length) {
                    anyCollision = !(a.sensor || b.sensor);
                    if (func) {
                        var set = new Array(contacts.length);
                        for (var i = 0; i < contacts.length; i++) {
                            set[i] = new ContactPoint(contacts[i].p, contacts[i].n, contacts[i].dist);
                        }
                        func(b, set);
                    }
                }
            };
            this.lock();
            this.activeShapes.query(bb, helper);
            this.staticShapes.query(bb, helper);
            this.unlock(true);
            return anyCollision;
        };
        Space.prototype.addPostStepCallback = function(func) {
            assertSoft(this.locked, "Adding a post-step callback when the space is not locked is unnecessary. Post-step callbacks will not called until the end of the next call to cpSpaceStep() or the next query.");
            this.postStepCallbacks.push(func);
        };
        Space.prototype.runPostStepCallbacks = function() {
            for (var i = 0; i < this.postStepCallbacks.length; i++) {
                this.postStepCallbacks[i]();
            }
            this.postStepCallbacks = [];
        };
        Space.prototype.lock = function() {
            this.locked++;
        };
        Space.prototype.unlock = function(runPostStep) {
            this.locked--;
            assert(this.locked >= 0, "Internal Error: Space lock underflow.");
            if (0 === this.locked && runPostStep) {
                var waking = this.rousedBodies;
                for (var i = 0; i < waking.length; i++) {
                    this.activateBody(waking[i]);
                }
                waking.length = 0;
                this.runPostStepCallbacks();
            }
        };
        Space.prototype.makeCollideShapes = function() {
            var space_ = this;
            return function(a, b) {
                var space = space_;
                if (!(a.bb_l <= b.bb_r && b.bb_l <= a.bb_r && a.bb_b <= b.bb_t && b.bb_b <= a.bb_t) || a.body === b.body || a.group && a.group === b.group || !(a.layers & b.layers)) {
                    return;
                }
                var handler = space.lookupHandler(a.collision_type, b.collision_type);
                var sensor = a.sensor || b.sensor;
                if (sensor && handler === defaultCollisionHandler) {
                    return;
                }
                if (a.collisionCode > b.collisionCode) {
                    var temp = a;
                    a = b;
                    b = temp;
                }
                var contacts = collideShapes(a, b);
                if (0 === contacts.length) {
                    return;
                }
                var arbHash = hashPair(a.hashid, b.hashid);
                var arb = space.cachedArbiters[arbHash];
                arb || (arb = space.cachedArbiters[arbHash] = new Arbiter(a, b));
                arb.update(contacts, handler, a, b);
                "first coll" != arb.state || handler.begin(arb, space) || arb.ignore();
                if ("ignore" !== arb.state && handler.preSolve(arb, space) && !sensor) {
                    space.arbiters.push(arb);
                } else {
                    arb.contacts = null;
                    "ignore" !== arb.state && (arb.state = "normal");
                }
                arb.stamp = space.stamp;
            };
        };
        Space.prototype.arbiterSetFilter = function(arb) {
            var ticks = this.stamp - arb.stamp;
            var a = arb.body_a, b = arb.body_b;
            if ((a.isStatic() || a.isSleeping()) && (b.isStatic() || b.isSleeping())) {
                return true;
            }
            if (ticks >= 1 && "cached" != arb.state) {
                arb.callSeparate(this);
                arb.state = "cached";
            }
            if (ticks >= this.collisionPersistence) {
                arb.contacts = null;
                return false;
            }
            return true;
        };
        var updateFunc = function(shape) {
            var body = shape.body;
            shape.update(body.p, body.rot);
        };
        Space.prototype.step = function(dt) {
            if (0 === dt) {
                return;
            }
            assert(0 === vzero.x && 0 === vzero.y, "vzero is invalid");
            this.stamp++;
            var prev_dt = this.curr_dt;
            this.curr_dt = dt;
            var i;
            var j;
            var hash;
            var bodies = this.bodies;
            var constraints = this.constraints;
            var arbiters = this.arbiters;
            for (i = 0; i < arbiters.length; i++) {
                var arb = arbiters[i];
                arb.state = "normal";
                arb.body_a.isSleeping() || arb.body_b.isSleeping() || arb.unthread();
            }
            arbiters.length = 0;
            this.lock();
            for (i = 0; i < bodies.length; i++) {
                bodies[i].position_func(dt);
            }
            this.activeShapes.each(updateFunc);
            this.activeShapes.reindexQuery(this.collideShapes);
            this.unlock(false);
            this.processComponents(dt);
            this.lock();
            for (hash in this.cachedArbiters) {
                this.arbiterSetFilter(this.cachedArbiters[hash]) || delete this.cachedArbiters[hash];
            }
            var slop = this.collisionSlop;
            var biasCoef = 1 - Math.pow(this.collisionBias, dt);
            for (i = 0; i < arbiters.length; i++) {
                arbiters[i].preStep(dt, slop, biasCoef);
            }
            for (i = 0; i < constraints.length; i++) {
                var constraint = constraints[i];
                constraint.preSolve(this);
                constraint.preStep(dt);
            }
            var damping = Math.pow(this.damping, dt);
            var gravity = this.gravity;
            for (i = 0; i < bodies.length; i++) {
                bodies[i].velocity_func(gravity, damping, dt);
            }
            var dt_coef = 0 === prev_dt ? 0 : dt / prev_dt;
            for (i = 0; i < arbiters.length; i++) {
                arbiters[i].applyCachedImpulse(dt_coef);
            }
            for (i = 0; i < constraints.length; i++) {
                constraints[i].applyCachedImpulse(dt_coef);
            }
            for (i = 0; i < this.iterations; i++) {
                for (j = 0; j < arbiters.length; j++) {
                    arbiters[j].applyImpulse();
                }
                for (j = 0; j < constraints.length; j++) {
                    constraints[j].applyImpulse();
                }
            }
            for (i = 0; i < constraints.length; i++) {
                constraints[i].postSolve(this);
            }
            for (i = 0; i < arbiters.length; i++) {
                arbiters[i].handler.postSolve(arbiters[i], this);
            }
            this.unlock(true);
        };
        var relative_velocity = function(a, b, r1, r2) {
            var v1_sumx = a.vx + -r1.y * a.w;
            var v1_sumy = a.vy + r1.x * a.w;
            var v2_sumx = b.vx + -r2.y * b.w;
            var v2_sumy = b.vy + r2.x * b.w;
            return new Vect(v2_sumx - v1_sumx, v2_sumy - v1_sumy);
        };
        var normal_relative_velocity = function(a, b, r1, r2, n) {
            var v1_sumx = a.vx + -r1.y * a.w;
            var v1_sumy = a.vy + r1.x * a.w;
            var v2_sumx = b.vx + -r2.y * b.w;
            var v2_sumy = b.vy + r2.x * b.w;
            return vdot2(v2_sumx - v1_sumx, v2_sumy - v1_sumy, n.x, n.y);
        };
        var apply_impulse = function(body, jx, jy, r) {
            body.vx += jx * body.m_inv;
            body.vy += jy * body.m_inv;
            body.w += body.i_inv * (r.x * jy - r.y * jx);
        };
        var apply_impulses = function(a, b, r1, r2, jx, jy) {
            apply_impulse(a, -jx, -jy, r1);
            apply_impulse(b, jx, jy, r2);
        };
        var apply_bias_impulse = function(body, jx, jy, r) {
            body.v_biasx += jx * body.m_inv;
            body.v_biasy += jy * body.m_inv;
            body.w_bias += body.i_inv * vcross2(r.x, r.y, jx, jy);
        };
        var k_scalar_body = function(body, r, n) {
            var rcn = vcross(r, n);
            return body.m_inv + body.i_inv * rcn * rcn;
        };
        var k_scalar = function(a, b, r1, r2, n) {
            var value = k_scalar_body(a, r1, n) + k_scalar_body(b, r2, n);
            assertSoft(0 !== value, "Unsolvable collision or constraint.");
            return value;
        };
        var k_tensor = function(a, b, r1, r2, k1, k2) {
            var k11, k12, k21, k22;
            var m_sum = a.m_inv + b.m_inv;
            k11 = m_sum;
            k12 = 0;
            k21 = 0;
            k22 = m_sum;
            var a_i_inv = a.i_inv;
            var r1xsq = r1.x * r1.x * a_i_inv;
            var r1ysq = r1.y * r1.y * a_i_inv;
            var r1nxy = -r1.x * r1.y * a_i_inv;
            k11 += r1ysq;
            k12 += r1nxy;
            k21 += r1nxy;
            k22 += r1xsq;
            var b_i_inv = b.i_inv;
            var r2xsq = r2.x * r2.x * b_i_inv;
            var r2ysq = r2.y * r2.y * b_i_inv;
            var r2nxy = -r2.x * r2.y * b_i_inv;
            k11 += r2ysq;
            k12 += r2nxy;
            k21 += r2nxy;
            k22 += r2xsq;
            var determinant = k11 * k22 - k12 * k21;
            assertSoft(0 !== determinant, "Unsolvable constraint.");
            var det_inv = 1 / determinant;
            k1.x = k22 * det_inv;
            k1.y = -k12 * det_inv;
            k2.x = -k21 * det_inv;
            k2.y = k11 * det_inv;
        };
        var mult_k = function(vr, k1, k2) {
            return new Vect(vdot(vr, k1), vdot(vr, k2));
        };
        var bias_coef = function(errorBias, dt) {
            return 1 - Math.pow(errorBias, dt);
        };
        var Constraint = cp.Constraint = function(a, b) {
            this.a = a;
            this.b = b;
            this.space = null;
            this.next_a = null;
            this.next_b = null;
            this.maxForce = 1 / 0;
            this.errorBias = Math.pow(.9, 60);
            this.maxBias = 1 / 0;
        };
        Constraint.prototype.activateBodies = function() {
            this.a && this.a.activate();
            this.b && this.b.activate();
        };
        Constraint.prototype.preStep = function(dt) {};
        Constraint.prototype.applyCachedImpulse = function(dt_coef) {};
        Constraint.prototype.applyImpulse = function() {};
        Constraint.prototype.getImpulse = function() {
            return 0;
        };
        Constraint.prototype.preSolve = function(space) {};
        Constraint.prototype.postSolve = function(space) {};
        Constraint.prototype.next = function(body) {
            return this.a === body ? this.next_a : this.next_b;
        };
        var PinJoint = cp.PinJoint = function(a, b, anchr1, anchr2) {
            Constraint.call(this, a, b);
            this.anchr1 = anchr1;
            this.anchr2 = anchr2;
            var p1 = a ? vadd(a.p, vrotate(anchr1, a.rot)) : anchr1;
            var p2 = b ? vadd(b.p, vrotate(anchr2, b.rot)) : anchr2;
            this.dist = vlength(vsub(p2, p1));
            assertSoft(this.dist > 0, "You created a 0 length pin joint. A pivot joint will be much more stable.");
            this.r1 = this.r2 = null;
            this.n = null;
            this.nMass = 0;
            this.jnAcc = this.jnMax = 0;
            this.bias = 0;
        };
        PinJoint.prototype = Object.create(Constraint.prototype);
        PinJoint.prototype.preStep = function(dt) {
            var a = this.a;
            var b = this.b;
            this.r1 = vrotate(this.anchr1, a.rot);
            this.r2 = vrotate(this.anchr2, b.rot);
            var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
            var dist = vlength(delta);
            this.n = vmult(delta, 1 / (dist ? dist : 1 / 0));
            this.nMass = 1 / k_scalar(a, b, this.r1, this.r2, this.n);
            var maxBias = this.maxBias;
            this.bias = clamp(-bias_coef(this.errorBias, dt) * (dist - this.dist) / dt, -maxBias, maxBias);
            this.jnMax = this.maxForce * dt;
        };
        PinJoint.prototype.applyCachedImpulse = function(dt_coef) {
            var j = vmult(this.n, this.jnAcc * dt_coef);
            apply_impulses(this.a, this.b, this.r1, this.r2, j.x, j.y);
        };
        PinJoint.prototype.applyImpulse = function() {
            var a = this.a;
            var b = this.b;
            var n = this.n;
            var vrn = normal_relative_velocity(a, b, this.r1, this.r2, n);
            var jn = (this.bias - vrn) * this.nMass;
            var jnOld = this.jnAcc;
            this.jnAcc = clamp(jnOld + jn, -this.jnMax, this.jnMax);
            jn = this.jnAcc - jnOld;
            apply_impulses(a, b, this.r1, this.r2, n.x * jn, n.y * jn);
        };
        PinJoint.prototype.getImpulse = function() {
            return Math.abs(this.jnAcc);
        };
        var SlideJoint = cp.SlideJoint = function(a, b, anchr1, anchr2, min, max) {
            Constraint.call(this, a, b);
            this.anchr1 = anchr1;
            this.anchr2 = anchr2;
            this.min = min;
            this.max = max;
            this.r1 = this.r2 = this.n = null;
            this.nMass = 0;
            this.jnAcc = this.jnMax = 0;
            this.bias = 0;
        };
        SlideJoint.prototype = Object.create(Constraint.prototype);
        SlideJoint.prototype.preStep = function(dt) {
            var a = this.a;
            var b = this.b;
            this.r1 = vrotate(this.anchr1, a.rot);
            this.r2 = vrotate(this.anchr2, b.rot);
            var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
            var dist = vlength(delta);
            var pdist = 0;
            if (dist > this.max) {
                pdist = dist - this.max;
                this.n = vnormalize_safe(delta);
            } else {
                if (dist < this.min) {
                    pdist = this.min - dist;
                    this.n = vneg(vnormalize_safe(delta));
                } else {
                    this.n = vzero;
                    this.jnAcc = 0;
                }
            }
            this.nMass = 1 / k_scalar(a, b, this.r1, this.r2, this.n);
            var maxBias = this.maxBias;
            this.bias = clamp(-bias_coef(this.errorBias, dt) * pdist / dt, -maxBias, maxBias);
            this.jnMax = this.maxForce * dt;
        };
        SlideJoint.prototype.applyCachedImpulse = function(dt_coef) {
            var jn = this.jnAcc * dt_coef;
            apply_impulses(this.a, this.b, this.r1, this.r2, this.n.x * jn, this.n.y * jn);
        };
        SlideJoint.prototype.applyImpulse = function() {
            if (0 === this.n.x && 0 === this.n.y) {
                return;
            }
            var a = this.a;
            var b = this.b;
            var n = this.n;
            var r1 = this.r1;
            var r2 = this.r2;
            var vr = relative_velocity(a, b, r1, r2);
            var vrn = vdot(vr, n);
            var jn = (this.bias - vrn) * this.nMass;
            var jnOld = this.jnAcc;
            this.jnAcc = clamp(jnOld + jn, -this.jnMax, 0);
            jn = this.jnAcc - jnOld;
            apply_impulses(a, b, this.r1, this.r2, n.x * jn, n.y * jn);
        };
        SlideJoint.prototype.getImpulse = function() {
            return Math.abs(this.jnAcc);
        };
        var PivotJoint = cp.PivotJoint = function(a, b, anchr1, anchr2) {
            Constraint.call(this, a, b);
            if ("undefined" === typeof anchr2) {
                var pivot = anchr1;
                anchr1 = a ? a.world2Local(pivot) : pivot;
                anchr2 = b ? b.world2Local(pivot) : pivot;
            }
            this.anchr1 = anchr1;
            this.anchr2 = anchr2;
            this.r1 = this.r2 = vzero;
            this.k1 = new Vect(0, 0);
            this.k2 = new Vect(0, 0);
            this.jAcc = vzero;
            this.jMaxLen = 0;
            this.bias = vzero;
        };
        PivotJoint.prototype = Object.create(Constraint.prototype);
        PivotJoint.prototype.preStep = function(dt) {
            var a = this.a;
            var b = this.b;
            this.r1 = vrotate(this.anchr1, a.rot);
            this.r2 = vrotate(this.anchr2, b.rot);
            k_tensor(a, b, this.r1, this.r2, this.k1, this.k2);
            this.jMaxLen = this.maxForce * dt;
            var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
            this.bias = vclamp(vmult(delta, -bias_coef(this.errorBias, dt) / dt), this.maxBias);
        };
        PivotJoint.prototype.applyCachedImpulse = function(dt_coef) {
            apply_impulses(this.a, this.b, this.r1, this.r2, this.jAcc.x * dt_coef, this.jAcc.y * dt_coef);
        };
        PivotJoint.prototype.applyImpulse = function() {
            var a = this.a;
            var b = this.b;
            var r1 = this.r1;
            var r2 = this.r2;
            var vr = relative_velocity(a, b, r1, r2);
            var j = mult_k(vsub(this.bias, vr), this.k1, this.k2);
            var jOld = this.jAcc;
            this.jAcc = vclamp(vadd(this.jAcc, j), this.jMaxLen);
            apply_impulses(a, b, this.r1, this.r2, this.jAcc.x - jOld.x, this.jAcc.y - jOld.y);
        };
        PivotJoint.prototype.getImpulse = function() {
            return vlength(this.jAcc);
        };
        var GrooveJoint = cp.GrooveJoint = function(a, b, groove_a, groove_b, anchr2) {
            Constraint.call(this, a, b);
            this.grv_a = groove_a;
            this.grv_b = groove_b;
            this.grv_n = vperp(vnormalize(vsub(groove_b, groove_a)));
            this.anchr2 = anchr2;
            this.grv_tn = null;
            this.clamp = 0;
            this.r1 = this.r2 = null;
            this.k1 = new Vect(0, 0);
            this.k2 = new Vect(0, 0);
            this.jAcc = vzero;
            this.jMaxLen = 0;
            this.bias = null;
        };
        GrooveJoint.prototype = Object.create(Constraint.prototype);
        GrooveJoint.prototype.preStep = function(dt) {
            var a = this.a;
            var b = this.b;
            var ta = a.local2World(this.grv_a);
            var tb = a.local2World(this.grv_b);
            var n = vrotate(this.grv_n, a.rot);
            var d = vdot(ta, n);
            this.grv_tn = n;
            this.r2 = vrotate(this.anchr2, b.rot);
            var td = vcross(vadd(b.p, this.r2), n);
            if (td <= vcross(ta, n)) {
                this.clamp = 1;
                this.r1 = vsub(ta, a.p);
            } else {
                if (td >= vcross(tb, n)) {
                    this.clamp = -1;
                    this.r1 = vsub(tb, a.p);
                } else {
                    this.clamp = 0;
                    this.r1 = vsub(vadd(vmult(vperp(n), -td), vmult(n, d)), a.p);
                }
            }
            k_tensor(a, b, this.r1, this.r2, this.k1, this.k2);
            this.jMaxLen = this.maxForce * dt;
            var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
            this.bias = vclamp(vmult(delta, -bias_coef(this.errorBias, dt) / dt), this.maxBias);
        };
        GrooveJoint.prototype.applyCachedImpulse = function(dt_coef) {
            apply_impulses(this.a, this.b, this.r1, this.r2, this.jAcc.x * dt_coef, this.jAcc.y * dt_coef);
        };
        GrooveJoint.prototype.grooveConstrain = function(j) {
            var n = this.grv_tn;
            var jClamp = this.clamp * vcross(j, n) > 0 ? j : vproject(j, n);
            return vclamp(jClamp, this.jMaxLen);
        };
        GrooveJoint.prototype.applyImpulse = function() {
            var a = this.a;
            var b = this.b;
            var r1 = this.r1;
            var r2 = this.r2;
            var vr = relative_velocity(a, b, r1, r2);
            var j = mult_k(vsub(this.bias, vr), this.k1, this.k2);
            var jOld = this.jAcc;
            this.jAcc = this.grooveConstrain(vadd(jOld, j));
            apply_impulses(a, b, this.r1, this.r2, this.jAcc.x - jOld.x, this.jAcc.y - jOld.y);
        };
        GrooveJoint.prototype.getImpulse = function() {
            return vlength(this.jAcc);
        };
        GrooveJoint.prototype.setGrooveA = function(value) {
            this.grv_a = value;
            this.grv_n = vperp(vnormalize(vsub(this.grv_b, value)));
            this.activateBodies();
        };
        GrooveJoint.prototype.setGrooveB = function(value) {
            this.grv_b = value;
            this.grv_n = vperp(vnormalize(vsub(value, this.grv_a)));
            this.activateBodies();
        };
        var defaultSpringForce = function(spring, dist) {
            return (spring.restLength - dist) * spring.stiffness;
        };
        var DampedSpring = cp.DampedSpring = function(a, b, anchr1, anchr2, restLength, stiffness, damping) {
            Constraint.call(this, a, b);
            this.anchr1 = anchr1;
            this.anchr2 = anchr2;
            this.restLength = restLength;
            this.stiffness = stiffness;
            this.damping = damping;
            this.springForceFunc = defaultSpringForce;
            this.target_vrn = this.v_coef = 0;
            this.r1 = this.r2 = null;
            this.nMass = 0;
            this.n = null;
        };
        DampedSpring.prototype = Object.create(Constraint.prototype);
        DampedSpring.prototype.preStep = function(dt) {
            var a = this.a;
            var b = this.b;
            this.r1 = vrotate(this.anchr1, a.rot);
            this.r2 = vrotate(this.anchr2, b.rot);
            var delta = vsub(vadd(b.p, this.r2), vadd(a.p, this.r1));
            var dist = vlength(delta);
            this.n = vmult(delta, 1 / (dist ? dist : 1 / 0));
            var k = k_scalar(a, b, this.r1, this.r2, this.n);
            assertSoft(0 !== k, "Unsolvable this.");
            this.nMass = 1 / k;
            this.target_vrn = 0;
            this.v_coef = 1 - Math.exp(-this.damping * dt * k);
            var f_spring = this.springForceFunc(this, dist);
            apply_impulses(a, b, this.r1, this.r2, this.n.x * f_spring * dt, this.n.y * f_spring * dt);
        };
        DampedSpring.prototype.applyCachedImpulse = function(dt_coef) {};
        DampedSpring.prototype.applyImpulse = function() {
            var a = this.a;
            var b = this.b;
            var n = this.n;
            var r1 = this.r1;
            var r2 = this.r2;
            var vrn = normal_relative_velocity(a, b, r1, r2, n);
            var v_damp = (this.target_vrn - vrn) * this.v_coef;
            this.target_vrn = vrn + v_damp;
            v_damp *= this.nMass;
            apply_impulses(a, b, this.r1, this.r2, this.n.x * v_damp, this.n.y * v_damp);
        };
        DampedSpring.prototype.getImpulse = function() {
            return 0;
        };
        var defaultSpringTorque = function(spring, relativeAngle) {
            return (relativeAngle - spring.restAngle) * spring.stiffness;
        };
        var DampedRotarySpring = cp.DampedRotarySpring = function(a, b, restAngle, stiffness, damping) {
            Constraint.call(this, a, b);
            this.restAngle = restAngle;
            this.stiffness = stiffness;
            this.damping = damping;
            this.springTorqueFunc = defaultSpringTorque;
            this.target_wrn = 0;
            this.w_coef = 0;
            this.iSum = 0;
        };
        DampedRotarySpring.prototype = Object.create(Constraint.prototype);
        DampedRotarySpring.prototype.preStep = function(dt) {
            var a = this.a;
            var b = this.b;
            var moment = a.i_inv + b.i_inv;
            assertSoft(0 !== moment, "Unsolvable spring.");
            this.iSum = 1 / moment;
            this.w_coef = 1 - Math.exp(-this.damping * dt * moment);
            this.target_wrn = 0;
            var j_spring = this.springTorqueFunc(this, a.a - b.a) * dt;
            a.w -= j_spring * a.i_inv;
            b.w += j_spring * b.i_inv;
        };
        DampedRotarySpring.prototype.applyImpulse = function() {
            var a = this.a;
            var b = this.b;
            var wrn = a.w - b.w;
            var w_damp = (this.target_wrn - wrn) * this.w_coef;
            this.target_wrn = wrn + w_damp;
            var j_damp = w_damp * this.iSum;
            a.w += j_damp * a.i_inv;
            b.w -= j_damp * b.i_inv;
        };
        var RotaryLimitJoint = cp.RotaryLimitJoint = function(a, b, min, max) {
            Constraint.call(this, a, b);
            this.min = min;
            this.max = max;
            this.jAcc = 0;
            this.iSum = this.bias = this.jMax = 0;
        };
        RotaryLimitJoint.prototype = Object.create(Constraint.prototype);
        RotaryLimitJoint.prototype.preStep = function(dt) {
            var a = this.a;
            var b = this.b;
            var dist = b.a - a.a;
            var pdist = 0;
            dist > this.max ? pdist = this.max - dist : dist < this.min && (pdist = this.min - dist);
            this.iSum = 1 / (1 / a.i + 1 / b.i);
            var maxBias = this.maxBias;
            this.bias = clamp(-bias_coef(this.errorBias, dt) * pdist / dt, -maxBias, maxBias);
            this.jMax = this.maxForce * dt;
            this.bias || (this.jAcc = 0);
        };
        RotaryLimitJoint.prototype.applyCachedImpulse = function(dt_coef) {
            var a = this.a;
            var b = this.b;
            var j = this.jAcc * dt_coef;
            a.w -= j * a.i_inv;
            b.w += j * b.i_inv;
        };
        RotaryLimitJoint.prototype.applyImpulse = function() {
            if (!this.bias) {
                return;
            }
            var a = this.a;
            var b = this.b;
            var wr = b.w - a.w;
            var j = -(this.bias + wr) * this.iSum;
            var jOld = this.jAcc;
            this.bias < 0 ? this.jAcc = clamp(jOld + j, 0, this.jMax) : this.jAcc = clamp(jOld + j, -this.jMax, 0);
            j = this.jAcc - jOld;
            a.w -= j * a.i_inv;
            b.w += j * b.i_inv;
        };
        RotaryLimitJoint.prototype.getImpulse = function() {
            return Math.abs(joint.jAcc);
        };
        var RatchetJoint = cp.RatchetJoint = function(a, b, phase, ratchet) {
            Constraint.call(this, a, b);
            this.angle = 0;
            this.phase = phase;
            this.ratchet = ratchet;
            this.angle = (b ? b.a : 0) - (a ? a.a : 0);
            this.iSum = this.bias = this.jAcc = this.jMax = 0;
        };
        RatchetJoint.prototype = Object.create(Constraint.prototype);
        RatchetJoint.prototype.preStep = function(dt) {
            var a = this.a;
            var b = this.b;
            var angle = this.angle;
            var phase = this.phase;
            var ratchet = this.ratchet;
            var delta = b.a - a.a;
            var diff = angle - delta;
            var pdist = 0;
            diff * ratchet > 0 ? pdist = diff : this.angle = Math.floor((delta - phase) / ratchet) * ratchet + phase;
            this.iSum = 1 / (a.i_inv + b.i_inv);
            var maxBias = this.maxBias;
            this.bias = clamp(-bias_coef(this.errorBias, dt) * pdist / dt, -maxBias, maxBias);
            this.jMax = this.maxForce * dt;
            this.bias || (this.jAcc = 0);
        };
        RatchetJoint.prototype.applyCachedImpulse = function(dt_coef) {
            var a = this.a;
            var b = this.b;
            var j = this.jAcc * dt_coef;
            a.w -= j * a.i_inv;
            b.w += j * b.i_inv;
        };
        RatchetJoint.prototype.applyImpulse = function() {
            if (!this.bias) {
                return;
            }
            var a = this.a;
            var b = this.b;
            var wr = b.w - a.w;
            var ratchet = this.ratchet;
            var j = -(this.bias + wr) * this.iSum;
            var jOld = this.jAcc;
            this.jAcc = clamp((jOld + j) * ratchet, 0, this.jMax * Math.abs(ratchet)) / ratchet;
            j = this.jAcc - jOld;
            a.w -= j * a.i_inv;
            b.w += j * b.i_inv;
        };
        RatchetJoint.prototype.getImpulse = function(joint) {
            return Math.abs(joint.jAcc);
        };
        var GearJoint = cp.GearJoint = function(a, b, phase, ratio) {
            Constraint.call(this, a, b);
            this.phase = phase;
            this.ratio = ratio;
            this.ratio_inv = 1 / ratio;
            this.jAcc = 0;
            this.iSum = this.bias = this.jMax = 0;
        };
        GearJoint.prototype = Object.create(Constraint.prototype);
        GearJoint.prototype.preStep = function(dt) {
            var a = this.a;
            var b = this.b;
            this.iSum = 1 / (a.i_inv * this.ratio_inv + this.ratio * b.i_inv);
            var maxBias = this.maxBias;
            this.bias = clamp(-bias_coef(this.errorBias, dt) * (b.a * this.ratio - a.a - this.phase) / dt, -maxBias, maxBias);
            this.jMax = this.maxForce * dt;
        };
        GearJoint.prototype.applyCachedImpulse = function(dt_coef) {
            var a = this.a;
            var b = this.b;
            var j = this.jAcc * dt_coef;
            a.w -= j * a.i_inv * this.ratio_inv;
            b.w += j * b.i_inv;
        };
        GearJoint.prototype.applyImpulse = function() {
            var a = this.a;
            var b = this.b;
            var wr = b.w * this.ratio - a.w;
            var j = (this.bias - wr) * this.iSum;
            var jOld = this.jAcc;
            this.jAcc = clamp(jOld + j, -this.jMax, this.jMax);
            j = this.jAcc - jOld;
            a.w -= j * a.i_inv * this.ratio_inv;
            b.w += j * b.i_inv;
        };
        GearJoint.prototype.getImpulse = function() {
            return Math.abs(this.jAcc);
        };
        GearJoint.prototype.setRatio = function(value) {
            this.ratio = value;
            this.ratio_inv = 1 / value;
            this.activateBodies();
        };
        var SimpleMotor = cp.SimpleMotor = function(a, b, rate) {
            Constraint.call(this, a, b);
            this.rate = rate;
            this.jAcc = 0;
            this.iSum = this.jMax = 0;
        };
        SimpleMotor.prototype = Object.create(Constraint.prototype);
        SimpleMotor.prototype.preStep = function(dt) {
            this.iSum = 1 / (this.a.i_inv + this.b.i_inv);
            this.jMax = this.maxForce * dt;
        };
        SimpleMotor.prototype.applyCachedImpulse = function(dt_coef) {
            var a = this.a;
            var b = this.b;
            var j = this.jAcc * dt_coef;
            a.w -= j * a.i_inv;
            b.w += j * b.i_inv;
        };
        SimpleMotor.prototype.applyImpulse = function() {
            var a = this.a;
            var b = this.b;
            var wr = b.w - a.w + this.rate;
            var j = -wr * this.iSum;
            var jOld = this.jAcc;
            this.jAcc = clamp(jOld + j, -this.jMax, this.jMax);
            j = this.jAcc - jOld;
            a.w -= j * a.i_inv;
            b.w += j * b.i_inv;
        };
        SimpleMotor.prototype.getImpulse = function() {
            return Math.abs(this.jAcc);
        };
    }), {} ],
    312: [ (function(require, module, exports) {
        module.exports = (function() {
            "use strict";
            function t() {
                "undefined" === typeof window.performance && (window.performance = {});
                if (!window.performance.now) {
                    var t = Date.now();
                    performance.timing && performance.timing.navigationStart && (t = performance.timing.navigationStart);
                    window.performance.now = function e() {
                        return Date.now() - t;
                    };
                }
                window.performance.mark || (window.performance.mark = function() {});
                window.performance.measure || (window.performance.measure = function() {});
                window.performance.memory || (window.performance.memory = {
                    usedJSHeapSize: 0,
                    totalJSHeapSize: 0
                });
            }
            var e = Math.round(window.devicePixelRatio || 1);
            var i = function t(e, i) {
                this._color = i || "#666";
                this._canvas = document.createElement("canvas");
                this._ctx = this._canvas.getContext("2d");
                this._canvas.className = "pstats-canvas";
                e.appendChild(this._canvas);
            };
            i.prototype.init = function t(i, a) {
                var n = i * e;
                var s = a * e;
                this._canvas.width = n;
                this._canvas.height = s;
                this._canvas.style.width = i + "px";
                this._canvas.style.height = a + "px";
                this._ctx.globalAlpha = 1;
                this._ctx.fillStyle = "#444";
                this._ctx.fillRect(0, 0, n, s);
            };
            var a = Math.round(window.devicePixelRatio || 1);
            var n = (function(t) {
                function e(e, i) {
                    t.call(this, e, i);
                    this._current = 0;
                    this._max = 0;
                }
                t && (e.__proto__ = t);
                e.prototype = Object.create(t && t.prototype);
                e.prototype.constructor = e;
                e.prototype.draw = function t(e, i) {
                    var n = this._canvas.width;
                    var s = this._canvas.height;
                    this._current += .1 * (e - this._current);
                    this._max *= .99;
                    this._current > this._max && (this._max = this._current);
                    var o = Math.round((1 - this._current / this._max) * s);
                    this._ctx.globalAlpha = 1;
                    this._ctx.drawImage(this._canvas, a, 0, n - a, s, 0, 0, n - a, s);
                    if (i) {
                        this._ctx.fillStyle = "#444";
                        this._ctx.fillRect(n - a, 0, a, s);
                        this._ctx.fillStyle = "#b70000";
                        this._ctx.fillRect(n - a, o, a, s - o);
                        this._ctx.globalAlpha = .5;
                        this._ctx.fillStyle = "#fff";
                        this._ctx.fillRect(n - a, o, a, a);
                    } else {
                        this._ctx.fillStyle = "#444";
                        this._ctx.fillRect(n - a, 0, a, s);
                        this._ctx.fillStyle = this._color;
                        this._ctx.fillRect(n - a, o, a, s - o);
                        this._ctx.globalAlpha = .5;
                        this._ctx.fillStyle = "#fff";
                        this._ctx.fillRect(n - a, o, a, a);
                    }
                };
                return e;
            })(i);
            var s = Math.round(window.devicePixelRatio || 1);
            var o = (function(t) {
                function e(e, i) {
                    t.call(this, e, i);
                    this._threshold = 0;
                    this._canvas2 = document.createElement("canvas");
                    this._ctx2 = this._canvas2.getContext("2d");
                }
                t && (e.__proto__ = t);
                e.prototype = Object.create(t && t.prototype);
                e.prototype.constructor = e;
                e.prototype.init = function e(i, a) {
                    t.prototype.init.call(this, i, a);
                    var n = i * s;
                    var o = a * s;
                    this._canvas2.width = n;
                    this._canvas2.height = o;
                    this._canvas2.style.width = i + "px";
                    this._canvas2.style.height = a + "px";
                    this._ctx2.globalAlpha = 1;
                    this._ctx2.fillStyle = "#444";
                    this._ctx2.fillRect(0, 0, n, o);
                };
                e.prototype.draw = function t(e, i) {
                    var a = this._canvas.width;
                    var n = this._canvas.height;
                    this._ctx.globalAlpha = 1;
                    this._ctx2.globalAlpha = 1;
                    if (e > this._threshold) {
                        var o = (e - e % n) / n;
                        var r = n * (o + 1);
                        var l = this._threshold;
                        this._threshold = r;
                        var c = l / r;
                        this._ctx2.drawImage(this._canvas, 0, 0);
                        this._ctx.fillStyle = "#444";
                        this._ctx.fillRect(0, 0, a, n);
                        this._ctx.drawImage(this._canvas2, s, 0, a - s, n, 0, Math.round((1 - c) * n), a - s, n);
                    } else {
                        this._ctx.drawImage(this._canvas, s, 0, a - s, n, 0, 0, a - s, n);
                    }
                    var h = Math.round(n * (1 - e / this._threshold));
                    if (i) {
                        this._ctx.fillStyle = "#444";
                        this._ctx.fillRect(a - s, 0, s, n);
                        this._ctx.fillStyle = "#b70000";
                        this._ctx.fillRect(a - s, h, s, n - h);
                        this._ctx.globalAlpha = .5;
                        this._ctx.fillStyle = "#fff";
                        this._ctx.fillRect(a - s, h, s, s);
                    } else {
                        this._ctx.fillStyle = "#444";
                        this._ctx.fillRect(a - s, 0, s, n);
                        this._ctx.fillStyle = this._color;
                        this._ctx.fillRect(a - s, h, s, n - h);
                        this._ctx.globalAlpha = .5;
                        this._ctx.fillStyle = "#fff";
                        this._ctx.fillRect(a - s, h, s, s);
                    }
                };
                return e;
            })(i);
            var r = Math.round(window.devicePixelRatio || 1);
            var l = (function(t) {
                function e(e, i, a, n) {
                    t.call(this, e, i);
                    this._min = a;
                    this._max = n;
                }
                t && (e.__proto__ = t);
                e.prototype = Object.create(t && t.prototype);
                e.prototype.constructor = e;
                e.prototype.draw = function t(e, i) {
                    var a = this._canvas.width;
                    var n = this._canvas.height;
                    var s = (e - this._min) / (this._max - this._min);
                    var o = Math.round((1 - s) * n);
                    this._ctx.globalAlpha = 1;
                    this._ctx.drawImage(this._canvas, r, 0, a - r, n, 0, 0, a - r, n);
                    if (i) {
                        this._ctx.fillStyle = "#444";
                        this._ctx.fillRect(a - r, 0, r, n);
                        this._ctx.fillStyle = "#b70000";
                        this._ctx.fillRect(a - r, o, r, n - o);
                        this._ctx.globalAlpha = .5;
                        this._ctx.fillStyle = "#fff";
                        this._ctx.fillRect(a - r, o, r, r);
                    } else {
                        this._ctx.fillStyle = "#444";
                        this._ctx.fillRect(a - r, 0, r, n);
                        this._ctx.fillStyle = this._color;
                        this._ctx.fillRect(a - r, o, r, n - o);
                        this._ctx.globalAlpha = .5;
                        this._ctx.fillStyle = "#fff";
                        this._ctx.fillRect(a - r, o, r, r);
                    }
                };
                return e;
            })(i);
            var c = Math.round(window.devicePixelRatio || 1);
            var h = function t(e, i) {
                this._colors = i;
                this._canvas = document.createElement("canvas");
                this._ctx = this._canvas.getContext("2d");
                this._canvas.className = "pstats-canvas";
                e.appendChild(this._canvas);
            };
            h.prototype.init = function t(e, i, a) {
                var n = e * c;
                var s = i * c;
                this._canvas.width = n;
                this._canvas.height = s * a;
                this._canvas.style.width = e + "px";
                this._canvas.style.height = i * a + "px";
                this._ctx.globalAlpha = 1;
                this._ctx.fillStyle = "#444";
                this._ctx.fillRect(0, 0, n, s * a);
            };
            h.prototype.draw = function t(e) {
                var i = this;
                var a = this._canvas.width;
                var n = this._canvas.height;
                this._ctx.globalAlpha = 1;
                this._ctx.drawImage(this._canvas, c, 0, a - c, n, 0, 0, a - c, n);
                var s = 0;
                for (var o = 0; o < e.length; ++o) {
                    var r = e[o] * n;
                    i._ctx.fillStyle = i._colors[o];
                    i._ctx.fillRect(a - c, s, c, r);
                    s += r;
                }
            };
            var p = function t(e, i) {
                this._id = e;
                this._opts = i || {};
                this._value = 0;
                this._total = 0;
                this._averageValue = 0;
                this._accumValue = 0;
                this._accumSamples = 0;
                this._accumStart = window.performance.now();
            };
            var _ = {
                value: {}
            };
            p.prototype._average = function t(e) {
                if (this._opts.average) {
                    this._accumValue += e;
                    ++this._accumSamples;
                    var i = performance.now();
                    if (i - this._accumStart >= this._opts.average) {
                        this._averageValue = this._accumValue / this._accumSamples;
                        this._accumValue = 0;
                        this._accumStart = i;
                        this._accumSamples = 0;
                    }
                }
            };
            _.value.get = function() {
                return this._value;
            };
            _.value.set = function(t) {
                this._value = t;
            };
            p.prototype.sample = function t() {
                this._average(this._value);
            };
            p.prototype.human = function t() {
                var e = this._opts.average ? this._averageValue : this._value;
                return Math.round(100 * e) / 100;
            };
            p.prototype.alarm = function t() {
                return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
            };
            Object.defineProperties(p.prototype, _);
            var f = (function(t) {
                function e(e, i) {
                    t.call(this, e, i);
                    this._time = window.performance.now();
                }
                t && (e.__proto__ = t);
                e.prototype = Object.create(t && t.prototype);
                e.prototype.constructor = e;
                e.prototype.start = function t() {
                    this._time = window.performance.now();
                };
                e.prototype.end = function t() {
                    this._value = window.performance.now() - this._time;
                    this._average(this._value);
                };
                e.prototype.tick = function t() {
                    this.end();
                    this.start();
                };
                e.prototype.frame = function t() {
                    var e = window.performance.now();
                    var i = e - this._time;
                    this._total++;
                    var a = this._opts.average || 1e3;
                    if (i > a) {
                        this._value = 1e3 * this._total / i;
                        this._total = 0;
                        this._time = e;
                        this._average(this._value);
                    }
                };
                return e;
            })(p);
            var u = Math.log(1024);
            var v = [ "Bytes", "KB", "MB", "GB", "TB" ];
            function d(t) {
                var e = 100;
                var i = Math.floor(Math.log(t) / u);
                if (0 === t) {
                    return "n/a";
                }
                return Math.round(t * e / Math.pow(1024, i)) / e + " " + v[i];
            }
            var m = (function(t) {
                function e(e, i, a) {
                    t.call(this, i, a);
                    this._stats = e;
                    this._start = 0;
                    0 === a.extension.indexOf("memory.") && (this._field = a.extension.substring(7));
                }
                t && (e.__proto__ = t);
                e.prototype = Object.create(t && t.prototype);
                e.prototype.constructor = e;
                e.prototype.snapshot = function t() {
                    this._value = this._stats[this._field];
                };
                e.prototype.start = function t() {
                    this._start = this._stats[this._field];
                };
                e.prototype.end = function t() {
                    this._value = this._stats[this._field] - this._start;
                };
                e.prototype.human = function e() {
                    return d(t.prototype.human.call(this));
                };
                return e;
            })(p);
            var x = function t() {
                var e = window.performance.memory;
                0 === e.totalJSHeapSize && console.warn("totalJSHeapSize === 0, performance.memory is only available in Chrome.");
                this._used = 0;
                this._total = 0;
                this._lastUsed = 0;
            };
            var w = {
                alarm: {},
                used: {},
                total: {}
            };
            x.prototype.tick = function t() {
                this._lastUsed = this._used;
                this._used = window.performance.memory.usedJSHeapSize;
                this._total = window.performance.memory.totalJSHeapSize;
            };
            w.alarm.get = function() {
                return this._used - this._lastUsed < 0;
            };
            w.used.get = function() {
                return window.performance.memory.usedJSHeapSize;
            };
            w.total.get = function() {
                return this._total;
            };
            x.prototype.counter = function t(e, i) {
                return new m(this, e, i);
            };
            Object.defineProperties(x.prototype, w);
            var y = {
                memory: x
            };
            var g = 100;
            var b = 10;
            var S = "\n  .pstats {\n    position: fixed;\n    z-index: 9999;\n\n    padding: 5px;\n    width: " + (g + 150) + "px;\n    right: 5px;\n    bottom: 5px;\n\n    font-size: 10px;\n    font-family: 'Roboto Condensed', tahoma, sans-serif;\n    overflow: hidden;\n    user-select: none;\n    cursor: default;\n\n    background: #222;\n    border-radius: 3px;\n  }\n\n  .pstats-container {\n    display: block;\n    position: relative;\n    color: #888;\n    white-space: nowrap;\n  }\n\n  .pstats-item {\n    position: absolute;\n    width: 250px;\n    height: 12px;\n    left: 0px;\n  }\n\n  .pstats-label {\n    position: absolute;\n    width: 150px;\n    height: 12px;\n    text-align: left;\n    transition: background 0.3s;\n  }\n\n  .pstats-label.alarm {\n    color: #ccc;\n    background: #800;\n\n    transition: background 0s;\n  }\n\n  .pstats-counter-id {\n    position: absolute;\n    width: 90px;\n    left: 0px;\n  }\n\n  .pstats-counter-value {\n    position: absolute;\n    width: 60px;\n    left: 90px;\n    text-align: right;\n  }\n\n  .pstats-canvas {\n    display: block;\n    position: absolute;\n    right: 0px;\n    top: 1px;\n  }\n\n  .pstats-fraction {\n    position: absolute;\n    width: 250px;\n    left: 0px;\n  }\n\n  .pstats-legend {\n    position: absolute;\n    width: 150px;\n\n    text-align: right;\n  }\n\n  .pstats-legend > span {\n    position: absolute;\n    right: 0px;\n  }\n";
            var R = document.createElement("style");
            R.type = "text/css";
            R.textContent = S;
            document.head.appendChild(R);
            var C = function t(e, i) {
                var a = this;
                i = i || {};
                this._showGraph = void 0 === i.showGraph || i._showGraph;
                this._values = i.values || {};
                this._fractions = i.fractions || [];
                this._id2counter = {};
                this._id2item = {};
                this._name2extStats = {};
                if (i.css) {
                    var s = document.createElement("style");
                    s.type = "text/css";
                    s.textContent = i.css;
                    document.head.appendChild(s);
                }
                if (i.extensions) {
                    for (var r = 0; r < i.extensions.length; ++r) {
                        var c = i.extensions[r];
                        var p = y[c];
                        if (!p) {
                            console.warn("Can not find extensions " + c + ", please register your extension via pstats.register().");
                            continue;
                        }
                        a._name2extStats[c] = new p();
                    }
                }
                this._root = document.createElement("div");
                this._root.className = "pstats";
                var _ = document.createElement("div");
                _.className = "pstats-container";
                this._root.appendChild(_);
                var f = 0;
                for (var u in a._values) {
                    var v = a._values[u];
                    var d = document.createElement("div");
                    d.className = "pstats-item";
                    var m = document.createElement("div");
                    m.className = "pstats-label";
                    var x = document.createElement("span");
                    x.className = "pstats-counter-id";
                    x.textContent = v.desc || u;
                    var w = document.createElement("div");
                    w.className = "pstats-counter-value";
                    var S = document.createTextNode("");
                    S.nodeValue = "0";
                    m.appendChild(x);
                    m.appendChild(w);
                    w.appendChild(S);
                    d.appendChild(m);
                    var R = void 0;
                    if (a._showGraph) {
                        R = void 0 !== v.min || void 0 !== v.max ? new l(d, v.color, v.min || 0, v.max || 9999) : v.threshold ? new o(d, v.color) : new n(d, v.color);
                        R.init(g - 5, b);
                    }
                    a._id2item[u] = {
                        label: m,
                        valueText: S,
                        graph: R
                    };
                    d.style.top = f + "px";
                    _.appendChild(d);
                    f += 12;
                }
                if (this._showGraph && i.fractions) {
                    for (var C = 0; C < i.fractions.length; ++C) {
                        var M = i.fractions[C];
                        var A = M.steps;
                        var E = A.length * b + 2;
                        M.colors = M.colors || [ "#850700", "#c74900", "#fcb300", "#284280", "#4c7c0c" ];
                        var k = document.createElement("div");
                        k.className = "pstats-fraction";
                        var N = document.createElement("div");
                        N.className = "pstats-legend";
                        N.style.height = E + "px";
                        for (var z = 0; z < A.length; ++z) {
                            var G = document.createElement("span");
                            G.textContent = A[z];
                            G.style.color = M.colors[z];
                            G.style.top = z * b + "px";
                            N.appendChild(G);
                        }
                        k.appendChild(N);
                        k.style.height = E + "px";
                        k.style.top = f + "px";
                        var O = new h(k, M.colors);
                        O.init(g - 5, b, A.length);
                        M.graph = O;
                        M.values = new Array(A.length);
                        _.appendChild(k);
                        f += A.length * b + 2;
                    }
                }
                _.style.height = f + "px";
                this._root.style.height = f + "px";
                this._showGraph || (this._root.style.width = "150px");
                e.appendChild(this._root);
            };
            C.prototype.item = function t(e) {
                if (!e) {
                    return null;
                }
                var i = this._id2counter[e];
                if (i) {
                    return i;
                }
                var a = this._values[e];
                if (!a) {
                    return null;
                }
                if (a.extension) {
                    var n = a.extension.indexOf(".");
                    var s = a.extension.substring(0, n);
                    var o = this._name2extStats[s];
                    if (!o) {
                        console.error("extension " + s + " not found, make sure you have register and enable it.");
                        return null;
                    }
                    i = o.counter(e, a);
                } else {
                    i = new f(e, a);
                }
                this._id2counter[e] = i;
                return i;
            };
            C.prototype.tick = function t() {
                var e = this;
                for (var i in e._name2extStats) {
                    var a = e._name2extStats[i];
                    a.tick();
                }
                for (var n in e._values) {
                    var s = e._id2counter[n];
                    if (s) {
                        s.sample();
                        var o = s.alarm();
                        var r = s.human();
                        var l = e._id2item[n];
                        l.label.classList.toggle("alarm", o > 0);
                        l.valueText.nodeValue = r;
                        e._showGraph && l.graph.draw(s.value, o);
                    }
                }
                if (this._showGraph) {
                    for (var c = 0; c < this._fractions.length; ++c) {
                        var h = e._fractions[c];
                        var p = e._id2counter[h.base];
                        if (p) {
                            var _ = h.steps;
                            for (var f = 0; f < _.length; ++f) {
                                var u = _[f];
                                var v = e._id2counter[u];
                                v && (h.values[f] = v.value / p.value);
                            }
                            h.graph.draw(h.values);
                        }
                    }
                }
            };
            t();
            var M = {
                new: function t(e, i) {
                    var a = new C(e, i);
                    return function(t) {
                        if (!t) {
                            return a;
                        }
                        return a.item(t);
                    };
                },
                register: function t(e, i) {
                    y[e] = i;
                }
            };
            return M;
        })();
    }), {} ],
    313: [ (function(require, module, exports) {
        Function('if(typeof CC_TEST=="undefined")CC_TEST=typeof tap=="object"||typeof QUnit=="object";if(typeof CC_EDITOR=="undefined")CC_EDITOR=typeof Editor=="object"&&typeof process=="object"&&"electron" in process.versions;if(typeof CC_DEV=="undefined")CC_DEV=CC_EDITOR||CC_TEST;if(typeof CC_JSB=="undefined")CC_JSB=false;')();
        require("./predefine");
        var isMainProcess = false;
        isMainProcess ? cc._initDebugSetting(1) : require("./cocos2d/index.js");
        require("./extends");
        isMainProcess && (Editor.versions["cocos2d"] = require("./package.json").version);
        module.exports = cc;
    }), {
        "./cocos2d/index.js": 240,
        "./extends": 289,
        "./package.json": void 0,
        "./predefine": 318
    } ],
    314: [ (function(require, module, exports) {
        Array.isArray || (Array.isArray = function(arg) {
            return "[object Array]" === Object.prototype.toString.call(arg);
        });
    }), {} ],
    315: [ (function(require, module, exports) {
        Math.sign || (Math.sign = function(x) {
            x = +x;
            if (0 === x || isNaN(x)) {
                return x;
            }
            return x > 0 ? 1 : -1;
        });
        Number.isInteger || (Number.isInteger = function(value) {
            return "number" === typeof value && (0 | value) === value;
        });
    }), {} ],
    316: [ (function(require, module, exports) {
        String.prototype.startsWith || (String.prototype.startsWith = function(searchString, position) {
            position = position || 0;
            return this.lastIndexOf(searchString, position) === position;
        });
        String.prototype.endsWith || (String.prototype.endsWith = function(searchString, position) {
            ("undefined" === typeof position || position > this.length) && (position = this.length);
            position -= searchString.length;
            var lastIndex = this.indexOf(searchString, position);
            return lastIndex !== -1 && lastIndex === position;
        });
    }), {} ],
    317: [ (function(require, module, exports) {
        window.__extends = function(d, b) {
            for (var p in b) {
                b.hasOwnProperty(p) && (d[p] = b[p]);
            }
            function __() {
                this.constructor = d;
            }
            d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        window.__assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) {
                    Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
                }
            }
            return t;
        };
        window.__rest = function(s, e) {
            var t = {};
            for (var p in s) {
                Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
            }
            if (null != s && "function" === typeof Object.getOwnPropertySymbols) {
                for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                    e.indexOf(p[i]) < 0 && (t[p[i]] = s[p[i]]);
                }
            }
            return t;
        };
        window.__decorate = function(decorators, target, key, desc) {
            var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
            if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) {
                r = Reflect.decorate(decorators, target, key, desc);
            } else {
                for (var i = decorators.length - 1; i >= 0; i--) {
                    (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
                }
            }
            return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        window.__param = function(paramIndex, decorator) {
            return function(target, key) {
                decorator(target, key, paramIndex);
            };
        };
        window.__metadata = function(metadataKey, metadataValue) {
            if ("object" === typeof Reflect && "function" === typeof Reflect.metadata) {
                return Reflect.metadata(metadataKey, metadataValue);
            }
        };
        window.__awaiter = function(thisArg, _arguments, P, generator) {
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : new P(function(resolve) {
                        resolve(result.value);
                    }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments)).next());
            });
        };
        window.__generator = function(thisArg, body) {
            var _ = {
                label: 0,
                sent: function() {
                    if (1 & t[0]) {
                        throw t[1];
                    }
                    return t[1];
                },
                trys: [],
                ops: []
            }, f, y, t;
            return {
                next: verb(0),
                throw: verb(1),
                return: verb(2)
            };
            function verb(n) {
                return function(v) {
                    return step([ n, v ]);
                };
            }
            function step(op) {
                if (f) {
                    throw new TypeError("Generator is already executing.");
                }
                while (_) {
                    try {
                        if (f = 1, y && (t = y[2 & op[0] ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) {
                            return t;
                        }
                        (y = 0, t) && (op = [ 0, t.value ]);
                        switch (op[0]) {
                          case 0:
                          case 1:
                            t = op;
                            break;

                          case 4:
                            _.label++;
                            return {
                                value: op[1],
                                done: false
                            };

                          case 5:
                            _.label++;
                            y = op[1];
                            op = [ 0 ];
                            continue;

                          case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;

                          default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
                                _ = 0;
                                continue;
                            }
                            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
                                _.label = op[1];
                                break;
                            }
                            if (6 === op[0] && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            t[2] && _.ops.pop();
                            _.trys.pop();
                            continue;
                        }
                        op = body.call(thisArg, _);
                    } catch (e) {
                        op = [ 6, e ];
                        y = 0;
                    } finally {
                        f = t = 0;
                    }
                }
                if (5 & op[0]) {
                    throw op[1];
                }
                return {
                    value: op[0] ? op[1] : void 0,
                    done: true
                };
            }
        };
    }), {} ],
    318: [ (function(require, module, exports) {
        cc = {};
        _ccsg = {};
        cc._Test = {};
        require("./CCDebugger");
        cc._initDebugSetting(cc.DebugMode.INFO);
        require("./DebugInfos");
        require("./polyfill/string");
        require("./polyfill/misc");
        require("./polyfill/array");
        require("./polyfill/typescript");
        require("./cocos2d/core/platform/js");
        require("./cocos2d/core/value-types");
        require("./cocos2d/core/utils");
        require("./cocos2d/core/platform/CCInputManager");
        require("./cocos2d/core/platform/CCInputExtension");
        require("./cocos2d/core/event");
        require("./cocos2d/core/platform/CCSys");
        require("./cocos2d/core/platform/CCMacro");
        require("./cocos2d/core/load-pipeline");
        require("./cocos2d/core/textures");
        require("./cocos2d/kazmath");
        require("./cocos2d/core/CCDirector");
        require("./cocos2d/core/CCDirectorWebGL");
        require("./cocos2d/core/CCDirectorCanvas");
        require("./cocos2d/core/platform/CCSAXParser");
        require("./cocos2d/core/platform/CCView");
        require("./cocos2d/core/platform/CCScreen");
        require("./cocos2d/core/CCScheduler");
        require("./cocos2d/core/event-manager");
        require("./cocos2d/core/renderer");
        require("./cocos2d/shaders");
        require("./cocos2d/compression");
        require("./CCBoot");
        require("./cocos2d/core/CCGame");
        require("./cocos2d/actions");
        ccui = {};
        ccs = {};
        cp = {};
    }), {
        "./CCBoot": 1,
        "./CCDebugger": 2,
        "./DebugInfos": 3,
        "./cocos2d/actions": 10,
        "./cocos2d/compression": 32,
        "./cocos2d/core/CCDirector": 35,
        "./cocos2d/core/CCDirectorCanvas": 36,
        "./cocos2d/core/CCDirectorWebGL": 37,
        "./cocos2d/core/CCGame": 40,
        "./cocos2d/core/CCScheduler": 43,
        "./cocos2d/core/event": 114,
        "./cocos2d/core/event-manager": 110,
        "./cocos2d/core/load-pipeline": 136,
        "./cocos2d/core/platform/CCInputExtension": 176,
        "./cocos2d/core/platform/CCInputManager": 177,
        "./cocos2d/core/platform/CCMacro": 178,
        "./cocos2d/core/platform/CCSAXParser": 180,
        "./cocos2d/core/platform/CCScreen": 181,
        "./cocos2d/core/platform/CCSys": 182,
        "./cocos2d/core/platform/CCView": 183,
        "./cocos2d/core/platform/js": 193,
        "./cocos2d/core/renderer": 202,
        "./cocos2d/core/textures": 216,
        "./cocos2d/core/utils": 222,
        "./cocos2d/core/value-types": 236,
        "./cocos2d/kazmath": 244,
        "./cocos2d/shaders": 274,
        "./polyfill/array": 314,
        "./polyfill/misc": 315,
        "./polyfill/string": 316,
        "./polyfill/typescript": 317
    } ]
}, {}, [ 313 ]);
//# sourceMappingURL=cocos2d-js.js.map